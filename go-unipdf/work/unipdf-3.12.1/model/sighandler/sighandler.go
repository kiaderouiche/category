//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_g "bytes";_dd "crypto";_e "crypto/rand";_ab "crypto/rsa";_ag "crypto/x509";_fcd "crypto/x509/pkix";_ad "encoding/asn1";_gc "errors";_db "fmt";_ge "github.com/unidoc/pkcs7";_af "github.com/unidoc/timestamp";_bd "github.com/unidoc/unipdf/v3/core";_c "github.com/unidoc/unipdf/v3/model";_b "hash";_d "io";_fcg "io/ioutil";_fc "net/http";_f "time";);

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler
// with a custom signing function. Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1Custom (certificate *_ag .Certificate ,signFunc SignFunc )(_c .SignatureHandler ,error ){return &adobeX509RSASHA1 {_dea :certificate ,_dcd :signFunc },nil ;};

// NewDigest creates a new digest.
func (_fa *adobeX509RSASHA1 )NewDigest (sig *_c .PdfSignature )(_c .Hasher ,error ){_dba ,_dad :=_fa .getCertificate (sig );if _dad !=nil {return nil ,_dad ;};_fda ,_ :=_dgc (_dba .SignatureAlgorithm );return _fda .New (),nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ab .PrivateKey ,certificate *_ag .Certificate )(_c .SignatureHandler ,error ){return &adobePKCS7Detached {_gg :certificate ,_fd :privateKey },nil ;};

// Validate validates PdfSignature.
func (_daa *adobeX509RSASHA1 )Validate (sig *_c .PdfSignature ,digest _c .Hasher )(_c .SignatureValidationResult ,error ){_fea ,_bcf :=_daa .getCertificate (sig );if _bcf !=nil {return _c .SignatureValidationResult {},_bcf ;};_ae :=sig .Contents .Bytes ();var _bcb []byte ;if _ ,_cfc :=_ad .Unmarshal (_ae ,&_bcb );_cfc !=nil {return _c .SignatureValidationResult {},_cfc ;};_aaf ,_ff :=digest .(_b .Hash );if !_ff {return _c .SignatureValidationResult {},_gc .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cgg ,_ :=_dgc (_fea .SignatureAlgorithm );if _bg :=_ab .VerifyPKCS1v15 (_fea .PublicKey .(*_ab .PublicKey ),_cgg ,_aaf .Sum (nil ),_bcb );_bg !=nil {return _c .SignatureValidationResult {},_bg ;};return _c .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewDigest creates a new digest.
func (_daga *docTimeStamp )NewDigest (sig *_c .PdfSignature )(_c .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// Validate validates PdfSignature.
func (_dde *docTimeStamp )Validate (sig *_c .PdfSignature ,digest _c .Hasher )(_c .SignatureValidationResult ,error ){_fff :=sig .Contents .Bytes ();_bgg ,_fdg :=_ge .Parse (_fff );if _fdg !=nil {return _c .SignatureValidationResult {},_fdg ;};if _fdg =_bgg .Verify ();_fdg !=nil {return _c .SignatureValidationResult {},_fdg ;};var _bbf timestampInfo ;_ ,_fdg =_ad .Unmarshal (_bgg .Content ,&_bbf );if _fdg !=nil {return _c .SignatureValidationResult {},_fdg ;};_feaa ,_fdg :=_gfd (_bbf .MessageImprint .HashAlgorithm .Algorithm );if _fdg !=nil {return _c .SignatureValidationResult {},_fdg ;};_fbd :=_feaa .New ();_acd :=digest .(*_g .Buffer );_fbd .Write (_acd .Bytes ());_fcdc :=_fbd .Sum (nil );_bcfb :=_c .SignatureValidationResult {IsSigned :true ,IsVerified :_g .Equal (_fcdc ,_bbf .MessageImprint .HashedMessage ),GeneralizedTime :_bbf .GeneralizedTime };return _bcfb ,nil ;};

// InitSignature initialises the PdfSignature.
func (_da *adobeX509RSASHA1 )InitSignature (sig *_c .PdfSignature )error {if _da ._dea ==nil {return _gc .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _da ._gd ==nil &&_da ._dcd ==nil {return _gc .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_cad :=*_da ;sig .Handler =&_cad ;sig .Filter =_bd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bd .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_bd .MakeString (string (_cad ._dea .Raw ));sig .Reference =nil ;_cadb ,_cc :=_cad .NewDigest (sig );if _cc !=nil {return _cc ;};_cadb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _cad .Sign (sig ,_cadb );};func (_efg *adobeX509RSASHA1 )getCertificate (_fcgc *_c .PdfSignature )(*_ag .Certificate ,error ){if _efg ._dea !=nil {return _efg ._dea ,nil ;};var _agf []byte ;switch _eg :=_fcgc .Cert .(type ){case *_bd .PdfObjectString :_agf =_eg .Bytes ();case *_bd .PdfObjectArray :if _eg .Len ()==0{return nil ,_gc .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_feg :=range _eg .Elements (){_dag ,_ddg :=_bd .GetString (_feg );if !_ddg {return nil ,_db .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_feg );};_agf =append (_agf ,_dag .Bytes ()...);};default:return nil ,_db .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_eg );};_bc ,_eaf :=_ag .ParseCertificates (_agf );if _eaf !=nil {return nil ,_eaf ;};return _bc [0],nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_ccc *adobeX509RSASHA1 )Sign (sig *_c .PdfSignature ,digest _c .Hasher )error {var _bae []byte ;var _ce error ;if _ccc ._dcd !=nil {_bae ,_ce =_ccc ._dcd (sig ,digest );if _ce !=nil {return _ce ;};}else {_adb ,_df :=digest .(_b .Hash );if !_df {return _gc .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ddgc ,_ :=_dgc (_ccc ._dea .SignatureAlgorithm );_bae ,_ce =_ab .SignPKCS1v15 (_e .Reader ,_ccc ._gd ,_ddgc ,_adb .Sum (nil ));if _ce !=nil {return _ce ;};};_bae ,_ce =_ad .Marshal (_bae );if _ce !=nil {return _ce ;};sig .Contents =_bd .MakeHexString (string (_bae ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_ea *adobePKCS7Detached )InitSignature (sig *_c .PdfSignature )error {if !_ea ._ga {if _ea ._gg ==nil {return _gc .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _ea ._fd ==nil {return _gc .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_adg :=*_ea ;sig .Handler =&_adg ;sig .Filter =_bd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bd .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_gga ,_bf :=_adg .NewDigest (sig );if _bf !=nil {return _bf ;};_gga .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _adg .Sign (sig ,_gga );};

// Sign sets the Contents fields.
func (_dec *adobePKCS7Detached )Sign (sig *_c .PdfSignature ,digest _c .Hasher )error {if _dec ._ga {_dg :=_dec ._cg ;if _dg <=0{_dg =8192;};sig .Contents =_bd .MakeHexString (string (make ([]byte ,_dg )));return nil ;};_bfb :=digest .(*_g .Buffer );_gfg ,_afg :=_ge .NewSignedData (_bfb .Bytes ());if _afg !=nil {return _afg ;};if _ac :=_gfg .AddSigner (_dec ._gg ,_dec ._fd ,_ge .SignerInfoConfig {});_ac !=nil {return _ac ;};_gfg .Detach ();_abd ,_afg :=_gfg .Finish ();if _afg !=nil {return _afg ;};_ca :=make ([]byte ,8192);copy (_ca ,_abd );sig .Contents =_bd .MakeHexString (string (_ca ));return nil ;};type adobeX509RSASHA1 struct{_gd *_ab .PrivateKey ;_dea *_ag .Certificate ;_dcd SignFunc ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_efe *_c .PdfSignature ,_ded _c .Hasher )([]byte ,error );

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _dd .Hash ,opts *DocTimeStampOpts )(_c .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_ed :timestampServerURL ,_ede :hashAlgorithm ,_abf :opts .SignatureSize },nil ;};type adobePKCS7Detached struct{_fd *_ab .PrivateKey ;_gg *_ag .Certificate ;_ga bool ;_cg int ;};

// Validate validates PdfSignature.
func (_efc *adobePKCS7Detached )Validate (sig *_c .PdfSignature ,digest _c .Hasher )(_c .SignatureValidationResult ,error ){_bb :=sig .Contents .Bytes ();_dca ,_gf :=_ge .Parse (_bb );if _gf !=nil {return _c .SignatureValidationResult {},_gf ;};_fg :=digest .(*_g .Buffer );_dca .Content =_fg .Bytes ();if _gf =_dca .Verify ();_gf !=nil {return _c .SignatureValidationResult {},_gf ;};return _c .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func (_bdc *adobePKCS7Detached )getCertificate (_de *_c .PdfSignature )(*_ag .Certificate ,error ){if _bdc ._gg !=nil {return _bdc ._gg ,nil ;};var _ef []byte ;switch _dc :=_de .Cert .(type ){case *_bd .PdfObjectString :_ef =_dc .Bytes ();case *_bd .PdfObjectArray :if _dc .Len ()==0{return nil ,_gc .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_ec :=range _dc .Elements (){_cgd ,_gb :=_bd .GetString (_ec );if !_gb {return nil ,_db .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_ec );};_ef =append (_ef ,_cgd .Bytes ()...);};default:return nil ,_db .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_dc );};_eac ,_cge :=_ag .ParseCertificates (_ef );if _cge !=nil {return nil ,_cge ;};return _eac [0],nil ;};func _dgc (_bbg _ag .SignatureAlgorithm )(_dd .Hash ,bool ){var _fe _dd .Hash ;switch _bbg {case _ag .SHA1WithRSA :_fe =_dd .SHA1 ;case _ag .SHA256WithRSA :_fe =_dd .SHA256 ;case _ag .SHA384WithRSA :_fe =_dd .SHA384 ;case _ag .SHA512WithRSA :_fe =_dd .SHA512 ;default:return _dd .SHA1 ,false ;};return _fe ,true ;};

// Sign sets the Contents fields for the PdfSignature.
func (_fcb *docTimeStamp )Sign (sig *_c .PdfSignature ,digest _c .Hasher )error {_eba :=digest .(*_g .Buffer );_fag :=_fcb ._ede .New ();if _ ,_afd :=_d .Copy (_fag ,_eba );_afd !=nil {return _afd ;};_aafg :=_af .Request {HashAlgorithm :_fcb ._ede ,HashedMessage :_fag .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_age ,_cdb :=_aafg .Marshal ();if _cdb !=nil {return _cdb ;};_fed ,_cdb :=_fc .Post (_fcb ._ed ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_g .NewBuffer (_age ));if _cdb !=nil {return _cdb ;};defer _fed .Body .Close ();_cef ,_cdb :=_fcg .ReadAll (_fed .Body );if _cdb !=nil {return _cdb ;};if _fed .StatusCode !=_fc .StatusOK {return _db .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_fed .StatusCode );};var _fbe struct{Version _ad .RawValue ;Content _ad .RawValue ;};if _ ,_cdb =_ad .Unmarshal (_cef ,&_fbe );_cdb !=nil {return _cdb ;};_cbe :=len (_fbe .Content .FullBytes );if _fcb ._abf > 0&&_cbe > _fcb ._abf {return _c .ErrSignNotEnoughSpace ;};if _cbe > 0{_fcb ._abf =_cbe +128;};sig .Contents =_bd .MakeHexString (string (_fbe .Content .FullBytes ));return nil ;};func (_afa *docTimeStamp )getCertificate (_geg *_c .PdfSignature )(*_ag .Certificate ,error ){var _eb []byte ;switch _bfd :=_geg .Cert .(type ){case *_bd .PdfObjectString :_eb =_bfd .Bytes ();case *_bd .PdfObjectArray :if _bfd .Len ()==0{return nil ,_gc .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_cac :=range _bfd .Elements (){_fdb ,_dbc :=_bd .GetString (_cac );if !_dbc {return nil ,_db .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_cac );};_eb =append (_eb ,_fdb .Bytes ()...);};default:return nil ,_db .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_bfd );};_cb ,_cd :=_ag .ParseCertificates (_eb );if _cd !=nil {return nil ,_cd ;};return _cb [0],nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ab .PrivateKey ,certificate *_ag .Certificate )(_c .SignatureHandler ,error ){return &adobeX509RSASHA1 {_dea :certificate ,_gd :privateKey },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_cf *adobePKCS7Detached )IsApplicable (sig *_c .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};type timestampInfo struct{Version int ;Policy _ad .RawValue ;MessageImprint struct{HashAlgorithm _fcd .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _ad .RawValue ;GeneralizedTime _f .Time ;};

// InitSignature initialises the PdfSignature.
func (_fae *docTimeStamp )InitSignature (sig *_c .PdfSignature )error {_gge :=*_fae ;sig .Handler =&_gge ;sig .Filter =_bd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bd .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _fae ._abf > 0{sig .Contents =_bd .MakeHexString (string (make ([]byte ,_fae ._abf )));}else {_fb ,_gcd :=_fae .NewDigest (sig );if _gcd !=nil {return _gcd ;};_fb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gcd =_gge .Sign (sig ,_fb );_gcd !=nil {return _gcd ;};_fae ._abf =_gge ._abf ;};return nil ;};

// NewDigest creates a new digest.
func (_gbb *adobePKCS7Detached )NewDigest (sig *_c .PdfSignature )(_c .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _dd .Hash )(_c .SignatureHandler ,error ){return &docTimeStamp {_ed :timestampServerURL ,_ede :hashAlgorithm },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gfa *docTimeStamp )IsApplicable (sig *_c .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_dbg *adobeX509RSASHA1 )IsApplicable (sig *_c .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};type docTimeStamp struct{_ed string ;_ede _dd .Hash ;_abf int ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_c .SignatureHandler ,error ){return &adobePKCS7Detached {_ga :true ,_cg :signatureLen },nil ;};func _gfd (_be _ad .ObjectIdentifier )(_dd .Hash ,error ){switch {case _be .Equal (_ge .OIDDigestAlgorithmSHA1 ),_be .Equal (_ge .OIDDigestAlgorithmECDSASHA1 ),_be .Equal (_ge .OIDDigestAlgorithmDSA ),_be .Equal (_ge .OIDDigestAlgorithmDSASHA1 ),_be .Equal (_ge .OIDEncryptionAlgorithmRSA ):return _dd .SHA1 ,nil ;case _be .Equal (_ge .OIDDigestAlgorithmSHA256 ),_be .Equal (_ge .OIDDigestAlgorithmECDSASHA256 ):return _dd .SHA256 ,nil ;case _be .Equal (_ge .OIDDigestAlgorithmSHA384 ),_be .Equal (_ge .OIDDigestAlgorithmECDSASHA384 ):return _dd .SHA384 ,nil ;case _be .Equal (_ge .OIDDigestAlgorithmSHA512 ),_be .Equal (_ge .OIDDigestAlgorithmECDSASHA512 ):return _dd .SHA512 ,nil ;};return _dd .Hash (0),_ge .ErrUnsupportedAlgorithm ;};