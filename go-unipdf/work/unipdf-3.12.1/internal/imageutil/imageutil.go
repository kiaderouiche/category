//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_e "errors";_a "fmt";_ee "github.com/unidoc/unipdf/v3/internal/bitwise";_egg "image";_eg "image/color";_d "image/draw";_g "math";);var _ Image =&NRGBA32 {};func _fdf (_bdac _eg .Color )_eg .Color {_aea :=_eg .GrayModel .Convert (_bdac ).(_eg .Gray );return _defe (_aea );};type ColorConverter interface{Convert (_bge _egg .Image )(Image ,error );};func (_gceg *Gray4 )At (x ,y int )_eg .Color {_gcg ,_ :=_gceg .ColorAt (x ,y );return _gcg };func (_edb *Gray2 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtGray2BPC (x ,y ,_edb .BytesPerLine ,_edb .Data ,_edb .Decode );};func (_efdd *Gray16 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtGray16BPC (x ,y ,_efdd .BytesPerLine ,_efdd .Data ,_efdd .Decode );};var (Gray2Model =_eg .ModelFunc (_fcbf );Gray4Model =_eg .ModelFunc (_fdf );NRGBA16Model =_eg .ModelFunc (_eeac ););type monochromeThresholdConverter struct{Threshold uint8 ;};func (_decf *NRGBA64 )ColorModel ()_eg .Model {return _eg .NRGBA64Model };func (_addc *Gray2 )GrayAt (x ,y int )_eg .Gray {_cafb ,_ :=ColorAtGray2BPC (x ,y ,_addc .BytesPerLine ,_addc .Data ,_addc .Decode );return _cafb ;};func _eeca (_bcb _egg .Image ,_dbecc uint8 )*_egg .Gray {_dbgc :=_bcb .Bounds ();_bdag :=_egg .NewGray (_dbgc );var (_gdgd _eg .Color ;_aabe _eg .Gray ;);for _bga :=0;_bga < _dbgc .Max .X ;_bga ++{for _gaea :=0;_gaea < _dbgc .Max .Y ;_gaea ++{_gdgd =_bcb .At (_bga ,_gaea );_bdag .Set (_bga ,_gaea ,_gdgd );_aabe =_bdag .GrayAt (_bga ,_gaea );_bdag .SetGray (_bga ,_gaea ,_eg .Gray {Y :_dgg (_aabe .Y ,_dbecc )});};};return _bdag ;};func _def (_gbc _egg .Image )(Image ,error ){if _gce ,_gbe :=_gbc .(*Monochrome );_gbe {return _gce ,nil ;};_ccag ,_edg :=_gbc .(Gray );if !_edg {_gfcc ,_aff :=GrayConverter .Convert (_gbc );if _aff !=nil {return nil ,_aff ;};_ccag =_gfcc .(Gray );};_bdc :=_gbc .Bounds ();_dad ,_ggc :=NewImage (_bdc .Max .X ,_bdc .Max .Y ,1,1,nil ,nil ,nil );if _ggc !=nil {return nil ,_ggc ;};_fdg :=_dad .(*Monochrome );_gedfb :=AutoThresholdTriangle (GrayHistogram (_ccag ));for _gfca :=0;_gfca < _bdc .Max .X ;_gfca ++{for _fca :=0;_fca < _bdc .Max .Y ;_fca ++{_abd :=_cfbg (_ccag .GrayAt (_gfca ,_fca ),monochromeModel (_gedfb ));_fdg .SetGray (_gfca ,_fca ,_abd );};};return _dad ,nil ;};func _abgea (_fbf ,_aagc NRGBA ,_fdge _egg .Rectangle ){for _fgac :=0;_fgac < _fdge .Max .X ;_fgac ++{for _ebfc :=0;_ebfc < _fdge .Max .Y ;_ebfc ++{_aagc .SetNRGBA (_fgac ,_ebfc ,_fbf .NRGBAAt (_fgac ,_ebfc ));};};};func _bbe (_cdcd _eg .Gray )_eg .CMYK {return _eg .CMYK {K :0xff-_cdcd .Y }};var _ Gray =&Monochrome {};func (_faa *monochromeThresholdConverter )Convert (img _egg .Image )(Image ,error ){if _dfa ,_fbda :=img .(*Monochrome );_fbda {return _dfa .Copy (),nil ;};_bda :=img .Bounds ();_deg ,_ecd :=NewImage (_bda .Max .X ,_bda .Max .Y ,1,1,nil ,nil ,nil );if _ecd !=nil {return nil ,_ecd ;};_deg .(*Monochrome ).ModelThreshold =_faa .Threshold ;for _fea :=0;_fea < _bda .Max .X ;_fea ++{for _acee :=0;_acee < _bda .Max .Y ;_acee ++{_ggg :=img .At (_fea ,_acee );_deg .Set (_fea ,_acee ,_ggg );};};return _deg ,nil ;};func (_adab *NRGBA16 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_adab .Width ,Y :_adab .Height }};};func (_dgbe *Gray4 )GrayAt (x ,y int )_eg .Gray {_ebg ,_ :=ColorAtGray4BPC (x ,y ,_dgbe .BytesPerLine ,_dgbe .Data ,_dgbe .Decode );return _ebg ;};func (_afd monochromeModel )Convert (c _eg .Color )_eg .Color {_fac :=_eg .GrayModel .Convert (c ).(_eg .Gray );return _cfbg (_fac ,_afd );};func (_dbbeb *ImageBase )Pix ()[]byte {return _dbbeb .Data };func (_ded *Gray16 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_ded .Width ,Y :_ded .Height }};};func (_fbag *Gray16 )At (x ,y int )_eg .Color {_bdd ,_ :=_fbag .ColorAt (x ,y );return _bdd };var _ Image =&Gray8 {};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_eg .Gray ,error ){_cab :=y *bytesPerLine +x ;if _cab >=len (data ){return _eg .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ade :=data [_cab ];if len (decode )==2{_ade =uint8 (uint32 (LinearInterpolate (float64 (_ade ),0,255,decode [0],decode [1]))&0xff);};return _eg .Gray {Y :_ade },nil ;};func (_fcae *NRGBA16 )setNRGBA (_cebdg ,_gfg ,_eaec int ,_gdbg _eg .NRGBA ){if _cebdg *3%2==0{_fcae .Data [_eaec ]=(_gdbg .R >>4)<<4|(_gdbg .G >>4);_fcae .Data [_eaec +1]=(_gdbg .B >>4)<<4|(_fcae .Data [_eaec +1]&0xf);}else {_fcae .Data [_eaec ]=(_fcae .Data [_eaec ]&0xf0)|(_gdbg .R >>4);_fcae .Data [_eaec +1]=(_gdbg .G >>4)<<4|(_gdbg .B >>4);};if _fcae .Alpha !=nil {_aee :=_gfg *BytesPerLine (_fcae .Width ,4,1);if _aee < len (_fcae .Alpha ){if _cebdg %2==0{_fcae .Alpha [_aee ]=(_gdbg .A >>uint (4))<<uint (4)|(_fcae .Alpha [_eaec ]&0xf);}else {_fcae .Alpha [_aee ]=(_fcae .Alpha [_aee ]&0xf0)|(_gdbg .A >>uint (4));};};};};type Gray2 struct{ImageBase };func (_gced *ImageBase )copy ()ImageBase {_dae :=*_gced ;_dae .Data =make ([]byte ,len (_gced .Data ));copy (_dae .Data ,_gced .Data );return _dae ;};var _ Image =&Gray16 {};func (_bccc *NRGBA32 )setRGBA (_cfae int ,_aacd _eg .NRGBA ){_abbe :=3*_cfae ;_bccc .Data [_abbe ]=_aacd .R ;_bccc .Data [_abbe +1]=_aacd .G ;_bccc .Data [_abbe +2]=_aacd .B ;if _cfae < len (_bccc .Alpha ){_bccc .Alpha [_cfae ]=_aacd .A ;};};func (_cdcdg *Gray16 )ColorModel ()_eg .Model {return _eg .Gray16Model };func _efde (_gdc ,_cge Gray ,_eabg _egg .Rectangle ){for _eba :=0;_eba < _eabg .Max .X ;_eba ++{for _aefg :=0;_aefg < _eabg .Max .Y ;_aefg ++{_cge .SetGray (_eba ,_aefg ,_gdc .GrayAt (_eba ,_aefg ));};};};func (_dag *Gray2 )Base ()*ImageBase {return &_dag .ImageBase };func _defe (_agcf _eg .Gray )_eg .Gray {_agcf .Y >>=4;_agcf .Y |=_agcf .Y <<4;return _agcf };func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_bbec :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _fde Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_fde =&Monochrome {ImageBase :_bbec ,ModelThreshold :0x0f};case 2:_fde =&Gray2 {ImageBase :_bbec };case 4:_fde =&Gray4 {ImageBase :_bbec };case 8:_fde =&Gray8 {ImageBase :_bbec };case 16:_fde =&Gray16 {ImageBase :_bbec };};case 3:switch bitsPerComponent {case 4:_fde =&NRGBA16 {ImageBase :_bbec };case 8:_fde =&NRGBA32 {ImageBase :_bbec };case 16:_fde =&NRGBA64 {ImageBase :_bbec };};case 4:_fde =&CMYK32 {ImageBase :_bbec };};if _fde ==nil {return nil ,ErrInvalidImage ;};return _fde ,nil ;};func _gfdf (_acc _egg .Image )(Image ,error ){if _dadd ,_ggcf :=_acc .(*Gray4 );_ggcf {return _dadd .Copy (),nil ;};_eebc :=_acc .Bounds ();_cdbf ,_baf :=NewImage (_eebc .Max .X ,_eebc .Max .Y ,4,1,nil ,nil ,nil );if _baf !=nil {return nil ,_baf ;};_cgc (_acc ,_cdbf ,_eebc );return _cdbf ,nil ;};func (_dcd *Gray4 )SetGray (x ,y int ,g _eg .Gray ){if x >=_dcd .Width ||y >=_dcd .Height {return ;};g =_defe (g );_dcd .setGray (x ,y ,g );};func _dcb (_dagg _egg .Image ,_cfba int )(_egg .Rectangle ,bool ,[]byte ){_bef :=_dagg .Bounds ();var (_cgdd bool ;_fdag []byte ;);switch _bafd :=_dagg .(type ){case SMasker :_cgdd =_bafd .HasAlpha ();case NRGBA ,RGBA ,*_egg .RGBA64 ,nrgba64 ,*_egg .NYCbCrA :_fdag =make ([]byte ,_bef .Max .X *_bef .Max .Y *_cfba );};return _bef ,_cgdd ,_fdag ;};type Gray4 struct{ImageBase };func (_ecef *Gray2 )SetGray (x ,y int ,gray _eg .Gray ){_afcb :=_gbb (gray );_edc :=y *_ecef .BytesPerLine ;_dab :=_edc +(x >>2);if _dab >=len (_ecef .Data ){return ;};_fda :=_afcb .Y >>6;_ecef .Data [_dab ]=(_ecef .Data [_dab ]&(^(0xc0>>uint (2*((x )&3)))))|(_fda <<uint (6-2*(x &3)));};func (_ef *CMYK32 )Base ()*ImageBase {return &_ef .ImageBase };func (_eea *Monochrome )Histogram ()(_caa [256]int ){for _ ,_ceg :=range _eea .Data {_caa [0xff]+=int (_bddc [_eea .Data [_ceg ]]);};return _caa ;};func init (){_ecgg ()};func (_eda *Monochrome )Base ()*ImageBase {return &_eda .ImageBase };type NRGBA interface{NRGBAAt (_dbge ,_dbcd int )_eg .NRGBA ;SetNRGBA (_cceg ,_gggb int ,_bdeeb _eg .NRGBA );};func _afbe (_ggfg *_egg .NYCbCrA ,_fae NRGBA ,_eged _egg .Rectangle ){for _dgda :=0;_dgda < _eged .Max .X ;_dgda ++{for _aabd :=0;_aabd < _eged .Max .Y ;_aabd ++{_cdee :=_ggfg .NYCbCrAAt (_dgda ,_aabd );_fae .SetNRGBA (_dgda ,_aabd ,_gec (_cdee ));};};};func (_be *CMYK32 )Set (x ,y int ,c _eg .Color ){_bb :=4*(y *_be .Width +x );if _bb +3>=len (_be .Data ){return ;};_ac :=_eg .CMYKModel .Convert (c ).(_eg .CMYK );_be .Data [_bb ]=_ac .C ;_be .Data [_bb +1]=_ac .M ;_be .Data [_bb +2]=_ac .Y ;_be .Data [_bb +3]=_ac .K ;};type CMYK interface{CMYKAt (_ge ,_db int )_eg .CMYK ;SetCMYK (_cd ,_b int ,_cg _eg .CMYK );};func (_egee *Gray16 )SetGray (x ,y int ,g _eg .Gray ){_cdd :=(y *_egee .BytesPerLine /2+x )*2;if _cdd +1>=len (_egee .Data ){return ;};_egee .Data [_cdd ]=g .Y ;_egee .Data [_cdd +1]=g .Y ;};func (_ecc *NRGBA16 )At (x ,y int )_eg .Color {_eeaaf ,_ :=_ecc .ColorAt (x ,y );return _eeaaf };func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_eg .NRGBA ,error ){_cabf :=y *width +x ;_edad :=3*_cabf ;if _edad +2>=len (data ){return _eg .NRGBA {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fcdb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cabf {_fcdb =alpha [_cabf ];};_edf ,_aad ,_cfee :=data [_edad ],data [_edad +1],data [_edad +2];if len (decode )==6{_edf =uint8 (uint32 (LinearInterpolate (float64 (_edf ),0,255,decode [0],decode [1]))&0xff);_aad =uint8 (uint32 (LinearInterpolate (float64 (_aad ),0,255,decode [2],decode [3]))&0xff);_cfee =uint8 (uint32 (LinearInterpolate (float64 (_cfee ),0,255,decode [4],decode [5]))&0xff);};return _eg .NRGBA {R :_edf ,G :_aad ,B :_cfee ,A :_fcdb },nil ;};func (_ecebb *Gray16 )Base ()*ImageBase {return &_ecebb .ImageBase };func (_fdgg *Gray4 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtGray4BPC (x ,y ,_fdgg .BytesPerLine ,_fdgg .Data ,_fdgg .Decode );};func (_dfg *NRGBA64 )At (x ,y int )_eg .Color {_eagf ,_ :=_dfg .ColorAt (x ,y );return _eagf };func _eacc (_eeaa _egg .Image )(Image ,error ){if _eed ,_bfgc :=_eeaa .(*Gray8 );_bfgc {return _eed .Copy (),nil ;};_dce :=_eeaa .Bounds ();_fcag ,_aeg :=NewImage (_dce .Max .X ,_dce .Max .Y ,8,1,nil ,nil ,nil );if _aeg !=nil {return nil ,_aeg ;};_cgc (_eeaa ,_fcag ,_dce );return _fcag ,nil ;};func _ad (_fc NRGBA ,_ged CMYK ,_ec _egg .Rectangle ){for _agf :=0;_agf < _ec .Max .X ;_agf ++{for _cc :=0;_cc < _ec .Max .Y ;_cc ++{_bcc :=_fc .NRGBAAt (_agf ,_cc );_ged .SetCMYK (_agf ,_cc ,_df (_bcc ));};};};var _ Image =&Gray2 {};func (_ecae *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_ecae .copy ()}};var ErrInvalidImage =_e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_eg .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};var _ Image =&Gray4 {};func _bbc (_adc _eg .NRGBA64 )_eg .NRGBA {return _eg .NRGBA {R :uint8 (_adc .R >>8),G :uint8 (_adc .G >>8),B :uint8 (_adc .B >>8),A :uint8 (_adc .A >>8)};};func (_gde *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_gde .copy ()}};func (_faf *Gray4 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_faf .Width ,Y :_faf .Height }};};func (_fcbc *Monochrome )setBit (_ggf ,_dbbe int ){_fcbc .Data [_ggf ]|=0x80>>uint (_dbbe &7)};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _cdg (_bfb _eg .NRGBA )_eg .Gray {_ba ,_de ,_ceb ,_ :=_bfb .RGBA ();_geg :=(19595*_ba +38470*_de +7471*_ceb +1<<15)>>24;return _eg .Gray {Y :uint8 (_geg )};};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_eg .Gray ,error ){_caff :=y *bytesPerLine +x >>1;if _caff >=len (data ){return _eg .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ffad :=data [_caff ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ffad =uint8 (uint32 (LinearInterpolate (float64 (_ffad ),0,15,decode [0],decode [1]))&0xf);};return _eg .Gray {Y :_ffad *17&0xff},nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_eab *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_eab .copy ()}};var _ _egg .Image =&Monochrome {};func (_eae *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_eae .ImageBase .copy (),ModelThreshold :_eae .ModelThreshold };};func (_cfe *Gray4 )setGray (_dde int ,_cgdc int ,_bgg _eg .Gray ){_gfe :=_cgdc *_cfe .BytesPerLine ;_cafc :=_gfe +(_dde >>1);if _cafc >=len (_cfe .Data ){return ;};_eggg :=_bgg .Y >>4;_cfe .Data [_cafc ]=(_cfe .Data [_cafc ]&(^(0xf0>>uint (4*(_dde &1)))))|(_eggg <<uint (4-4*(_dde &1)));};func MonochromeModel (threshold uint8 )_eg .Model {return monochromeModel (threshold )};func (_fbee *NRGBA64 )Set (x ,y int ,c _eg .Color ){_gdd :=(y *_fbee .Width +x )*2;_fgae :=_gdd *3;if _fgae +5>=len (_fbee .Data ){return ;};_dbad :=_eg .NRGBA64Model .Convert (c ).(_eg .NRGBA64 );_fbee .setNRGBA64 (_fgae ,_dbad ,_gdd );};func _dgg (_fdcd ,_dbcg uint8 )uint8 {if _fdcd < _dbcg {return 255;};return 0;};func (_ddb *Gray8 )Base ()*ImageBase {return &_ddb .ImageBase };func (_ddd *Monochrome )Validate ()error {if len (_ddd .Data )!=_ddd .Height *_ddd .BytesPerLine {return ErrInvalidImage ;};return nil ;};type Gray16 struct{ImageBase };func (_ca *CMYK32 )ColorModel ()_eg .Model {return _eg .CMYKModel };func _cee (_gd RGBA ,_fe CMYK ,_gedg _egg .Rectangle ){for _fg :=0;_fg < _gedg .Max .X ;_fg ++{for _cf :=0;_cf < _gedg .Max .Y ;_cf ++{_fa :=_gd .RGBAAt (_fg ,_cf );_fe .SetCMYK (_fg ,_cf ,_geb (_fa ));};};};type CMYK32 struct{ImageBase };func (_egef *ImageBase )newAlpha (){_afge :=BytesPerLine (_egef .Width ,_egef .BitsPerComponent ,1);_egef .Alpha =make ([]byte ,_egef .Height *_afge );};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _g .Abs (xmax -xmin )< 0.000001{return ymin ;};_agad :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _agad ;};var _ Gray =&Gray4 {};func (_cebd *Gray4 )Set (x ,y int ,c _eg .Color ){if x >=_cebd .Width ||y >=_cebd .Height {return ;};_gcc :=Gray4Model .Convert (c ).(_eg .Gray );_cebd .setGray (x ,y ,_gcc );};func (_f *CMYK32 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtCMYK (x ,y ,_f .Width ,_f .Data ,_f .Decode );};func (_bbcd *Monochrome )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_bbcd .Width ,Y :_bbcd .Height }};};type Gray interface{GrayAt (_fba ,_afc int )_eg .Gray ;SetGray (_gee ,_bde int ,_ece _eg .Gray );};func (_fag *Monochrome )clearBit (_ebfe ,_ecgad int ){_fag .Data [_ebfe ]&=^(0x80>>uint (_ecgad &7))};func _cbab (_fagcg _egg .Image )(Image ,error ){if _bed ,_eefa :=_fagcg .(*NRGBA32 );_eefa {return _bed .Copy (),nil ;};_eeeb ,_bafb ,_abe :=_dcb (_fagcg ,1);_gffb ,_gcce :=NewImage (_eeeb .Max .X ,_eeeb .Max .Y ,8,3,nil ,_abe ,nil );if _gcce !=nil {return nil ,_gcce ;};_gffd (_fagcg ,_gffb ,_eeeb );if len (_abe )!=0&&!_bafb {if _fbdd :=_cdbg (_abe ,_gffb );_fbdd !=nil {return nil ,_fbdd ;};};return _gffb ,nil ;};func _bfgf (_gaae _egg .Image ,_aba Image ,_fdbc _egg .Rectangle ){if _aeea ,_bgd :=_gaae .(SMasker );_bgd &&_aeea .HasAlpha (){_aba .(SMasker ).MakeAlpha ();};_dgd (_gaae ,_aba ,_fdbc );};var _ Gray =&Gray8 {};func _geb (_cbe _eg .RGBA )_eg .CMYK {_aag ,_bbd ,_gff ,_cad :=_eg .RGBToCMYK (_cbe .R ,_cbe .G ,_cbe .B );return _eg .CMYK {C :_aag ,M :_bbd ,Y :_gff ,K :_cad };};func _bdabe (_dbae _egg .Image )(Image ,error ){if _bfgd ,_cgdg :=_dbae .(*NRGBA64 );_cgdg {return _bfgd .Copy (),nil ;};_gcae ,_bdfae ,_fbeg :=_dcb (_dbae ,2);_bcde ,_bedd :=NewImage (_gcae .Max .X ,_gcae .Max .Y ,16,3,nil ,_fbeg ,nil );if _bedd !=nil {return nil ,_bedd ;};_bfgf (_dbae ,_bcde ,_gcae );if len (_fbeg )!=0&&!_bdfae {if _eaca :=_cdbg (_fbeg ,_bcde );_eaca !=nil {return nil ,_eaca ;};};return _bcde ,nil ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_ege *Gray4 )Base ()*ImageBase {return &_ege .ImageBase };func (_dbe *Gray8 )Histogram ()(_efb [256]int ){for _bdfa :=0;_bdfa < len (_dbe .Data );_bdfa ++{_efb [_dbe .Data [_bdfa ]]++;};return _efb ;};func _ecgg (){for _bddd :=0;_bddd < 256;_bddd ++{_bddc [_bddd ]=uint8 (_bddd &0x1)+(uint8 (_bddd >>1)&0x1)+(uint8 (_bddd >>2)&0x1)+(uint8 (_bddd >>3)&0x1)+(uint8 (_bddd >>4)&0x1)+(uint8 (_bddd >>5)&0x1)+(uint8 (_bddd >>6)&0x1)+(uint8 (_bddd >>7)&0x1);};};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_eg .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func ImgToBinary (i _egg .Image ,threshold uint8 )*_egg .Gray {switch _gega :=i .(type ){case *_egg .Gray :if _bbcb (_gega ){return _gega ;};return _fceg (_gega ,threshold );case *_egg .Gray16 :return _dfbaf (_gega ,threshold );default:return _eeca (_gega ,threshold );};};func (_dbg *Gray16 )Set (x ,y int ,c _eg .Color ){_aec :=(y *_dbg .BytesPerLine /2+x )*2;if _aec +1>=len (_dbg .Data ){return ;};_cfbe :=_eg .Gray16Model .Convert (c ).(_eg .Gray16 );_dbg .Data [_aec ],_dbg .Data [_aec +1]=uint8 (_cfbe .Y >>8),uint8 (_cfbe .Y &0xff);};var _ _egg .Image =&Gray16 {};func (_aeag *NRGBA32 )Base ()*ImageBase {return &_aeag .ImageBase };func (_fcg *Gray4 )Histogram ()(_fcga [256]int ){for _cga :=0;_cga < _fcg .Width ;_cga ++{for _ccg :=0;_ccg < _fcg .Height ;_ccg ++{_fcga [_fcg .GrayAt (_cga ,_ccg ).Y ]++;};};return _fcga ;};func (_gdca *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_gdca .copy ()}};var _ _egg .Image =&NRGBA32 {};var _ _egg .Image =&NRGBA64 {};func _gdb (_adec RGBA ,_gedb Gray ,_fcd _egg .Rectangle ){for _abg :=0;_abg < _fcd .Max .X ;_abg ++{for _ebag :=0;_ebag < _fcd .Max .Y ;_ebag ++{_beg :=_feea (_adec .RGBAAt (_abg ,_ebag ));_gedb .SetGray (_abg ,_ebag ,_beg );};};};func (_defa *Gray16 )GrayAt (x ,y int )_eg .Gray {_dabg ,_ :=_defa .ColorAt (x ,y );return _eg .Gray {Y :uint8 (_dabg .(_eg .Gray16 ).Y >>8)};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_abde :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _abde ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_bbee :=width *colorComponents *bitsPerComponent ;_dbc :=_abde *8;_afca :=8-(_dbc -_bbee );_cgda :=_ee .NewReader (data );_aecb :=_abde -1;_fdb :=make ([]byte ,_aecb );_bcd :=make ([]byte ,height *_abde );_agda :=_ee .NewWriterMSB (_bcd );var _bcg uint64 ;var _ecf error ;for _bbb :=0;_bbb < height ;_bbb ++{_ ,_ecf =_cgda .Read (_fdb );if _ecf !=nil {return nil ,_ecf ;};_ ,_ecf =_agda .Write (_fdb );if _ecf !=nil {return nil ,_ecf ;};_bcg ,_ecf =_cgda .ReadBits (byte (_afca ));if _ecf !=nil {return nil ,_ecf ;};_ ,_ecf =_agda .WriteBits (_bcg ,_afca );if _ecf !=nil {return nil ,_ecf ;};_agda .FinishByte ();};return _bcd ,nil ;};func (_afga *Gray4 )ColorModel ()_eg .Model {return Gray4Model };var _bddc [256]uint8 ;func (_fdea *NRGBA16 )Set (x ,y int ,c _eg .Color ){_edgc :=y *_fdea .BytesPerLine +x *3/2;if _edgc +1>=len (_fdea .Data ){return ;};_aac :=NRGBA16Model .Convert (c ).(_eg .NRGBA );_fdea .setNRGBA (x ,y ,_edgc ,_aac );};func (_ceac *Gray8 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_ceac .Width ,Y :_ceac .Height }};};type Image interface{_d .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_aegg ,_dgc int )(_eg .Color ,error );Validate ()error ;};func _fceg (_dggb *_egg .Gray ,_ffb uint8 )*_egg .Gray {_ggcg :=_dggb .Bounds ();_gfdd :=_egg .NewGray (_ggcg );for _adf :=0;_adf < _ggcg .Dx ();_adf ++{for _cgebf :=0;_cgebf < _ggcg .Dy ();_cgebf ++{_edae :=_dggb .GrayAt (_adf ,_cgebf );_gfdd .SetGray (_adf ,_cgebf ,_eg .Gray {Y :_dgg (_edae .Y ,_ffb )});};};return _gfdd ;};func (_ccba *NRGBA32 )At (x ,y int )_eg .Color {_fcca ,_ :=_ccba .ColorAt (x ,y );return _fcca };var _ NRGBA =&NRGBA32 {};func _aabc (_daaf NRGBA ,_ggad Gray ,_aegc _egg .Rectangle ){for _cdgg :=0;_cdgg < _aegc .Max .X ;_cdgg ++{for _cbfc :=0;_cbfc < _aegc .Max .Y ;_cbfc ++{_acfa :=_cdg (_daaf .NRGBAAt (_cdgg ,_cbfc ));_ggad .SetGray (_cdgg ,_cbfc ,_acfa );};};};func _feea (_add _eg .RGBA )_eg .Gray {_acga :=(19595*uint32 (_add .R )+38470*uint32 (_add .G )+7471*uint32 (_add .B )+1<<7)>>16;return _eg .Gray {Y :uint8 (_acga )};};func _gad (_ccdb _eg .NRGBA )_eg .NRGBA {_ccdb .R =_ccdb .R >>4|(_ccdb .R >>4)<<4;_ccdb .G =_ccdb .G >>4|(_ccdb .G >>4)<<4;_ccdb .B =_ccdb .B >>4|(_ccdb .B >>4)<<4;return _ccdb ;};func (_gdgf *NRGBA64 )setNRGBA64 (_dgf int ,_aecc _eg .NRGBA64 ,_baa int ){_gdgf .Data [_dgf ]=uint8 (_aecc .R >>8);_gdgf .Data [_dgf +1]=uint8 (_aecc .R &0xff);_gdgf .Data [_dgf +2]=uint8 (_aecc .G >>8);_gdgf .Data [_dgf +3]=uint8 (_aecc .G &0xff);_gdgf .Data [_dgf +4]=uint8 (_aecc .B >>8);_gdgf .Data [_dgf +5]=uint8 (_aecc .B &0xff);if _baa +1< len (_gdgf .Alpha ){_gdgf .Alpha [_baa ]=uint8 (_aecc .A >>8);_gdgf .Alpha [_baa +1]=uint8 (_aecc .A &0xff);};};func _ega (_agc _eg .CMYK )_eg .NRGBA {_bcca ,_bfg ,_cec :=_eg .CMYKToRGB (_agc .C ,_agc .M ,_agc .Y ,_agc .K );return _eg .NRGBA {R :_bcca ,G :_bfg ,B :_cec ,A :0xff};};type Histogramer interface{Histogram ()[256]int ;};func (_gaac *Gray2 )At (x ,y int )_eg .Color {_cgde ,_ :=_gaac .ColorAt (x ,y );return _cgde };func GrayHistogram (g Gray )(_aegb [256]int ){switch _abf :=g .(type ){case Histogramer :return _abf .Histogram ();case _egg .Image :_ffdf :=_abf .Bounds ();for _ffdg :=0;_ffdg < _ffdf .Max .X ;_ffdg ++{for _cbgg :=0;_cbgg < _ffdf .Max .Y ;_cbgg ++{_aegb [g .GrayAt (_ffdg ,_cbgg ).Y ]++;};};return _aegb ;default:return [256]int {};};};var _ Image =&NRGBA16 {};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_dec *Gray8 )GrayAt (x ,y int )_eg .Gray {_ccb ,_ :=ColorAtGray8BPC (x ,y ,_dec .BytesPerLine ,_dec .Data ,_dec .Decode );return _ccb ;};func (_ffcg *Gray16 )Histogram ()(_fagd [256]int ){for _ebc :=0;_ebc < _ffcg .Width ;_ebc ++{for _gcca :=0;_gcca < _ffcg .Height ;_gcca ++{_fagd [_ffcg .GrayAt (_ebc ,_gcca ).Y ]++;};};return _fagd ;};func _ccc (_cced _egg .Image )(Image ,error ){if _adgg ,_ddc :=_cced .(*Gray16 );_ddc {return _adgg .Copy (),nil ;};_agb :=_cced .Bounds ();_fagc ,_dbf :=NewImage (_agb .Max .X ,_agb .Max .Y ,16,1,nil ,nil ,nil );if _dbf !=nil {return nil ,_dbf ;};_cgc (_cced ,_fagc ,_agb );return _fagc ,nil ;};func _fef (_eeaf CMYK ,_eaf Gray ,_bca _egg .Rectangle ){for _adcc :=0;_adcc < _bca .Max .X ;_adcc ++{for _dge :=0;_dge < _bca .Max .Y ;_dge ++{_ddeg :=_fcb (_eeaf .CMYKAt (_adcc ,_dge ));_eaf .SetGray (_adcc ,_dge ,_ddeg );};};};var _ _egg .Image =&Gray4 {};func _faff (_cegf RGBA ,_dced NRGBA ,_bccce _egg .Rectangle ){for _beaa :=0;_beaa < _bccce .Max .X ;_beaa ++{for _ecda :=0;_ecda < _bccce .Max .Y ;_ecda ++{_dbgg :=_cegf .RGBAAt (_beaa ,_ecda );_dced .SetNRGBA (_beaa ,_ecda ,_bbed (_dbgg ));};};};func (_afgd *Monochrome )Set (x ,y int ,c _eg .Color ){_gfd :=y *_afgd .BytesPerLine +x >>3;if _gfd > len (_afgd .Data )-1{return ;};_bgc :=_afgd .ColorModel ().Convert (c ).(_eg .Gray );_afgd .setGray (x ,_bgc ,_gfd );};func (_edaf *Gray4 )Validate ()error {if len (_edaf .Data )!=_edaf .Height *_edaf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func (_cea *Gray2 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_cea .Width ,Y :_cea .Height }};};func (_gc *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_gc .copy ()}};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_eg .Gray16 ,error ){_eeee :=(y *bytesPerLine /2+x )*2;if _eeee +1>=len (data ){return _eg .Gray16 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dff :=uint16 (data [_eeee ])<<8|uint16 (data [_eeee +1]);if len (decode )==2{_dff =uint16 (uint64 (LinearInterpolate (float64 (_dff ),0,65535,decode [0],decode [1])));};return _eg .Gray16 {Y :_dff },nil ;};func (_eca *Gray8 )Validate ()error {if len (_eca .Data )!=_eca .Height *_eca .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gffd (_bgfa _egg .Image ,_gdda Image ,_dafc _egg .Rectangle ){if _bdg ,_bega :=_bgfa .(SMasker );_bega &&_bdg .HasAlpha (){_gdda .(SMasker ).MakeAlpha ();};switch _fdc :=_bgfa .(type ){case Gray :_bfa (_fdc ,_gdda .(NRGBA ),_dafc );case NRGBA :_abgea (_fdc ,_gdda .(NRGBA ),_dafc );case *_egg .NYCbCrA :_afbe (_fdc ,_gdda .(NRGBA ),_dafc );case CMYK :_gaag (_fdc ,_gdda .(NRGBA ),_dafc );case RGBA :_faff (_fdc ,_gdda .(NRGBA ),_dafc );case nrgba64 :_afgae (_fdc ,_gdda .(NRGBA ),_dafc );default:_dgd (_bgfa ,_gdda ,_dafc );};};func (_gea *NRGBA16 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtNRGBA16 (x ,y ,_gea .Width ,_gea .BytesPerLine ,_gea .Data ,_gea .Alpha ,_gea .Decode );};func (_afe *NRGBA64 )NRGBA64At (x ,y int )_eg .NRGBA64 {_ffg ,_ :=ColorAtNRGBA64 (x ,y ,_afe .Width ,_afe .Data ,_afe .Alpha ,_afe .Decode );return _ffg ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_eg .NRGBA ,error ){_addd :=y *bytesPerLine +x *3/2;if _addd +1>=len (data ){return _eg .NRGBA {},_cfeg (x ,y );};const (_cdga =0xf;_eecf =uint8 (0xff););_agfb :=_eecf ;if alpha !=nil {_bggg :=y *BytesPerLine (width ,4,1);if _bggg < len (alpha ){if x %2==0{_agfb =(alpha [_bggg ]>>uint (4))&_cdga ;}else {_agfb =alpha [_bggg ]&_cdga ;};_agfb |=_agfb <<4;};};var _gegb ,_abdf ,_abge uint8 ;if x *3%2==0{_gegb =(data [_addd ]>>uint (4))&_cdga ;_abdf =data [_addd ]&_cdga ;_abge =(data [_addd +1]>>uint (4))&_cdga ;}else {_gegb =data [_addd ]&_cdga ;_abdf =(data [_addd +1]>>uint (4))&_cdga ;_abge =data [_addd +1]&_cdga ;};if len (decode )==6{_gegb =uint8 (uint32 (LinearInterpolate (float64 (_gegb ),0,15,decode [0],decode [1]))&0xf);_abdf =uint8 (uint32 (LinearInterpolate (float64 (_abdf ),0,15,decode [2],decode [3]))&0xf);_abge =uint8 (uint32 (LinearInterpolate (float64 (_abge ),0,15,decode [4],decode [5]))&0xf);};return _eg .NRGBA {R :(_gegb <<4)|(_gegb &0xf),G :(_abdf <<4)|(_abdf &0xf),B :(_abge <<4)|(_abge &0xf),A :_agfb },nil ;};func (_ddea *NRGBA32 )ColorModel ()_eg .Model {return _eg .NRGBAModel };func _cfeg (_eddg int ,_fgbc int )error {return _a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_eddg ,_fgbc );};func _caf (_gedf _eg .Gray )_eg .NRGBA {return _eg .NRGBA {R :_gedf .Y ,G :_gedf .Y ,B :_gedf .Y ,A :0xff}};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gccb :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_gccb .Data =make ([]byte ,height *_gccb .BytesPerLine );};return _gccb ;};func FromGoImage (i _egg .Image )(Image ,error ){switch _aceg :=i .(type ){case Image :return _aceg .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_egg .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_egg .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _gdcac ,_fecd ,_deda ,_edafc int ;for _fefc :=0;_fefc < len (histogram );_fefc ++{if histogram [_fefc ]> 0{_gdcac =_fefc ;break ;};};if _gdcac > 0{_gdcac --;};for _dbgf :=255;_dbgf > 0;_dbgf --{if histogram [_dbgf ]> 0{_edafc =_dbgf ;break ;};};if _edafc < 255{_edafc ++;};for _bgdc :=0;_bgdc < 256;_bgdc ++{if histogram [_bgdc ]> _fecd {_deda =_bgdc ;_fecd =histogram [_bgdc ];};};var _gafb bool ;if (_deda -_gdcac )< (_edafc -_deda ){_gafb =true ;var _ddee int ;_febg :=255;for _ddee < _febg {_dedc :=histogram [_ddee ];histogram [_ddee ]=histogram [_febg ];histogram [_febg ]=_dedc ;_ddee ++;_febg --;};_gdcac =255-_edafc ;_deda =255-_deda ;};if _gdcac ==_deda {return uint8 (_gdcac );};_ddbd :=float64 (histogram [_deda ]);_gdce :=float64 (_gdcac -_deda );_ebcg :=_g .Sqrt (_ddbd *_ddbd +_gdce *_gdce );_ddbd /=_ebcg ;_gdce /=_ebcg ;_ebcg =_ddbd *float64 (_gdcac )+_gdce *float64 (histogram [_gdcac ]);_fdda :=_gdcac ;var _baef float64 ;for _gddb :=_gdcac +1;_gddb <=_deda ;_gddb ++{_bfgg :=_ddbd *float64 (_gddb )+_gdce *float64 (histogram [_gddb ])-_ebcg ;if _bfgg > _baef {_fdda =_gddb ;_baef =_bfgg ;};};_fdda --;if _gafb {var _gefg int ;_efbc :=255;for _gefg < _efbc {_acfc :=histogram [_gefg ];histogram [_gefg ]=histogram [_efbc ];histogram [_efbc ]=_acfc ;_gefg ++;_efbc --;};return uint8 (255-_fdda );};return uint8 (_fdda );};func (_ddef *NRGBA64 )Base ()*ImageBase {return &_ddef .ImageBase };type Gray8 struct{ImageBase };func (_fec *Gray2 )ColorModel ()_eg .Model {return Gray2Model };type NRGBA16 struct{ImageBase };func (_aaf *NRGBA64 )Validate ()error {if len (_aaf .Data )!=3*2*_aaf .Width *_aaf .Height {return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_cba *Monochrome )setGray (_gba int ,_eag _eg .Gray ,_efdc int ){if _eag .Y ==0{_cba .clearBit (_efdc ,_gba );}else {_cba .setBit (_efdc ,_gba );};};func (_afb *Monochrome )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtGray1BPC (x ,y ,_afb .BytesPerLine ,_afb .Data ,_afb .Decode );};var _ _egg .Image =&NRGBA16 {};func _bbed (_gdg _eg .RGBA )_eg .NRGBA {switch _gdg .A {case 0xff:return _eg .NRGBA {R :_gdg .R ,G :_gdg .G ,B :_gdg .B ,A :0xff};case 0x00:return _eg .NRGBA {};default:_fed ,_fbb ,_cca ,_dfb :=_gdg .RGBA ();_fed =(_fed *0xffff)/_dfb ;_fbb =(_fbb *0xffff)/_dfb ;_cca =(_cca *0xffff)/_dfb ;return _eg .NRGBA {R :uint8 (_fed >>8),G :uint8 (_fbb >>8),B :uint8 (_cca >>8),A :uint8 (_dfb >>8)};};};func (_aeeg *NRGBA16 )Validate ()error {if len (_aeeg .Data )!=3*_aeeg .Width *_aeeg .Height /2{return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_ccd *ImageBase )MakeAlpha (){_ccd .newAlpha ()};func (_bdf *Monochrome )ColorModel ()_eg .Model {return MonochromeModel (_bdf .ModelThreshold )};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_eg .NRGBA64 ,error ){_eaga :=(y *width +x )*2;_gefd :=_eaga *3;if _gefd +5>=len (data ){return _eg .NRGBA64 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _gfee =0xffff;_dfef :=uint16 (_gfee );if alpha !=nil &&len (alpha )> _eaga +1{_dfef =uint16 (alpha [_eaga ])<<8|uint16 (alpha [_eaga +1]);};_gbg :=uint16 (data [_gefd ])<<8|uint16 (data [_gefd +1]);_bac :=uint16 (data [_gefd +2])<<8|uint16 (data [_gefd +3]);_fbba :=uint16 (data [_gefd +4])<<8|uint16 (data [_gefd +5]);if len (decode )==6{_gbg =uint16 (uint64 (LinearInterpolate (float64 (_gbg ),0,65535,decode [0],decode [1]))&_gfee );_bac =uint16 (uint64 (LinearInterpolate (float64 (_bac ),0,65535,decode [2],decode [3]))&_gfee );_fbba =uint16 (uint64 (LinearInterpolate (float64 (_fbba ),0,65535,decode [4],decode [5]))&_gfee );};return _eg .NRGBA64 {R :_gbg ,G :_bac ,B :_fbba ,A :_dfef },nil ;};func (_daf *Gray2 )Histogram ()(_gdgc [256]int ){for _cbb :=0;_cbb < _daf .Width ;_cbb ++{for _dfab :=0;_dfab < _daf .Height ;_dfab ++{_gdgc [_daf .GrayAt (_cbb ,_dfab ).Y ]++;};};return _gdgc ;};func (_ddfc *ImageBase )GetAlpha ()[]byte {return _ddfc .Alpha };type RGBA interface{RGBAAt (_caeg ,_aae int )_eg .RGBA ;SetRGBA (_gfdca ,_fbc int ,_bdab _eg .RGBA );};func _gaag (_abec CMYK ,_agg NRGBA ,_eaeg _egg .Rectangle ){for _feff :=0;_feff < _eaeg .Max .X ;_feff ++{for _aeaf :=0;_aeaf < _eaeg .Max .Y ;_aeaf ++{_fcac :=_abec .CMYKAt (_feff ,_aeaf );_agg .SetNRGBA (_feff ,_aeaf ,_ega (_fcac ));};};};func (_cfa *ImageBase )HasAlpha ()bool {if _cfa .Alpha ==nil {return false ;};for _bbeg :=range _cfa .Alpha {if _cfa .Alpha [_bbeg ]!=0xff{return true ;};};return false ;};func (_eceb *Gray8 )At (x ,y int )_eg .Color {_bafg ,_ :=_eceb .ColorAt (x ,y );return _bafg };var _ Gray =&Gray2 {};func (_gade *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_gade .copy ()}};func (_gbba *NRGBA16 )NRGBAAt (x ,y int )_eg .NRGBA {_ggcb ,_ :=ColorAtNRGBA16 (x ,y ,_gbba .Width ,_gbba .BytesPerLine ,_gbba .Data ,_gbba .Alpha ,_gbba .Decode );return _ggcb ;};var _ Gray =&Gray16 {};func _df (_da _eg .NRGBA )_eg .CMYK {_bae ,_ffc ,_dgb ,_ :=_da .RGBA ();_gaf ,_ebf ,_fbd ,_dgdd :=_eg .RGBToCMYK (uint8 (_bae >>8),uint8 (_ffc >>8),uint8 (_dgb >>8));return _eg .CMYK {C :_gaf ,M :_ebf ,Y :_fbd ,K :_dgdd };};func IsGrayImgBlackAndWhite (i *_egg .Gray )bool {return _bbcb (i )};func (_cce *Gray16 )Validate ()error {if len (_cce .Data )!=_cce .Height *_cce .BytesPerLine {return ErrInvalidImage ;};return nil ;};var _ _egg .Image =&Gray2 {};func (_dfabe *Gray8 )SetGray (x ,y int ,g _eg .Gray ){_eeef :=y *_dfabe .BytesPerLine +x ;if _eeef > len (_dfabe .Data )-1{return ;};_dfabe .Data [_eeef ]=g .Y ;};func (_cdb *Gray2 )Set (x ,y int ,c _eg .Color ){if x >=_cdb .Width ||y >=_cdb .Height {return ;};_dcf :=Gray2Model .Convert (c ).(_eg .Gray );_ada :=y *_cdb .BytesPerLine ;_bded :=_ada +(x >>2);_facd :=_dcf .Y >>6;_cdb .Data [_bded ]=(_cdb .Data [_bded ]&(^(0xc0>>uint (2*((x )&3)))))|(_facd <<uint (6-2*(x &3)));};func _fcb (_gfc _eg .CMYK )_eg .Gray {_bgf ,_abc ,_eac :=_eg .CMYKToRGB (_gfc .C ,_gfc .M ,_gfc .Y ,_gfc .K );_gcf :=(19595*uint32 (_bgf )+38470*uint32 (_abc )+7471*uint32 (_eac )+1<<7)>>16;return _eg .Gray {Y :uint8 (_gcf )};};func (_aga *Gray2 )Validate ()error {if len (_aga .Data )!=_aga .Height *_aga .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_eg .CMYK ,error ){_bd :=4*(y *width +x );if _bd +3>=len (data ){return _eg .CMYK {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_bd ]&0xff;M :=data [_bd +1]&0xff;Y :=data [_bd +2]&0xff;K :=data [_bd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _eg .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_cbf *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cbf .copy ()}};func _cgc (_dedg _egg .Image ,_baed Image ,_ced _egg .Rectangle ){switch _dfba :=_dedg .(type ){case Gray :_efde (_dfba ,_baed .(Gray ),_ced );case NRGBA :_aabc (_dfba ,_baed .(Gray ),_ced );case CMYK :_fef (_dfba ,_baed .(Gray ),_ced );case RGBA :_gdb (_dfba ,_baed .(Gray ),_ced );default:_dgd (_dedg ,_baed .(Image ),_ced );};};type colorConverter struct{_fgd func (_dba _egg .Image )(Image ,error );};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_eg .Gray ,error ){_eee :=y *bytesPerLine +x >>2;if _eee >=len (data ){return _eg .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ede :=data [_eee ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ede =uint8 (uint32 (LinearInterpolate (float64 (_ede ),0,3.0,decode [0],decode [1]))&3);};return _eg .Gray {Y :_ede *85},nil ;};func (_dd *CMYK32 )SetCMYK (x ,y int ,c _eg .CMYK ){_ggb :=4*(y *_dd .Width +x );if _ggb +3>=len (_dd .Data ){return ;};_dd .Data [_ggb ]=c .C ;_dd .Data [_ggb +1]=c .M ;_dd .Data [_ggb +2]=c .Y ;_dd .Data [_ggb +3]=c .K ;};func (_dedd *NRGBA32 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtNRGBA32 (x ,y ,_dedd .Width ,_dedd .Data ,_dedd .Alpha ,_dedd .Decode );};func _ddcf (_fcf _egg .Image )(Image ,error ){if _ccf ,_ecde :=_fcf .(*NRGBA16 );_ecde {return _ccf .Copy (),nil ;};_affg :=_fcf .Bounds ();_cbg ,_gbea :=NewImage (_affg .Max .X ,_affg .Max .Y ,4,3,nil ,nil ,nil );if _gbea !=nil {return nil ,_gbea ;};_gffd (_fcf ,_cbg ,_affg );return _cbg ,nil ;};var _ Image =&NRGBA64 {};func (_aegf *NRGBA64 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtNRGBA64 (x ,y ,_aegf .Width ,_aegf .Data ,_aegf .Alpha ,_aegf .Decode );};func _afgae (_cgeb nrgba64 ,_bbcg NRGBA ,_aeb _egg .Rectangle ){for _cdda :=0;_cdda < _aeb .Max .X ;_cdda ++{for _bfbe :=0;_bfbe < _aeb .Max .Y ;_bfbe ++{_gace :=_cgeb .NRGBA64At (_cdda ,_bfbe );_bbcg .SetNRGBA (_cdda ,_bfbe ,_bbc (_gace ));};};};func _gec (_agd _eg .NYCbCrA )_eg .NRGBA {_ebe :=int32 (_agd .Y )*0x10101;_dc :=int32 (_agd .Cb )-128;_cfd :=int32 (_agd .Cr )-128;_bfd :=_ebe +91881*_cfd ;if uint32 (_bfd )&0xff000000==0{_bfd >>=8;}else {_bfd =^(_bfd >>31)&0xffff;};_cde :=_ebe -22554*_dc -46802*_cfd ;if uint32 (_cde )&0xff000000==0{_cde >>=8;}else {_cde =^(_cde >>31)&0xffff;};_gca :=_ebe +116130*_dc ;if uint32 (_gca )&0xff000000==0{_gca >>=8;}else {_gca =^(_gca >>31)&0xffff;};return _eg .NRGBA {R :uint8 (_bfd >>8),G :uint8 (_cde >>8),B :uint8 (_gca >>8),A :_agd .A };};func (_gb colorConverter )Convert (src _egg .Image )(Image ,error ){return _gb ._fgd (src )};func (_dfe *NRGBA64 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_dfe .Width ,Y :_dfe .Height }};};func (_febe *NRGBA32 )Validate ()error {if len (_febe .Data )!=3*_febe .Width *_febe .Height {return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _ab (_gcb _egg .Image )(Image ,error ){if _ce ,_gag :=_gcb .(*CMYK32 );_gag {return _ce .Copy (),nil ;};_eeg :=_gcb .Bounds ();_bf ,_ace :=NewImage (_eeg .Max .X ,_eeg .Max .Y ,8,4,nil ,nil ,nil );if _ace !=nil {return nil ,_ace ;};switch _ea :=_gcb .(type ){case CMYK :_gga (_ea ,_bf .(CMYK ),_eeg );case Gray :_gf (_ea ,_bf .(CMYK ),_eeg );case NRGBA :_ad (_ea ,_bf .(CMYK ),_eeg );case RGBA :_cee (_ea ,_bf .(CMYK ),_eeg );default:_dgd (_gcb ,_bf ,_eeg );};return _bf ,nil ;};func _cdbg (_dffa []byte ,_fgfg Image )error {_adeb :=true ;for _cgb :=0;_cgb < len (_dffa );_cgb ++{if _dffa [_cgb ]!=0xff{_adeb =false ;break ;};};if _adeb {switch _ddcg :=_fgfg .(type ){case *NRGBA32 :_ddcg .Alpha =nil ;case *NRGBA64 :_ddcg .Alpha =nil ;default:return _a .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fgfg );};};return nil ;};func _bbcb (_feac *_egg .Gray )bool {for _afdf :=0;_afdf < len (_feac .Pix );_afdf ++{if !_bfbd (_feac .Pix [_afdf ]){return false ;};};return true ;};type NRGBA32 struct{ImageBase };func _gegf (_ebeb _egg .Image )(Image ,error ){if _gfccd ,_adg :=_ebeb .(*Gray2 );_adg {return _gfccd .Copy (),nil ;};_fgb :=_ebeb .Bounds ();_bdee ,_edd :=NewImage (_fgb .Max .X ,_fgb .Max .Y ,2,1,nil ,nil ,nil );if _edd !=nil {return nil ,_edd ;};_cgc (_ebeb ,_bdee ,_fgb );return _bdee ,nil ;};var (MonochromeConverter =ConverterFunc (_def );Gray2Converter =ConverterFunc (_gegf );Gray4Converter =ConverterFunc (_gfdf );GrayConverter =ConverterFunc (_eacc );Gray16Converter =ConverterFunc (_ccc );NRGBA16Converter =ConverterFunc (_ddcf );NRGBAConverter =ConverterFunc (_cbab );NRGBA64Converter =ConverterFunc (_bdabe );CMYKConverter =ConverterFunc (_ab ););func _eeac (_ccab _eg .Color )_eg .Color {_cfbgf :=_eg .NRGBAModel .Convert (_ccab ).(_eg .NRGBA );return _gad (_cfbgf );};func _bfa (_daeg Gray ,_dca NRGBA ,_bgce _egg .Rectangle ){for _bad :=0;_bad < _bgce .Max .X ;_bad ++{for _eeff :=0;_eeff < _bgce .Max .Y ;_eeff ++{_fccab :=_daeg .GrayAt (_bad ,_eeff );_dca .SetNRGBA (_bad ,_eeff ,_caf (_fccab ));};};};func _fcbf (_gge _eg .Color )_eg .Color {_bdff :=_eg .GrayModel .Convert (_gge ).(_eg .Gray );return _gbb (_bdff );};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_eg .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};var _ _egg .Image =&Gray8 {};func _bfbd (_fgaf uint8 )bool {if _fgaf ==0||_fgaf ==255{return true ;};return false ;};func (_ecga *Monochrome )GrayAt (x ,y int )_eg .Gray {_ggba ,_ :=ColorAtGray1BPC (x ,y ,_ecga .BytesPerLine ,_ecga .Data ,_ecga .Decode );return _ggba ;};var _ NRGBA =&NRGBA16 {};func (_ffadc *Gray8 )ColorAt (x ,y int )(_eg .Color ,error ){return ColorAtGray8BPC (x ,y ,_ffadc .BytesPerLine ,_ffadc .Data ,_ffadc .Decode );};func _gf (_cdc Gray ,_eb CMYK ,_gaa _egg .Rectangle ){for _cb :=0;_cb < _gaa .Max .X ;_cb ++{for _fcc :=0;_fcc < _gaa .Max .Y ;_fcc ++{_acg :=_cdc .GrayAt (_cb ,_fcc );_eb .SetCMYK (_cb ,_fcc ,_bbe (_acg ));};};};var _ Image =&Monochrome {};func (_cff *Monochrome )At (x ,y int )_eg .Color {_daa ,_ :=_cff .ColorAt (x ,y );return _daa };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_eg .Gray ,error ){_egd :=y *bytesPerLine +x >>3;if _egd >=len (data ){return _eg .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ebef :=data [_egd ]>>uint (7-(x &7))&1;if len (decode )==2{_ebef =uint8 (LinearInterpolate (float64 (_ebef ),0.0,1.0,decode [0],decode [1]))&1;};return _eg .Gray {Y :_ebef *255},nil ;};func (_gcfe *NRGBA16 )SetNRGBA (x ,y int ,c _eg .NRGBA ){_aead :=y *_gcfe .BytesPerLine +x *3/2;if _aead +1>=len (_gcfe .Data ){return ;};c =_gad (c );_gcfe .setNRGBA (x ,y ,_aead ,c );};func (_bggf *NRGBA16 )ColorModel ()_eg .Model {return NRGBA16Model };func (_eff *CMYK32 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_eff .Width ,Y :_eff .Height }};};type NRGBA64 struct{ImageBase };func (_agbc *NRGBA32 )NRGBAAt (x ,y int )_eg .NRGBA {_gdf ,_ :=ColorAtNRGBA32 (x ,y ,_agbc .Width ,_agbc .Data ,_agbc .Alpha ,_agbc .Decode );return _gdf ;};func (_feb *NRGBA16 )Base ()*ImageBase {return &_feb .ImageBase };func (_ed *CMYK32 )Validate ()error {if len (_ed .Data )!=4*_ed .Width *_ed .Height {return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_efd *Monochrome )SetGray (x ,y int ,g _eg .Gray ){_fdd :=y *_efd .BytesPerLine +x >>3;if _fdd > len (_efd .Data )-1{return ;};g =_cfbg (g ,monochromeModel (_efd .ModelThreshold ));_efd .setGray (x ,g ,_fdd );};func ImgToGray (i _egg .Image )*_egg .Gray {if _aeead ,_gcgc :=i .(*_egg .Gray );_gcgc {return _aeead ;};_dbfb :=i .Bounds ();_eccc :=_egg .NewGray (_dbfb );for _egc :=0;_egc < _dbfb .Max .X ;_egc ++{for _ead :=0;_ead < _dbfb .Max .Y ;_ead ++{_ffda :=i .At (_egc ,_ead );_eccc .Set (_egc ,_ead ,_ffda );};};return _eccc ;};func ConverterFunc (converterFunc func (_ecg _egg .Image )(Image ,error ))ColorConverter {return colorConverter {_fgd :converterFunc };};type monochromeModel uint8 ;func (_aaab *NRGBA32 )SetNRGBA (x ,y int ,c _eg .NRGBA ){_agdag :=y *_aaab .Width +x ;_bbbg :=3*_agdag ;if _bbbg +2>=len (_aaab .Data ){return ;};_aaab .setRGBA (_agdag ,c );return ;};func (_aef *Gray8 )ColorModel ()_eg .Model {return _eg .GrayModel };func (_addg *NRGBA64 )SetNRGBA64 (x ,y int ,c _eg .NRGBA64 ){_feeac :=(y *_addg .Width +x )*2;_bdba :=_feeac *3;if _bdba +5>=len (_addg .Data ){return ;};_addg .setNRGBA64 (_bdba ,c ,_feeac );};func (_fdga *Gray8 )Set (x ,y int ,c _eg .Color ){_ggce :=y *_fdga .BytesPerLine +x ;if _ggce > len (_fdga .Data )-1{return ;};_cegg :=_eg .GrayModel .Convert (c );_fdga .Data [_ggce ]=_cegg .(_eg .Gray ).Y ;};func (_ff *CMYK32 )At (x ,y int )_eg .Color {_gef ,_ :=_ff .ColorAt (x ,y );return _gef };type nrgba64 interface{NRGBA64At (_efg ,_beb int )_eg .NRGBA64 ;SetNRGBA64 (_ebgf ,_cbd int ,_dcc _eg .NRGBA64 );};func _dgd (_fee _egg .Image ,_cfb Image ,_fd _egg .Rectangle ){for _afg :=0;_afg < _fd .Max .X ;_afg ++{for _cgd :=0;_cgd < _fd .Max .Y ;_cgd ++{_bea :=_fee .At (_afg ,_cgd );_cfb .Set (_afg ,_cgd ,_bea );};};};func (_dbec *NRGBA32 )Set (x ,y int ,c _eg .Color ){_gac :=y *_dbec .Width +x ;_gceda :=3*_gac ;if _gceda +2>=len (_dbec .Data ){return ;};_gfb :=_eg .NRGBAModel .Convert (c ).(_eg .NRGBA );_dbec .setRGBA (_gac ,_gfb );};func (_fbg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_fbg .copy ()}};func (_cdgae *NRGBA32 )Bounds ()_egg .Rectangle {return _egg .Rectangle {Max :_egg .Point {X :_cdgae .Width ,Y :_cdgae .Height }};};func _gbb (_gffg _eg .Gray )_eg .Gray {_eef :=_gffg .Y >>6;_eef |=_eef <<2;_gffg .Y =_eef |_eef <<4;return _gffg ;};func _cfbg (_ffa _eg .Gray ,_eeb monochromeModel )_eg .Gray {if _ffa .Y > uint8 (_eeb ){return _eg .Gray {Y :_g .MaxUint8 };};return _eg .Gray {};};func _gga (_dbb ,_af CMYK ,_bc _egg .Rectangle ){for _dg :=0;_dg < _bc .Max .X ;_dg ++{for _bg :=0;_bg < _bc .Max .Y ;_bg ++{_af .SetCMYK (_dg ,_bg ,_dbb .CMYKAt (_dg ,_bg ));};};};var _ Image =&CMYK32 {};func _dfbaf (_abcea *_egg .Gray16 ,_egdb uint8 )*_egg .Gray {_dea :=_abcea .Bounds ();_efa :=_egg .NewGray (_dea );for _fgde :=0;_fgde < _dea .Dx ();_fgde ++{for _fafb :=0;_fafb < _dea .Dy ();_fafb ++{_gcea :=_abcea .Gray16At (_fgde ,_fafb );_efa .SetGray (_fgde ,_fafb ,_eg .Gray {Y :_dgg (uint8 (_gcea .Y /256),_egdb )});};};return _efa ;};func (_fb *CMYK32 )CMYKAt (x ,y int )_eg .CMYK {_ga ,_ :=ColorAtCMYK (x ,y ,_fb .Width ,_fb .Data ,_fb .Decode );return _ga ;};