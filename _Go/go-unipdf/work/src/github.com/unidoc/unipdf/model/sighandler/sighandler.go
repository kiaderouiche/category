//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_g "bytes";_dc "crypto";_dcd "crypto/rand";_gd "crypto/rsa";_f "crypto/x509";_gb "crypto/x509/pkix";_db "encoding/asn1";_da "errors";_d "fmt";_e "github.com/unidoc/pkcs7";_de "github.com/unidoc/timestamp";_dd "github.com/unidoc/unipdf/v3/core";_fc "github.com/unidoc/unipdf/v3/model";_ad "github.com/unidoc/unipdf/v3/model/sigutil";_b "hash";_c "time";);

// Validate validates PdfSignature.
func (_dcc *adobeX509RSASHA1 )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){_abg ,_gge :=_dcc .getCertificate (sig );if _gge !=nil {return _fc .SignatureValidationResult {},_gge ;};_dcg :=sig .Contents .Bytes ();var _dccg []byte ;if _ ,_age :=_db .Unmarshal (_dcg ,&_dccg );_age !=nil {return _fc .SignatureValidationResult {},_age ;};_aab ,_gc :=digest .(_b .Hash );if !_gc {return _fc .SignatureValidationResult {},_da .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_addg ,_ :=_bba (_abg .SignatureAlgorithm );if _cda :=_gd .VerifyPKCS1v15 (_abg .PublicKey .(*_gd .PublicKey ),_addg ,_aab .Sum (nil ),_dccg );_cda !=nil {return _fc .SignatureValidationResult {},_cda ;};return _fc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};type adobeX509RSASHA1 struct{_aed *_gd .PrivateKey ;_adf *_f .Certificate ;_cc SignFunc ;_cd bool ;};type adobePKCS7Detached struct{_bc *_gd .PrivateKey ;_gg *_f .Certificate ;_fg bool ;_bb int ;};

// InitSignature initialises the PdfSignature.
func (_fbd *adobeX509RSASHA1 )InitSignature (sig *_fc .PdfSignature )error {if _fbd ._adf ==nil {return _da .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _fbd ._aed ==nil &&_fbd ._cc ==nil {return _da .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_af :=*_fbd ;sig .Handler =&_af ;sig .Filter =_dd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dd .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_dd .MakeString (string (_af ._adf .Raw ));sig .Reference =nil ;_ge ,_eaa :=_af .NewDigest (sig );if _eaa !=nil {return _eaa ;};_ge .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _af .sign (sig ,_ge ,_fbd ._cd );};type docTimeStamp struct{_bec string ;_bgdd _dc .Hash ;_ddb int ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bfc *adobeX509RSASHA1 )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {var _ec []byte ;var _aga error ;if _bfc ._cc !=nil {_ec ,_aga =_bfc ._cc (sig ,digest );if _aga !=nil {return _aga ;};}else {_ddg ,_ccb :=digest .(_b .Hash );if !_ccb {return _da .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_df ,_ :=_bba (_bfc ._adf .SignatureAlgorithm );_ec ,_aga =_gd .SignPKCS1v15 (_dcd .Reader ,_bfc ._aed ,_df ,_ddg .Sum (nil ));if _aga !=nil {return _aga ;};};_ec ,_aga =_db .Marshal (_ec );if _aga !=nil {return _aga ;};sig .Contents =_dd .MakeHexString (string (_ec ));return nil ;};

// Validate validates PdfSignature.
func (_bee *docTimeStamp )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){_aee :=sig .Contents .Bytes ();_ade ,_gce :=_e .Parse (_aee );if _gce !=nil {return _fc .SignatureValidationResult {},_gce ;};if _gce =_ade .Verify ();_gce !=nil {return _fc .SignatureValidationResult {},_gce ;};var _bd timestampInfo ;_ ,_gce =_db .Unmarshal (_ade .Content ,&_bd );if _gce !=nil {return _fc .SignatureValidationResult {},_gce ;};_eab ,_gce :=_fcba (_bd .MessageImprint .HashAlgorithm .Algorithm );if _gce !=nil {return _fc .SignatureValidationResult {},_gce ;};_cbe :=_eab .New ();_aca :=digest .(*_g .Buffer );_cbe .Write (_aca .Bytes ());_ebd :=_cbe .Sum (nil );_ed :=_fc .SignatureValidationResult {IsSigned :true ,IsVerified :_g .Equal (_ebd ,_bd .MessageImprint .HashedMessage ),GeneralizedTime :_bd .GeneralizedTime };return _ed ,nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _dc .Hash )(_fc .SignatureHandler ,error ){return &docTimeStamp {_bec :timestampServerURL ,_bgdd :hashAlgorithm },nil ;};func _bba (_adg _f .SignatureAlgorithm )(_dc .Hash ,bool ){var _dcb _dc .Hash ;switch _adg {case _f .SHA1WithRSA :_dcb =_dc .SHA1 ;case _f .SHA256WithRSA :_dcb =_dc .SHA256 ;case _f .SHA384WithRSA :_dcb =_dc .SHA384 ;case _f .SHA512WithRSA :_dcb =_dc .SHA512 ;default:return _dc .SHA1 ,false ;};return _dcb ,true ;};

// NewDigest creates a new digest.
func (_fcb *adobePKCS7Detached )NewDigest (sig *_fc .PdfSignature )(_fc .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};func (_eaf *adobeX509RSASHA1 )getCertificate (_bge *_fc .PdfSignature )(*_f .Certificate ,error ){if _eaf ._adf !=nil {return _eaf ._adf ,nil ;};_eb ,_ga :=_bge .GetCerts ();if _ga !=nil {return nil ,_ga ;};return _eb [0],nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_gd .PrivateKey ,certificate *_f .Certificate )(_fc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_adf :certificate ,_aed :privateKey },nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_f .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_fc .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_adf :certificate ,_cc :signFunc ,_cd :opts .EstimateSize },nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_ca *adobePKCS7Detached )IsApplicable (sig *_fc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};func (_add *adobePKCS7Detached )getCertificate (_ab *_fc .PdfSignature )(*_f .Certificate ,error ){if _add ._gg !=nil {return _add ._gg ,nil ;};_deg ,_aa :=_ab .GetCerts ();if _aa !=nil {return nil ,_aa ;};return _deg [0],nil ;};

// NewDigest creates a new digest.
func (_bef *adobeX509RSASHA1 )NewDigest (sig *_fc .PdfSignature )(_fc .Hasher ,error ){_cdf ,_cca :=_bef .getCertificate (sig );if _cca !=nil {return nil ,_cca ;};_bf ,_ :=_bba (_cdf .SignatureAlgorithm );return _bf .New (),nil ;};func (_afff *docTimeStamp )getCertificate (_fa *_fc .PdfSignature )(*_f .Certificate ,error ){_dfa ,_fae :=_fa .GetCerts ();if _fae !=nil {return nil ,_fae ;};return _dfa [0],nil ;};func _fcba (_gbfb _db .ObjectIdentifier )(_dc .Hash ,error ){switch {case _gbfb .Equal (_e .OIDDigestAlgorithmSHA1 ),_gbfb .Equal (_e .OIDDigestAlgorithmECDSASHA1 ),_gbfb .Equal (_e .OIDDigestAlgorithmDSA ),_gbfb .Equal (_e .OIDDigestAlgorithmDSASHA1 ),_gbfb .Equal (_e .OIDEncryptionAlgorithmRSA ):return _dc .SHA1 ,nil ;case _gbfb .Equal (_e .OIDDigestAlgorithmSHA256 ),_gbfb .Equal (_e .OIDDigestAlgorithmECDSASHA256 ):return _dc .SHA256 ,nil ;case _gbfb .Equal (_e .OIDDigestAlgorithmSHA384 ),_gbfb .Equal (_e .OIDDigestAlgorithmECDSASHA384 ):return _dc .SHA384 ,nil ;case _gbfb .Equal (_e .OIDDigestAlgorithmSHA512 ),_gbfb .Equal (_e .OIDDigestAlgorithmECDSASHA512 ):return _dc .SHA512 ,nil ;};return _dc .Hash (0),_e .ErrUnsupportedAlgorithm ;};

// InitSignature initialises the PdfSignature.
func (_beg *docTimeStamp )InitSignature (sig *_fc .PdfSignature )error {_dfc :=*_beg ;sig .Handler =&_dfc ;sig .Filter =_dd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dd .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _beg ._ddb > 0{sig .Contents =_dd .MakeHexString (string (make ([]byte ,_beg ._ddb )));}else {_ccc ,_gaf :=_beg .NewDigest (sig );if _gaf !=nil {return _gaf ;};_ccc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gaf =_dfc .Sign (sig ,_ccc );_gaf !=nil {return _gaf ;};_beg ._ddb =_dfc ._ddb ;};return nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_f .Certificate ,signFunc SignFunc )(_fc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_adf :certificate ,_cc :signFunc },nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_fc .SignatureHandler ,error ){return &adobePKCS7Detached {_fg :true ,_bb :signatureLen },nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_gd .PrivateKey ,certificate *_f .Certificate )(_fc .SignatureHandler ,error ){return &adobePKCS7Detached {_gg :certificate ,_bc :privateKey },nil ;};type timestampInfo struct{Version int ;Policy _db .RawValue ;MessageImprint struct{HashAlgorithm _gb .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _db .RawValue ;GeneralizedTime _c .Time ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bbe *docTimeStamp )IsApplicable (sig *_fc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// InitSignature initialises the PdfSignature.
func (_dab *adobePKCS7Detached )InitSignature (sig *_fc .PdfSignature )error {if !_dab ._fg {if _dab ._gg ==nil {return _da .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _dab ._bc ==nil {return _da .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_cf :=*_dab ;sig .Handler =&_cf ;sig .Filter =_dd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dd .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_fb ,_be :=_cf .NewDigest (sig );if _be !=nil {return _be ;};_fb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _cf .Sign (sig ,_fb );};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _dc .Hash ,opts *DocTimeStampOpts )(_fc .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_bec :timestampServerURL ,_bgdd :hashAlgorithm ,_ddb :opts .SignatureSize },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gbb *adobeX509RSASHA1 )IsApplicable (sig *_fc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// NewDigest creates a new digest.
func (_aef *docTimeStamp )NewDigest (sig *_fc .PdfSignature )(_fc .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};func (_dfe *adobeX509RSASHA1 )sign (_cdfa *_fc .PdfSignature ,_ded _fc .Hasher ,_abgd bool )error {if !_abgd {return _dfe .Sign (_cdfa ,_ded );};_cb ,_aff :=_dfe ._adf .PublicKey .(*_gd .PublicKey );if !_aff {return _d .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_cb );};_bgeb ,_bgd :=_db .Marshal (make ([]byte ,_cb .Size ()));if _bgd !=nil {return _bgd ;};_cdfa .Contents =_dd .MakeHexString (string (_bgeb ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_gcb *docTimeStamp )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {_abe ,_ged :=_ad .NewTimestampRequest (digest .(*_g .Buffer ),&_de .RequestOptions {Hash :_gcb ._bgdd ,Certificates :true });if _ged !=nil {return _ged ;};_gab :=_ad .NewTimestampClient ();_acac ,_ged :=_gab .GetEncodedToken (_gcb ._bec ,_abe );if _ged !=nil {return _ged ;};_bca :=len (_acac );if _gcb ._ddb > 0&&_bca > _gcb ._ddb {return _fc .ErrSignNotEnoughSpace ;};if _bca > 0{_gcb ._ddb =_bca +128;};sig .Contents =_dd .MakeHexString (string (_acac ));return nil ;};

// Validate validates PdfSignature.
func (_cfd *adobePKCS7Detached )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){_eg :=sig .Contents .Bytes ();_gbf ,_gdd :=_e .Parse (_eg );if _gdd !=nil {return _fc .SignatureValidationResult {},_gdd ;};_bg :=digest .(*_g .Buffer );_gbf .Content =_bg .Bytes ();if _gdd =_gbf .Verify ();_gdd !=nil {return _fc .SignatureValidationResult {},_gdd ;};return _fc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Sign sets the Contents fields.
func (_ba *adobePKCS7Detached )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {if _ba ._fg {_ea :=_ba ._bb ;if _ea <=0{_ea =8192;};sig .Contents =_dd .MakeHexString (string (make ([]byte ,_ea )));return nil ;};_fe :=digest .(*_g .Buffer );_dg ,_dce :=_e .NewSignedData (_fe .Bytes ());if _dce !=nil {return _dce ;};if _bad :=_dg .AddSigner (_ba ._gg ,_ba ._bc ,_e .SignerInfoConfig {});_bad !=nil {return _bad ;};_dg .Detach ();_gddg ,_dce :=_dg .Finish ();if _dce !=nil {return _dce ;};_fed :=make ([]byte ,8192);copy (_fed ,_gddg );sig .Contents =_dd .MakeHexString (string (_fed ));return nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_ag *_fc .PdfSignature ,_ae _fc .Hasher )([]byte ,error );