//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_de "bytes";_c "crypto/aes";_f "crypto/cipher";_dc "crypto/md5";_gd "crypto/rand";_ddf "crypto/rc4";_ge "crypto/sha256";_d "crypto/sha512";_dg "encoding/binary";_dd "errors";_e "fmt";_ca "github.com/unidoc/unipdf/v3/common";_fed "hash";_fe "io";_a "math";);func (_bff stdHandlerR4 )alg3Key (R int ,_ce []byte )[]byte {_dag :=_dc .New ();_bbb :=_bff .paddedPass (_ce );_dag .Write (_bbb );if R >=3{for _abc :=0;_abc < 50;_abc ++{_cgc :=_dag .Sum (nil );_dag =_dc .New ();_dag .Write (_cgc );};};_bd :=_dag .Sum (nil );if R ==2{_bd =_bd [0:5];}else {_bd =_bd [0:_bff .Length /8];};return _bd ;};func (_fbe stdHandlerR6 )alg2b (R int ,_gbe ,_gcg ,_dff []byte )([]byte ,error ){if R ==5{return _fd (_gbe );};return _fae (_gbe ,_gcg ,_dff );};func (stdHandlerR4 )paddedPass (_geg []byte )[]byte {_fee :=make ([]byte ,32);_ece :=copy (_fee ,_geg );for ;_ece < 32;_ece ++{_fee [_ece ]=_eaf [_ece -len (_geg )];};return _fee ;};type ecbEncrypter ecb ;

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_fa stdHandlerR4 )alg4 (_abf []byte ,_bgd []byte )([]byte ,error ){_bdg ,_bca :=_ddf .NewCipher (_abf );if _bca !=nil {return nil ,_dd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gfd :=[]byte (_eaf );_ecd :=make ([]byte ,len (_gfd ));_bdg .XORKeyStream (_ecd ,_gfd );return _ecd ,nil ;};func (_gde stdHandlerR4 )alg2 (_ecc *StdEncryptDict ,_aa []byte )[]byte {_ca .Log .Trace ("\u0061\u006c\u0067\u0032");_gc :=_gde .paddedPass (_aa );_cg :=_dc .New ();_cg .Write (_gc );_cg .Write (_ecc .O );var _bb [4]byte ;_dg .LittleEndian .PutUint32 (_bb [:],uint32 (_ecc .P ));_cg .Write (_bb [:]);_ca .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_bb );_cg .Write ([]byte (_gde .ID0 ));_ca .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ecc .R ,_ecc .EncryptMetadata );if (_ecc .R >=4)&&!_ecc .EncryptMetadata {_cg .Write ([]byte {0xff,0xff,0xff,0xff});};_eeg :=_cg .Sum (nil );if _ecc .R >=3{_cg =_dc .New ();for _ae :=0;_ae < 50;_ae ++{_cg .Reset ();_cg .Write (_eeg [0:_gde .Length /8]);_eeg =_cg .Sum (nil );};};if _ecc .R >=3{return _eeg [0:_gde .Length /8];};return _eeg [0:5];};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// Authenticate implements StdHandler interface.
func (_cfb stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cfb .alg2a (d ,pass );};

// Authenticate implements StdHandler interface.
func (_fffa stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ca .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_abcfe ,_gdb :=_fffa .alg7 (d ,pass );if _gdb !=nil {return nil ,0,_gdb ;};if _abcfe !=nil {_ca .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _abcfe ,PermOwner ,nil ;};_ca .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_abcfe ,_gdb =_fffa .alg6 (d ,pass );if _gdb !=nil {return nil ,0,_gdb ;};if _abcfe !=nil {_ca .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _abcfe ,d .P ,nil ;};return nil ,0,nil ;};func (_cef stdHandlerR6 )alg8 (_afga *StdEncryptDict ,_bbg []byte ,_aee []byte )error {if _aga :=_ead ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bbg );_aga !=nil {return _aga ;};var _bdbae [16]byte ;if _ ,_abg :=_fe .ReadFull (_gd .Reader ,_bdbae [:]);_abg !=nil {return _abg ;};_edfg :=_bdbae [0:8];_dgcfd :=_bdbae [8:16];_ebaa :=make ([]byte ,len (_aee )+len (_edfg ));_egf :=copy (_ebaa ,_aee );copy (_ebaa [_egf :],_edfg );_bfa ,_efc :=_cef .alg2b (_afga .R ,_ebaa ,_aee ,nil );if _efc !=nil {return _efc ;};U :=make ([]byte ,len (_bfa )+len (_edfg )+len (_dgcfd ));_egf =copy (U ,_bfa [:32]);_egf +=copy (U [_egf :],_edfg );copy (U [_egf :],_dgcfd );_afga .U =U ;_egf =len (_aee );copy (_ebaa [_egf :],_dgcfd );_bfa ,_efc =_cef .alg2b (_afga .R ,_ebaa ,_aee ,nil );if _efc !=nil {return _efc ;};_fg ,_efc :=_cdg (_bfa [:32]);if _efc !=nil {return _efc ;};_bbgg :=make ([]byte ,_c .BlockSize );_ddgg :=_f .NewCBCEncrypter (_fg ,_bbgg );UE :=make ([]byte ,32);_ddgg .CryptBlocks (UE ,_bbg [:32]);_afga .UE =UE ;return nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ed *StdEncryptDict ,_af ,_bc []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ee *StdEncryptDict ,_ef []byte )([]byte ,Permissions ,error );};func (_feg stdHandlerR4 )alg6 (_aef *StdEncryptDict ,_aab []byte )([]byte ,error ){var (_bgg []byte ;_eff error ;);_ffg :=_feg .alg2 (_aef ,_aab );if _aef .R ==2{_bgg ,_eff =_feg .alg4 (_ffg ,_aab );}else if _aef .R >=3{_bgg ,_eff =_feg .alg5 (_ffg ,_aab );}else {return nil ,_dd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _eff !=nil {return nil ,_eff ;};_ca .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_bgg ),string (_aef .U ));_bda :=_bgg ;_aag :=_aef .U ;if _aef .R >=3{if len (_bda )> 16{_bda =_bda [0:16];};if len (_aag )> 16{_aag =_aag [0:16];};};if !_de .Equal (_bda ,_aag ){return nil ,nil ;};return _ffg ,nil ;};func (_fcg stdHandlerR6 )alg11 (_gba *StdEncryptDict ,_fdf []byte )([]byte ,error ){if _bfba :=_ead ("\u0061\u006c\u00671\u0031","\u0055",48,_gba .U );_bfba !=nil {return nil ,_bfba ;};_gfg :=make ([]byte ,len (_fdf )+8);_bde :=copy (_gfg ,_fdf );_bde +=copy (_gfg [_bde :],_gba .U [32:40]);_gac ,_fgg :=_fcg .alg2b (_gba .R ,_gfg ,_fdf ,nil );if _fgg !=nil {return nil ,_fgg ;};_gac =_gac [:32];if !_de .Equal (_gac ,_gba .U [:32]){return nil ,nil ;};return _gac ,nil ;};func (_bcd stdHandlerR4 )alg7 (_bba *StdEncryptDict ,_bfe []byte )([]byte ,error ){_gcc :=_bcd .alg3Key (_bba .R ,_bfe );_ege :=make ([]byte ,len (_bba .O ));if _bba .R ==2{_fbd ,_fad :=_ddf .NewCipher (_gcc );if _fad !=nil {return nil ,_dd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fbd .XORKeyStream (_ege ,_bba .O );}else if _bba .R >=3{_adf :=append ([]byte {},_bba .O ...);for _adg :=0;_adg < 20;_adg ++{_bae :=append ([]byte {},_gcc ...);for _bdb :=0;_bdb < len (_gcc );_bdb ++{_bae [_bdb ]^=byte (19-_adg );};_beg ,_bgdg :=_ddf .NewCipher (_bae );if _bgdg !=nil {return nil ,_dd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_beg .XORKeyStream (_ege ,_adf );_adf =append ([]byte {},_ege ...);};}else {return nil ,_dd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_eb ,_eegf :=_bcd .alg6 (_bba ,_ege );if _eegf !=nil {return nil ,nil ;};return _eb ,nil ;};func _b (_gf _f .Block )_f .BlockMode {return (*ecbDecrypter )(_ad (_gf ))};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};type ecbDecrypter ecb ;

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// Allowed checks if a set of permissions can be granted.
func (_ddg Permissions )Allowed (p2 Permissions )bool {return _ddg &p2 ==p2 };func (_feb stdHandlerR6 )alg10 (_fga *StdEncryptDict ,_adfc []byte )error {if _gcgd :=_ead ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_adfc );_gcgd !=nil {return _gcgd ;};_bbc :=uint64 (uint32 (_fga .P ))|(_a .MaxUint32 <<32);Perms :=make ([]byte ,16);_dg .LittleEndian .PutUint64 (Perms [:8],_bbc );if _fga .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_dbb :=_fe .ReadFull (_gd .Reader ,Perms [12:16]);_dbb !=nil {return _dbb ;};_fecd ,_add :=_cdg (_adfc [:32]);if _add !=nil {return _add ;};_cdc :=_da (_fecd );_cdc .CryptBlocks (Perms ,Perms );_fga .Perms =Perms [:16];return nil ;};type stdHandlerR6 struct{};func (_ba errInvalidField )Error ()string {return _e .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ba .Func ,_ba .Field ,_ba .Exp ,_ba .Got );};func (_ggcb stdHandlerR6 )alg12 (_dcca *StdEncryptDict ,_efb []byte )([]byte ,error ){if _gfgc :=_ead ("\u0061\u006c\u00671\u0032","\u0055",48,_dcca .U );_gfgc !=nil {return nil ,_gfgc ;};if _bgdb :=_ead ("\u0061\u006c\u00671\u0032","\u004f",48,_dcca .O );_bgdb !=nil {return nil ,_bgdb ;};_gbc :=make ([]byte ,len (_efb )+8+48);_bgb :=copy (_gbc ,_efb );_bgb +=copy (_gbc [_bgb :],_dcca .O [32:40]);_bgb +=copy (_gbc [_bgb :],_dcca .U [0:48]);_cabd ,_bdbac :=_ggcb .alg2b (_dcca .R ,_gbc ,_efb ,_dcca .U [0:48]);if _bdbac !=nil {return nil ,_bdbac ;};_cabd =_cabd [:32];if !_de .Equal (_cabd ,_dcca .O [:32]){return nil ,nil ;};return _cabd ,nil ;};func _da (_ec _f .Block )_f .BlockMode {return (*ecbEncrypter )(_ad (_ec ))};func _cdg (_eea []byte )(_f .Block ,error ){_bag ,_bdac :=_c .NewCipher (_eea );if _bdac !=nil {_ca .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bdac );return nil ,_bdac ;};return _bag ,nil ;};func _cb (_fadg []byte ,_cbc int ){_cae :=_cbc ;for _cae < len (_fadg ){copy (_fadg [_cae :],_fadg [:_cae ]);_cae *=2;};};func (_cab *ecbDecrypter )BlockSize ()int {return _cab ._cf };type ecb struct{_gg _f .Block ;_cf int ;};func _fd (_fea []byte )([]byte ,error ){_gga :=_ge .New ();_gga .Write (_fea );return _gga .Sum (nil ),nil };const (PermOwner =Permissions (_a .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_bg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bg ._cf !=0{_ca .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_ca .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_bg ._gg .Decrypt (dst ,src [:_bg ._cf ]);src =src [_bg ._cf :];dst =dst [_bg ._cf :];};};func _fae (_cba ,_eec ,_caf []byte )([]byte ,error ){var (_bfb ,_dfd ,_afg _fed .Hash ;);_bfb =_ge .New ();_fcb :=make ([]byte ,64);_aae :=_bfb ;_aae .Write (_cba );K :=_aae .Sum (_fcb [:0]);_deeb :=make ([]byte ,64*(127+64+48));_eccg :=func (_dad int )([]byte ,error ){_fde :=len (_eec )+len (K )+len (_caf );_dec :=_deeb [:_fde ];_baf :=copy (_dec ,_eec );_baf +=copy (_dec [_baf :],K [:]);_baf +=copy (_dec [_baf :],_caf );if _baf !=_fde {_ca .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_dd .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_deeb [:_fde *64];_cb (K1 ,_fde );_bdba ,_fcf :=_cdg (K [0:16]);if _fcf !=nil {return nil ,_fcf ;};_fce :=_f .NewCBCEncrypter (_bdba ,K [16:32]);_fce .CryptBlocks (K1 ,K1 );E :=K1 ;_ecda :=0;for _cdb :=0;_cdb < 16;_cdb ++{_ecda +=int (E [_cdb ]%3);};var _edf _fed .Hash ;switch _ecda %3{case 0:_edf =_bfb ;case 1:if _dfd ==nil {_dfd =_d .New384 ();};_edf =_dfd ;case 2:if _afg ==nil {_afg =_d .New ();};_edf =_afg ;};_edf .Reset ();_edf .Write (E );K =_edf .Sum (_fcb [:0]);return E ,nil ;};for _dged :=0;;{E ,_aefd :=_eccg (_dged );if _aefd !=nil {return nil ,_aefd ;};_afb :=E [len (E )-1];_dged ++;if _dged >=64&&_afb <=uint8 (_dged -32){break ;};};return K [:32],nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};var _ StdHandler =stdHandlerR6 {};func _ad (_ea _f .Block )*ecb {return &ecb {_gg :_ea ,_cf :_ea .BlockSize ()}};func (_db stdHandlerR6 )alg2a (_baef *StdEncryptDict ,_bfd []byte )([]byte ,Permissions ,error ){if _aea :=_ead ("\u0061\u006c\u00672\u0061","\u004f",48,_baef .O );_aea !=nil {return nil ,0,_aea ;};if _fag :=_ead ("\u0061\u006c\u00672\u0061","\u0055",48,_baef .U );_fag !=nil {return nil ,0,_fag ;};if len (_bfd )> 127{_bfd =_bfd [:127];};_aed ,_cad :=_db .alg12 (_baef ,_bfd );if _cad !=nil {return nil ,0,_cad ;};var (_gee []byte ;_gb []byte ;_fbg []byte ;);var _ebe Permissions ;if len (_aed )!=0{_ebe =PermOwner ;_ggg :=make ([]byte ,len (_bfd )+8+48);_dgcf :=copy (_ggg ,_bfd );_dgcf +=copy (_ggg [_dgcf :],_baef .O [40:48]);copy (_ggg [_dgcf :],_baef .U [0:48]);_gee =_ggg ;_gb =_baef .OE ;_fbg =_baef .U [0:48];}else {_aed ,_cad =_db .alg11 (_baef ,_bfd );if _cad ==nil &&len (_aed )==0{_aed ,_cad =_db .alg11 (_baef ,[]byte (""));};if _cad !=nil {return nil ,0,_cad ;}else if len (_aed )==0{return nil ,0,nil ;};_ebe =_baef .P ;_deb :=make ([]byte ,len (_bfd )+8);_ede :=copy (_deb ,_bfd );copy (_deb [_ede :],_baef .U [40:48]);_gee =_deb ;_gb =_baef .UE ;_fbg =nil ;};if _bad :=_ead ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_gb );_bad !=nil {return nil ,0,_bad ;};_gb =_gb [:32];_agc ,_cad :=_db .alg2b (_baef .R ,_gee ,_bfd ,_fbg );if _cad !=nil {return nil ,0,_cad ;};_aedb ,_cad :=_c .NewCipher (_agc [:32]);if _cad !=nil {return nil ,0,_cad ;};_aaf :=make ([]byte ,_c .BlockSize );_dcd :=_f .NewCBCDecrypter (_aedb ,_aaf );_adgg :=make ([]byte ,32);_dcd .CryptBlocks (_adgg ,_gb );if _baef .R ==5{return _adgg ,_ebe ,nil ;};_cad =_db .alg13 (_baef ,_adgg );if _cad !=nil {return nil ,0,_cad ;};return _adgg ,_ebe ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_dfg stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gbaa :=make ([]byte ,32);if _ ,_abge :=_fe .ReadFull (_gd .Reader ,_gbaa );_abge !=nil {return nil ,_abge ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _eafa :=_dfg .alg8 (d ,_gbaa ,upass );_eafa !=nil {return nil ,_eafa ;};if _fba :=_dfg .alg9 (d ,_gbaa ,opass );_fba !=nil {return nil ,_fba ;};if d .R ==5{return _gbaa ,nil ;};if _cee :=_dfg .alg10 (d ,_gbaa );_cee !=nil {return nil ,_cee ;};return _gbaa ,nil ;};var _ StdHandler =stdHandlerR4 {};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_dgc stdHandlerR4 )alg3 (R int ,_ff ,_edc []byte )([]byte ,error ){var _eegd []byte ;if len (_edc )> 0{_eegd =_dgc .alg3Key (R ,_edc );}else {_eegd =_dgc .alg3Key (R ,_ff );};_be ,_dfb :=_ddf .NewCipher (_eegd );if _dfb !=nil {return nil ,_dd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gfb :=_dgc .paddedPass (_ff );_bea :=make ([]byte ,len (_gfb ));_be .XORKeyStream (_bea ,_gfb );if R >=3{_abcf :=make ([]byte ,len (_eegd ));for _bfc :=0;_bfc < 19;_bfc ++{for _eg :=0;_eg < len (_eegd );_eg ++{_abcf [_eg ]=_eegd [_eg ]^byte (_bfc +1);};_dge ,_ag :=_ddf .NewCipher (_abcf );if _ag !=nil {return nil ,_dd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dge .XORKeyStream (_bea ,_bea );};};return _bea ,nil ;};func (_ccb stdHandlerR6 )alg13 (_baff *StdEncryptDict ,_egfc []byte )error {if _gff :=_ead ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_egfc );_gff !=nil {return _gff ;};if _cfa :=_ead ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_baff .Perms );_cfa !=nil {return _cfa ;};_aafc :=make ([]byte ,16);copy (_aafc ,_baff .Perms [:16]);_aeb ,_dgda :=_c .NewCipher (_egfc [:32]);if _dgda !=nil {return _dgda ;};_fgc :=_b (_aeb );_fgc .CryptBlocks (_aafc ,_aafc );if !_de .Equal (_aafc [9:12],[]byte ("\u0061\u0064\u0062")){return _dd .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_agd :=Permissions (_dg .LittleEndian .Uint32 (_aafc [0:4]));if _agd !=_baff .P {return _dd .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _ggd bool ;if _aafc [8]=='T'{_ggd =true ;}else if _aafc [8]=='F'{_ggd =false ;}else {return _dd .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _ggd !=_baff .EncryptMetadata {return _dd .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fc stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_effb :=_fc .alg3 (d .R ,upass ,opass );if _effb !=nil {_ca .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_effb );return nil ,_effb ;};d .O =O ;_ca .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gdd :=_fc .alg2 (d ,upass );U ,_effb :=_fc .alg5 (_gdd ,upass );if _effb !=nil {_ca .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_effb );return nil ,_effb ;};d .U =U ;_ca .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gdd ,nil ;};func _ead (_dgf ,_cd string ,_df int ,_ab []byte )error {if len (_ab )< _df {return errInvalidField {Func :_dgf ,Field :_cd ,Exp :_df ,Got :len (_ab )};};return nil ;};func (_adb *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_adb ._cf !=0{_ca .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_ca .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_adb ._gg .Encrypt (dst ,src [:_adb ._cf ]);src =src [_adb ._cf :];dst =dst [_adb ._cf :];};};func (_bec stdHandlerR4 )alg5 (_cc []byte ,_fec []byte )([]byte ,error ){_cda :=_dc .New ();_cda .Write ([]byte (_eaf ));_cda .Write ([]byte (_bec .ID0 ));_ga :=_cda .Sum (nil );_ca .Log .Trace ("\u0061\u006c\u0067\u0035");_ca .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_cc );_ca .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bec .ID0 );if len (_ga )!=16{return nil ,_dd .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_fb ,_fff :=_ddf .NewCipher (_cc );if _fff !=nil {return nil ,_dd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bcae :=make ([]byte ,16);_fb .XORKeyStream (_bcae ,_ga );_efe :=make ([]byte ,len (_cc ));for _ceb :=0;_ceb < 19;_ceb ++{for _dee :=0;_dee < len (_cc );_dee ++{_efe [_dee ]=_cc [_dee ]^byte (_ceb +1);};_fb ,_fff =_ddf .NewCipher (_efe );if _fff !=nil {return nil ,_dd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fb .XORKeyStream (_bcae ,_bcae );_ca .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ceb ,_efe );_ca .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ceb ,_bcae );};_bee :=make ([]byte ,32);for _gaf :=0;_gaf < 16;_gaf ++{_bee [_gaf ]=_bcae [_gaf ];};_ ,_fff =_gd .Read (_bee [16:32]);if _fff !=nil {return nil ,_dd .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _bee ,nil ;};func (_bbaa stdHandlerR6 )alg9 (_bdgg *StdEncryptDict ,_dgd []byte ,_cfg []byte )error {if _dfbb :=_ead ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_dgd );_dfbb !=nil {return _dfbb ;};if _cbe :=_ead ("\u0061\u006c\u0067\u0039","\u0055",48,_bdgg .U );_cbe !=nil {return _cbe ;};var _feee [16]byte ;if _ ,_afc :=_fe .ReadFull (_gd .Reader ,_feee [:]);_afc !=nil {return _afc ;};_adfb :=_feee [0:8];_ac :=_feee [8:16];_ggb :=_bdgg .U [:48];_gdc :=make ([]byte ,len (_cfg )+len (_adfb )+len (_ggb ));_cbd :=copy (_gdc ,_cfg );_cbd +=copy (_gdc [_cbd :],_adfb );_cbd +=copy (_gdc [_cbd :],_ggb );_ggc ,_dbg :=_bbaa .alg2b (_bdgg .R ,_gdc ,_cfg ,_ggb );if _dbg !=nil {return _dbg ;};O :=make ([]byte ,len (_ggc )+len (_adfb )+len (_ac ));_cbd =copy (O ,_ggc [:32]);_cbd +=copy (O [_cbd :],_adfb );_cbd +=copy (O [_cbd :],_ac );_bdgg .O =O ;_cbd =len (_cfg );_cbd +=copy (_gdc [_cbd :],_ac );_ggc ,_dbg =_bbaa .alg2b (_bdgg .R ,_gdc ,_cfg ,_ggb );if _dbg !=nil {return _dbg ;};_feca ,_dbg :=_cdg (_ggc [:32]);if _dbg !=nil {return _dbg ;};_ded :=make ([]byte ,_c .BlockSize );_eee :=_f .NewCBCEncrypter (_feca ,_ded );OE :=make ([]byte ,32);_eee .CryptBlocks (OE ,_dgd [:32]);_bdgg .OE =OE ;return nil ;};func (_dae *ecbEncrypter )BlockSize ()int {return _dae ._cf };const _eaf ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};