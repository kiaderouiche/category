//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_cb "bufio";_fc "bytes";_f "compress/lzw";_ba "compress/zlib";_de "crypto/md5";_ge "crypto/rand";_dc "encoding/hex";_g "errors";_cf "fmt";_ae "github.com/unidoc/unipdf/v3/common";_cd "github.com/unidoc/unipdf/v3/core/security";_ag "github.com/unidoc/unipdf/v3/core/security/crypt";_fb "github.com/unidoc/unipdf/v3/internal/ccittfax";_ca "github.com/unidoc/unipdf/v3/internal/imageutil";_fa "github.com/unidoc/unipdf/v3/internal/jbig2";_gf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_df "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_dg "github.com/unidoc/unipdf/v3/internal/jbig2/document";_bab "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ef "github.com/unidoc/unipdf/v3/internal/strutils";_ce "golang.org/x/image/tiff/lzw";_ea "golang.org/x/xerrors";_eb "image";_cg "image/color";_eg "image/jpeg";_bc "io";_gg "reflect";_b "regexp";_d "sort";_e "strconv";_a "strings";_dcc "time";);

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_aca *PdfObjectDictionary );EncodeBytes (_bgdf []byte )([]byte ,error );DecodeBytes (_ada []byte )([]byte ,error );DecodeStream (_dgc *PdfObjectStream )([]byte ,error );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bedf *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_cgfdf :=MakeArray ();for _ ,_efcb :=range vals {_cgfdf .Append (MakeInteger (int64 (_efcb )));};return _cgfdf ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bgfc *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_bdd :=MakeDict ();_bdd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgfc .GetFilterName ()));_feg :=_bgfc .MakeDecodeParams ();if _feg !=nil {_bdd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_feg );};return _bdd ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_adb *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eea :=_fc .NewReader (encoded );var _dcdgeb []byte ;for {_eecfa ,_fefg :=_eea .ReadByte ();if _fefg !=nil {return nil ,_fefg ;};if _eecfa =='>'{break ;};if IsWhiteSpace (_eecfa ){continue ;};if (_eecfa >='a'&&_eecfa <='f')||(_eecfa >='A'&&_eecfa <='F')||(_eecfa >='0'&&_eecfa <='9'){_dcdgeb =append (_dcdgeb ,_eecfa );}else {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_eecfa );return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_eecfa );};};if len (_dcdgeb )%2==1{_dcdgeb =append (_dcdgeb ,'0');};_ae .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dcdgeb );_bagg :=make ([]byte ,_dc .DecodedLen (len (_dcdgeb )));_ ,_acaf :=_dc .Decode (_bagg ,_dcdgeb );if _acaf !=nil {return nil ,_acaf ;};return _bagg ,nil ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _fcab :=obj .(type ){case *PdfObjectFloat :return float64 (*_fcab ),nil ;case *PdfObjectInteger :return float64 (*_fcab ),nil ;};return 0,ErrNotANumber ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_dfg string ,_ceab bool ){_adbff ,_ceab :=TraceToDirectObject (obj ).(*PdfObjectString );if _ceab {return _adbff .Str (),true ;};return ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_cdcgc []byte ,_ffgd bool ){_bcaee ,_ffgd :=TraceToDirectObject (obj ).(*PdfObjectString );if _ffgd {return _bcaee .Bytes (),true ;};return ;};type objectStreams map[int ]objectStream ;

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_adc *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _adc .isDecrypted (obj ){return nil ;};switch _bae :=obj .(type ){case *PdfIndirectObject :_adc ._cfe [_bae ]=true ;_ae .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bae .ObjectNumber ,_bae .GenerationNumber );_ccc :=_bae .ObjectNumber ;_baf :=_bae .GenerationNumber ;_def :=_adc .Decrypt (_bae .PdfObject ,_ccc ,_baf );if _def !=nil {return _def ;};return nil ;case *PdfObjectStream :_adc ._cfe [_bae ]=true ;_edc :=_bae .PdfObjectDictionary ;if _adc ._bg .R !=5{if _edcg ,_affb :=_edc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_affb &&*_edcg =="\u0058\u0052\u0065\u0066"{return nil ;};};_faf :=_bae .ObjectNumber ;_fcdb :=_bae .GenerationNumber ;_ae .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_faf ,_fcdb );_bfef :=_fdce ;if _adc ._bac .V >=4{_bfef =_adc ._geeg ;_ae .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_adc ._geeg );if _ccd ,_bfcd :=_edc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_bfcd {if _ffd ,_bfbe :=GetName (_ccd .Get (0));_bfbe {if *_ffd =="\u0043\u0072\u0079p\u0074"{_bfef ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dfae ,_fca :=_edc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_fca {if _bgdc ,_daec :=_dfae .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_daec {if _ ,_agfb :=_adc ._gfg [string (*_bgdc )];_agfb {_ae .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_bgdc );_bfef =string (*_bgdc );};};};};};};_ae .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bfef );if _bfef =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_aegc :=_adc .Decrypt (_edc ,_faf ,_fcdb );if _aegc !=nil {return _aegc ;};_ggf ,_aegc :=_adc .makeKey (_bfef ,uint32 (_faf ),uint32 (_fcdb ),_adc ._bgd );if _aegc !=nil {return _aegc ;};_bae .Stream ,_aegc =_adc .decryptBytes (_bae .Stream ,_bfef ,_ggf );if _aegc !=nil {return _aegc ;};_edc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bae .Stream ))));return nil ;case *PdfObjectString :_ae .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cca :=_fdce ;if _adc ._bac .V >=4{_ae .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_adc ._gcg );if _adc ._gcg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cca =_adc ._gcg ;};_ead ,_cebb :=_adc .makeKey (_cca ,uint32 (parentObjNum ),uint32 (parentGenNum ),_adc ._bgd );if _cebb !=nil {return _cebb ;};_efb :=_bae .Str ();_ffdb :=make ([]byte ,len (_efb ));for _cfff :=0;_cfff < len (_efb );_cfff ++{_ffdb [_cfff ]=_efb [_cfff ];};_ae .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ffdb ,_ffdb );_ffdb ,_cebb =_adc .decryptBytes (_ffdb ,_cca ,_ead );if _cebb !=nil {return _cebb ;};_bae ._bdaa =string (_ffdb );return nil ;case *PdfObjectArray :for _ ,_fbcc :=range _bae .Elements (){_faba :=_adc .Decrypt (_fbcc ,parentObjNum ,parentGenNum );if _faba !=nil {return _faba ;};};return nil ;case *PdfObjectDictionary :_cdgf :=false ;if _agc :=_bae .Get ("\u0054\u0079\u0070\u0065");_agc !=nil {_geg ,_faag :=_agc .(*PdfObjectName );if _faag &&*_geg =="\u0053\u0069\u0067"{_cdgf =true ;};};for _ ,_gbd :=range _bae .Keys (){_bcce :=_bae .Get (_gbd );if _cdgf &&string (_gbd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gbd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gbd )!="\u0050\u0072\u0065\u0076"&&string (_gbd )!="\u004c\u0061\u0073\u0074"{_acee :=_adc .Decrypt (_bcce ,parentObjNum ,parentGenNum );if _acee !=nil {return _acee ;};};};return nil ;};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gfbec *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };func (_bdb *PdfCrypt )makeKey (_egg string ,_agbg ,_gab uint32 ,_bbed []byte )([]byte ,error ){_gac ,_caef :=_bdb ._gfg [_egg ];if !_caef {return nil ,_cf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_egg );};return _gac .MakeKey (_agbg ,_gab ,_bbed );};

// GetFilterName returns the name of the encoding filter.
func (_gbea *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_dccf *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_fbcae :=_dccf ._agff [key ];if !_fbcae {_dccf ._cfbgg =append (_dccf ._cfbgg ,key );};_dccf ._agff [key ]=val ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bbede *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bbede .isEncrypted (obj ){return nil ;};switch _aab :=obj .(type ){case *PdfIndirectObject :_bbede ._aec [_aab ]=true ;_ae .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_aab .ObjectNumber ,_aab .GenerationNumber );_egc :=_aab .ObjectNumber ;_egcg :=_aab .GenerationNumber ;_fgfd :=_bbede .Encrypt (_aab .PdfObject ,_egc ,_egcg );if _fgfd !=nil {return _fgfd ;};return nil ;case *PdfObjectStream :_bbede ._aec [_aab ]=true ;_bgf :=_aab .PdfObjectDictionary ;if _dbd ,_cgbd :=_bgf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cgbd &&*_dbd =="\u0058\u0052\u0065\u0066"{return nil ;};_fcde :=_aab .ObjectNumber ;_cfc :=_aab .GenerationNumber ;_ae .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fcde ,_cfc );_gcda :=_fdce ;if _bbede ._bac .V >=4{_gcda =_bbede ._geeg ;_ae .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bbede ._geeg );if _eaae ,_eeb :=_bgf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_eeb {if _efgc ,_ccgd :=GetName (_eaae .Get (0));_ccgd {if *_efgc =="\u0043\u0072\u0079p\u0074"{_gcda ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bedc ,_baa :=_bgf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_baa {if _ebgb ,_cgbf :=_bedc .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cgbf {if _ ,_ggca :=_bbede ._gfg [string (*_ebgb )];_ggca {_ae .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ebgb );_gcda =string (*_ebgb );};};};};};};_ae .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gcda );if _gcda =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_cgef :=_bbede .Encrypt (_aab .PdfObjectDictionary ,_fcde ,_cfc );if _cgef !=nil {return _cgef ;};_dbc ,_cgef :=_bbede .makeKey (_gcda ,uint32 (_fcde ),uint32 (_cfc ),_bbede ._bgd );if _cgef !=nil {return _cgef ;};_aab .Stream ,_cgef =_bbede .encryptBytes (_aab .Stream ,_gcda ,_dbc );if _cgef !=nil {return _cgef ;};_bgf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aab .Stream ))));return nil ;case *PdfObjectString :_ae .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gda :=_fdce ;if _bbede ._bac .V >=4{_ae .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bbede ._gcg );if _bbede ._gcg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gda =_bbede ._gcg ;};_cgefb ,_fdd :=_bbede .makeKey (_gda ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bbede ._bgd );if _fdd !=nil {return _fdd ;};_dafc :=_aab .Str ();_fdfb :=make ([]byte ,len (_dafc ));for _gcb :=0;_gcb < len (_dafc );_gcb ++{_fdfb [_gcb ]=_dafc [_gcb ];};_ae .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_fdfb ,_fdfb );_fdfb ,_fdd =_bbede .encryptBytes (_fdfb ,_gda ,_cgefb );if _fdd !=nil {return _fdd ;};_aab ._bdaa =string (_fdfb );return nil ;case *PdfObjectArray :for _ ,_acb :=range _aab .Elements (){_gaf :=_bbede .Encrypt (_acb ,parentObjNum ,parentGenNum );if _gaf !=nil {return _gaf ;};};return nil ;case *PdfObjectDictionary :_ddb :=false ;if _gbfb :=_aab .Get ("\u0054\u0079\u0070\u0065");_gbfb !=nil {_fdb ,_fbae :=_gbfb .(*PdfObjectName );if _fbae &&*_fdb =="\u0053\u0069\u0067"{_ddb =true ;};};for _ ,_aga :=range _aab .Keys (){_agd :=_aab .Get (_aga );if _ddb &&string (_aga )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_aga )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_aga )!="\u0050\u0072\u0065\u0076"&&string (_aga )!="\u004c\u0061\u0073\u0074"{_eag :=_bbede .Encrypt (_agd ,parentObjNum ,parentGenNum );if _eag !=nil {return _eag ;};};};return nil ;};return nil ;};func (_edag *PdfParser )readComment ()(string ,error ){var _dcbc _fc .Buffer ;_ ,_ebgcf :=_edag .skipSpaces ();if _ebgcf !=nil {return _dcbc .String (),_ebgcf ;};_aeb :=true ;for {_gbeg ,_fface :=_edag ._bgcee .Peek (1);if _fface !=nil {_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fface .Error ());return _dcbc .String (),_fface ;};if _aeb &&_gbeg [0]!='%'{return _dcbc .String (),_g .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_aeb =false ;if (_gbeg [0]!='\r')&&(_gbeg [0]!='\n'){_edgd ,_ :=_edag ._bgcee .ReadByte ();_dcbc .WriteByte (_edgd );}else {break ;};};return _dcbc .String (),nil ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cdgg *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cdgg .GetFilterName ());return encoded ,ErrNoJPXDecode ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_fbfd *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_egea :=data ;var _ffed error ;for _fbe :=len (_fbfd ._ccfc )-1;_fbe >=0;_fbe --{_fbad :=_fbfd ._ccfc [_fbe ];_egea ,_ffed =_fbad .EncodeBytes (_egea );if _ffed !=nil {return nil ,_ffed ;};};return _egea ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aedc *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};func _dgdde ()string {return _ae .Version };

// Len returns the number of elements in the streams.
func (_egcef *PdfObjectStreams )Len ()int {if _egcef ==nil {return 0;};return len (_egcef ._geec );};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ae .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gfag ,_afega :=NewEncoderFromStream (streamObj );if _afega !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_afega );return nil ,_afega ;};_ae .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_gfag );_cddg ,_afega :=_gfag .DecodeStream (streamObj );if _afega !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_afega );return nil ,_afega ;};return _cddg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_babf *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_ccfc []StreamEncoder };

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_bcae *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ddda _fc .Buffer ;_bad :=_fc .NewReader (encoded );var _gedf _bc .ReadCloser ;if _bcae .EarlyChange ==1{_gedf =_ce .NewReader (_bad ,_ce .MSB ,8);}else {_gedf =_f .NewReader (_bad ,_f .MSB ,8);};defer _gedf .Close ();if _ ,_ddgf :=_ddda .ReadFrom (_gedf );_ddgf !=nil {if _ddgf !=_bc .ErrUnexpectedEOF ||_ddda .Len ()==0{return nil ,_ddgf ;};_ae .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ddgf );};return _ddda .Bytes (),nil ;};func (_cbbb *FlateEncoder )postDecodePredict (_gca []byte )([]byte ,error ){if _cbbb .Predictor > 1{if _cbbb .Predictor ==2{_ae .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ae .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_cbbb .Colors );_caa :=_cbbb .Columns *_cbbb .Colors ;if _caa < 1{return []byte {},nil ;};_fdef :=len (_gca )/_caa ;if len (_gca )%_caa !=0{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gca ),_caa );};if _caa %_cbbb .Colors !=0{return nil ,_cf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_caa ,_cbbb .Colors );};if _caa > len (_gca ){_ae .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_caa ,len (_gca ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ae .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gca ),_gca );_dbga :=_fc .NewBuffer (nil );for _egda :=0;_egda < _fdef ;_egda ++{_geae :=_gca [_caa *_egda :_caa *(_egda +1)];for _fff :=_cbbb .Colors ;_fff < _caa ;_fff ++{_geae [_fff ]+=_geae [_fff -_cbbb .Colors ];};_dbga .Write (_geae );};_dfde :=_dbga .Bytes ();_ae .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_dfde ),_dfde );return _dfde ,nil ;}else if _cbbb .Predictor >=10&&_cbbb .Predictor <=15{_ae .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bcdf :=_cbbb .Columns *_cbbb .Colors +1;_dcgf :=len (_gca )/_bcdf ;if len (_gca )%_bcdf !=0{return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gca ),_bcdf );};if _bcdf > len (_gca ){_ae .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bcdf ,len (_gca ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cfb :=_fc .NewBuffer (nil );_ae .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cbbb .Columns );_ae .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gca ),_bcdf ,_dcgf );_gge :=make ([]byte ,_bcdf );for _decb :=0;_decb < _bcdf ;_decb ++{_gge [_decb ]=0;};_aabe :=_cbbb .Colors ;for _agbf :=0;_agbf < _dcgf ;_agbf ++{_baea :=_gca [_bcdf *_agbf :_bcdf *(_agbf +1)];_cec :=_baea [0];switch _cec {case _adfc :case _cfdb :for _dcea :=1+_aabe ;_dcea < _bcdf ;_dcea ++{_baea [_dcea ]+=_baea [_dcea -_aabe ];};case _adcg :for _adca :=1;_adca < _bcdf ;_adca ++{_baea [_adca ]+=_gge [_adca ];};case _bfbc :for _acaa :=1;_acaa < _aabe +1;_acaa ++{_baea [_acaa ]+=_gge [_acaa ]/2;};for _daa :=_aabe +1;_daa < _bcdf ;_daa ++{_baea [_daa ]+=byte ((int (_baea [_daa -_aabe ])+int (_gge [_daa ]))/2);};case _egad :for _bfgf :=1;_bfgf < _bcdf ;_bfgf ++{var _dbe ,_cfcf ,_fadd byte ;_cfcf =_gge [_bfgf ];if _bfgf >=_aabe +1{_dbe =_baea [_bfgf -_aabe ];_fadd =_gge [_bfgf -_aabe ];};_baea [_bfgf ]+=_abfdc (_dbe ,_cfcf ,_fadd );};default:_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_cec ,_agbf );return nil ,_cf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cec );};copy (_gge ,_baea );_cfb .Write (_baea [1:]);};_feec :=_cfb .Bytes ();return _feec ,nil ;}else {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cbbb .Predictor );return nil ,_cf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cbbb .Predictor );};};return _gca ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbdc *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};var _cadcg =_b .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");func (_eef *PdfCrypt )generateParams (_bce ,_acc []byte )error {_fde :=_eef .securityHandler ();_ded ,_bcdc :=_fde .GenerateParams (&_eef ._bg ,_acc ,_bce );if _bcdc !=nil {return _bcdc ;};_eef ._bgd =_ded ;return nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_acdb *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _acdb .Predictor !=1&&_acdb .Predictor !=11{_ae .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _acdb .Predictor ==11{_cea :=_acdb .Columns ;_fddb :=len (data )/_cea ;if len (data )%_cea !=0{_ae .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_acbe :=_fc .NewBuffer (nil );_cfbc :=make ([]byte ,_cea );for _eeeb :=0;_eeeb < _fddb ;_eeeb ++{_fged :=data [_cea *_eeeb :_cea *(_eeeb +1)];_cfbc [0]=_fged [0];for _bbc :=1;_bbc < _cea ;_bbc ++{_cfbc [_bbc ]=byte (int (_fged [_bbc ]-_fged [_bbc -1])%256);};_acbe .WriteByte (1);_acbe .Write (_cfbc );};data =_acbe .Bytes ();};var _ebgf _fc .Buffer ;_dcdc :=_ba .NewWriter (&_ebgf );_dcdc .Write (data );_dcdc .Close ();return _ebgf .Bytes (),nil ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_dfbbf *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};var _dfaf =_b .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// UpdateParams updates the parameter values of the encoder.
func (_ede *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// UpdateParams updates the parameter values of the encoder.
func (_efge *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_ggbd ,_ecfd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ecfd ==nil {_efge .ColorComponents =int (_ggbd );};_cged ,_ecfd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ecfd ==nil {_efge .BitsPerComponent =int (_cged );};_cgea ,_ecfd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ecfd ==nil {_efge .Width =int (_cgea );};_gfgb ,_ecfd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ecfd ==nil {_efge .Height =int (_gfgb );};_ecgg ,_ecfd :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _ecfd ==nil {_efge .Quality =int (_ecgg );};};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func (_gaad *PdfParser )parseXrefStream (_becf *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _becf !=nil {_ae .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_becf );_gaad ._gabd .Seek (int64 (*_becf ),_bc .SeekStart );_gaad ._bgcee =_cb .NewReader (_gaad ._gabd );};_ffeda :=_gaad .GetFileOffset ();_defc ,_bagc :=_gaad .ParseIndirectObject ();if _bagc !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_ae .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_defc );_gbeb ,_dfed :=_defc .(*PdfObjectStream );if !_dfed {_ae .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_fabd :=_gbeb .PdfObjectDictionary ;_gbed ,_dfed :=_gbeb .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_dfed {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_g .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_gbed )> 8388607{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_gbed );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gfbed :=_gbeb .PdfObjectDictionary .Get ("\u0057");_bbgfg ,_dfed :=_gfbed .(*PdfObjectArray );if !_dfed {return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_dceg :=_bbgfg .Len ();if _dceg !=3{_ae .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_dceg );return nil ,_g .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _dcgd []int64 ;for _ccfg :=0;_ccfg < 3;_ccfg ++{_gefc ,_bcff :=GetInt (_bbgfg .Get (_ccfg ));if !_bcff {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_dcgd =append (_dcgd ,int64 (*_gefc ));};_aggg ,_bagc :=DecodeStream (_gbeb );if _bagc !=nil {_ae .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_bagc );return nil ,_bagc ;};_fegd :=int (_dcgd [0]);_gcdb :=int (_dcgd [0]+_dcgd [1]);_befcc :=int (_dcgd [0]+_dcgd [1]+_dcgd [2]);_acae :=int (_dcgd [0]+_dcgd [1]+_dcgd [2]);if _fegd < 0||_gcdb < 0||_befcc < 0{_ae .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_fegd ,_gcdb ,_befcc );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _acae ==0{_ae .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _fabd ,nil ;};_gcfb :=len (_aggg )/_acae ;_bbae :=0;_adfbd :=_gbeb .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _dgbaf []int ;if _adfbd !=nil {_ae .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_adfbd );_gacdb ,_bgag :=_adfbd .(*PdfObjectArray );if !_bgag {_ae .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_g .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _gacdb .Len ()%2!=0{_ae .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bbae =0;_gdg ,_beag :=_gacdb .ToIntegerArray ();if _beag !=nil {_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_beag );return nil ,_beag ;};for _cadb :=0;_cadb < len (_gdg );_cadb +=2{_aafa :=_gdg [_cadb ];_eedd :=_gdg [_cadb +1];for _eage :=0;_eage < _eedd ;_eage ++{_dgbaf =append (_dgbaf ,_aafa +_eage );};_bbae +=_eedd ;};}else {for _egge :=0;_egge < int (*_gbed );_egge ++{_dgbaf =append (_dgbaf ,_egge );};_bbae =int (*_gbed );};if _gcfb ==_bbae +1{_ae .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_ddgfe :=_bbae -1;for _ ,_dcaf :=range _dgbaf {if _dcaf > _ddgfe {_ddgfe =_dcaf ;};};_dgbaf =append (_dgbaf ,_ddgfe +1);_bbae ++;};if _gcfb !=len (_dgbaf ){_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_gcfb ,len (_dgbaf ));return nil ,_g .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_ae .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_bbae );_ae .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_dgbaf );_bcca :=func (_cfebb []byte )int64 {var _fbbg int64 ;for _daaa :=0;_daaa < len (_cfebb );_daaa ++{_fbbg +=int64 (_cfebb [_daaa ])*(1<<uint (8*(len (_cfebb )-_daaa -1)));};return _fbbg ;};_ae .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_aggg ));_abcf :=0;for _fcbb :=0;_fcbb < len (_aggg );_fcbb +=_acae {_dggbd :=_ebbec (len (_aggg ),_fcbb ,_fcbb +_fegd );if _dggbd !=nil {_ae .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dggbd );return nil ,_dggbd ;};_cgg :=_aggg [_fcbb :_fcbb +_fegd ];_dggbd =_ebbec (len (_aggg ),_fcbb +_fegd ,_fcbb +_gcdb );if _dggbd !=nil {_ae .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dggbd );return nil ,_dggbd ;};_abeg :=_aggg [_fcbb +_fegd :_fcbb +_gcdb ];_dggbd =_ebbec (len (_aggg ),_fcbb +_gcdb ,_fcbb +_befcc );if _dggbd !=nil {_ae .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dggbd );return nil ,_dggbd ;};_eebde :=_aggg [_fcbb +_gcdb :_fcbb +_befcc ];_gdba :=_bcca (_cgg );_fadb :=_bcca (_abeg );_gcefb :=_bcca (_eebde );if _dcgd [0]==0{_gdba =1;};if _abcf >=len (_dgbaf ){_ae .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_eceaa :=_dgbaf [_abcf ];_abcf ++;_ae .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_eceaa ,_cgg );_ae .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_eceaa ,_abeg );_ae .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_eceaa ,_eebde );_ae .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_eceaa ,_gdba ,_fadb ,_gcefb );if _gdba ==0{_ae .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _gdba ==1{_ae .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_abeg );if _fadb ==_ffeda {_ae .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_eceaa ,_gbeb .ObjectNumber );_eceaa =int (_gbeb .ObjectNumber );};if _cbfc ,_ebgg :=_gaad ._dbac .ObjectMap [_eceaa ];!_ebgg ||int (_gcefb )> _cbfc .Generation {_bdbe :=XrefObject {ObjectNumber :_eceaa ,XType :XrefTypeTableEntry ,Offset :_fadb ,Generation :int (_gcefb )};_gaad ._dbac .ObjectMap [_eceaa ]=_bdbe ;};}else if _gdba ==2{_ae .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_bbgc :=_gaad ._dbac .ObjectMap [_eceaa ];!_bbgc {_cfdf :=XrefObject {ObjectNumber :_eceaa ,XType :XrefTypeObjectStream ,OsObjNumber :int (_fadb ),OsObjIndex :int (_gcefb )};_gaad ._dbac .ObjectMap [_eceaa ]=_cfdf ;_ae .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_cfdf );};}else {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _gaad ._ccba ==nil {_dafb :=XrefTypeObjectStream ;_gaad ._ccba =&_dafb ;};return _fabd ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_bbddg JBIG2EncoderSettings )Validate ()error {const _bdabc ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _bbddg .Threshold < 0||_bbddg .Threshold > 1.0{return _bab .Errorf (_bdabc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_bbddg .Threshold );};if _bbddg .ResolutionX < 0{return _bab .Errorf (_bdabc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbddg .ResolutionX );};if _bbddg .ResolutionY < 0{return _bab .Errorf (_bdabc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbddg .ResolutionY );};if _bbddg .DefaultPixelValue !=0&&_bbddg .DefaultPixelValue !=1{return _bab .Errorf (_bdabc ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_bbddg .DefaultPixelValue );};if _bbddg .Compression !=JB2Generic {return _bab .Errorf (_bdabc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_fed *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _fa .DecodeBytes (encoded ,_df .Parameters {},_fed .Globals );};

// Clear resets the dictionary to an empty state.
func (_dgdfc *PdfObjectDictionary )Clear (){_dgdfc ._cfbgg =[]PdfObjectName {};_dgdfc ._agff =map[PdfObjectName ]PdfObject {};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfbd *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_bfbd ._ccfc )==0{return nil ;};if len (_bfbd ._ccfc )==1{return _bfbd ._ccfc [0].MakeDecodeParams ();};_aegf :=MakeArray ();for _ ,_eefb :=range _bfbd ._ccfc {_gfbe :=_eefb .MakeDecodeParams ();if _gfbe ==nil {_aegf .Append (MakeNull ());}else {_aegf .Append (_gfbe );};};return _aegf ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_aegab string ,_dcee bool ){_bgcc ,_dcee :=TraceToDirectObject (obj ).(*PdfObjectName );if _dcee {return string (*_bgcc ),true ;};return ;};

// DecodeStream implements ASCII hex decoding.
func (_gcee *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gcee .DecodeBytes (streamObj .Stream );};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_eegd *PdfIndirectObject ,_cfdfa bool ){obj =ResolveReference (obj );_eegd ,_cfdfa =obj .(*PdfIndirectObject );return _eegd ,_cfdfa ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_feeca *PdfParser )GetCrypter ()*PdfCrypt {return _feeca ._fdggf };func (_gagg *JBIG2Image )toBitmap ()(_abea *_gf .Bitmap ,_egdad error ){const _eggc ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _gagg .Data ==nil {return nil ,_bab .Error (_eggc ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _gagg .Width ==0||_gagg .Height ==0{return nil ,_bab .Error (_eggc ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _gagg .HasPadding {_abea ,_egdad =_gf .NewWithData (_gagg .Width ,_gagg .Height ,_gagg .Data );}else {_abea ,_egdad =_gf .NewWithUnpaddedData (_gagg .Width ,_gagg .Height ,_gagg .Data );};if _egdad !=nil {return nil ,_bab .Wrap (_egdad ,_eggc ,"");};return _abea ,nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_dcgb *_ca .ImageBase ;};

// String returns a string representation of `name`.
func (_dggf *PdfObjectName )String ()string {return string (*_dggf )};var _ecgd =_b .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_agb *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_cge ,_ ,_gfb :=_agb .lookupByNumberWrapper (objNumber ,true );return _cge ,_gfb ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_gdac *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _eaefg []float64 ;for _ ,_cedf :=range _gdac .Elements (){switch _cabge :=_cedf .(type ){case *PdfObjectInteger :_eaefg =append (_eaefg ,float64 (*_cabge ));case *PdfObjectFloat :_eaefg =append (_eaefg ,float64 (*_cabge ));default:return nil ,ErrTypeError ;};};return _eaefg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cgce *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };func (_gece *PdfParser )inspect ()(map[string ]int ,error ){_ae .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_ae .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_gedga :=map[string ]int {};_bdgbe :=0;_aggggb :=0;var _dgddf []int ;for _bgfe :=range _gece ._dbac .ObjectMap {_dgddf =append (_dgddf ,_bgfe );};_d .Ints (_dgddf );_dcbd :=0;for _ ,_defgb :=range _dgddf {_abecc :=_gece ._dbac .ObjectMap [_defgb ];if _abecc .ObjectNumber ==0{continue ;};_bdgbe ++;_ae .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_ae .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_abecc .ObjectNumber );_cgbdg ,_edgb :=_gece .LookupByNumber (_abecc .ObjectNumber );if _edgb !=nil {_ae .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_abecc .ObjectNumber ,_edgb );_aggggb ++;continue ;};_ae .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_cgbdg );_fdced ,_caggg :=_cgbdg .(*PdfIndirectObject );if _caggg {_ae .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_abecc .ObjectNumber ,_fdced );_cdbf ,_efbbe :=_fdced .PdfObject .(*PdfObjectDictionary );if _efbbe {if _adfcg ,_cbffd :=_cdbf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cbffd {_fgca :=string (*_adfcg );_ae .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_fgca );_ ,_aeaf :=_gedga [_fgca ];if _aeaf {_gedga [_fgca ]++;}else {_gedga [_fgca ]=1;};}else if _fgeg ,_acdce :=_cdbf .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_acdce {_aeegf :=string (*_fgeg );_ae .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_aeegf );_ ,_gcdcg :=_gedga [_aeegf ];if _gcdcg {_gedga [_aeegf ]++;}else {_gedga [_aeegf ]=1;};};if _ddcb ,_abgb :=_cdbf .Get ("\u0053").(*PdfObjectName );_abgb &&*_ddcb =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_addb :=_gedga ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _addb {_gedga ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_gedga ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _dgdaf ,_bgdfe :=_cgbdg .(*PdfObjectStream );_bgdfe {if _egege ,_fdcd :=_dgdaf .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fdcd {_ae .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_egege );_ffcaa :=string (*_egege );_gedga [_ffcaa ]++;};}else {_cgcg ,_addbe :=_cgbdg .(*PdfObjectDictionary );if _addbe {_cdee ,_dbdg :=_cgcg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _dbdg {_bbcd :=string (*_cdee );_ae .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_bbcd );_gedga [_bbcd ]++;};};_ae .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_abecc .ObjectNumber ,_cgbdg );};_dcbd ++;};_ae .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_ae .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_ae .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_bdgbe );_ae .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_aggggb );for _ccec ,_edef :=range _gedga {_ae .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_ccec ,_edef );};_ae .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_gece ._dbac .ObjectMap )< 1{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_cf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_ddga ,_bde :=_gedga ["\u0046\u006f\u006e\u0074"];if !_bde ||_ddga < 2{_ae .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_ae .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _gedga ,nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_ggag :=PdfObjectString {_bdaa :s ,_gfdaa :true };return &_ggag ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_baadb *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_fcdeg ,_deef :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _deef ==nil {_baadb .BitsPerComponent =int (_fcdeg );};_bbca ,_deef :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _deef ==nil {_baadb .Width =int (_bbca );};_dcbf ,_deef :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _deef ==nil {_baadb .Height =int (_dcbf );};_cdcf ,_deef :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _deef ==nil {_baadb .ColorComponents =int (_cdcf );};};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_bbfe *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bcag []byte ;_ae .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_eeag :=0;_bdbdg :=false ;for _eeag < len (encoded )&&!_bdbdg {_ecea :=[5]byte {0,0,0,0,0};_fbbdc :=0;_ffa :=0;_fbaf :=4;for _ffa < 5+_fbbdc {if _eeag +_ffa ==len (encoded ){break ;};_cfdbb :=encoded [_eeag +_ffa ];if IsWhiteSpace (_cfdbb ){_fbbdc ++;_ffa ++;continue ;}else if _cfdbb =='~'&&_eeag +_ffa +1< len (encoded )&&encoded [_eeag +_ffa +1]=='>'{_fbaf =(_ffa -_fbbdc )-1;if _fbaf < 0{_fbaf =0;};_bdbdg =true ;break ;}else if _cfdbb >='!'&&_cfdbb <='u'{_cfdbb -='!';}else if _cfdbb =='z'&&_ffa -_fbbdc ==0{_fbaf =4;_ffa ++;break ;}else {_ae .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_ecea [_ffa -_fbbdc ]=_cfdbb ;_ffa ++;};_eeag +=_ffa ;for _adfb :=_fbaf +1;_adfb < 5;_adfb ++{_ecea [_adfb ]=84;};_faab :=uint32 (_ecea [0])*85*85*85*85+uint32 (_ecea [1])*85*85*85+uint32 (_ecea [2])*85*85+uint32 (_ecea [3])*85+uint32 (_ecea [4]);_bbgb :=[]byte {byte ((_faab >>24)&0xff),byte ((_faab >>16)&0xff),byte ((_faab >>8)&0xff),byte (_faab &0xff)};_bcag =append (_bcag ,_bbgb [:_fbaf ]...);};_ae .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_ae .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_bcag );return _bcag ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gcbc *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_eada :=MakeDict ();_eada .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gcbc .GetFilterName ()));return _eada ;};func (_dbcda *PdfParser )parseHexString ()(*PdfObjectString ,error ){_dbcda ._bgcee .ReadByte ();var _cfbd _fc .Buffer ;for {_eded ,_cecee :=_dbcda ._bgcee .Peek (1);if _cecee !=nil {return MakeString (""),_cecee ;};if _eded [0]=='>'{_dbcda ._bgcee .ReadByte ();break ;};_gfba ,_ :=_dbcda ._bgcee .ReadByte ();if !IsWhiteSpace (_gfba ){_cfbd .WriteByte (_gfba );};};if _cfbd .Len ()%2==1{_cfbd .WriteRune ('0');};_cbgb ,_ :=_dc .DecodeString (_cfbd .String ());return MakeHexString (string (_cbgb )),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gdfa *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _bc .ReadSeeker )(*PdfParser ,error ){_bcbf :=&PdfParser {_gabd :rs ,ObjCache :make (objectCache ),_bcdb :map[int64 ]bool {}};_baead ,_dfddd ,_gfdc :=_bcbf .parsePdfVersion ();if _gfdc !=nil {_ae .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_gfdc );return nil ,_gfdc ;};_bcbf ._dfe .Major =_baead ;_bcbf ._dfe .Minor =_dfddd ;if _bcbf ._dgae ,_gfdc =_bcbf .loadXrefs ();_gfdc !=nil {_ae .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_gfdc );return nil ,_gfdc ;};_ae .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_bcbf ._dgae );if len (_bcbf ._dbac .ObjectMap )==0{return nil ,_cf .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _bcbf ,nil ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_abad *JBIG2Encoder )DecodeGlobals (encoded []byte )(_fa .Globals ,error ){return _fa .DecodeGlobals (encoded );};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_gcdf *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_acgg :=_fc .NewReader (encoded );var _eebd []byte ;for {_gafe ,_fce :=_acgg .ReadByte ();if _fce !=nil {return nil ,_fce ;};if _gafe > 128{_gcdfd ,_cgd :=_acgg .ReadByte ();if _cgd !=nil {return nil ,_cgd ;};for _bge :=0;_bge < 257-int (_gafe );_bge ++{_eebd =append (_eebd ,_gcdfd );};}else if _gafe < 128{for _agcg :=0;_agcg < int (_gafe )+1;_agcg ++{_aage ,_aabg :=_acgg .ReadByte ();if _aabg !=nil {return nil ,_aabg ;};_eebd =append (_eebd ,_aage );};}else {break ;};};return _eebd ,nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_dedfc *PdfObjectDictionary )Keys ()[]PdfObjectName {if _dedfc ==nil {return nil ;};return _dedfc ._cfbgg ;};func (_fad *PdfCrypt )isEncrypted (_gcf PdfObject )bool {_ ,_dba :=_fad ._aec [_gcf ];if _dba {_ae .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_ae .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func _fagd (_bcfb PdfObject )(*float64 ,error ){switch _fcae :=_bcfb .(type ){case *PdfObjectFloat :_ceafa :=float64 (*_fcae );return &_ceafa ,nil ;case *PdfObjectInteger :_cgge :=float64 (*_fcae );return &_cgge ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};type cryptFilters map[string ]_ag .Filter ;

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_dcafa *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_fecae ,_gebd :=_dcafa ._agff [key ];if !_gebd {return nil ;};return _fecae ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_gbee *PdfParser )IsAuthenticated ()bool {return _gbee ._fdggf ._afd };

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ceee *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// Append appends PdfObject(s) to the streams.
func (_dbcbc *PdfObjectStreams )Append (objects ...PdfObject ){if _dbcbc ==nil {_ae .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_dbcbc ._geec =append (_dbcbc ._geec ,objects ...);};

// WriteString outputs the object as it is to be written to file.
func (_cafbe *PdfObjectBool )WriteString ()string {if *_cafbe {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_eedcb *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _daab []int ;for _ ,_efdb :=range _eedcb .Elements (){if _cdbb ,_bbedec :=_efdb .(*PdfObjectInteger );_bbedec {_daab =append (_daab ,int (*_cdbb ));}else {return nil ,ErrTypeError ;};};return _daab ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_bcge *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_ggac :=_fc .NewReader (data );var _dedf []byte ;var _gcaa []byte ;_gcbg ,_ecb :=_ggac .ReadByte ();if _ecb ==_bc .EOF {return []byte {},nil ;}else if _ecb !=nil {return nil ,_ecb ;};_gdfe :=1;for {_gecf ,_ecfb :=_ggac .ReadByte ();if _ecfb ==_bc .EOF {break ;}else if _ecfb !=nil {return nil ,_ecfb ;};if _gecf ==_gcbg {if len (_gcaa )> 0{_gcaa =_gcaa [:len (_gcaa )-1];if len (_gcaa )> 0{_dedf =append (_dedf ,byte (len (_gcaa )-1));_dedf =append (_dedf ,_gcaa ...);};_gdfe =1;_gcaa =[]byte {};};_gdfe ++;if _gdfe >=127{_dedf =append (_dedf ,byte (257-_gdfe ),_gcbg );_gdfe =0;};}else {if _gdfe > 0{if _gdfe ==1{_gcaa =[]byte {_gcbg };}else {_dedf =append (_dedf ,byte (257-_gdfe ),_gcbg );};_gdfe =0;};_gcaa =append (_gcaa ,_gecf );if len (_gcaa )>=127{_dedf =append (_dedf ,byte (len (_gcaa )-1));_dedf =append (_dedf ,_gcaa ...);_gcaa =[]byte {};};};_gcbg =_gecf ;};if len (_gcaa )> 0{_dedf =append (_dedf ,byte (len (_gcaa )-1));_dedf =append (_dedf ,_gcaa ...);}else if _gdfe > 0{_dedf =append (_dedf ,byte (257-_gdfe ),_gcbg );};_dedf =append (_dedf ,128);return _dedf ,nil ;};func (_cdcef *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _cdcef ._cbaf {return nil ,_cf .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_cdcef ._cbaf =true ;_cdcef ._gabd .Seek (0,_bc .SeekStart );_cdcef ._bgcee =_cb .NewReader (_cdcef ._gabd );_fbfg :=20;_fbg :=make ([]byte ,_fbfg );_dcgeg :=XrefTable {};_dcgeg .ObjectMap =make (map[int ]XrefObject );for {_cbda ,_ggae :=_cdcef ._bgcee .ReadByte ();if _ggae !=nil {if _ggae ==_bc .EOF {break ;}else {return nil ,_ggae ;};};if _cbda =='j'&&_fbg [_fbfg -1]=='b'&&_fbg [_fbfg -2]=='o'&&IsWhiteSpace (_fbg [_fbfg -3]){_faad :=_fbfg -4;for IsWhiteSpace (_fbg [_faad ])&&_faad > 0{_faad --;};if _faad ==0||!IsDecimalDigit (_fbg [_faad ]){continue ;};for IsDecimalDigit (_fbg [_faad ])&&_faad > 0{_faad --;};if _faad ==0||!IsWhiteSpace (_fbg [_faad ]){continue ;};for IsWhiteSpace (_fbg [_faad ])&&_faad > 0{_faad --;};if _faad ==0||!IsDecimalDigit (_fbg [_faad ]){continue ;};for IsDecimalDigit (_fbg [_faad ])&&_faad > 0{_faad --;};if _faad ==0{continue ;};_ddff :=_cdcef .GetFileOffset ()-int64 (_fbfg -_faad );_acfg :=append (_fbg [_faad +1:],_cbda );_edde ,_dafe ,_afeae :=_gdbg (string (_acfg ));if _afeae !=nil {_ae .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_afeae );return nil ,_afeae ;};if _agcd ,_ebca :=_dcgeg .ObjectMap [_edde ];!_ebca ||_agcd .Generation < _dafe {_cfeg :=XrefObject {};_cfeg .XType =XrefTypeTableEntry ;_cfeg .ObjectNumber =_edde ;_cfeg .Generation =_dafe ;_cfeg .Offset =_ddff ;_dcgeg .ObjectMap [_edde ]=_cfeg ;};};_fbg =append (_fbg [1:_fbfg ],_cbda );};_cdcef ._fedb =nil ;return &_dcgeg ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_abac *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_daaf error ){const _ebcc ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _abac ==nil {return _bab .Error (_ebcc ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_abac .DefaultPageSettings ;};if _abac ._ecdd ==nil {_abac ._ecdd =_dg .InitEncodeDocument (settings .FileMode );};if _daaf =settings .Validate ();_daaf !=nil {return _bab .Wrap (_daaf ,_ebcc ,"");};_cbbd ,_daaf :=img .toBitmap ();if _daaf !=nil {return _bab .Wrap (_daaf ,_ebcc ,"");};switch settings .Compression {case JB2Generic :if _daaf =_abac ._ecdd .AddGenericPage (_cbbd ,settings .DuplicatedLinesRemoval );_daaf !=nil {return _bab .Wrap (_daaf ,_ebcc ,"");};case JB2SymbolCorrelation :return _bab .Error (_ebcc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _bab .Error (_ebcc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _bab .Error (_ebcc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func (_cdg *PdfCrypt )authenticate (_ebga []byte )(bool ,error ){_cdg ._afd =false ;_eabf :=_cdg .securityHandler ();_cfg ,_daf ,_cbagd :=_eabf .Authenticate (&_cdg ._bg ,_ebga );if _cbagd !=nil {return false ,_cbagd ;}else if _daf ==0||len (_cfg )==0{return false ,nil ;};_cdg ._afd =true ;_cdg ._bgd =_cfg ;return true ,nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_fgeba Version )String ()string {return _cf .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_fgeba .Major ,_fgeba .Minor );};

// GetFilterName returns the name of the encoding filter.
func (_gcedd *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// Bytes returns the PdfObjectString content as a []byte array.
func (_dbcdc *PdfObjectString )Bytes ()[]byte {return []byte (_dbcdc ._bdaa )};func (_beed *ASCII85Encoder )base256Tobase85 (_bec uint32 )[5]byte {_cdfe :=[5]byte {0,0,0,0,0};_bcbd :=_bec ;for _ecdf :=0;_ecdf < 5;_ecdf ++{_gacd :=uint32 (1);for _eafb :=0;_eafb < 4-_ecdf ;_eafb ++{_gacd *=85;};_geafg :=_bcbd /_gacd ;_bcbd =_bcbd %_gacd ;_cdfe [_ecdf ]=byte (_geafg );};return _cdfe ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_cbac *PdfObjectArray )Get (i int )PdfObject {if _cbac ==nil ||i >=len (_cbac ._adbe )||i < 0{return nil ;};return _cbac ._adbe [i ];};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_gfgg :=TraceToDirectObject (obj ).(*PdfObjectNull );return _gfgg ;};func _ebbec (_cdfd ,_gfbea ,_begf int )error {if _gfbea < 0||_gfbea > _cdfd {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _begf < _gfbea {return _g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _begf > _cdfd {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};func (_gdbd *PdfParser )parseObject ()(PdfObject ,error ){_ae .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_gdbd .skipSpaces ();for {_fggb ,_beab :=_gdbd ._bgcee .Peek (2);if _beab !=nil {if _beab !=_bc .EOF ||len (_fggb )==0{return nil ,_beab ;};if len (_fggb )==1{_fggb =append (_fggb ,' ');};};_ae .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_fggb ));if _fggb [0]=='/'{_fded ,_ccae :=_gdbd .parseName ();_ae .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_fded );return &_fded ,_ccae ;}else if _fggb [0]=='('{_ae .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_gabc ,_fffc :=_gdbd .parseString ();return _gabc ,_fffc ;}else if _fggb [0]=='['{_ae .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_badb ,_ecbb :=_gdbd .parseArray ();return _badb ,_ecbb ;}else if (_fggb [0]=='<')&&(_fggb [1]=='<'){_ae .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_bccc ,_acdgd :=_gdbd .ParseDict ();return _bccc ,_acdgd ;}else if _fggb [0]=='<'{_ae .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_cfeb ,_agdb :=_gdbd .parseHexString ();return _cfeb ,_agdb ;}else if _fggb [0]=='%'{_gdbd .readComment ();_gdbd .skipSpaces ();}else {_ae .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_fggb ,_ =_gdbd ._bgcee .Peek (15);_gbff :=string (_fggb );_ae .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_gbff );if (len (_gbff )> 3)&&(_gbff [:4]=="\u006e\u0075\u006c\u006c"){_dega ,_cda :=_gdbd .parseNull ();return &_dega ,_cda ;}else if (len (_gbff )> 4)&&(_gbff [:5]=="\u0066\u0061\u006cs\u0065"){_ecgcg ,_ffdc :=_gdbd .parseBool ();return &_ecgcg ,_ffdc ;}else if (len (_gbff )> 3)&&(_gbff [:4]=="\u0074\u0072\u0075\u0065"){_efea ,_abcad :=_gdbd .parseBool ();return &_efea ,_abcad ;};_efde :=_bebg .FindStringSubmatch (_gbff );if len (_efde )> 1{_fggb ,_ =_gdbd ._bgcee .ReadBytes ('R');_ae .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_fggb [:]));_bbaf ,_agdd :=_bafb (string (_fggb ));_bbaf ._dfbbf =_gdbd ;return &_bbaf ,_agdd ;};_defb :=_fbee .FindStringSubmatch (_gbff );if len (_defb )> 1{_ae .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_ecce ,_bbfg :=_gdbd .parseNumber ();return _ecce ,_bbfg ;};_defb =_daea .FindStringSubmatch (_gbff );if len (_defb )> 1{_ae .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_ae .Log .Trace ("\u0025\u0020\u0073",_defb );_gdbfc ,_ddfa :=_gdbd .parseNumber ();return _gdbfc ,_ddfa ;};_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_gbff );return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// GetXrefType returns the type of the first xref object (table or stream).
func (_bfefc *PdfParser )GetXrefType ()*xrefType {return _bfefc ._ccba };

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bcd :=&PdfCrypt {_afd :false ,_cfe :make (map[PdfObject ]bool ),_aec :make (map[PdfObject ]bool ),_ged :make (map[int ]struct{}),_ecd :parser };_bbfd ,_ddf :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_ddf {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _bcd ,_g .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_bbfd !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_ae .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_bbfd );return _bcd ,_g .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bcd ._bac .Filter =string (*_bbfd );if _fdf ,_aeac :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_aeac {_bcd ._bac .SubFilter =_fdf .Str ();_ae .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_fdf );};if L ,_beef :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_beef {if (*L %8)!=0{_ae .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _bcd ,_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bcd ._bac .Length =int (*L );}else {_bcd ._bac .Length =40;};_bcd ._bac .V =0;if _cgb ,_dgbg :=ed .Get ("\u0056").(*PdfObjectInteger );_dgbg {V :=int (*_cgb );_bcd ._bac .V =V ;if V >=1&&V <=2{_bcd ._gfg =_dgb (_bcd ._bac .Length );}else if V >=4&&V <=5{if _ecac :=_bcd .loadCryptFilters (ed );_ecac !=nil {return _bcd ,_ecac ;};}else {_ae .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _bcd ,_g .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _aef :=_fab (&_bcd ._bg ,ed );_aef !=nil {return _bcd ,_aef ;};_eecg :="";if _fcga ,_ccg :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_ccg &&_fcga .Len ()>=1{_bed ,_bfb :=GetString (_fcga .Get (0));if !_bfb {return _bcd ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_eecg =_bed .Str ();}else {_ae .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_bcd ._agg =_eecg ;return _bcd ,nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_dcbg :=PdfObjectBool (val );return &_dcbg };func (_abaa *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_abaa ._bgcee )};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_abb *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_abb .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_dfbf []float64 ,_afge error ){for _ ,_dfee :=range objects {_dgcfc ,_bfaf :=GetNumberAsFloat (_dfee );if _bfaf !=nil {return nil ,_bfaf ;};_dfbf =append (_dfbf ,_dgcfc );};return _dfbf ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_fffa *PdfParser )GetXrefTable ()XrefTable {return _fffa ._dbac };

// WriteString outputs the object as it is to be written to file.
func (_afdda *PdfObjectDictionary )WriteString ()string {var _cfag _a .Builder ;_cfag .WriteString ("\u003c\u003c");for _ ,_ccdc :=range _afdda ._cfbgg {_affd :=_afdda ._agff [_ccdc ];_cfag .WriteString (_ccdc .WriteString ());_cfag .WriteString ("\u0020");_cfag .WriteString (_affd .WriteString ());};_cfag .WriteString ("\u003e\u003e");return _cfag .String ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dda *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_eccc :=MakeDict ();_eccc .Set ("\u004b",MakeInteger (int64 (_dda .K )));_eccc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dda .Columns )));if _dda .BlackIs1 {_eccc .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_dda .BlackIs1 ));};if _dda .EncodedByteAlign {_eccc .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_dda .EncodedByteAlign ));};if _dda .EndOfLine &&_dda .K >=0{_eccc .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_dda .EndOfLine ));};if _dda .Rows !=0&&!_dda .EndOfBlock {_eccc .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_dda .Rows )));};if !_dda .EndOfBlock {_eccc .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_dda .EndOfBlock ));};if _dda .DamagedRowsBeforeError !=0{_eccc .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_dda .DamagedRowsBeforeError )));};return _eccc ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_cgbe :=&PdfIndirectObject {};_cgbe .PdfObject =obj ;return _cgbe ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ag .Filter ,userPass ,ownerPass []byte ,perm _cd .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_cac :=&PdfCrypt {_aec :make (map[PdfObject ]bool ),_gfg :make (cryptFilters ),_bg :_cd .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _dfc Version ;if cf !=nil {_dfd :=cf .PDFVersion ();_dfc .Major ,_dfc .Minor =_dfd [0],_dfd [1];V ,R :=cf .HandlerVersion ();_cac ._bac .V =V ;_cac ._bg .R =R ;_cac ._bac .Length =cf .KeyLength ()*8;};const (_fbd =_fdce ;);_cac ._gfg [_fbd ]=cf ;if _cac ._bac .V >=4{_cac ._geeg =_fbd ;_cac ._gcg =_fbd ;};_aae :=_cac .newEncryptDict ();_bcfd :=_de .Sum ([]byte (_dcc .Now ().Format (_dcc .RFC850 )));_bfg :=string (_bcfd [:]);_ffbg :=make ([]byte ,100);_ge .Read (_ffbg );_bcfd =_de .Sum (_ffbg );_af :=string (_bcfd [:]);_ae .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ffbg );_ae .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_bfg );_cac ._agg =_bfg ;_efg :=_cac .generateParams (userPass ,ownerPass );if _efg !=nil {return nil ,nil ,_efg ;};_dcg (&_cac ._bg ,_aae );if _cac ._bac .V >=4{if _ggg :=_cac .saveCryptFilters (_aae );_ggg !=nil {return nil ,nil ,_ggg ;};};return _cac ,&EncryptInfo {Version :_dfc ,Encrypt :_aae ,ID0 :_bfg ,ID1 :_af },nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dgdf *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func _cbca (_cebd int )int {if _cebd < 0{return -_cebd ;};return _cebd ;};

// GetFilterName returns the name of the encoding filter.
func (_eegb *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func _abfdc (_aabb ,_agcf ,_acff uint8 )uint8 {_gfbc :=int (_acff );_eadc :=int (_agcf )-_gfbc ;_abag :=int (_aabb )-_gfbc ;_gfbc =_efab (_eadc +_abag );_eadc =_efab (_eadc );_abag =_efab (_abag );if _eadc <=_abag &&_eadc <=_gfbc {return _aabb ;}else if _abag <=_gfbc {return _agcf ;};return _acff ;};var _faeg =_b .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// GetFilterName returns the name of the encoding filter.
func (_abaf *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_efc :=&DCTEncoder {};_efc .ColorComponents =3;_efc .BitsPerComponent =8;_efc .Quality =DefaultJPEGQuality ;return _efc ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_efgg *PdfParser )GetObjectNums ()[]int {var _febbb []int ;for _ ,_ccge :=range _efgg ._dbac .ObjectMap {_febbb =append (_febbb ,_ccge .ObjectNumber );};_d .Ints (_febbb );return _febbb ;};var (ErrUnsupportedEncodingParameters =_g .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_g .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_g .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_g .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_ea .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_g .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// Append appends PdfObject(s) to the array.
func (_dgdfd *PdfObjectArray )Append (objects ...PdfObject ){if _dgdfd ==nil {_ae .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_dgdfd ._adbe =append (_dgdfd ._adbe ,objects ...);};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_eeae *PdfObjectName ,_efbb bool ){_eeae ,_efbb =TraceToDirectObject (obj ).(*PdfObjectName );return _eeae ,_efbb ;};

// UpdateParams updates the parameter values of the encoder.
func (_gbg *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bdbd *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_ddd :=MakeDict ();_ddd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bdbd .GetFilterName ()));_ecfa :=_bdbd .MakeDecodeParams ();if _ecfa !=nil {_ddd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ecfa );};_ddd .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_bdbd .EarlyChange )));return _ddd ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _bbea :=obj .(type ){case *PdfObjectFloat :_ae .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_bbea ),nil ;case *PdfObjectInteger :return int64 (*_bbea ),nil ;};return 0,ErrNotANumber ;};func _acd (_faef *_ag .FilterDict ,_fgf *PdfObjectDictionary )error {if _bbd ,_bfc :=_fgf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bfc {if _eed :=string (*_bbd );_eed !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_ae .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_eed );};};_dga ,_ad :=_fgf .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_ad {return _cf .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_faef .CFM =string (*_dga );if _dae ,_ebb :=_fgf .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_ebb {_faef .AuthEvent =_cd .AuthEvent (*_dae );}else {_faef .AuthEvent =_cd .EventDocOpen ;};if _bgc ,_dcge :=_fgf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_dcge {_faef .Length =int (*_bgc );};return nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _feedc ,_gebeb :=obj .(*PdfObjectReference );_gebeb {obj =_feedc .Resolve ();};_fcbe ,_dggbdc :=obj .(*PdfIndirectObject );_daed :=0;for _dggbdc {obj =_fcbe .PdfObject ;_fcbe ,_dggbdc =GetIndirect (obj );_daed ++;if _daed > _ebgad {_ae .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_ebgad );return nil ;};};return obj ;};

// String returns a string describing `ref`.
func (_edaa *PdfObjectReference )String ()string {return _cf .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_edaa .ObjectNumber ,_edaa .GenerationNumber );};

// UpdateParams updates the parameter values of the encoder.
func (_bbg *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_ecg ,_fef :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _fef ==nil {_bbg .Predictor =int (_ecg );};_cbcc ,_fef :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fef ==nil {_bbg .BitsPerComponent =int (_cbcc );};_cdcg ,_fef :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fef ==nil {_bbg .Columns =int (_cdcg );};_bfgb ,_fef :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fef ==nil {_bbg .Colors =int (_bfgb );};};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_edda *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fcgc :=_fc .NewReader (encoded );_fege ,_ccga :=_eg .Decode (_fcgc );if _ccga !=nil {_ae .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ccga );return nil ,_ccga ;};_bdda :=_fege .Bounds ();var _eaba =make ([]byte ,_bdda .Dx ()*_bdda .Dy ()*_edda .ColorComponents *_edda .BitsPerComponent /8);_ffe :=0;for _agea :=_bdda .Min .Y ;_agea < _bdda .Max .Y ;_agea ++{for _afbe :=_bdda .Min .X ;_afbe < _bdda .Max .X ;_afbe ++{_dcdge :=_fege .At (_afbe ,_agea );if _edda .ColorComponents ==1{if _edda .BitsPerComponent ==16{_cece ,_caee :=_dcdge .(_cg .Gray16 );if !_caee {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_eaba [_ffe ]=byte ((_cece .Y >>8)&0xff);_ffe ++;_eaba [_ffe ]=byte (_cece .Y &0xff);_ffe ++;}else {_acad ,_gae :=_dcdge .(_cg .Gray );if !_gae {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_eaba [_ffe ]=_acad .Y &0xff;_ffe ++;};}else if _edda .ColorComponents ==3{if _edda .BitsPerComponent ==16{_egcb ,_adag :=_dcdge .(_cg .RGBA64 );if !_adag {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_eaba [_ffe ]=byte ((_egcb .R >>8)&0xff);_ffe ++;_eaba [_ffe ]=byte (_egcb .R &0xff);_ffe ++;_eaba [_ffe ]=byte ((_egcb .G >>8)&0xff);_ffe ++;_eaba [_ffe ]=byte (_egcb .G &0xff);_ffe ++;_eaba [_ffe ]=byte ((_egcb .B >>8)&0xff);_ffe ++;_eaba [_ffe ]=byte (_egcb .B &0xff);_ffe ++;}else {_gad ,_dbbe :=_dcdge .(_cg .RGBA );if _dbbe {_eaba [_ffe ]=_gad .R &0xff;_ffe ++;_eaba [_ffe ]=_gad .G &0xff;_ffe ++;_eaba [_ffe ]=_gad .B &0xff;_ffe ++;}else {_deb ,_aeae :=_dcdge .(_cg .YCbCr );if !_aeae {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bcga ,_ceca ,_ccea ,_ :=_deb .RGBA ();_eaba [_ffe ]=byte (_bcga >>8);_ffe ++;_eaba [_ffe ]=byte (_ceca >>8);_ffe ++;_eaba [_ffe ]=byte (_ccea >>8);_ffe ++;};};}else if _edda .ColorComponents ==4{_gcab ,_gag :=_dcdge .(_cg .CMYK );if !_gag {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_eaba [_ffe ]=255-_gcab .C &0xff;_ffe ++;_eaba [_ffe ]=255-_gcab .M &0xff;_ffe ++;_eaba [_ffe ]=255-_gcab .Y &0xff;_ffe ++;_eaba [_ffe ]=255-_gcab .K &0xff;_ffe ++;};};};return _eaba ,nil ;};var _bebg =_b .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");func (_gace *PdfParser )parseName ()(PdfObjectName ,error ){var _cdbgf _fc .Buffer ;_gecff :=false ;for {_bfdf ,_dggb :=_gace ._bgcee .Peek (1);if _dggb ==_bc .EOF {break ;};if _dggb !=nil {return PdfObjectName (_cdbgf .String ()),_dggb ;};if !_gecff {if _bfdf [0]=='/'{_gecff =true ;_gace ._bgcee .ReadByte ();}else if _bfdf [0]=='%'{_gace .readComment ();_gace .skipSpaces ();}else {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_bfdf ,_bfdf );return PdfObjectName (_cdbgf .String ()),_cf .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_bfdf [0]);};}else {if IsWhiteSpace (_bfdf [0]){break ;}else if (_bfdf [0]=='/')||(_bfdf [0]=='[')||(_bfdf [0]=='(')||(_bfdf [0]==']')||(_bfdf [0]=='<')||(_bfdf [0]=='>'){break ;}else if _bfdf [0]=='#'{_egaab ,_cfcgc :=_gace ._bgcee .Peek (3);if _cfcgc !=nil {return PdfObjectName (_cdbgf .String ()),_cfcgc ;};_acdgf ,_cfcgc :=_dc .DecodeString (string (_egaab [1:3]));if _cfcgc !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_cdbgf .WriteByte ('#');_gace ._bgcee .Discard (1);continue ;};_gace ._bgcee .Discard (3);_cdbgf .Write (_acdgf );}else {_dbcb ,_ :=_gace ._bgcee .ReadByte ();_cdbgf .WriteByte (_dbcb );};};};return PdfObjectName (_cdbgf .String ()),nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _egfef (obj ,0)};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_bdbc :=&FlateEncoder {};_bdbc .Predictor =1;_bdbc .BitsPerComponent =8;_bdbc .Colors =1;_bdbc .Columns =1;return _bdbc ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_fegc *PdfObjectReference )Resolve ()PdfObject {if _fegc ._dfbbf ==nil {return MakeNull ();};_dbgac ,_ ,_gbbg :=_fegc ._dfbbf .resolveReference (_fegc );if _gbbg !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_gbbg );return MakeNull ();};if _dbgac ==nil {_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _dbgac ;};func (_aeadb *offsetReader )Read (p []byte )(_dfbb int ,_fcb error ){return _aeadb ._gbef .Read (p )};func _acefg (_edg *PdfObjectStream ,_dcdf *PdfObjectDictionary )(*FlateEncoder ,error ){_efeb :=NewFlateEncoder ();_fgd :=_edg .PdfObjectDictionary ;if _fgd ==nil {return _efeb ,nil ;};_efeb ._dcgb =_fafc (_fgd );if _dcdf ==nil {_ccf :=TraceToDirectObject (_fgd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _cbab :=_ccf .(type ){case *PdfObjectArray :if _cbab .Len ()!=1{_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_cbab .Len ());return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cdd ,_fee :=GetDict (_cbab .Get (0));_fee {_dcdf =_cdd ;};case *PdfObjectDictionary :_dcdf =_cbab ;case *PdfObjectNull ,nil :default:_ae .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_ccf );return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dcdf ==nil {return _efeb ,nil ;};_ae .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dcdf .String ());_bddb :=_dcdf .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _bddb ==nil {_ae .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_gfdd ,_bgfb :=_bddb .(*PdfObjectInteger );if !_bgfb {_ae .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_bddb );return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_efeb .Predictor =int (*_gfdd );};_bddb =_dcdf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _bddb !=nil {_abe ,_ebd :=_bddb .(*PdfObjectInteger );if !_ebd {_ae .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_cf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_efeb .BitsPerComponent =int (*_abe );};if _efeb .Predictor > 1{_efeb .Columns =1;_bddb =_dcdf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _bddb !=nil {_fec ,_cega :=_bddb .(*PdfObjectInteger );if !_cega {return nil ,_cf .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_efeb .Columns =int (*_fec );};_efeb .Colors =1;_bddb =_dcdf .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _bddb !=nil {_bdc ,_ccef :=_bddb .(*PdfObjectInteger );if !_ccef {return nil ,_cf .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_efeb .Colors =int (*_bdc );};};return _efeb ,nil ;};type xrefType int ;func _aaddab (_efag PdfObject ,_agcda int ,_cddf map[PdfObject ]struct{})error {_ae .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_agcda );if _ ,_cagg :=_cddf [_efag ];_cagg {_ae .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_cddf [_efag ]=struct{}{};switch _cdfc :=_efag .(type ){case *PdfIndirectObject :_fdefc :=_cdfc ;_ae .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_fdefc );_ae .Log .Trace ("\u002d\u0020\u0025\u0073",_fdefc .PdfObject );return _aaddab (_fdefc .PdfObject ,_agcda +1,_cddf );case *PdfObjectStream :_cdgfe :=_cdfc ;return _aaddab (_cdgfe .PdfObjectDictionary ,_agcda +1,_cddf );case *PdfObjectDictionary :_fgfgf :=_cdfc ;_ae .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_fgfgf );for _ ,_gcdc :=range _fgfgf .Keys (){_fbedb :=_fgfgf .Get (_gcdc );if _gage ,_fcgd :=_fbedb .(*PdfObjectReference );_fcgd {_befa :=_gage .Resolve ();_fgfgf .Set (_gcdc ,_befa );_fdbgd :=_aaddab (_befa ,_agcda +1,_cddf );if _fdbgd !=nil {return _fdbgd ;};}else {_aebd :=_aaddab (_fbedb ,_agcda +1,_cddf );if _aebd !=nil {return _aebd ;};};};return nil ;case *PdfObjectArray :_fdadf :=_cdfc ;_ae .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_fdadf );for _bcbfe ,_bcffb :=range _fdadf .Elements (){if _deadc ,_feebd :=_bcffb .(*PdfObjectReference );_feebd {_beac :=_deadc .Resolve ();_fdadf .Set (_bcbfe ,_beac );_face :=_aaddab (_beac ,_agcda +1,_cddf );if _face !=nil {return _face ;};}else {_facc :=_aaddab (_bcffb ,_agcda +1,_cddf );if _facc !=nil {return _facc ;};};};return nil ;case *PdfObjectReference :_ae .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _g .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func _bafb (_dccg string )(PdfObjectReference ,error ){_caccg :=PdfObjectReference {};_cbff :=_bebg .FindStringSubmatch (_dccg );if len (_cbff )< 3{_ae .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _caccg ,_g .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_cdcb ,_ :=_e .Atoi (_cbff [1]);_aaad ,_ :=_e .Atoi (_cbff [2]);_caccg .ObjectNumber =int64 (_cdcb );_caccg .GenerationNumber =int64 (_aaad );return _caccg ,nil ;};func _efege (_gcdg *PdfObjectStream ,_cdcge *MultiEncoder )(*DCTEncoder ,error ){_dbf :=NewDCTEncoder ();_adff :=_gcdg .PdfObjectDictionary ;if _adff ==nil {return _dbf ,nil ;};_ecfee :=_gcdg .Stream ;if _cdcge !=nil {_aede ,_cbccb :=_cdcge .DecodeBytes (_ecfee );if _cbccb !=nil {return nil ,_cbccb ;};_ecfee =_aede ;};_gfc :=_fc .NewReader (_ecfee );_ggdc ,_dgf :=_eg .DecodeConfig (_gfc );if _dgf !=nil {_ae .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dgf );return nil ,_dgf ;};switch _ggdc .ColorModel {case _cg .RGBAModel :_dbf .BitsPerComponent =8;_dbf .ColorComponents =3;case _cg .RGBA64Model :_dbf .BitsPerComponent =16;_dbf .ColorComponents =3;case _cg .GrayModel :_dbf .BitsPerComponent =8;_dbf .ColorComponents =1;case _cg .Gray16Model :_dbf .BitsPerComponent =16;_dbf .ColorComponents =1;case _cg .CMYKModel :_dbf .BitsPerComponent =8;_dbf .ColorComponents =4;case _cg .YCbCrModel :_dbf .BitsPerComponent =8;_dbf .ColorComponents =3;default:return nil ,_g .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_dbf .Width =_ggdc .Width ;_dbf .Height =_ggdc .Height ;_ae .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_dbf );_dbf .Quality =DefaultJPEGQuality ;return _dbf ,nil ;};func _eaed (_cded *PdfObjectStream )(*MultiEncoder ,error ){_gdfaa :=NewMultiEncoder ();_egfb :=_cded .PdfObjectDictionary ;if _egfb ==nil {return _gdfaa ,nil ;};var _dcga *PdfObjectDictionary ;var _dgba []PdfObject ;_gbag :=_egfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gbag !=nil {_addd ,_gded :=_gbag .(*PdfObjectDictionary );if _gded {_dcga =_addd ;};_ebad ,_eecgb :=_gbag .(*PdfObjectArray );if _eecgb {for _ ,_eace :=range _ebad .Elements (){_eace =TraceToDirectObject (_eace );if _eacf ,_dbab :=_eace .(*PdfObjectDictionary );_dbab {_dgba =append (_dgba ,_eacf );}else {_dgba =append (_dgba ,MakeDict ());};};};};_gbag =_egfb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _gbag ==nil {return nil ,_cf .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_bgbd ,_ebgc :=_gbag .(*PdfObjectArray );if !_ebgc {return nil ,_cf .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _aefc ,_acaaf :=range _bgbd .Elements (){_ffff ,_bgce :=_acaaf .(*PdfObjectName );if !_bgce {return nil ,_cf .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _agec PdfObject ;if _dcga !=nil {_agec =_dcga ;}else {if len (_dgba )> 0{if _aefc >=len (_dgba ){return nil ,_cf .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_agec =_dgba [_aefc ];};};var _eaceg *PdfObjectDictionary ;if _bccd ,_egde :=_agec .(*PdfObjectDictionary );_egde {_eaceg =_bccd ;};_ae .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_ffff ,_agec ,_eaceg );if *_ffff ==StreamEncodingFilterNameFlate {_dffg ,_dgdg :=_acefg (_cded ,_eaceg );if _dgdg !=nil {return nil ,_dgdg ;};_gdfaa .AddEncoder (_dffg );}else if *_ffff ==StreamEncodingFilterNameLZW {_dbdf ,_gcae :=_bdg (_cded ,_eaceg );if _gcae !=nil {return nil ,_gcae ;};_gdfaa .AddEncoder (_dbdf );}else if *_ffff ==StreamEncodingFilterNameASCIIHex {_cdfed :=NewASCIIHexEncoder ();_gdfaa .AddEncoder (_cdfed );}else if *_ffff ==StreamEncodingFilterNameASCII85 {_bfebf :=NewASCII85Encoder ();_gdfaa .AddEncoder (_bfebf );}else if *_ffff ==StreamEncodingFilterNameDCT {_bedfc ,_gggb :=_efege (_cded ,_gdfaa );if _gggb !=nil {return nil ,_gggb ;};_gdfaa .AddEncoder (_bedfc );_ae .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_ae .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_gdfaa );}else {_ae .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_ffff );return nil ,_cf .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _gdfaa ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_bgfd *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_ecae :=MakeDict ();_ecae .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgfd .GetFilterName ()));return _ecae ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_dgcf :=MultiEncoder {};_dgcf ._ccfc =[]StreamEncoder {};return &_dgcf ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};func (_cacc *PdfCrypt )decryptBytes (_bda []byte ,_egd string ,_fcd []byte )([]byte ,error ){_ae .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_ebc ,_eeg :=_cacc ._gfg [_egd ];if !_eeg {return nil ,_cf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_egd );};return _ebc .DecryptBytes (_bda ,_fcd );};

// SetImage sets the image base for given flate encoder.
func (_aceg *FlateEncoder )SetImage (img *_ca .ImageBase ){_aceg ._dcgb =img };

// String returns a string describing `stream`.
func (_fecb *PdfObjectStream )String ()string {return _cf .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_fecb .ObjectNumber ,_fecb .PdfObjectDictionary );};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_cdca *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ae .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_ae .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cdca .Predictor );_abd ,_fdbe :=_cdca .DecodeBytes (streamObj .Stream );if _fdbe !=nil {return nil ,_fdbe ;};_ae .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_ae .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_abd ),_abd );if _cdca .Predictor > 1{if _cdca .Predictor ==2{_ae .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ecdg :=_cdca .Columns *_cdca .Colors ;if _ecdg < 1{return []byte {},nil ;};_dcdg :=len (_abd )/_ecdg ;if len (_abd )%_ecdg !=0{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_abd ),_ecdg );};if _ecdg %_cdca .Colors !=0{return nil ,_cf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ecdg ,_cdca .Colors );};if _ecdg > len (_abd ){_ae .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ecdg ,len (_abd ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ae .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_abd ),_abd );_eac :=_fc .NewBuffer (nil );for _gfge :=0;_gfge < _dcdg ;_gfge ++{_eggg :=_abd [_ecdg *_gfge :_ecdg *(_gfge +1)];for _dee :=_cdca .Colors ;_dee < _ecdg ;_dee ++{_eggg [_dee ]=byte (int (_eggg [_dee ]+_eggg [_dee -_cdca .Colors ])%256);};_eac .Write (_eggg );};_eeeba :=_eac .Bytes ();_ae .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_eeeba ),_eeeba );return _eeeba ,nil ;}else if _cdca .Predictor >=10&&_cdca .Predictor <=15{_ae .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fea :=_cdca .Columns *_cdca .Colors +1;if _fea < 1{return []byte {},nil ;};_bea :=len (_abd )/_fea ;if len (_abd )%_fea !=0{return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_abd ),_fea );};if _fea > len (_abd ){_ae .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fea ,len (_abd ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fda :=_fc .NewBuffer (nil );_ae .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cdca .Columns );_ae .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_abd ),_fea ,_bea );_bdbca :=make ([]byte ,_fea );for _baad :=0;_baad < _fea ;_baad ++{_bdbca [_baad ]=0;};for _acge :=0;_acge < _bea ;_acge ++{_dbcd :=_abd [_fea *_acge :_fea *(_acge +1)];_cace :=_dbcd [0];switch _cace {case 0:case 1:for _aedd :=2;_aedd < _fea ;_aedd ++{_dbcd [_aedd ]=byte (int (_dbcd [_aedd ]+_dbcd [_aedd -1])%256);};case 2:for _abda :=1;_abda < _fea ;_abda ++{_dbcd [_abda ]=byte (int (_dbcd [_abda ]+_bdbca [_abda ])%256);};default:_ae .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cace );return nil ,_cf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cace );};for _ddfd :=0;_ddfd < _fea ;_ddfd ++{_bdbca [_ddfd ]=_dbcd [_ddfd ];};_fda .Write (_dbcd [1:]);};_fbcb :=_fda .Bytes ();return _fbcb ,nil ;}else {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cdca .Predictor );return nil ,_cf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cdca .Predictor );};};return _abd ,nil ;};func _aeacb (_cfab *PdfObjectStream ,_cfgf *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// String returns a string describing `array`.
func (_cdag *PdfObjectArray )String ()string {_dbbae :="\u005b";for _gffg ,_cafgb :=range _cdag .Elements (){_dbbae +=_cafgb .String ();if _gffg < (_cdag .Len ()-1){_dbbae +="\u002c\u0020";};};_dbbae +="\u005d";return _dbbae ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_ae .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cgeb ,_adffa :=NewEncoderFromStream (streamObj );if _adffa !=nil {_ae .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_adffa );return _adffa ;};if _fcf ,_gbca :=_cgeb .(*LZWEncoder );_gbca {_fcf .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_ae .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_cgeb );_cdfec ,_adffa :=_cgeb .EncodeBytes (streamObj .Stream );if _adffa !=nil {_ae .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_adffa );return _adffa ;};streamObj .Stream =_cdfec ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cdfec ))));return nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_bdaa string ;_gfdaa bool ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_gbf *PdfCrypt )GetAccessPermissions ()_cd .Permissions {return _gbf ._bg .P };

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_agff map[PdfObjectName ]PdfObject ;_cfbgg []PdfObjectName ;_bebad *PdfParser ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};var _fbee =_b .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func _fafc (_aabed *PdfObjectDictionary )(_feeba *_ca .ImageBase ){var (_bfbcc *PdfObjectInteger ;_gbfaf bool ;);if _bfbcc ,_gbfaf =_aabed .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_gbfaf {_feeba =&_ca .ImageBase {Width :int (*_bfbcc )};}else {return nil ;};if _bfbcc ,_gbfaf =_aabed .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_gbfaf {_feeba .Height =int (*_bfbcc );};if _bfbcc ,_gbfaf =_aabed .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_gbfaf {_feeba .BitsPerComponent =int (*_bfbcc );};if _bfbcc ,_gbfaf =_aabed .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_gbfaf {_feeba .ColorComponents =int (*_bfbcc );};return _feeba ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gacf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func (_cdc *PdfParser )lookupByNumber (_cgf int ,_ee bool )(PdfObject ,bool ,error ){_cc ,_dgee :=_cdc .ObjCache [_cgf ];if _dgee {_ae .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_cgf );return _cc ,false ,nil ;};if _cdc ._fedb ==nil {_cdc ._fedb =map[int ]bool {};};if _cdc ._fedb [_cgf ]{_ae .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_cgf );return nil ,false ,_g .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_cdc ._fedb [_cgf ]=true ;defer delete (_cdc ._fedb ,_cgf );_da ,_dgee :=_cdc ._dbac .ObjectMap [_cgf ];if !_dgee {_ae .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _eec PdfObjectNull ;return &_eec ,false ,nil ;};_ae .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_cgf );if _da .XType ==XrefTypeTableEntry {_ae .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_da .ObjectNumber );_ae .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_da .Generation );_ae .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_da .Offset );_cdc ._gabd .Seek (_da .Offset ,_bc .SeekStart );_cdc ._bgcee =_cb .NewReader (_cdc ._gabd );_gec ,_gc :=_cdc .ParseIndirectObject ();if _gc !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_gc );if _ee {_ae .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_efe ,_ff :=_cdc .repairRebuildXrefsTopDown ();if _ff !=nil {_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_ff );return nil ,false ,_ff ;};_cdc ._dbac =*_efe ;return _cdc .lookupByNumber (_cgf ,false );};return nil ,false ,_gc ;};if _ee {_dcb ,_ ,_ :=_dcd (_gec );if int (_dcb )!=_cgf {_ae .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_ggcd :=_cdc .rebuildXrefTable ();if _ggcd !=nil {return nil ,false ,_ggcd ;};_cdc .ObjCache =objectCache {};return _cdc .lookupByNumberWrapper (_cgf ,false );};};_ae .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_cdc .ObjCache [_cgf ]=_gec ;return _gec ,false ,nil ;}else if _da .XType ==XrefTypeObjectStream {_ae .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_ae .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_ae .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_da .OsObjNumber ,_da .OsObjIndex );if _da .OsObjNumber ==_cgf {_ae .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_g .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_gb :=_cdc ._dbac .ObjectMap [_da .OsObjNumber ];_gb {_caf ,_fbb :=_cdc .lookupObjectViaOS (_da .OsObjNumber ,_cgf );if _fbb !=nil {_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_fbb );return nil ,true ,_fbb ;};_ae .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_cdc .ObjCache [_cgf ]=_caf ;if _cdc ._fdggf !=nil {_cdc ._fdggf ._cfe [_caf ]=true ;};return _caf ,true ,nil ;};_ae .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_g .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_g .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ggdb *FlateEncoder )MakeDecodeParams ()PdfObject {if _ggdb .Predictor > 1{_gbe :=MakeDict ();_gbe .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ggdb .Predictor )));if _ggdb .BitsPerComponent !=8{_gbe .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ggdb .BitsPerComponent )));};if _ggdb .Columns !=1{_gbe .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ggdb .Columns )));};if _ggdb .Colors !=1{_gbe .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ggdb .Colors )));};return _gbe ;};return nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gbdg *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetFilterName returns the name of the encoding filter.
func (_cgfd *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func _bca (_bcf XrefTable ){_ae .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_ae .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cab :=0;for _ ,_bbf :=range _bcf .ObjectMap {_ae .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_cab +1,_bbf .ObjectNumber ,_bbf .Generation ,_bbf .Offset );_cab ++;};};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_fbge *PdfParser )Inspect ()(map[string ]int ,error ){return _fbge .inspect ()};func (_eecc *PdfObjectFloat )String ()string {return _cf .Sprintf ("\u0025\u0066",*_eecc )};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_ceccg *PdfObjectArray ,_ccfcaa bool ){_ceccg ,_ccfcaa =TraceToDirectObject (obj ).(*PdfObjectArray );return _ceccg ,_ccfcaa ;};func _dcd (_gdec PdfObject )(int64 ,int64 ,error ){if _eaa ,_fgc :=_gdec .(*PdfIndirectObject );_fgc {return _eaa .ObjectNumber ,_eaa .GenerationNumber ,nil ;};if _decc ,_bee :=_gdec .(*PdfObjectStream );_bee {return _decc .ObjectNumber ,_decc .GenerationNumber ,nil ;};return 0,0,_g .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func (_debf *PdfParser )skipComments ()error {if _ ,_aafc :=_debf .skipSpaces ();_aafc !=nil {return _aafc ;};_fdda :=true ;for {_ddbf ,_dede :=_debf ._bgcee .Peek (1);if _dede !=nil {_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_dede .Error ());return _dede ;};if _fdda &&_ddbf [0]!='%'{return nil ;};_fdda =false ;if (_ddbf [0]!='\r')&&(_ddbf [0]!='\n'){_debf ._bgcee .ReadByte ();}else {break ;};};return _debf .skipComments ();};func (_cadcb *PdfParser )parseArray ()(*PdfObjectArray ,error ){_bcee :=MakeArray ();_cadcb ._bgcee .ReadByte ();for {_cadcb .skipSpaces ();_ddcab ,_cgcdg :=_cadcb ._bgcee .Peek (1);if _cgcdg !=nil {return _bcee ,_cgcdg ;};if _ddcab [0]==']'{_cadcb ._bgcee .ReadByte ();break ;};_fabb ,_cgcdg :=_cadcb .parseObject ();if _cgcdg !=nil {return _bcee ,_cgcdg ;};_bcee .Append (_fabb );};return _bcee ,nil ;};

// PdfVersion returns version of the PDF file.
func (_gfcg *PdfParser )PdfVersion ()Version {return _gfcg ._dfe };func _gdbg (_gadc string )(int ,int ,error ){_ccfff :=_dfbg .FindStringSubmatch (_gadc );if len (_ccfff )< 3{return 0,0,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dace ,_ :=_e .Atoi (_ccfff [1]);_gfeaa ,_ :=_e .Atoi (_ccfff [2]);return _dace ,_gfeaa ,nil ;};func _dag (_bgg _ag .Filter ,_gce _cd .AuthEvent )*PdfObjectDictionary {if _gce ==""{_gce =_cd .EventDocOpen ;};_gced :=MakeDict ();_gced .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_gced .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_gce )));_gced .Set ("\u0043\u0046\u004d",MakeName (_bgg .Name ()));_gced .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bgg .KeyLength ())));return _gced ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_edce *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_edce ._gabd .Seek (offset ,_bc .SeekStart );_edce ._bgcee =_cb .NewReader (_edce ._gabd );};func (_acef *PdfCrypt )securityHandler ()_cd .StdHandler {if _acef ._bg .R >=5{return _cd .NewHandlerR6 ();};return _cd .NewHandlerR4 (_acef ._agg ,_acef ._bac .Length );};func (_cgeg *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_bc .SeekStart {offset +=_cgeg ._cfcg ;};_eefg ,_egegb :=_cgeg ._gbef .Seek (offset ,whence );if _egegb !=nil {return _eefg ,_egegb ;};if whence ==_bc .SeekCurrent {_eefg -=_cgeg ._cfcg ;};if _eefg < 0{return 0,_g .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _eefg ,nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _eb .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _ddge ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_bab .Error (_ddge ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_adcb uint8 ;_gcef _ca .Image ;_bagag error ;);if bwThreshold ==JB2ImageAutoThreshold {_gcef ,_bagag =_ca .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_bab .Error (_ddge ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_adcb =uint8 (255*bwThreshold );_gcef ,_bagag =_ca .MonochromeThresholdConverter (_adcb ).Convert (i );};if _bagag !=nil {return nil ,_bagag ;};return _afbd (_gcef ),nil ;};func _bdg (_bfa *PdfObjectStream ,_bcfc *PdfObjectDictionary )(*LZWEncoder ,error ){_bdgd :=NewLZWEncoder ();_cfda :=_bfa .PdfObjectDictionary ;if _cfda ==nil {return _bdgd ,nil ;};if _bcfc ==nil {_aad :=TraceToDirectObject (_cfda .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _aad !=nil {if _aega ,_add :=_aad .(*PdfObjectDictionary );_add {_bcfc =_aega ;}else if _befg ,_aeeg :=_aad .(*PdfObjectArray );_aeeg {if _befg .Len ()==1{if _beb ,_gcfg :=GetDict (_befg .Get (0));_gcfg {_bcfc =_beb ;};};};if _bcfc ==nil {_ae .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_aad );return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_babd :=_cfda .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _babd !=nil {_ffg ,_gcc :=_babd .(*PdfObjectInteger );if !_gcc {_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_babd );return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_ffg !=0&&*_ffg !=1{return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_bdgd .EarlyChange =int (*_ffg );}else {_bdgd .EarlyChange =1;};if _bcfc ==nil {return _bdgd ,nil ;};if _ebbb ,_fbbd :=GetIntVal (_bcfc .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_fbbd {if _ebbb ==0||_ebbb ==1{_bdgd .EarlyChange =_ebbb ;}else {_ae .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_ebbb );};};_babd =_bcfc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _babd !=nil {_ccda ,_deab :=_babd .(*PdfObjectInteger );if !_deab {_ae .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_babd );return nil ,_cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bdgd .Predictor =int (*_ccda );};_babd =_bcfc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _babd !=nil {_abg ,_dadg :=_babd .(*PdfObjectInteger );if !_dadg {_ae .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_cf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bdgd .BitsPerComponent =int (*_abg );};if _bdgd .Predictor > 1{_bdgd .Columns =1;_babd =_bcfc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _babd !=nil {_bfd ,_gdfb :=_babd .(*PdfObjectInteger );if !_gdfb {return nil ,_cf .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bdgd .Columns =int (*_bfd );};_bdgd .Colors =1;_babd =_bcfc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _babd !=nil {_ece ,_gcbf :=_babd .(*PdfObjectInteger );if !_gcbf {return nil ,_cf .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_bdgd .Colors =int (*_ece );};};_ae .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bcfc .String ());return _bdgd ,nil ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_geec []PdfObject ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bac encryptDict ;_bg _cd .StdEncryptDict ;_agg string ;_bgd []byte ;_cfe map[PdfObject ]bool ;_aec map[PdfObject ]bool ;_afd bool ;_gfg cryptFilters ;_geeg string ;_gcg string ;_ecd *PdfParser ;_ged map[int ]struct{};};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_feb *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _feb .DecodeBytes (streamObj .Stream );};func (_bfeab *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ggab :=_bfeab ._bgcee .Discard (4);return PdfObjectNull {},_ggab ;};

// DecodeStream implements ASCII85 stream decoding.
func (_befc *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _befc .DecodeBytes (streamObj .Stream );};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;const (DefaultJPEGQuality =75;);

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_aagc int ,_bgec bool ){_dabd ,_bgec :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _bgec &&_dabd !=nil {return int (*_dabd ),true ;};return 0,false ;};

// String returns the state of the bool as "true" or "false".
func (_abgc *PdfObjectBool )String ()string {if *_abgc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_ceaa *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gdb _fc .Buffer ;for _ ,_cbe :=range data {_gdb .WriteString (_cf .Sprintf ("\u0025\u002e\u0032X\u0020",_cbe ));};_gdb .WriteByte ('>');return _gdb .Bytes (),nil ;};func (_afc *PdfParser )parseBool ()(PdfObjectBool ,error ){_bcdgd ,_acgb :=_afc ._bgcee .Peek (4);if _acgb !=nil {return PdfObjectBool (false ),_acgb ;};if (len (_bcdgd )>=4)&&(string (_bcdgd [:4])=="\u0074\u0072\u0075\u0065"){_afc ._bgcee .Discard (4);return PdfObjectBool (true ),nil ;};_bcdgd ,_acgb =_afc ._bgcee .Peek (5);if _acgb !=nil {return PdfObjectBool (false ),_acgb ;};if (len (_bcdgd )>=5)&&(string (_bcdgd [:5])=="\u0066\u0061\u006cs\u0065"){_afc ._bgcee .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_g .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_dfe Version ;_gabd _bc .ReadSeeker ;_bgcee *_cb .Reader ;_bfbf int64 ;_dbac XrefTable ;_fdad int64 ;_ccba *xrefType ;_cafb objectStreams ;_dgae *PdfObjectDictionary ;_fdggf *PdfCrypt ;_cbaf bool ;ObjCache objectCache ;_fedb map[int ]bool ;_bcdb map[int64 ]bool ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_ecdd *_dg .Document ;

// Globals are the JBIG2 global segments.
Globals _fa .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// String returns a string describing `streams`.
func (_fdeg *PdfObjectStreams )String ()string {return _cf .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_fdeg .ObjectNumber );};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_agee *PdfObjectString )Decoded ()string {if _agee ==nil {return "";};_afee :=[]byte (_agee ._bdaa );if len (_afee )>=2&&_afee [0]==0xFE&&_afee [1]==0xFF{return _ef .UTF16ToString (_afee [2:]);};return _ef .PDFDocEncodingToString (_afee );};var _aff =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// WriteString outputs the object as it is to be written to file.
func (_ddgfa *PdfObjectFloat )WriteString ()string {return _e .FormatFloat (float64 (*_ddgfa ),'f',-1,64);};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_bbba *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_bbba ._geec ){return _g .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_bbba ._geec [i ]=obj ;return nil ;};func (_ace *PdfCrypt )loadCryptFilters (_eee *PdfObjectDictionary )error {_ace ._gfg =cryptFilters {};_eca :=_eee .Get ("\u0043\u0046");_eca =TraceToDirectObject (_eca );if _ceg ,_aecg :=_eca .(*PdfObjectReference );_aecg {_ecde ,_cgfg :=_ace ._ecd .LookupByReference (*_ceg );if _cgfg !=nil {_ae .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _cgfg ;};_eca =TraceToDirectObject (_ecde );};_bfea ,_cdf :=_eca .(*PdfObjectDictionary );if !_cdf {_ae .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_eca );return _g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_eae :=range _bfea .Keys (){_bgb :=_bfea .Get (_eae );if _ccb ,_fba :=_bgb .(*PdfObjectReference );_fba {_abf ,_bcg :=_ace ._ecd .LookupByReference (*_ccb );if _bcg !=nil {_ae .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _bcg ;};_bgb =TraceToDirectObject (_abf );};_fbbc ,_acdg :=_bgb .(*PdfObjectDictionary );if !_acdg {return _cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_eae ,_bgb );};if _eae =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _gfd _ag .FilterDict ;if _ed :=_acd (&_gfd ,_fbbc );_ed !=nil {return _ed ;};_ecc ,_cdb :=_ag .NewFilter (_gfd );if _cdb !=nil {return _cdb ;};_ace ._gfg [string (_eae )]=_ecc ;};_ace ._gfg ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ag .NewIdentity ();_ace ._gcg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cdfa ,_aea :=_eee .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_aea {if _ ,_caec :=_ace ._gfg [string (*_cdfa )];!_caec {return _cf .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_cdfa );};_ace ._gcg =string (*_cdfa );};_ace ._geeg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cad ,_gdc :=_eee .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_gdc {if _ ,_cce :=_ace ._gfg [string (*_cad )];!_cce {return _cf .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_cad );};_ace ._geeg =string (*_cad );};return nil ;};func (_fcce *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _cagc *PdfObjectDictionary ;_abgg ,_ddfdb :=_fcce .readTextLine ();if _ddfdb !=nil {return nil ,_ddfdb ;};_ae .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_abgg );_fdfc :=-1;_bagb :=0;_fbbdb :=false ;_cfcb :="";for {_fcce .skipSpaces ();_ ,_ecacf :=_fcce ._bgcee .Peek (1);if _ecacf !=nil {return nil ,_ecacf ;};_abgg ,_ecacf =_fcce .readTextLine ();if _ecacf !=nil {return nil ,_ecacf ;};_abef :=_dfaf .FindStringSubmatch (_abgg );if len (_abef )==0{_abfc :=len (_cfcb )> 0;_cfcb +=_abgg +"\u000a";if _abfc {_abef =_dfaf .FindStringSubmatch (_cfcb );};};if len (_abef )==3{_adcae ,_ :=_e .Atoi (_abef [1]);_gebc ,_ :=_e .Atoi (_abef [2]);_fdfc =_adcae ;_bagb =_gebc ;_fbbdb =true ;_cfcb ="";_ae .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_fdfc ,_bagb );continue ;};_aeba :=_bage .FindStringSubmatch (_abgg );if len (_aeba )==4{if !_fbbdb {_ae .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_g .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_bfag ,_ :=_e .ParseInt (_aeba [1],10,64);_dcdcd ,_ :=_e .Atoi (_aeba [2]);_eefbc :=_aeba [3];_cfcb ="";if _a .ToLower (_eefbc )=="\u006e"&&_bfag > 1{_gfcf ,_dddg :=_fcce ._dbac .ObjectMap [_fdfc ];if !_dddg ||_dcdcd > _gfcf .Generation {_efgeg :=XrefObject {ObjectNumber :_fdfc ,XType :XrefTypeTableEntry ,Offset :_bfag ,Generation :_dcdcd };_fcce ._dbac .ObjectMap [_fdfc ]=_efgeg ;};};_fdfc ++;continue ;};if (len (_abgg )> 6)&&(_abgg [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_ae .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_abgg );if len (_abgg )> 9{_geaea :=_fcce .GetFileOffset ();_fcce .SetFileOffset (_geaea -int64 (len (_abgg ))+7);};_fcce .skipSpaces ();_fcce .skipComments ();_ae .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_ae .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_abgg );_cagc ,_ecacf =_fcce .ParseDict ();_ae .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _ecacf !=nil {_ae .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ecacf );return nil ,_ecacf ;};break ;};if _abgg =="\u0025\u0025\u0045O\u0046"{_ae .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_g .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_ae .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_abgg );};_ae .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _fcce ._ccba ==nil {_gead :=XrefTypeTableEntry ;_fcce ._ccba =&_gead ;};return _cagc ,nil ;};var _daea =_b .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");var _dbda =_b .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// String returns a string describing `null`.
func (_bdge *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_cgdd *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_gafc :=n ;_edgf :=0;_bfeba :=0;for _gafc > 0{_ade ,_ddaf :=_cgdd ._bgcee .Read (p [_edgf :]);if _ddaf !=nil {_ae .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_ade ,_bfeba ,_ddaf .Error ());return _edgf ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_bfeba ++;_edgf +=_ade ;_gafc -=_ade ;};return _edgf ,nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_aeda *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _ccdd ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _aeda .ColorComponents !=1||_aeda .BitsPerComponent !=1{return nil ,_bab .Errorf (_ccdd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_gaagc *_gf .Bitmap ;_gede error ;);_dcaae :=(_aeda .Width *_aeda .Height )==len (data );if _dcaae {_gaagc ,_gede =_gf .NewWithUnpaddedData (_aeda .Width ,_aeda .Height ,data );}else {_gaagc ,_gede =_gf .NewWithData (_aeda .Width ,_aeda .Height ,data );};if _gede !=nil {return nil ,_gede ;};_gaac :=_aeda .DefaultPageSettings ;if _gede =_gaac .Validate ();_gede !=nil {return nil ,_bab .Wrap (_gede ,_ccdd ,"");};switch _gaac .Compression {case JB2Generic :if _gede =_aeda ._ecdd .AddGenericPage (_gaagc ,_gaac .DuplicatedLinesRemoval );_gede !=nil {return nil ,_bab .Wrap (_gede ,_ccdd ,"");};case JB2SymbolCorrelation :return nil ,_bab .Error (_ccdd ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_bab .Error (_ccdd ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_bab .Error (_ccdd ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _aeda .Encode ();};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_fadc :=&LZWEncoder {};_fadc .Predictor =1;_fadc .BitsPerComponent =8;_fadc .Colors =1;_fadc .Columns =1;_fadc .EarlyChange =1;return _fadc ;};var _eeebad =_b .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// WriteString outputs the object as it is to be written to file.
func (_ccdg *PdfObjectString )WriteString ()string {var _dbgc _fc .Buffer ;if _ccdg ._gfdaa {_feed :=_dc .EncodeToString (_ccdg .Bytes ());_dbgc .WriteString ("\u003c");_dbgc .WriteString (_feed );_dbgc .WriteString ("\u003e");return _dbgc .String ();};_fgef :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_dbgc .WriteString ("\u0028");for _accf :=0;_accf < len (_ccdg ._bdaa );_accf ++{_fdaff :=_ccdg ._bdaa [_accf ];if _baed ,_adbf :=_fgef [_fdaff ];_adbf {_dbgc .WriteString (_baed );}else {_dbgc .WriteByte (_fdaff );};};_dbgc .WriteString ("\u0029");return _dbgc .String ();};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_aaf *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aaf .DecodeBytes (streamObj .Stream );};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_gbdd *PdfParser )Decrypt (password []byte )(bool ,error ){if _gbdd ._fdggf ==nil {return false ,_g .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_ccfca ,_gdaf :=_gbdd ._fdggf .authenticate (password );if _gdaf !=nil {return false ,_gdaf ;};if !_ccfca {_ccfca ,_gdaf =_gbdd ._fdggf .authenticate ([]byte (""));};return _ccfca ,_gdaf ;};

// Remove removes an element specified by key.
func (_cfde *PdfObjectDictionary )Remove (key PdfObjectName ){_eeebf :=-1;for _ccce ,_dgdc :=range _cfde ._cfbgg {if _dgdc ==key {_eeebf =_ccce ;break ;};};if _eeebf >=0{_cfde ._cfbgg =append (_cfde ._cfbgg [:_eeebf ],_cfde ._cfbgg [_eeebf +1:]...);delete (_cfde ._agff ,key );};};func _bcdce (_bdggc ,_fgbf PdfObject ,_aegb int )bool {if _aegb > _ebgad {_ae .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ebgad );return false ;};if _bdggc ==nil &&_fgbf ==nil {return true ;}else if _bdggc ==nil ||_fgbf ==nil {return false ;};if _gg .TypeOf (_bdggc )!=_gg .TypeOf (_fgbf ){return false ;};switch _dabc :=_bdggc .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_dabc ==*(_fgbf .(*PdfObjectName ));case *PdfObjectString :return *_dabc ==*(_fgbf .(*PdfObjectString ));case *PdfObjectInteger :return *_dabc ==*(_fgbf .(*PdfObjectInteger ));case *PdfObjectBool :return *_dabc ==*(_fgbf .(*PdfObjectBool ));case *PdfObjectFloat :return *_dabc ==*(_fgbf .(*PdfObjectFloat ));case *PdfIndirectObject :return _bcdce (TraceToDirectObject (_bdggc ),TraceToDirectObject (_fgbf ),_aegb +1);case *PdfObjectArray :_bgcd :=_fgbf .(*PdfObjectArray );if len ((*_dabc )._adbe )!=len ((*_bgcd )._adbe ){return false ;};for _daff ,_cgac :=range (*_dabc )._adbe {if !_bcdce (_cgac ,(*_bgcd )._adbe [_daff ],_aegb +1){return false ;};};return true ;case *PdfObjectDictionary :_gaagf :=_fgbf .(*PdfObjectDictionary );_agbgc ,_ffbeb :=(*_dabc )._agff ,(*_gaagf )._agff ;if len (_agbgc )!=len (_ffbeb ){return false ;};for _dcgcg ,_gfaf :=range _agbgc {_bcbdb ,_gcbb :=_ffbeb [_dcgcg ];if !_gcbb ||!_bcdce (_gfaf ,_bcbdb ,_aegb +1){return false ;};};return true ;case *PdfObjectStream :_aggf :=_fgbf .(*PdfObjectStream );return _bcdce ((*_dabc ).PdfObjectDictionary ,(*_aggf ).PdfObjectDictionary ,_aegb +1);default:_ae .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_bdggc );};return false ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_ecdd :_dg .InitEncodeDocument (false )}};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_fadg *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _fadg .Predictor !=1{return nil ,_cf .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _fadg .EarlyChange ==1{return nil ,_cf .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _ggcg _fc .Buffer ;_cbae :=_f .NewWriter (&_ggcg ,_f .MSB ,8);_cbae .Write (data );_cbae .Close ();return _ggcg .Bytes (),nil ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_aac *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_aead ,_bead :=_ca .NewImage (_aac .Width ,_aac .Height ,_aac .BitsPerComponent ,_aac .ColorComponents ,data ,nil ,nil );if _bead !=nil {return nil ,_bead ;};_ddgc :=_eg .Options {};_ddgc .Quality =_aac .Quality ;var _aadd _fc .Buffer ;if _bead =_eg .Encode (&_aadd ,_aead ,&_ddgc );_bead !=nil {return nil ,_bead ;};return _aadd .Bytes (),nil ;};func _efab (_dgfa int )int {_geag :=_dgfa >>(_gegc -1);return (_dgfa ^_geag )-_geag };

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_eedc :=PdfObjectNull {};return &_eedc };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _aaddab (o ,0,traversed );};

// String returns a string describing `d`.
func (_bcgg *PdfObjectDictionary )String ()string {var _gffgd _a .Builder ;_gffgd .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_daae :=range _bcgg ._cfbgg {_ccddg :=_bcgg ._agff [_daae ];_gffgd .WriteString ("\u0022"+_daae .String ()+"\u0022\u003a\u0020");_gffgd .WriteString (_ccddg .String ());_gffgd .WriteString ("\u002c\u0020");};_gffgd .WriteString ("\u0029");return _gffgd .String ();};var _bage =_b .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_adbe []PdfObject };

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_afea float64 ,_gaea bool ){_bdcg ,_gaea :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _gaea {return float64 (*_bdcg ),true ;};return 0,false ;};func _afbd (_beeff _ca .Image )*JBIG2Image {_cagd :=_beeff .Base ();return &JBIG2Image {Data :_cagd .Data ,Width :_cagd .Width ,Height :_cagd .Height ,HasPadding :true };};

// GetFilterName returns the name of the encoding filter.
func (_fgec *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// Len returns the number of elements in the array.
func (_aefg *PdfObjectArray )Len ()int {if _aefg ==nil {return 0;};return len (_aefg ._adbe );};func (_ededg *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_ededg ._dbac .ObjectMap =make (map[int ]XrefObject );_ededg ._cafb =make (objectStreams );_dabf ,_eegbc :=_ededg ._gabd .Seek (0,_bc .SeekEnd );if _eegbc !=nil {return nil ,_eegbc ;};_ae .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_dabf );_ededg ._bfbf =_dabf ;_eegbc =_ededg .seekToEOFMarker (_dabf );if _eegbc !=nil {_ae .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_eegbc );return nil ,_eegbc ;};_ebe ,_eegbc :=_ededg ._gabd .Seek (0,_bc .SeekCurrent );if _eegbc !=nil {return nil ,_eegbc ;};var _fdae int64 =64;_egba :=_ebe -_fdae ;if _egba < 0{_egba =0;};_ ,_eegbc =_ededg ._gabd .Seek (_egba ,_bc .SeekStart );if _eegbc !=nil {return nil ,_eegbc ;};_dgfc :=make ([]byte ,_fdae );_ ,_eegbc =_ededg ._gabd .Read (_dgfc );if _eegbc !=nil {_ae .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_eegbc );return nil ,_eegbc ;};_aabgb :=_ecgd .FindStringSubmatch (string (_dgfc ));if len (_aabgb )< 2{_ae .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_g .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_aabgb )> 2{_ae .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_dgfc );return nil ,_g .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_cfcfc ,_ :=_e .ParseInt (_aabgb [1],10,64);_ae .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_cfcfc );if _cfcfc > _dabf {_ae .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_ae .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_cfcfc ,_eegbc =_ededg .repairLocateXref ();if _eegbc !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_eegbc ;};};_ededg ._gabd .Seek (_cfcfc ,_bc .SeekStart );_ededg ._bgcee =_cb .NewReader (_ededg ._gabd );_aafg ,_eegbc :=_ededg .parseXref ();if _eegbc !=nil {return nil ,_eegbc ;};_dadd :=_aafg .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _dadd !=nil {_adfbb ,_gdcg :=_dadd .(*PdfObjectInteger );if !_gdcg {return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_eegbc =_ededg .parseXrefStream (_adfbb );if _eegbc !=nil {return nil ,_eegbc ;};};var _fggbd []int64 ;_badfb :=func (_aggc int64 ,_gfce []int64 )bool {for _ ,_efae :=range _gfce {if _efae ==_aggc {return true ;};};return false ;};_dadd =_aafg .Get ("\u0050\u0072\u0065\u0076");for _dadd !=nil {_dcef ,_dfdd :=_dadd .(*PdfObjectInteger );if !_dfdd {_ae .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_dadd );return _aafg ,nil ;};_cdbc :=*_dcef ;_ae .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_cdbc );_ededg ._gabd .Seek (int64 (_cdbc ),_bc .SeekStart );_ededg ._bgcee =_cb .NewReader (_ededg ._gabd );_cgdb ,_gdbe :=_ededg .parseXref ();if _gdbe !=nil {_ae .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_ae .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_dadd =_cgdb .Get ("\u0050\u0072\u0065\u0076");if _dadd !=nil {_ccfb :=*(_dadd .(*PdfObjectInteger ));if _badfb (int64 (_ccfb ),_fggbd ){_ae .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_fggbd =append (_fggbd ,int64 (_ccfb ));};};return _aafg ,nil ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_egb *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_debd :=&_fb .Encoder {K :_egb .K ,Columns :_egb .Columns ,EndOfLine :_egb .EndOfLine ,EndOfBlock :_egb .EndOfBlock ,BlackIs1 :_egb .BlackIs1 ,DamagedRowsBeforeError :_egb .DamagedRowsBeforeError ,Rows :_egb .Rows ,EncodedByteAlign :_egb .EncodedByteAlign };_afeg ,_gdfef :=_debd .Decode (encoded );if _gdfef !=nil {return nil ,_gdfef ;};var _bcfg []byte ;_acdc :=0;var _agca byte ;var _fdgg byte ;for _fdaa :=range _afeg {if _agca !=0{_bcfg =append (_bcfg ,_fdgg );_fdgg =0;_acdc ++;_agca =0;};for _caad :=range _afeg [_fdaa ]{_fdgg |=_afeg [_fdaa ][_caad ]<<(7-_agca );_agca ++;if _agca ==8{_bcfg =append (_bcfg ,_fdgg );_fdgg =0;_acdc ++;_agca =0;};};};if _agca > 0{_bcfg =append (_bcfg ,_fdgg );};return _bcfg ,nil ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_gfea *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gfea .DecodeBytes (streamObj .Stream );};func (_daecg *PdfParser )repairSeekXrefMarker ()error {_aacg ,_bdga :=_daecg ._gabd .Seek (0,_bc .SeekEnd );if _bdga !=nil {return _bdga ;};_dbff :=_b .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _bagd int64 ;var _eade int64 =1000;for _bagd < _aacg {if _aacg <=(_eade +_bagd ){_eade =_aacg -_bagd ;};_ ,_abgcf :=_daecg ._gabd .Seek (-_bagd -_eade ,_bc .SeekEnd );if _abgcf !=nil {return _abgcf ;};_dabeg :=make ([]byte ,_eade );_daecg ._gabd .Read (_dabeg );_ae .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_dabeg ));_befb :=_dbff .FindAllStringIndex (string (_dabeg ),-1);if _befb !=nil {_aabga :=_befb [len (_befb )-1];_ae .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_befb );_daecg ._gabd .Seek (-_bagd -_eade +int64 (_aabga [0]),_bc .SeekEnd );_daecg ._bgcee =_cb .NewReader (_daecg ._gabd );for {_dfef ,_cgbfa :=_daecg ._bgcee .Peek (1);if _cgbfa !=nil {return _cgbfa ;};_ae .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_dfef [0],_dfef [0]);if !IsWhiteSpace (_dfef [0]){break ;};_daecg ._bgcee .Discard (1);};return nil ;};_ae .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_bagd +=_eade ;};_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _g .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// UpdateParams updates the parameter values of the encoder.
func (_fecc *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};const _fdce ="\u0053\u0074\u0064C\u0046";

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_gffa :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_gffa .PdfObjectDictionary =encoder .MakeStreamDict ();_gcfgb ,_fagc :=encoder .EncodeBytes (contents );if _fagc !=nil {return nil ,_fagc ;};_gffa .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gcfgb ))));_gffa .Stream =_gcfgb ;return _gffa ,nil ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_edf *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ae .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_ae .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_edf .Predictor );if _edf .BitsPerComponent !=8{return nil ,_cf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_edf .BitsPerComponent );};_bdab ,_bcb :=_edf .DecodeBytes (streamObj .Stream );if _bcb !=nil {return nil ,_bcb ;};_bdab ,_bcb =_edf .postDecodePredict (_bdab );if _bcb !=nil {return nil ,_bcb ;};return _edf .cleanImageData (_bdab );};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_agggg *PdfObjectStreams ,_ffgdb bool ){_agggg ,_ffgdb =obj .(*PdfObjectStreams );return _agggg ,_ffgdb ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bcfec ,_ccaef :=obj .(*PdfObjectReference );_ccaef {return _bcfec .Resolve ();};return obj ;};type objectCache map[int ]PdfObject ;const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_adda *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _adda .DecodeBytes (streamObj .Stream );};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_cdcc *JBIG2Encoder )Encode ()(_bbgf []byte ,_fabe error ){const _dcgfd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _cdcc ._ecdd ==nil {return nil ,_bab .Errorf (_dcgfd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_cdcc ._ecdd .FullHeaders =_cdcc .DefaultPageSettings .FileMode ;_bbgf ,_fabe =_cdcc ._ecdd .Encode ();if _fabe !=nil {return nil ,_bab .Wrap (_fabe ,_dcgfd ,"");};return _bbgf ,nil ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_eabb :=&ASCIIHexEncoder {};return _eabb };func (_egfe *PdfObjectInteger )String ()string {return _cf .Sprintf ("\u0025\u0064",*_egfe )};func (_ccag *JBIG2Encoder )encodeImage (_fage _eb .Image )([]byte ,error ){const _befcf ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_ccbd ,_bgca :=GoImageToJBIG2 (_fage ,JB2ImageAutoThreshold );if _bgca !=nil {return nil ,_bab .Wrap (_bgca ,_befcf ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _bgca =_ccag .AddPageImage (_ccbd ,&_ccag .DefaultPageSettings );_bgca !=nil {return nil ,_bab .Wrap (_bgca ,_befcf ,"");};return _ccag .Encode ();};

// UpdateParams updates the parameter values of the encoder.
func (_ege *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_eba ,_ggce :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ggce ==nil {_ege .Predictor =int (_eba );};_gaag ,_ggce :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ggce ==nil {_ege .BitsPerComponent =int (_gaag );};_faec ,_ggce :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ggce ==nil {_ege .Columns =int (_faec );};_cgba ,_ggce :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ggce ==nil {_ege .Colors =int (_cgba );};_ggda ,_ggce :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _ggce ==nil {_ege .EarlyChange =int (_ggda );};};

// WriteString outputs the object as it is to be written to file.
func (_agbff *PdfObjectArray )WriteString ()string {var _fgab _a .Builder ;_fgab .WriteString ("\u005b");for _cced ,_fbed :=range _agbff .Elements (){_fgab .WriteString (_fbed .WriteString ());if _cced < (_agbff .Len ()-1){_fgab .WriteString ("\u0020");};};_fgab .WriteString ("\u005d");return _fgab .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_acec *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_deca *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _febbg =20;_dadgf ,_ :=_deca ._bgcee .Peek (_febbg );for _bdcd :=0;_bdcd < 2;_bdcd ++{if _deca ._fdad ==0{_deca ._fdad =_deca .GetFileOffset ();};if _dfbg .Match (_dadgf ){_ae .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_ae .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dadgf ));return _deca .parseXrefStream (nil );};if _cadcg .Match (_dadgf ){_ae .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _deca .parseXrefTable ();};_dfaa :=_deca .GetFileOffset ();if _deca ._fdad ==0{_deca ._fdad =_dfaa ;};_deca .SetFileOffset (_dfaa -_febbg );defer _deca .SetFileOffset (_dfaa );_fega ,_ :=_deca ._bgcee .Peek (_febbg );_dadgf =append (_fega ,_dadgf ...);};_ae .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _acege :=_deca .repairSeekXrefMarker ();_acege !=nil {_ae .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_acege );return nil ,_acege ;};return _deca .parseXrefTable ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gbb *LZWEncoder )MakeDecodeParams ()PdfObject {if _gbb .Predictor > 1{_eecf :=MakeDict ();_eecf .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gbb .Predictor )));if _gbb .BitsPerComponent !=8{_eecf .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gbb .BitsPerComponent )));};if _gbb .Columns !=1{_eecf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gbb .Columns )));};if _gbb .Colors !=1{_eecf .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gbb .Colors )));};return _eecf ;};return nil ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_egga *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_ae .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_eega :=MakeDict ();_eega ._bebad =_egga ;_gcdag ,_ :=_egga ._bgcee .ReadByte ();if _gcdag !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_gcdag ,_ =_egga ._bgcee .ReadByte ();if _gcdag !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_egga .skipSpaces ();_egga .skipComments ();_efga ,_cdbe :=_egga ._bgcee .Peek (2);if _cdbe !=nil {return nil ,_cdbe ;};_ae .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_efga ),string (_efga ));if (_efga [0]=='>')&&(_efga [1]=='>'){_ae .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_egga ._bgcee .ReadByte ();_egga ._bgcee .ReadByte ();break ;};_ae .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_gaef ,_cdbe :=_egga .parseName ();_ae .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_gaef );if _cdbe !=nil {_ae .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_cdbe );return nil ,_cdbe ;};if len (_gaef )> 4&&_gaef [len (_gaef )-4:]=="\u006e\u0075\u006c\u006c"{_bgff :=_gaef [0:len (_gaef )-4];_ae .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_gaef );_ae .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_bgff );_egga .skipSpaces ();_dcdfa ,_ :=_egga ._bgcee .Peek (1);if _dcdfa [0]=='/'{_eega .Set (_bgff ,MakeNull ());continue ;};};_egga .skipSpaces ();_fgea ,_cdbe :=_egga .parseObject ();if _cdbe !=nil {return nil ,_cdbe ;};_eega .Set (_gaef ,_fgea );if _ae .Log .IsLogLevel (_ae .LogLevelTrace ){_ae .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_gaef ,_fgea .String ());};};_ae .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _eega ,nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// WriteString outputs the object as it is to be written to file.
func (_ebag *PdfObjectReference )WriteString ()string {var _cdcad _a .Builder ;_cdcad .WriteString (_e .FormatInt (_ebag .ObjectNumber ,10));_cdcad .WriteString ("\u0020");_cdcad .WriteString (_e .FormatInt (_ebag .GenerationNumber ,10));_cdcad .WriteString ("\u0020\u0052");return _cdcad .String ();};

// Elements returns a slice of the PdfObject elements in the array.
func (_gegcg *PdfObjectArray )Elements ()[]PdfObject {if _gegcg ==nil {return nil ;};return _gegcg ._adbe ;};

// LookupByReference looks up a PdfObject by a reference.
func (_eaf *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_ae .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _eaf .LookupByNumber (int (ref .ObjectNumber ));};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_abff *PdfObjectDictionary ,_eaaec bool ){_abff ,_eaaec =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _abff ,_eaaec ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _ceaf _fc .Buffer ;_ceaf .Write ([]byte {0xFE,0xFF});_ceaf .WriteString (_ef .StringToUTF16 (s ));return &PdfObjectString {_bdaa :_ceaf .String (),_gfdaa :true };};return &PdfObjectString {_bdaa :string (_ef .StringToPDFDocEncoding (s )),_gfdaa :false };};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_gcabc :=PdfObjectInteger (val );return &_gcabc };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aeef *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_gegad *PdfObjectString ,_dbfe bool ){_gegad ,_dbfe =TraceToDirectObject (obj ).(*PdfObjectString );return _gegad ,_dbfe ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_dbb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_fcgg :=MakeDict ();_fcgg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dbb .GetFilterName ()));return _fcgg ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_deaa :=MakeArray ();for _ ,_ebgca :=range vals {_deaa .Append (MakeInteger (_ebgca ));};return _deaa ;};const JB2ImageAutoThreshold =-1.0;

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_bbfeb *PdfParser )GetFileOffset ()int64 {_feccb ,_ :=_bbfeb ._gabd .Seek (0,_bc .SeekCurrent );_feccb -=int64 (_bbfeb ._bgcee .Buffered ());return _feccb ;};

// GetXrefOffset returns the offset of the xref table.
func (_bedff *PdfParser )GetXrefOffset ()int64 {return _bedff ._fdad };

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_ced *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_deg :=encoded ;var _bgfdg error ;for _ ,_egeg :=range _ced ._ccfc {_ae .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_egeg ,_egeg );_deg ,_bgfdg =_egeg .DecodeBytes (_deg );if _bgfdg !=nil {return nil ,_bgfdg ;};};return _deg ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fgb *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_geeb :=range _fgb ._ccfc {_geeb .UpdateParams (params );};};var _dfbg =_b .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// String returns a string describing `ind`.
func (_adg *PdfIndirectObject )String ()string {return _cf .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_adg ).ObjectNumber );};const _ebgad =10;func _dgb (_fcg int )cryptFilters {return cryptFilters {_fdce :_ag .NewFilterV2 (_fcg )}};const _gegc =32<<(^uint (0)>>63);func (_gbfg *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_gbfg ._gabd .Seek (0,_bc .SeekStart );_gbfg ._bgcee =_cb .NewReader (_gbfg ._gabd );_dccgd :=20;_daeec :=make ([]byte ,_dccgd );for {_deed ,_accb :=_gbfg ._bgcee .ReadByte ();if _accb !=nil {if _accb ==_bc .EOF {break ;}else {return 0,0,_accb ;};};if IsDecimalDigit (_deed )&&_daeec [_dccgd -1]=='.'&&IsDecimalDigit (_daeec [_dccgd -2])&&_daeec [_dccgd -3]=='-'&&_daeec [_dccgd -4]=='F'&&_daeec [_dccgd -5]=='D'&&_daeec [_dccgd -6]=='P'{_bbeaf :=int (_daeec [_dccgd -2]-'0');_bddbd :=int (_deed -'0');return _bbeaf ,_bddbd ,nil ;};_daeec =append (_daeec [1:_dccgd ],_deed );};return 0,0,_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_caea *JBIG2Encoder )EncodeImage (img _eb .Image )([]byte ,error ){return _caea .encodeImage (img )};func (_abadf *PdfParser )seekToEOFMarker (_bace int64 )error {var _ageg int64 ;var _ffag int64 =2048;for _ageg < _bace -4{if _bace <=(_ffag +_ageg ){_ffag =_bace -_ageg ;};_ ,_gedg :=_abadf ._gabd .Seek (-_ageg -_ffag ,_bc .SeekEnd );if _gedg !=nil {return _gedg ;};_cfbg :=make ([]byte ,_ffag );_abadf ._gabd .Read (_cfbg );_ae .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_cfbg ));_fgdf :=_dbda .FindAllStringIndex (string (_cfbg ),-1);if _fgdf !=nil {_aadda :=_fgdf [len (_fgdf )-1];_ae .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fgdf );_abadf ._gabd .Seek (-_ageg -_ffag +int64 (_aadda [0]),_bc .SeekEnd );return nil ;};_ae .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ageg +=_ffag -4;};_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _g .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_aeacc *PdfParser )IsEncrypted ()(bool ,error ){if _aeacc ._fdggf !=nil {return true ,nil ;}else if _aeacc ._dgae ==nil {return false ,nil ;};_ae .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_fdaf :=_aeacc ._dgae .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _fdaf ==nil {return false ,nil ;};_ae .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_bdgb *PdfObjectDictionary ;);switch _gdag :=_fdaf .(type ){case *PdfObjectDictionary :_bdgb =_gdag ;case *PdfObjectReference :_ae .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_gdag );_eccb ,_bgfa :=_aeacc .LookupByReference (*_gdag );_ae .Log .Trace ("\u0031\u003a\u0020%\u0071",_eccb );if _bgfa !=nil {return false ,_bgfa ;};_cdaf ,_gbfac :=_eccb .(*PdfIndirectObject );if !_gbfac {_ae .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_dac ,_gbfac :=_cdaf .PdfObject .(*PdfObjectDictionary );_ae .Log .Trace ("\u0032\u003a\u0020%\u0071",_dac );if !_gbfac {return false ,_g .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_bdgb =_dac ;case *PdfObjectNull :_ae .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_cf .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_gdag );};_dbead ,_fffg :=PdfCryptNewDecrypt (_aeacc ,_bdgb ,_aeacc ._dgae );if _fffg !=nil {return false ,_fffg ;};for _ ,_deeb :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_fac :=_aeacc ._dgae .Get (PdfObjectName (_deeb ));if _fac ==nil {continue ;};switch _beba :=_fac .(type ){case *PdfObjectReference :_dbead ._ged [int (_beba .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_dbead ._cfe [_beba ]=true ;_dbead ._ged [int (_beba .ObjectNumber )]=struct{}{};};};_aeacc ._fdggf =_dbead ;_ae .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_dbead );return true ,nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_feaf *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _cecce []float64 ;for _ ,_cadca :=range _feaf .Elements (){_bbcaf ,_dcf :=GetNumberAsFloat (TraceToDirectObject (_cadca ));if _dcf !=nil {return nil ,_cf .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_cecce =append (_cecce ,_bbcaf );};return _cecce ,nil ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_dcgc *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_bbdg ,_ffca :=_dcgc ._agff [key ].(*PdfObjectString );if !_ffca {return "",false ;};return _bbdg .Str (),true ;};func (_fadcg *PdfParser )parseString ()(*PdfObjectString ,error ){_fadcg ._bgcee .ReadByte ();var _cdeg _fc .Buffer ;_ggaa :=1;for {_ccege ,_gbcb :=_fadcg ._bgcee .Peek (1);if _gbcb !=nil {return MakeString (_cdeg .String ()),_gbcb ;};if _ccege [0]=='\\'{_fadcg ._bgcee .ReadByte ();_gbfc ,_abcd :=_fadcg ._bgcee .ReadByte ();if _abcd !=nil {return MakeString (_cdeg .String ()),_abcd ;};if IsOctalDigit (_gbfc ){_efega ,_gfee :=_fadcg ._bgcee .Peek (2);if _gfee !=nil {return MakeString (_cdeg .String ()),_gfee ;};var _bcdg []byte ;_bcdg =append (_bcdg ,_gbfc );for _ ,_ebgfa :=range _efega {if IsOctalDigit (_ebgfa ){_bcdg =append (_bcdg ,_ebgfa );}else {break ;};};_fadcg ._bgcee .Discard (len (_bcdg )-1);_ae .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bcdg );_cbad ,_gfee :=_e .ParseUint (string (_bcdg ),8,32);if _gfee !=nil {return MakeString (_cdeg .String ()),_gfee ;};_cdeg .WriteByte (byte (_cbad ));continue ;};switch _gbfc {case 'n':_cdeg .WriteRune ('\n');case 'r':_cdeg .WriteRune ('\r');case 't':_cdeg .WriteRune ('\t');case 'b':_cdeg .WriteRune ('\b');case 'f':_cdeg .WriteRune ('\f');case '(':_cdeg .WriteRune ('(');case ')':_cdeg .WriteRune (')');case '\\':_cdeg .WriteRune ('\\');};continue ;}else if _ccege [0]=='('{_ggaa ++;}else if _ccege [0]==')'{_ggaa --;if _ggaa ==0{_fadcg ._bgcee .ReadByte ();break ;};};_bacg ,_ :=_fadcg ._bgcee .ReadByte ();_cdeg .WriteByte (_bacg );};return MakeString (_cdeg .String ()),nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_cbdf *PdfObjectInteger ,_ecad bool ){_cbdf ,_ecad =TraceToDirectObject (obj ).(*PdfObjectInteger );return _cbdf ,_ecad ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ccdb *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ccdb .DecodeBytes (streamObj .Stream );};

// Clear resets the array to an empty state.
func (_feae *PdfObjectArray )Clear (){_feae ._adbe =[]PdfObject {}};

// WriteString outputs the object as it is to be written to file.
func (_ggcb *PdfObjectStreams )WriteString ()string {var _becfg _a .Builder ;_becfg .WriteString (_e .FormatInt (_ggcb .ObjectNumber ,10));_becfg .WriteString ("\u0020\u0030\u0020\u0052");return _becfg .String ();};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_adbe :objects }};func (_ecfg *PdfParser )repairLocateXref ()(int64 ,error ){_cgbdf :=int64 (1000);_ecfg ._gabd .Seek (-_cgbdf ,_bc .SeekCurrent );_gegb ,_eddc :=_ecfg ._gabd .Seek (0,_bc .SeekCurrent );if _eddc !=nil {return 0,_eddc ;};_efdbb :=make ([]byte ,_cgbdf );_ecfg ._gabd .Read (_efdbb );_bbff :=_eeebad .FindAllStringIndex (string (_efdbb ),-1);if len (_bbff )< 1{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_g .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_gaacb :=int64 (_bbff [len (_bbff )-1][0]);_bebd :=_gegb +_gaacb ;return _bebd ,nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_cbaga *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cbaga .GetFilterName ());return data ,ErrNoJPXDecode ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_afaa :=&PdfObjectDictionary {};_afaa ._agff =map[PdfObjectName ]PdfObject {};_afaa ._cfbgg =[]PdfObjectName {};return _afaa ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_eegc *PdfParser )GetTrailer ()*PdfObjectDictionary {return _eegc ._dgae };func (_egac *PdfParser )skipSpaces ()(int ,error ){_degg :=0;for {_bcab ,_gbcg :=_egac ._bgcee .ReadByte ();if _gbcg !=nil {return 0,_gbcg ;};if IsWhiteSpace (_bcab ){_degg ++;}else {_egac ._bgcee .UnreadByte ();break ;};};return _degg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cfee *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ffgb *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_gd []XrefObject ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_cb .Reader )(PdfObject ,error ){_dfda :=false ;_gdgc :=true ;var _aaaa _fc .Buffer ;for {if _ae .Log .IsLogLevel (_ae .LogLevelTrace ){_ae .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_aaaa .String ());};_aaef ,_fdbge :=buf .Peek (1);if _fdbge ==_bc .EOF {break ;};if _fdbge !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_fdbge );return nil ,_fdbge ;};if _gdgc &&(_aaef [0]=='-'||_aaef [0]=='+'){_beca ,_ :=buf .ReadByte ();_aaaa .WriteByte (_beca );_gdgc =false ;}else if IsDecimalDigit (_aaef [0]){_afgeb ,_ :=buf .ReadByte ();_aaaa .WriteByte (_afgeb );}else if _aaef [0]=='.'{_afdg ,_ :=buf .ReadByte ();_aaaa .WriteByte (_afdg );_dfda =true ;}else if _aaef [0]=='e'||_aaef [0]=='E'{_ddbbe ,_ :=buf .ReadByte ();_aaaa .WriteByte (_ddbbe );_dfda =true ;_gdgc =true ;}else {break ;};};var _dggfc PdfObject ;if _dfda {_fdfbg ,_bcceb :=_e .ParseFloat (_aaaa .String (),64);if _bcceb !=nil {_ae .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_aaaa .String (),_bcceb );_fdfbg =0.0;};_adga :=PdfObjectFloat (_fdfbg );_dggfc =&_adga ;}else {_eege ,_egfcb :=_e .ParseInt (_aaaa .String (),10,64);if _egfcb !=nil {_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_aaaa .String (),_egfcb );_eege =0;};_ggcec :=PdfObjectInteger (_eege );_dggfc =&_ggcec ;};return _dggfc ,nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_cdda *MultiEncoder )GetFilterName ()string {_feeb :="";for _bceg ,_bdbde :=range _cdda ._ccfc {_feeb +=_bdbde .GetFilterName ();if _bceg < len (_cdda ._ccfc )-1{_feeb +="\u0020";};};return _feeb ;};type objectStream struct{N int ;_cba []byte ;_gde map[int ]int64 ;};

// String returns a descriptive information string about the encryption method used.
func (_ega *PdfCrypt )String ()string {if _ega ==nil {return "";};_efgf :=_ega ._bac .Filter +"\u0020\u002d\u0020";if _ega ._bac .V ==0{_efgf +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _ega ._bac .V ==1{_efgf +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _ega ._bac .V ==2{_efgf +=_cf .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_ega ._bac .Length );}else if _ega ._bac .V ==3{_efgf +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _ega ._bac .V >=4{_efgf +=_cf .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_ega ._geeg ,_ega ._gcg );_efgf +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _dd ,_dad :=range _ega ._gfg {_efgf +=_cf .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_dd ,_dad .Name (),_dad .KeyLength ());};};_afb :=_ega .GetAccessPermissions ();_efgf +=_cf .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_afb );return _efgf ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_bdgf :=MakeArray ();for _ ,_ceff :=range vals {_bdgf .Append (MakeFloat (_ceff ));};return _bdgf ;};

// UpdateParams updates the parameter values of the encoder.
func (_efd *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _egce ,_gfbf :=GetNumberAsInt64 (params .Get ("\u004b"));_gfbf ==nil {_efd .K =int (_egce );};if _eafe ,_cbf :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_cbf ==nil {_efd .Columns =int (_eafe );}else if _eafe ,_cbf =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_cbf ==nil {_efd .Columns =int (_eafe );};if _bfefd ,_ecag :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ecag ==nil {_efd .BlackIs1 =_bfefd > 0;}else {if _beg ,_cceg :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cceg {_efd .BlackIs1 =_beg ;}else {if _ddag ,_fabag :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fabag {_begc ,_egcf :=_ddag .ToIntegerArray ();if _egcf ==nil {_efd .BlackIs1 =_begc [0]==1&&_begc [1]==0;};};};};if _ddfb ,_bbdd :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bbdd ==nil {_efd .EncodedByteAlign =_ddfb > 0;}else {if _ffab ,_aadc :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_aadc {_efd .EncodedByteAlign =_ffab ;};};if _badf ,_cadc :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cadc ==nil {_efd .EndOfLine =_badf > 0;}else {if _ebcf ,_gfe :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gfe {_efd .EndOfLine =_ebcf ;};};if _edgc ,_cag :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_cag ==nil {_efd .Rows =int (_edgc );}else if _edgc ,_cag =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_cag ==nil {_efd .Rows =int (_edgc );};if _ecdfa ,_dgfe :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dgfe ==nil {_efd .EndOfBlock =_ecdfa > 0;}else {if _gfbd ,_fgfg :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fgfg {_efd .EndOfBlock =_gfbd ;};};if _caecb ,_accd :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_accd !=nil {_efd .DamagedRowsBeforeError =int (_caecb );};};func (_efbg *PdfParser )rebuildXrefTable ()error {_gedd :=XrefTable {};_gedd .ObjectMap =map[int ]XrefObject {};_dead :=make ([]int ,0,len (_efbg ._dbac .ObjectMap ));for _bdfd :=range _efbg ._dbac .ObjectMap {_dead =append (_dead ,_bdfd );};_d .Ints (_dead );for _ ,_cdggf :=range _dead {_gceeb :=_efbg ._dbac .ObjectMap [_cdggf ];_dffbb ,_ ,_acac :=_efbg .lookupByNumberWrapper (_cdggf ,false );if _acac !=nil {_ae .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_acac );_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_gfed ,_daag :=_efbg .repairRebuildXrefsTopDown ();if _daag !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_daag );return _daag ;};_efbg ._dbac =*_gfed ;_ae .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_bdgfd ,_caebf ,_acac :=_dcd (_dffbb );if _acac !=nil {return _acac ;};_gceeb .ObjectNumber =int (_bdgfd );_gceeb .Generation =int (_caebf );_gedd .ObjectMap [int (_bdgfd )]=_gceeb ;};_efbg ._dbac =_gedd ;_ae .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_bca (_efbg ._dbac );return nil ;};func (_dce *PdfParser )lookupByNumberWrapper (_cff int ,_cbd bool )(PdfObject ,bool ,error ){_agf ,_aaa ,_ec :=_dce .lookupByNumber (_cff ,_cbd );if _ec !=nil {return nil ,_aaa ,_ec ;};if !_aaa &&_dce ._fdggf !=nil &&!_dce ._fdggf .isDecrypted (_agf ){_fge :=_dce ._fdggf .Decrypt (_agf ,0,0);if _fge !=nil {return nil ,_aaa ,_fge ;};};return _agf ,_aaa ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cbdc *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func (_ddfg *PdfParser )parsePdfVersion ()(int ,int ,error ){var _cgeda int64 =20;_gfeag :=make ([]byte ,_cgeda );_ddfg ._gabd .Seek (0,_bc .SeekStart );_ddfg ._gabd .Read (_gfeag );var _baca error ;var _cgefbe ,_gfgd int ;if _adcbg :=_faeg .FindStringSubmatch (string (_gfeag ));len (_adcbg )< 3{if _cgefbe ,_gfgd ,_baca =_ddfg .seekPdfVersionTopDown ();_baca !=nil {_ae .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_baca ;};_ddfg ._gabd ,_baca =_fffb (_ddfg ._gabd ,_ddfg .GetFileOffset ()-8);if _baca !=nil {return 0,0,_baca ;};}else {if _cgefbe ,_baca =_e .Atoi (_adcbg [1]);_baca !=nil {return 0,0,_baca ;};if _gfgd ,_baca =_e .Atoi (_adcbg [2]);_baca !=nil {return 0,0,_baca ;};_ddfg .SetFileOffset (0);};_ddfg ._bgcee =_cb .NewReader (_ddfg ._gabd );_ae .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_cgefbe ,_gfgd );return _cgefbe ,_gfgd ,nil ;};func (_gfda *PdfParser )readTextLine ()(string ,error ){var _cdgc _fc .Buffer ;for {_cga ,_cfea :=_gfda ._bgcee .Peek (1);if _cfea !=nil {_ae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cfea .Error ());return _cdgc .String (),_cfea ;};if (_cga [0]!='\r')&&(_cga [0]!='\n'){_eceadc ,_ :=_gfda ._bgcee .ReadByte ();_cdgc .WriteByte (_eceadc );}else {break ;};};return _cdgc .String (),nil ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bccf *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _baag []int64 ;for _ ,_abcda :=range _bccf .Elements (){if _daee ,_abec :=_abcda .(*PdfObjectInteger );_abec {_baag =append (_baag ,int64 (*_daee ));}else {return nil ,ErrTypeError ;};};return _baag ,nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_cbbg *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ae .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_bba :=_fc .NewReader (encoded );_age ,_cffg :=_ba .NewReader (_bba );if _cffg !=nil {_ae .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_cffg );_ae .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_cffg ;};defer _age .Close ();var _cfd _fc .Buffer ;_cfd .ReadFrom (_age );return _cfd .Bytes (),nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;const (_adfc =0;_cfdb =1;_adcg =2;_bfbc =3;_egad =4;);

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_afae *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_caece *PdfObjectString )Str ()string {return _caece ._bdaa };func _cafg (_dcec *PdfObjectStream ,_fbaed *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _egfc ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_ebgff :=&JBIG2Encoder {};_bfbcf :=_dcec .PdfObjectDictionary ;if _bfbcf ==nil {return _ebgff ,nil ;};if _fbaed ==nil {_ddcg :=_bfbcf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ddcg !=nil {switch _cdce :=_ddcg .(type ){case *PdfObjectDictionary :_fbaed =_cdce ;case *PdfObjectArray :if _cdce .Len ()==1{if _fcag ,_eaee :=GetDict (_cdce .Get (0));_eaee {_fbaed =_fcag ;};};default:_ae .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_ddcg );return nil ,_bab .Errorf (_egfc ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_cdce );};};};if _fbaed ==nil {return _ebgff ,nil ;};_ebgff .UpdateParams (_fbaed );_fece :=_fbaed .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _fece ==nil {return _ebgff ,nil ;};var _gbbe error ;_adfff ,_afdd :=_fece .(*PdfObjectStream );if !_afdd {_gbbe =_bab .Error (_egfc ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbbe );return nil ,_gbbe ;};_ebgff .Globals ,_gbbe =_fa .DecodeGlobals (_adfff .Stream );if _gbbe !=nil {_gbbe =_bab .Wrap (_gbbe ,_egfc ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbbe );return nil ,_gbbe ;};return _ebgff ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_cccg *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cef _fc .Buffer ;for _fdgc :=0;_fdgc < len (data );_fdgc +=4{_gcfd :=data [_fdgc ];_baga :=1;_cfgc :=byte (0);if _fdgc +1< len (data ){_cfgc =data [_fdgc +1];_baga ++;};_afag :=byte (0);if _fdgc +2< len (data ){_afag =data [_fdgc +2];_baga ++;};_afe :=byte (0);if _fdgc +3< len (data ){_afe =data [_fdgc +3];_baga ++;};_fgeb :=(uint32 (_gcfd )<<24)|(uint32 (_cfgc )<<16)|(uint32 (_afag )<<8)|uint32 (_afe );if _fgeb ==0{_cef .WriteByte ('z');}else {_cecf :=_cccg .base256Tobase85 (_fgeb );for _ ,_becc :=range _cecf [:_baga +1]{_cef .WriteByte (_becc +'!');};};};_cef .WriteString ("\u007e\u003e");return _cef .Bytes (),nil ;};func (_fggc *PdfParser )resolveReference (_efdc *PdfObjectReference )(PdfObject ,bool ,error ){_fddd ,_gabb :=_fggc .ObjCache [int (_efdc .ObjectNumber )];if _gabb {return _fddd ,true ,nil ;};_gacbb ,_aegag :=_fggc .LookupByReference (*_efdc );if _aegag !=nil {return nil ,false ,_aegag ;};_fggc .ObjCache [int (_efdc .ObjectNumber )]=_gacbb ;return _gacbb ,false ,nil ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_gccb :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _gccb ==nil {return NewRawEncoder (),nil ;};if _ ,_afaea :=_gccb .(*PdfObjectNull );_afaea {return NewRawEncoder (),nil ;};_fdee ,_cfga :=_gccb .(*PdfObjectName );if !_cfga {_abba ,_afeb :=_gccb .(*PdfObjectArray );if !_afeb {return nil ,_cf .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _abba .Len ()==0{return NewRawEncoder (),nil ;};if _abba .Len ()!=1{_aafcb ,_bfde :=_eaed (streamObj );if _bfde !=nil {_ae .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bfde );return nil ,_bfde ;};_ae .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_aafcb );return _aafcb ,nil ;};_gccb =_abba .Get (0);_fdee ,_afeb =_gccb .(*PdfObjectName );if !_afeb {return nil ,_cf .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_fdee {case StreamEncodingFilterNameFlate :return _acefg (streamObj ,nil );case StreamEncodingFilterNameLZW :return _bdg (streamObj ,nil );case StreamEncodingFilterNameDCT :return _efege (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _aeacb (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _bgde (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _cafg (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_ae .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_cf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_fdee );};func _fab (_cbg *_cd .StdEncryptDict ,_faa *PdfObjectDictionary )error {R ,_bffb :=_faa .Get ("\u0052").(*PdfObjectInteger );if !_bffb {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _cf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_cbg .R =int (*R );O ,_bffb :=_faa .GetString ("\u004f");if !_bffb {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _cbg .R ==5||_cbg .R ==6{if len (O )< 48{return _cf .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _cf .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_cbg .O =[]byte (O );U ,_bffb :=_faa .GetString ("\u0055");if !_bffb {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _cbg .R ==5||_cbg .R ==6{if len (U )< 48{return _cf .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_ae .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_cbg .U =[]byte (U );if _cbg .R >=5{OE ,_cae :=_faa .GetString ("\u004f\u0045");if !_cae {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _cf .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_cbg .OE =[]byte (OE );UE ,_cae :=_faa .GetString ("\u0055\u0045");if !_cae {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _cf .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_cbg .UE =[]byte (UE );};P ,_bffb :=_faa .Get ("\u0050").(*PdfObjectInteger );if !_bffb {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_cbg .P =_cd .Permissions (*P );if _cbg .R ==6{Perms ,_dgd :=_faa .GetString ("\u0050\u0065\u0072m\u0073");if !_dgd {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _cf .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_cbg .Perms =[]byte (Perms );};if _cbag ,_gdf :=_faa .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_gdf {_cbg .EncryptMetadata =bool (*_cbag );}else {_cbg .EncryptMetadata =true ;};return nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_cfae :=PdfObjectString {_bdaa :s };return &_cfae };type offsetReader struct{_gbef _bc .ReadSeeker ;_cfcg int64 ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_bcaf *PdfParser )CheckAccessRights (password []byte )(bool ,_cd .Permissions ,error ){if _bcaf ._fdggf ==nil {return true ,_cd .PermOwner ,nil ;};return _bcaf ._fdggf .checkAccessRights (password );};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_gfddg :=&ASCII85Encoder {};return _gfddg };

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_bada *JBIG2Encoder )DecodeImages (encoded []byte )([]_eb .Image ,error ){const _dab ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_eagd ,_ccbf :=_df .Decode (encoded ,_df .Parameters {},_bada .Globals .ToDocumentGlobals ());if _ccbf !=nil {return nil ,_bab .Wrap (_ccbf ,_dab ,"");};_ddca ,_ccbf :=_eagd .PageNumber ();if _ccbf !=nil {return nil ,_bab .Wrap (_ccbf ,_dab ,"");};_dcaa :=[]_eb .Image {};var _dgbgc _eb .Image ;for _fdefe :=1;_fdefe <=_ddca ;_fdefe ++{_dgbgc ,_ccbf =_eagd .DecodePageImage (_fdefe );if _ccbf !=nil {return nil ,_bab .Wrapf (_ccbf ,_dab ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fdefe );};_dcaa =append (_dcaa ,_dgbgc );};return _dcaa ,nil ;};func _dcg (_aag *_cd .StdEncryptDict ,_ggb *PdfObjectDictionary ){_ggb .Set ("\u0052",MakeInteger (int64 (_aag .R )));_ggb .Set ("\u0050",MakeInteger (int64 (_aag .P )));_ggb .Set ("\u004f",MakeStringFromBytes (_aag .O ));_ggb .Set ("\u0055",MakeStringFromBytes (_aag .U ));if _aag .R >=5{_ggb .Set ("\u004f\u0045",MakeStringFromBytes (_aag .OE ));_ggb .Set ("\u0055\u0045",MakeStringFromBytes (_aag .UE ));_ggb .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_aag .EncryptMetadata ));if _aag .R > 5{_ggb .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_aag .Perms ));};};};

// WriteString outputs the object as it is to be written to file.
func (_egae *PdfIndirectObject )WriteString ()string {var _edac _a .Builder ;_edac .WriteString (_e .FormatInt (_egae .ObjectNumber ,10));_edac .WriteString ("\u0020\u0030\u0020\u0052");return _edac .String ();};

// WriteString outputs the object as it is to be written to file.
func (_ddbe *PdfObjectStream )WriteString ()string {var _faecg _a .Builder ;_faecg .WriteString (_e .FormatInt (_ddbe .ObjectNumber ,10));_faecg .WriteString ("\u0020\u0030\u0020\u0052");return _faecg .String ();};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_aeea *JBIG2Image )ToGoImage ()(_eb .Image ,error ){const _afegb ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _aeea .Data ==nil {return nil ,_bab .Error (_afegb ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _aeea .Width ==0||_aeea .Height ==0{return nil ,_bab .Error (_afegb ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_edfd ,_gggbb :=_ca .NewImage (_aeea .Width ,_aeea .Height ,1,1,_aeea .Data ,nil ,nil );if _gggbb !=nil {return nil ,_gggbb ;};return _edfd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dbeb *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_fcc *FlateEncoder )SetPredictor (columns int ){_fcc .Predictor =11;_fcc .Columns =columns };

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_eeff :=PdfObjectFloat (val );return &_eeff };

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_egdg bool ,_dfad bool ){_aefe ,_dfad :=TraceToDirectObject (obj ).(*PdfObjectBool );if _dfad {return bool (*_aefe ),true ;};return false ,false ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_cg .Model ;Bounds ()_eb .Rectangle ;At (_gebe ,_cdfb int )_cg .Color ;Set (_caeg ,_dca int ,_aba _cg .Color );};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gbdf *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_dfff :=range another .Keys (){_cacb :=another .Get (_dfff );_gbdf .Set (_dfff ,_cacb );};};return _gbdf ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gdcb *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gdcb ._ccfc =append (_gdcb ._ccfc ,encoder );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ebdg *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_afa :=MakeDict ();_afa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ebdg .GetFilterName ()));return _afa ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_ddce *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _aecc :=val .(type ){case *PdfObjectName :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectDictionary :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectStream :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectString :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectNull :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectInteger :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectArray :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectBool :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectFloat :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfObjectReference :if _aecc !=nil {_ddce .Set (key ,val );};case *PdfIndirectObject :if _aecc !=nil {_ddce .Set (key ,val );};default:_ae .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_fecce *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_gacbe :=PdfIndirectObject {};_gacbe ._dfbbf =_fecce ;_ae .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_becfa ,_gega :=_fecce ._bgcee .Peek (20);if _gega !=nil {if _gega !=_bc .EOF {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_gacbe ,_gega ;};};_ae .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_becfa ));_cegd :=_dfbg .FindStringSubmatchIndex (string (_becfa ));if len (_cegd )< 6{if _gega ==_bc .EOF {return nil ,_gega ;};_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_becfa ));return &_gacbe ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_fecce ._bgcee .Discard (_cegd [0]);_ae .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_cegd );_gbdc :=_cegd [1]-_cegd [0];_gcbca :=make ([]byte ,_gbdc );_ ,_gega =_fecce .ReadAtLeast (_gcbca ,_gbdc );if _gega !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_gega );return nil ,_gega ;};_ae .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gcbca );_bdbcb :=_dfbg .FindStringSubmatch (string (_gcbca ));if len (_bdbcb )< 3{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gcbca ));return &_gacbe ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_fcbf ,_ :=_e .Atoi (_bdbcb [1]);_bbab ,_ :=_e .Atoi (_bdbcb [2]);_gacbe .ObjectNumber =int64 (_fcbf );_gacbe .GenerationNumber =int64 (_bbab );for {_bbef ,_fade :=_fecce ._bgcee .Peek (2);if _fade !=nil {return &_gacbe ,_fade ;};_ae .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bbef ),string (_bbef ));if IsWhiteSpace (_bbef [0]){_fecce .skipSpaces ();}else if _bbef [0]=='%'{_fecce .skipComments ();}else if (_bbef [0]=='<')&&(_bbef [1]=='<'){_ae .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_gacbe .PdfObject ,_fade =_fecce .ParseDict ();_ae .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_fade );if _fade !=nil {return &_gacbe ,_fade ;};_ae .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_bbef [0]=='/')||(_bbef [0]=='(')||(_bbef [0]=='[')||(_bbef [0]=='<'){_gacbe .PdfObject ,_fade =_fecce .parseObject ();if _fade !=nil {return &_gacbe ,_fade ;};_ae .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _bbef [0]==']'{_ae .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_fecce ._bgcee .Discard (1);}else {if _bbef [0]=='e'{_bebb ,_aaag :=_fecce .readTextLine ();if _aaag !=nil {return nil ,_aaag ;};if len (_bebb )>=6&&_bebb [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _bbef [0]=='s'{_bbef ,_ =_fecce ._bgcee .Peek (10);if string (_bbef [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cbcd :=6;if len (_bbef )> 6{if IsWhiteSpace (_bbef [_cbcd ])&&_bbef [_cbcd ]!='\r'&&_bbef [_cbcd ]!='\n'{_ae .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_cbcd ++;};if _bbef [_cbcd ]=='\r'{_cbcd ++;if _bbef [_cbcd ]=='\n'{_cbcd ++;};}else if _bbef [_cbcd ]=='\n'{_cbcd ++;};};_fecce ._bgcee .Discard (_cbcd );_aagee ,_fcbbc :=_gacbe .PdfObject .(*PdfObjectDictionary );if !_fcbbc {return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ae .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_aagee );_gdbb ,_gcbcg :=_fecce .traceStreamLength (_aagee .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _gcbcg !=nil {_ae .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_gcbcg );return nil ,_gcbcg ;};_ae .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gdbb );_egcc ,_bagba :=_gdbb .(*PdfObjectInteger );if !_bagba {return nil ,_g .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_bedffb :=*_egcc ;if _bedffb < 0{return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_babdd :=_fecce .GetFileOffset ();_ebaa :=_fecce .xrefNextObjectOffset (_babdd );if _babdd +int64 (_bedffb )> _ebaa &&_ebaa > _babdd {_ae .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_babdd +int64 (_bedffb ));_ae .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ebaa );_gfcc :=_ebaa -_babdd -17;if _gfcc < 0{return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_ae .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_gfcc );_bedffb =PdfObjectInteger (_gfcc );_aagee .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_gfcc ));};if int64 (_bedffb )> _fecce ._bfbf {_ae .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_ccff :=make ([]byte ,_bedffb );_ ,_gcbcg =_fecce .ReadAtLeast (_ccff ,int (_bedffb ));if _gcbcg !=nil {_ae .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_ccff ),_ccff );_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gcbcg );return nil ,_gcbcg ;};_abcg :=PdfObjectStream {};_abcg .Stream =_ccff ;_abcg .PdfObjectDictionary =_gacbe .PdfObject .(*PdfObjectDictionary );_abcg .ObjectNumber =_gacbe .ObjectNumber ;_abcg .GenerationNumber =_gacbe .GenerationNumber ;_abcg .PdfObjectReference ._dfbbf =_fecce ;_fecce .skipSpaces ();_fecce ._bgcee .Discard (9);_fecce .skipSpaces ();return &_abcg ,nil ;};};_gacbe .PdfObject ,_fade =_fecce .parseObject ();if _gacbe .PdfObject ==nil {_ae .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_gacbe .PdfObject =MakeNull ();};return &_gacbe ,_fade ;};};if _gacbe .PdfObject ==nil {_ae .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_gacbe .PdfObject =MakeNull ();};_ae .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_gacbe ,nil ;};func (_gddf *PdfCrypt )isDecrypted (_fdg PdfObject )bool {_ ,_eda :=_gddf ._cfe [_fdg ];if _eda {_ae .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _fbc :=_fdg .(type ){case *PdfObjectStream :if _gddf ._bg .R !=5{if _ecfe ,_dbg :=_fbc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dbg &&*_ecfe =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_eda =_gddf ._ged [int (_fbc .ObjectNumber )];_eda {return true ;};switch _bdf :=_fbc .PdfObject .(type ){case *PdfObjectDictionary :_cde :=true ;for _ ,_cbb :=range _aff {if _bdf .Get (_cbb )==nil {_cde =false ;break ;};};if _cde {return true ;};};};_ae .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_bdgg *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _cgcd ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _dbec :=_bdgg .AddPageImage (img ,&_bdgg .DefaultPageSettings );_dbec !=nil {return nil ,_bab .Wrap (_dbec ,_cgcd ,"");};return _bdgg .Encode ();};

// WriteString outputs the object as it is to be written to file.
func (_cabg *PdfObjectName )WriteString ()string {var _gceb _fc .Buffer ;if len (*_cabg )> 127{_ae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_cabg );};_gceb .WriteString ("\u002f");for _fdbgc :=0;_fdbgc < len (*_cabg );_fdbgc ++{_acga :=(*_cabg )[_fdbgc ];if !IsPrintable (_acga )||_acga =='#'||IsDelimiter (_acga ){_gceb .WriteString (_cf .Sprintf ("\u0023\u0025\u002e2\u0078",_acga ));}else {_gceb .WriteByte (_acga );};};return _gceb .String ();};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_aabec *PdfObjectFloat ,_gdbc bool ){_aabec ,_gdbc =TraceToDirectObject (obj ).(*PdfObjectFloat );return _aabec ,_gdbc ;};func (_dfa *PdfCrypt )saveCryptFilters (_dgda *PdfObjectDictionary )error {if _dfa ._bac .V < 4{return _g .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_ggd :=MakeDict ();_dgda .Set ("\u0043\u0046",_ggd );for _dfb ,_bbeb :=range _dfa ._gfg {if _dfb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bd :=_dag (_bbeb ,"");_ggd .Set (PdfObjectName (_dfb ),_bd );};_dgda .Set ("\u0053\u0074\u0072\u0046",MakeName (_dfa ._gcg ));_dgda .Set ("\u0053\u0074\u006d\u0046",MakeName (_dfa ._geeg ));return nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_aaaf *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_aaaf ._adbe ){return _g .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_aaaf ._adbe [i ]=obj ;return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bdba *PdfObjectInteger )WriteString ()string {return _e .FormatInt (int64 (*_bdba ),10)};func (_aeec *PdfParser )xrefNextObjectOffset (_bgcea int64 )int64 {_defg :=int64 (0);if len (_aeec ._dbac .ObjectMap )==0{return 0;};if len (_aeec ._dbac ._gd )==0{_gfgfg :=0;for _ ,_fdbg :=range _aeec ._dbac .ObjectMap {if _fdbg .Offset > 0{_gfgfg ++;};};if _gfgfg ==0{return 0;};_aeec ._dbac ._gd =make ([]XrefObject ,_gfgfg );_agfa :=0;for _ ,_afdb :=range _aeec ._dbac .ObjectMap {if _afdb .Offset > 0{_aeec ._dbac ._gd [_agfa ]=_afdb ;_agfa ++;};};_d .Slice (_aeec ._dbac ._gd ,func (_cgaa ,_becca int )bool {return _aeec ._dbac ._gd [_cgaa ].Offset < _aeec ._dbac ._gd [_becca ].Offset });};_fbbdca :=_d .Search (len (_aeec ._dbac ._gd ),func (_feee int )bool {return _aeec ._dbac ._gd [_feee ].Offset >=_bgcea });if _fbbdca < len (_aeec ._dbac ._gd ){_defg =_aeec ._dbac ._gd [_fbbdca ].Offset ;};return _defg ;};func (_ecf *PdfCrypt )checkAccessRights (_ddg []byte )(bool ,_cd .Permissions ,error ){_dde :=_ecf .securityHandler ();_gea ,_gcd ,_bef :=_dde .Authenticate (&_ecf ._bg ,_ddg );if _bef !=nil {return false ,0,_bef ;}else if _gcd ==0||len (_gea )==0{return false ,0,nil ;};return true ,_gcd ,nil ;};func _fffb (_ccegd _bc .ReadSeeker ,_cedc int64 )(*offsetReader ,error ){_dffb :=&offsetReader {_gbef :_ccegd ,_cfcg :_cedc };_ ,_bbb :=_dffb .Seek (0,_bc .SeekStart );return _dffb ,_bbb ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_eabc *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_bffe ,_gfa :=obj .(*PdfObjectReference );if !_gfa {return obj ,nil ;};_ffb :=_eabc .GetFileOffset ();defer func (){_eabc .SetFileOffset (_ffb )}();_ceb ,_fga :=_eabc .LookupByReference (*_bffe );if _fga !=nil {return nil ,_fga ;};_gbc ,_bbe :=_ceb .(*PdfIndirectObject );if !_bbe {return _ceb ,nil ;};_ceb =_gbc .PdfObject ;_ ,_gfa =_ceb .(*PdfObjectReference );if _gfa {return _gbc ,_g .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ceb ,nil ;};func _egfef (_gcaae PdfObject ,_gfca int )PdfObject {if _gfca > _ebgad {_ae .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ebgad );return MakeNull ();};switch _adeb :=_gcaae .(type ){case *PdfIndirectObject :_gcaae =_egfef ((*_adeb ).PdfObject ,_gfca +1);case *PdfObjectArray :for _faga ,_daaec :=range (*_adeb )._adbe {(*_adeb )._adbe [_faga ]=_egfef (_daaec ,_gfca +1);};case *PdfObjectDictionary :for _adagg ,_fead :=range (*_adeb )._agff {(*_adeb )._agff [_adagg ]=_egfef (_fead ,_gfca +1);};_d .Slice ((*_adeb )._cfbgg ,func (_adba ,_fcca int )bool {return (*_adeb )._cfbgg [_adba ]< (*_adeb )._cfbgg [_fcca ]});};return _gcaae ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_adbc *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_bbda :=_adbc .GetFileOffset ();_ ,_edgfe :=_adbc ._gabd .Seek (offset ,_bc .SeekStart );if _edgfe !=nil {return nil ,_edgfe ;};_bgcf :=make ([]byte ,len );_ ,_edgfe =_bc .ReadAtLeast (_adbc ._gabd ,_bgcf ,int (len ));if _edgfe !=nil {return nil ,_edgfe ;};_adbc .SetFileOffset (_bbda );return _bgcf ,nil ;};func _bgde (_bfba *PdfObjectStream ,_egf *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_dedfa :=NewCCITTFaxEncoder ();_bcagb :=_bfba .PdfObjectDictionary ;if _bcagb ==nil {return _dedfa ,nil ;};if _egf ==nil {_gbfa :=TraceToDirectObject (_bcagb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gbfa !=nil {switch _bcef :=_gbfa .(type ){case *PdfObjectDictionary :_egf =_bcef ;case *PdfObjectArray :if _bcef .Len ()==1{if _cdfg ,_faea :=GetDict (_bcef .Get (0));_faea {_egf =_cdfg ;};};default:_ae .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gbfa );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _egf ==nil {_ae .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gbfa );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gba ,_abca :=GetNumberAsInt64 (_egf .Get ("\u004b"));_abca ==nil {_dedfa .K =int (_gba );};if _fgg ,_cabe :=GetNumberAsInt64 (_egf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_cabe ==nil {_dedfa .Columns =int (_fgg );}else {_dedfa .Columns =1728;};if _bgeg ,_eagb :=GetNumberAsInt64 (_egf .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eagb ==nil {_dedfa .BlackIs1 =_bgeg > 0;}else {if _aegd ,_gdbf :=GetBoolVal (_egf .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gdbf {_dedfa .BlackIs1 =_aegd ;}else {if _afbee ,_dbba :=GetArray (_egf .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_dbba {_dgdd ,_gcaad :=_afbee .ToIntegerArray ();if _gcaad ==nil {_dedfa .BlackIs1 =_dgdd [0]==1&&_dgdd [1]==0;};};};};if _ffbe ,_acbd :=GetNumberAsInt64 (_egf .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_acbd ==nil {_dedfa .EncodedByteAlign =_ffbe > 0;}else {if _fbca ,_bbfaa :=GetBoolVal (_egf .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bbfaa {_dedfa .EncodedByteAlign =_fbca ;};};if _gceee ,_afdc :=GetNumberAsInt64 (_egf .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_afdc ==nil {_dedfa .EndOfLine =_gceee > 0;}else {if _adfa ,_gabe :=GetBoolVal (_egf .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gabe {_dedfa .EndOfLine =_adfa ;};};if _fced ,_gff :=GetNumberAsInt64 (_egf .Get ("\u0052\u006f\u0077\u0073"));_gff ==nil {_dedfa .Rows =int (_fced );};_dedfa .EndOfBlock =true ;if _acgc ,_dagc :=GetNumberAsInt64 (_egf .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dagc ==nil {_dedfa .EndOfBlock =_acgc > 0;}else {if _gfgf ,_ccgae :=GetBoolVal (_egf .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ccgae {_dedfa .EndOfBlock =_gfgf ;};};if _ecdb ,_ecgc :=GetNumberAsInt64 (_egf .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_ecgc !=nil {_dedfa .DamagedRowsBeforeError =int (_ecdb );};_ae .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_egf .String ());return _dedfa ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cegb *PdfObjectStream ,_eeab bool ){obj =ResolveReference (obj );_cegb ,_eeab =obj .(*PdfObjectStream );return _cegb ,_eeab ;};func (_ga *PdfParser )lookupObjectViaOS (_bag int ,_fd int )(PdfObject ,error ){var _fg *_fc .Reader ;var _eab objectStream ;var _bb bool ;_eab ,_bb =_ga ._cafb [_bag ];if !_bb {_ggc ,_dff :=_ga .LookupByNumber (_bag );if _dff !=nil {_ae .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_bag );return nil ,_dff ;};_cee ,_fe :=_ggc .(*PdfObjectStream );if !_fe {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _ga ._fdggf !=nil &&!_ga ._fdggf .isDecrypted (_cee ){return nil ,_g .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_db :=_cee .PdfObjectDictionary ;_ae .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_db .String ());_gga ,_fe :=_db .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_fe {_ae .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _a .ToLower (string (*_gga ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_g .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_fe :=_db .Get ("\u004e").(*PdfObjectInteger );if !_fe {return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ab ,_fe :=_db .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_fe {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ae .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gga ,*N );_fdc ,_dff :=DecodeStream (_cee );if _dff !=nil {return nil ,_dff ;};_ae .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_fdc );_gee :=_ga .GetFileOffset ();defer func (){_ga .SetFileOffset (_gee )}();_fg =_fc .NewReader (_fdc );_ga ._bgcee =_cb .NewReader (_fg );_ae .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_gef :=map[int ]int64 {};for _dge :=0;_dge < int (*N );_dge ++{_ga .skipSpaces ();_ac ,_cbc :=_ga .parseNumber ();if _cbc !=nil {return nil ,_cbc ;};_bf ,_bcc :=_ac .(*PdfObjectInteger );if !_bcc {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_ga .skipSpaces ();_ac ,_cbc =_ga .parseNumber ();if _cbc !=nil {return nil ,_cbc ;};_aa ,_bcc :=_ac .(*PdfObjectInteger );if !_bcc {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_ae .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_bf ,*_aa );_gef [int (*_bf )]=int64 (*_ab +*_aa );};_eab =objectStream {N :int (*N ),_cba :_fdc ,_gde :_gef };_ga ._cafb [_bag ]=_eab ;}else {_aed :=_ga .GetFileOffset ();defer func (){_ga .SetFileOffset (_aed )}();_fg =_fc .NewReader (_eab ._cba );_ga ._bgcee =_cb .NewReader (_fg );};_gaa :=_eab ._gde [_fd ];_ae .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_fd ,_gaa );_fg .Seek (_gaa ,_bc .SeekStart );_ga ._bgcee =_cb .NewReader (_fg );_be ,_ :=_ga ._bgcee .Peek (100);_ae .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_be ));_dec ,_aee :=_ga .parseObject ();if _aee !=nil {_ae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_aee );return nil ,_aee ;};if _dec ==nil {return nil ,_g .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_bff :=PdfIndirectObject {};_bff .ObjectNumber =int64 (_fd );_bff .PdfObject =_dec ;return &_bff ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gdda *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_dbfa :=MakeDict ();_dbfa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_gdda .GetFilterArray ());for _ ,_feab :=range _gdda ._ccfc {_feca :=_feab .MakeStreamDict ();for _ ,_dgff :=range _feca .Keys (){_fgfb :=_feca .Get (_dgff );if _dgff !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_dgff !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_dbfa .Set (_dgff ,_fgfb );};};};_agab :=_gdda .MakeDecodeParams ();if _agab !=nil {_dbfa .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_agab );};return _dbfa ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_gcgd :=PdfObjectName (s );return &_gcgd };

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_fgde *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ebdf [][]byte ;for _gdde :=0;_gdde < len (data );_gdde +=_fgde .Columns {_dbce :=make ([]byte ,_fgde .Columns );_dbea :=0;for _ecead :=0;_ecead < _fgde .Columns ;_ecead ++{if data [_gdde +_ecead ]==255{_dbce [_dbea ]=1;}else {_dbce [_dbea ]=0;};_dbea ++;};_ebdf =append (_ebdf ,_dbce );};_gfddga :=&_fb .Encoder {K :_fgde .K ,Columns :_fgde .Columns ,EndOfLine :_fgde .EndOfLine ,EndOfBlock :_fgde .EndOfBlock ,BlackIs1 :_fgde .BlackIs1 ,DamagedRowsBeforeError :_fgde .DamagedRowsBeforeError ,Rows :_fgde .Rows ,EncodedByteAlign :_fgde .EncodedByteAlign };return _gfddga .Encode (_ebdf ),nil ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ag .FilterDict ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bcfe *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_beedb :=MakeDict ();_beedb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcfe .GetFilterName ()));_ddec :=_bcfe .MakeDecodeParams ();if _ddec !=nil {_beedb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ddec );};return _beedb ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_bebf :=_fc .NewReader ([]byte (txt ));_ggada :=&PdfParser {ObjCache :objectCache {},_gabd :_bebf ,_bgcee :_cb .NewReader (_bebf ),_bfbf :int64 (len (txt )),_bcdb :map[int64 ]bool {}};_ggada ._dbac .ObjectMap =make (map[int ]XrefObject );return _ggada ;};func (_ggfb *PdfCrypt )encryptBytes (_bcde []byte ,_efeg string ,_decg []byte )([]byte ,error ){_ae .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_ggcde ,_ddc :=_ggfb ._gfg [_efeg ];if !_ddc {return nil ,_cf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_efeg );};return _ggcde .EncryptBytes (_bcde ,_decg );};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_geec :objects };};func (_egaa *FlateEncoder )cleanImageData (_acf []byte )([]byte ,error ){if _egaa ._dcgb ==nil {return _acf ,nil ;};if _egaa ._dcgb .BitsPerComponent >=8{return _acf ,nil ;};_baab :=_egaa ._dcgb .BitsPerComponent *_egaa ._dcgb .Width *_egaa ._dcgb .ColorComponents *_egaa ._dcgb .Height /8;_acf =_acf [:_baab ];var _bbfa error ;_acf ,_bbfa =_ca .AddDataPadding (_egaa ._dcgb .Width ,_egaa ._dcgb .Height ,_egaa ._dcgb .BitsPerComponent ,_egaa ._dcgb .ColorComponents ,_acf );if _bbfa !=nil {return nil ,_bbfa ;};return _acf ,nil ;};func (_dea *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_adf :=MakeDict ();_adf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_adf .Set ("\u0056",MakeInteger (int64 (_dea ._bac .V )));_adf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dea ._bac .Length )));return _adf ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_gaed *MultiEncoder )GetFilterArray ()*PdfObjectArray {_ffc :=make ([]PdfObject ,len (_gaed ._ccfc ));for _ddea ,_gddb :=range _gaed ._ccfc {_ffc [_ddea ]=MakeName (_gddb .GetFilterName ());};return MakeArray (_ffc ...);};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cfef *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gdff :=MakeDict ();_gdff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfef .GetFilterName ()));return _gdff ;};func (_acfb *PdfParser )traceStreamLength (_gfec PdfObject )(PdfObject ,error ){_bbcc ,_bdaba :=_gfec .(*PdfObjectReference );if _bdaba {_cdbd ,_ebbe :=_acfb ._bcdb [_bbcc .ObjectNumber ];if _ebbe &&_cdbd {_ae .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_g .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_acfb ._bcdb [_bbcc .ObjectNumber ]=true ;};_cdgfc ,_ebdb :=_acfb .Resolve (_gfec );if _ebdb !=nil {return nil ,_ebdb ;};_ae .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cdgfc );if _bdaba {_acfb ._bcdb [_bbcc .ObjectNumber ]=false ;};return _cdgfc ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_agcb *PdfObjectBool ,_eedcc bool ){_agcb ,_eedcc =TraceToDirectObject (obj ).(*PdfObjectBool );return _agcb ,_eedcc ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_edcga *PdfObjectReference )GetParser ()*PdfParser {return _edcga ._dfbbf };

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_egdd *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_ddbb *PdfObjectStreams )Elements ()[]PdfObject {if _ddbb ==nil {return nil ;};return _ddbb ._geec ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _bcdce (obj1 ,obj2 ,0)};

// String returns a string representation of the *PdfObjectString.
func (_edae *PdfObjectString )String ()string {return _edae ._bdaa };