//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_bag "github.com/unidoc/unipdf/v3/common";_bb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ba "io";);func (_ce *Encoder )code0 (_abf *codingContext ,_aea uint32 ,_fca uint16 ,_gedc byte ){if _abf .mps (_aea )==0{_ce .codeMPS (_abf ,_aea ,_fca ,_gedc );}else {_ce .codeLPS (_abf ,_aea ,_fca ,_gedc );};};func (_gec *Encoder )EncodeInteger (proc Class ,value int )(_egf error ){_bag .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _egf =_gec .encodeInteger (proc ,value );_egf !=nil {return _f .Wrap (_egf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};var _gbc =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_dab *Encoder )renormalize (){for {_dab ._cb <<=1;_dab ._gb <<=1;_dab ._ge --;if _dab ._ge ==0{_dab .byteOut ();};if (_dab ._cb &0x8000)!=0{break ;};};};func (_aad *Encoder )codeLPS (_adfa *codingContext ,_dag uint32 ,_bbdg uint16 ,_bgb byte ){_aad ._cb -=_bbdg ;if _aad ._cb < _bbdg {_aad ._gb +=uint32 (_bbdg );}else {_aad ._cb =_bbdg ;};if _gbc [_bgb ]._cab ==1{_adfa .flipMps (_dag );};_adfa ._ae [_dag ]=_gbc [_bgb ]._eca ;_aad .renormalize ();};func (_dfd *Encoder )WriteTo (w _ba .Writer )(int64 ,error ){const _bbb ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cbf int64 ;for _agb ,_bab :=range _dfd ._fe {_bce ,_bgdg :=w .Write (_bab );if _bgdg !=nil {return 0,_f .Wrapf (_bgdg ,_bbb ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_agb );};_cbf +=int64 (_bce );};_dfd ._ccc =_dfd ._ccc [:_dfd ._aff ];_dac ,_aee :=w .Write (_dfd ._ccc );if _aee !=nil {return 0,_f .Wrap (_aee ,_bbb ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cbf +=int64 (_dac );return _cbf ,nil ;};func (_cg *Encoder )Refine (iTemp ,iTarget *_bb .Bitmap ,ox ,oy int )error {for _ddc :=0;_ddc < iTarget .Height ;_ddc ++{var _ege int ;_cfgd :=_ddc +oy ;var (_ad ,_egfc ,_afb ,_gc ,_ccg uint16 ;_aacd ,_ea ,_ff ,_fg ,_ab byte ;);if _cfgd >=1&&(_cfgd -1)< iTemp .Height {_aacd =iTemp .Data [(_cfgd -1)*iTemp .RowStride ];};if _cfgd >=0&&_cfgd < iTemp .Height {_ea =iTemp .Data [_cfgd *iTemp .RowStride ];};if _cfgd >=-1&&_cfgd +1< iTemp .Height {_ff =iTemp .Data [(_cfgd +1)*iTemp .RowStride ];};if _ddc >=1{_fg =iTarget .Data [(_ddc -1)*iTarget .RowStride ];};_ab =iTarget .Data [_ddc *iTarget .RowStride ];_gdg :=uint (6+ox );_ad =uint16 (_aacd >>_gdg );_egfc =uint16 (_ea >>_gdg );_afb =uint16 (_ff >>_gdg );_gc =uint16 (_fg >>6);_gbe :=uint (2-ox );_aacd <<=_gbe ;_ea <<=_gbe ;_ff <<=_gbe ;_fg <<=2;for _ege =0;_ege < iTarget .Width ;_ege ++{_cbd :=(_ad <<10)|(_egfc <<7)|(_afb <<4)|(_gc <<1)|_ccg ;_adc :=_ab >>7;_aef :=_cg .encodeBit (_cg ._dd ,uint32 (_cbd ),_adc );if _aef !=nil {return _aef ;};_ad <<=1;_egfc <<=1;_afb <<=1;_gc <<=1;_ad |=uint16 (_aacd >>7);_egfc |=uint16 (_ea >>7);_afb |=uint16 (_ff >>7);_gc |=uint16 (_fg >>7);_ccg =uint16 (_adc );_cgd :=_ege %8;_ddd :=_ege /8+1;if _cgd ==5+ox {_aacd ,_ea ,_ff =0,0,0;if _ddd < iTemp .RowStride &&_cfgd >=1&&(_cfgd -1)< iTemp .Height {_aacd =iTemp .Data [(_cfgd -1)*iTemp .RowStride +_ddd ];};if _ddd < iTemp .RowStride &&_cfgd >=0&&_cfgd < iTemp .Height {_ea =iTemp .Data [_cfgd *iTemp .RowStride +_ddd ];};if _ddd < iTemp .RowStride &&_cfgd >=-1&&(_cfgd +1)< iTemp .Height {_ff =iTemp .Data [(_cfgd +1)*iTemp .RowStride +_ddd ];};}else {_aacd <<=1;_ea <<=1;_ff <<=1;};if _cgd ==5&&_ddc >=1{_fg =0;if _ddd < iTarget .RowStride {_fg =iTarget .Data [(_ddc -1)*iTarget .RowStride +_ddd ];};}else {_fg <<=1;};if _cgd ==7{_ab =0;if _ddd < iTarget .RowStride {_ab =iTarget .Data [_ddc *iTarget .RowStride +_ddd ];};}else {_ab <<=1;};_ad &=7;_egfc &=7;_afb &=7;_gc &=7;};};return nil ;};func (_g Class )String ()string {switch _g {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func New ()*Encoder {_aeg :=&Encoder {};_aeg .Init ();return _aeg };func (_caa *Encoder )EncodeOOB (proc Class )(_aaca error ){_bag .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _aaca =_caa .encodeOOB (proc );_aaca !=nil {return _f .Wrap (_aaca ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_cfde *Encoder )Final (){_cfde .flush ()};func (_dg *Encoder )Reset (){_dg ._cb =0x8000;_dg ._gb =0;_dg ._ge =12;_dg ._ag =-1;_dg ._ed =0;_dg ._bg =nil ;_dg ._dd =_ec (_eba );};func (_cga *Encoder )code1 (_edd *codingContext ,_agf uint32 ,_gdf uint16 ,_cd byte ){if _edd .mps (_agf )==1{_cga .codeMPS (_edd ,_agf ,_gdf ,_cd );}else {_cga .codeLPS (_edd ,_agf ,_gdf ,_cd );};};type Class int ;var _gf =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};type intEncRangeS struct{_d ,_bbd int ;_c ,_bd uint8 ;_af uint16 ;_bc uint8 ;};func (_ccgb *Encoder )emit (){if _ccgb ._aff ==_aec {_ccgb ._fe =append (_ccgb ._fe ,_ccgb ._ccc );_ccgb ._ccc =make ([]byte ,_aec );_ccgb ._aff =0;};_ccgb ._ccc [_ccgb ._aff ]=_ccgb ._ed ;_ccgb ._aff ++;};func (_cea *Encoder )encodeIAID (_bdbe ,_ddad int )error {if _cea ._bg ==nil {_cea ._bg =_ec (1<<uint (_bdbe ));};_adb :=uint32 (1<<uint32 (_bdbe +1))-1;_ddad <<=uint (32-_bdbe );_ecfe :=uint32 (1);for _eaa :=0;_eaa < _bdbe ;_eaa ++{_baa :=_ecfe &_adb ;_abff :=uint8 ((uint32 (_ddad )&0x80000000)>>31);if _daa :=_cea .encodeBit (_cea ._bg ,_baa ,_abff );_daa !=nil {return _daa ;};_ecfe =(_ecfe <<1)|uint32 (_abff );_ddad <<=1;};return nil ;};func (_ef *codingContext )flipMps (_cc uint32 ){_ef ._e [_cc ]=1-_ef ._e [_cc ]};func (_cff *Encoder )DataSize ()int {return _cff .dataSize ()};const _bdb =0x9b25;func (_bad *Encoder )codeMPS (_aegf *codingContext ,_fbf uint32 ,_adf uint16 ,_ddb byte ){_bad ._cb -=_adf ;if _bad ._cb &0x8000!=0{_bad ._gb +=uint32 (_adf );return ;};if _bad ._cb < _adf {_bad ._cb =_adf ;}else {_bad ._gb +=uint32 (_adf );};_aegf ._ae [_fbf ]=_gbc [_ddb ]._ddaf ;_bad .renormalize ();};func (_gfc *Encoder )Flush (){_gfc ._aff =0;_gfc ._fe =nil ;_gfc ._ag =-1};func (_gd *Encoder )EncodeIAID (symbolCodeLength ,value int )(_dfg error ){_bag .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _dfg =_gd .encodeIAID (symbolCodeLength ,value );_dfg !=nil {return _f .Wrap (_dfg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fc *Encoder )EncodeBitmap (bm *_bb .Bitmap ,duplicateLineRemoval bool )error {_bag .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_fb ,_fd uint8 ;_bgc ,_fdf ,_edc uint16 ;_efg ,_fcg ,_ee byte ;_da ,_dc ,_be int ;_bgd ,_fa []byte ;);for _eg :=0;_eg < bm .Height ;_eg ++{_efg ,_fcg =0,0;if _eg >=2{_efg =bm .Data [(_eg -2)*bm .RowStride ];};if _eg >=1{_fcg =bm .Data [(_eg -1)*bm .RowStride ];if duplicateLineRemoval {_dc =_eg *bm .RowStride ;_bgd =bm .Data [_dc :_dc +bm .RowStride ];_be =(_eg -1)*bm .RowStride ;_fa =bm .Data [_be :_be +bm .RowStride ];if _a .Equal (_bgd ,_fa ){_fd =_fb ^1;_fb =1;}else {_fd =_fb ;_fb =0;};};};if duplicateLineRemoval {if _ac :=_fc .encodeBit (_fc ._dd ,_bdb ,_fd );_ac !=nil {return _ac ;};if _fb !=0{continue ;};};_ee =bm .Data [_eg *bm .RowStride ];_bgc =uint16 (_efg >>5);_fdf =uint16 (_fcg >>4);_efg <<=3;_fcg <<=4;_edc =0;for _da =0;_da < bm .Width ;_da ++{_gbd :=uint32 (_bgc <<11|_fdf <<4|_edc );_ca :=(_ee &0x80)>>7;_fdc :=_fc .encodeBit (_fc ._dd ,_gbd ,_ca );if _fdc !=nil {return _fdc ;};_bgc <<=1;_fdf <<=1;_edc <<=1;_bgc |=uint16 ((_efg &0x80)>>7);_fdf |=uint16 ((_fcg &0x80)>>7);_edc |=uint16 (_ca );_ged :=_da %8;_gg :=_da /8+1;if _ged ==4&&_eg >=2{_efg =0;if _gg < bm .RowStride {_efg =bm .Data [(_eg -2)*bm .RowStride +_gg ];};}else {_efg <<=1;};if _ged ==3&&_eg >=1{_fcg =0;if _gg < bm .RowStride {_fcg =bm .Data [(_eg -1)*bm .RowStride +_gg ];};}else {_fcg <<=1;};if _ged ==7{_ee =0;if _gg < bm .RowStride {_ee =bm .Data [_eg *bm .RowStride +_gg ];};}else {_ee <<=1;};_bgc &=31;_fdf &=127;_edc &=15;};};return nil ;};func (_ace *Encoder )setBits (){_gdfd :=_ace ._gb +uint32 (_ace ._cb );_ace ._gb |=0xffff;if _ace ._gb >=_gdfd {_ace ._gb -=0x8000;};};var _ _ba .WriterTo =&Encoder {};func (_ffg *Encoder )encodeOOB (_ggb Class )error {_ffa :=_ffg ._cfd [_ggb ];_cfff :=_ffg .encodeBit (_ffa ,1,1);if _cfff !=nil {return _cfff ;};_cfff =_ffg .encodeBit (_ffa ,3,0);if _cfff !=nil {return _cfff ;};_cfff =_ffg .encodeBit (_ffa ,6,0);if _cfff !=nil {return _cfff ;};_cfff =_ffg .encodeBit (_ffa ,12,0);if _cfff !=nil {return _cfff ;};return nil ;};func (_eda *Encoder )lBlock (){if _eda ._ag >=0{_eda .emit ();};_eda ._ag ++;_eda ._ed =uint8 (_eda ._gb >>19);_eda ._gb &=0x7ffff;_eda ._ge =8;};type state struct{_bf uint16 ;_ddaf ,_eca uint8 ;_cab uint8 ;};func (_aeae *Encoder )encodeBit (_eb *codingContext ,_abe uint32 ,_ead uint8 )error {const _dda ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_aeae ._cf ++;if _abe >=uint32 (len (_eb ._ae )){return _f .Errorf (_dda ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_abe );};_gda :=_eb ._ae [_abe ];_eeb :=_eb .mps (_abe );_gfb :=_gbc [_gda ]._bf ;_bag .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_aeae ._cf ,_ead ,_gda ,_eeb ,_gfb ,_aeae ._cb ,_aeae ._gb ,_aeae ._ge ,_aeae ._ed ,_aeae ._ag );if _ead ==0{_aeae .code0 (_eb ,_abe ,_gfb ,_gda );}else {_aeae .code1 (_eb ,_abe ,_gfb ,_gda );};return nil ;};func (_dagb *Encoder )encodeInteger (_ffe Class ,_fga int )error {const _ecf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _fga > 2000000000||_fga < -2000000000{return _f .Errorf (_ecf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_fga );};_afa :=_dagb ._cfd [_ffe ];_ebc :=uint32 (1);var _db int ;for ;;_db ++{if _gf [_db ]._d <=_fga &&_gf [_db ]._bbd >=_fga {break ;};};if _fga < 0{_fga =-_fga ;};_fga -=int (_gf [_db ]._af );_dgb :=_gf [_db ]._c ;for _faa :=uint8 (0);_faa < _gf [_db ]._bd ;_faa ++{_abfa :=_dgb &1;if _gca :=_dagb .encodeBit (_afa ,_ebc ,_abfa );_gca !=nil {return _f .Wrap (_gca ,_ecf ,"");};_dgb >>=1;if _ebc &0x100> 0{_ebc =(((_ebc <<1)|uint32 (_abfa ))&0x1ff)|0x100;}else {_ebc =(_ebc <<1)|uint32 (_abfa );};};_fga <<=32-_gf [_db ]._bc ;for _acd :=uint8 (0);_acd < _gf [_db ]._bc ;_acd ++{_gef :=uint8 ((uint32 (_fga )&0x80000000)>>31);if _ebcc :=_dagb .encodeBit (_afa ,_ebc ,_gef );_ebcc !=nil {return _f .Wrap (_ebcc ,_ecf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_fga <<=1;if _ebc &0x100!=0{_ebc =(((_ebc <<1)|uint32 (_gef ))&0x1ff)|0x100;}else {_ebc =(_ebc <<1)|uint32 (_gef );};};return nil ;};func (_cbc *Encoder )byteOut (){if _cbc ._ed ==0xff{_cbc .rBlock ();return ;};if _cbc ._gb < 0x8000000{_cbc .lBlock ();return ;};_cbc ._ed ++;if _cbc ._ed !=0xff{_cbc .lBlock ();return ;};_cbc ._gb &=0x7ffffff;_cbc .rBlock ();};const (_eba =65536;_aec =20*1024;);type Encoder struct{_gb uint32 ;_cb uint16 ;_ge ,_ed uint8 ;_ag int ;_cf int ;_fe [][]byte ;_ccc []byte ;_aff int ;_dd *codingContext ;_cfd [13]*codingContext ;_bg *codingContext ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type codingContext struct{_ae []byte ;_e []byte ;};func _ec (_df int )*codingContext {return &codingContext {_ae :make ([]byte ,_df ),_e :make ([]byte ,_df )};};func (_cfg *Encoder )Init (){_cfg ._dd =_ec (_eba );_cfg ._cb =0x8000;_cfg ._gb =0;_cfg ._ge =12;_cfg ._ag =-1;_cfg ._ed =0;_cfg ._aff =0;_cfg ._ccc =make ([]byte ,_aec );for _aag :=0;_aag < len (_cfg ._cfd );_aag ++{_cfg ._cfd [_aag ]=_ec (512);};_cfg ._bg =nil ;};func (_aa *codingContext )mps (_aac uint32 )int {return int (_aa ._e [_aac ])};func (_cfa *Encoder )dataSize ()int {return _aec *len (_cfa ._fe )+_cfa ._aff };func (_bgf *Encoder )flush (){_bgf .setBits ();_bgf ._gb <<=_bgf ._ge ;_bgf .byteOut ();_bgf ._gb <<=_bgf ._ge ;_bgf .byteOut ();_bgf .emit ();if _bgf ._ed !=0xff{_bgf ._ag ++;_bgf ._ed =0xff;_bgf .emit ();};_bgf ._ag ++;_bgf ._ed =0xac;_bgf ._ag ++;_bgf .emit ();};func (_dcb *Encoder )rBlock (){if _dcb ._ag >=0{_dcb .emit ();};_dcb ._ag ++;_dcb ._ed =uint8 (_dcb ._gb >>20);_dcb ._gb &=0xfffff;_dcb ._ge =7;};