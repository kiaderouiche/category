//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_g "github.com/unidoc/unipdf/v3/internal/bitwise";_c "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);func (_ga *Writer )WriteSamples (samples []uint32 )error {for _cff :=0;_cff < len (samples );_cff ++{if _ecd :=_ga .WriteSample (samples [_cff ]);_ecd !=nil {return _ecd ;};};return nil ;};func (_cc *Reader )ReadSamples (samples []uint32 )(_ccc error ){for _ca :=0;_ca < len (samples );_ca ++{samples [_ca ],_ccc =_cc .ReadSample ();if _ccc !=nil {return _ccc ;};};return nil ;};func (_gf *Reader )ReadSample ()(uint32 ,error ){if _gf ._be ==_gf ._b .Height {return 0,_e .EOF ;};_bg ,_d :=_gf ._a .ReadBits (byte (_gf ._b .BitsPerComponent ));if _d !=nil {return 0,_d ;};_gf ._cf --;if _gf ._cf ==0{_gf ._cf =_gf ._b .ColorComponents ;_gf ._cg ++;};if _gf ._cg ==_gf ._b .Width {if _gf ._ce {_gf ._a .ConsumeRemainingBits ();};_gf ._cg =0;_gf ._be ++;};return uint32 (_bg ),nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _bf []uint32 ;_da :=bitsPerSample ;var _ccb uint32 ;var _ef byte ;_fb :=0;_ge :=0;_aa :=0;for _aa < len (data ){if _fb > 0{_ec :=_fb ;if _da < _ec {_ec =_da ;};_ccb =(_ccb <<uint (_ec ))|uint32 (_ef >>uint (8-_ec ));_fb -=_ec ;if _fb > 0{_ef =_ef <<uint (_ec );}else {_ef =0;};_da -=_ec ;if _da ==0{_bf =append (_bf ,_ccb );_da =bitsPerSample ;_ccb =0;_ge ++;};}else {_gg :=data [_aa ];_aa ++;_ab :=8;if _da < _ab {_ab =_da ;};_fb =8-_ab ;_ccb =(_ccb <<uint (_ab ))|uint32 (_gg >>uint (_fb ));if _ab < 8{_ef =_gg <<uint (_ab );};_da -=_ab ;if _da ==0{_bf =append (_bf ,_ccb );_da =bitsPerSample ;_ccb =0;_ge ++;};};};for _fb >=bitsPerSample {_ecf :=_fb ;if _da < _ecf {_ecf =_da ;};_ccb =(_ccb <<uint (_ecf ))|uint32 (_ef >>uint (8-_ecf ));_fb -=_ecf ;if _fb > 0{_ef =_ef <<uint (_ecf );}else {_ef =0;};_da -=_ecf ;if _da ==0{_bf =append (_bf ,_ccb );_da =bitsPerSample ;_ccb =0;_ge ++;};};return _bf ;};func NewReader (img _c .ImageBase )*Reader {return &Reader {_a :_g .NewReader (img .Data ),_b :img ,_cf :img .ColorComponents ,_ce :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type Writer struct{_ea _c .ImageBase ;_gb *_g .Writer ;_dee ,_aae int ;_fbc bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bc []uint32 ;_gee :=bitsPerOutputSample ;var _dd uint32 ;var _geed uint32 ;_gd :=0;_de :=0;_fc :=0;for _fc < len (data ){if _gd > 0{_ee :=_gd ;if _gee < _ee {_ee =_gee ;};_dd =(_dd <<uint (_ee ))|(_geed >>uint (bitsPerInputSample -_ee ));_gd -=_ee ;if _gd > 0{_geed =_geed <<uint (_ee );}else {_geed =0;};_gee -=_ee ;if _gee ==0{_bc =append (_bc ,_dd );_gee =bitsPerOutputSample ;_dd =0;_de ++;};}else {_cb :=data [_fc ];_fc ++;_dag :=bitsPerInputSample ;if _gee < _dag {_dag =_gee ;};_gd =bitsPerInputSample -_dag ;_dd =(_dd <<uint (_dag ))|(_cb >>uint (_gd ));if _dag < bitsPerInputSample {_geed =_cb <<uint (_dag );};_gee -=_dag ;if _gee ==0{_bc =append (_bc ,_dd );_gee =bitsPerOutputSample ;_dd =0;_de ++;};};};for _gd >=bitsPerOutputSample {_fg :=_gd ;if _gee < _fg {_fg =_gee ;};_dd =(_dd <<uint (_fg ))|(_geed >>uint (bitsPerInputSample -_fg ));_gd -=_fg ;if _gd > 0{_geed =_geed <<uint (_fg );}else {_geed =0;};_gee -=_fg ;if _gee ==0{_bc =append (_bc ,_dd );_gee =bitsPerOutputSample ;_dd =0;_de ++;};};if _gee > 0&&_gee < bitsPerOutputSample {_dd <<=uint (_gee );_bc =append (_bc ,_dd );};return _bc ;};type SampleWriter interface{WriteSample (_bea uint32 )error ;WriteSamples (_af []uint32 )error ;};func (_db *Writer )WriteSample (sample uint32 )error {if _ ,_cef :=_db ._gb .WriteBits (uint64 (sample ),_db ._ea .BitsPerComponent );_cef !=nil {return _cef ;};_db ._aae --;if _db ._aae ==0{_db ._aae =_db ._ea .ColorComponents ;_db ._dee ++;};if _db ._dee ==_db ._ea .Width {if _db ._fbc {_db ._gb .FinishByte ();};_db ._dee =0;};return nil ;};type Reader struct{_b _c .ImageBase ;_a *_g .Reader ;_cg ,_be ,_cf int ;_ce bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_ed []uint32 )error ;};func NewWriter (img _c .ImageBase )*Writer {return &Writer {_gb :_g .NewWriterMSB (img .Data ),_ea :img ,_aae :img .ColorComponents ,_fbc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};