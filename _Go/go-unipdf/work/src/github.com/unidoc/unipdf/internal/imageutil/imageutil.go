//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_b "errors";_bc "fmt";_cb "github.com/unidoc/unipdf/v3/internal/bitwise";_ac "image";_c "image/color";_g "image/draw";_a "math";);type Gray4 struct{ImageBase };func _edgg (_fgdec uint8 )bool {if _fgdec ==0||_fgdec ==255{return true ;};return false ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_cdd :=y *bytesPerLine +x >>2;if _cdd >=len (data ){return _c .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ebd :=data [_cdd ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ebd =uint8 (uint32 (LinearInterpolate (float64 (_ebd ),0,3.0,decode [0],decode [1]))&3);};return _c .Gray {Y :_ebd *85},nil ;};func (_fegb *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_fegb .ImageBase .copy (),ModelThreshold :_fegb .ModelThreshold };};func (_dfcf *Gray4 )SetGray (x ,y int ,g _c .Gray ){if x >=_dfcf .Width ||y >=_dfcf .Height {return ;};g =_bgdga (g );_dfcf .setGray (x ,y ,g );};func (_gcc *NRGBA16 )Base ()*ImageBase {return &_gcc .ImageBase };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _a .Abs (xmax -xmin )< 0.000001{return ymin ;};_adcg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _adcg ;};func MonochromeModel (threshold uint8 )_c .Model {return monochromeModel (threshold )};func _cbcf (_gcf RGBA ,_eefe Gray ,_bdab _ac .Rectangle ){for _gedf :=0;_gedf < _bdab .Max .X ;_gedf ++{for _eeed :=0;_eeed < _bdab .Max .Y ;_eeed ++{_adda :=_gb (_gcf .RGBAAt (_gedf ,_eeed ));_eefe .SetGray (_gedf ,_eeed ,_adda );};};};func (_afc *Gray8 )ColorModel ()_c .Model {return _c .GrayModel };func (_dgdg *ImageBase )HasAlpha ()bool {if _dgdg .Alpha ==nil {return false ;};for _ddb :=range _dgdg .Alpha {if _dgdg .Alpha [_ddb ]!=0xff{return true ;};};return false ;};func _gbee (_dgdf _ac .Image )(Image ,error ){if _gcdc ,_aaf :=_dgdf .(*Gray4 );_aaf {return _gcdc .Copy (),nil ;};_bffe :=_dgdf .Bounds ();_cff ,_debg :=NewImage (_bffe .Max .X ,_bffe .Max .Y ,4,1,nil ,nil ,nil );if _debg !=nil {return nil ,_debg ;};_fac (_dgdf ,_cff ,_bffe );return _cff ,nil ;};func _bge (_cdf _c .RGBA )_c .NRGBA {switch _cdf .A {case 0xff:return _c .NRGBA {R :_cdf .R ,G :_cdf .G ,B :_cdf .B ,A :0xff};case 0x00:return _c .NRGBA {};default:_eee ,_bbfc ,_ca ,_efe :=_cdf .RGBA ();_eee =(_eee *0xffff)/_efe ;_bbfc =(_bbfc *0xffff)/_efe ;_ca =(_ca *0xffff)/_efe ;return _c .NRGBA {R :uint8 (_eee >>8),G :uint8 (_bbfc >>8),B :uint8 (_ca >>8),A :uint8 (_efe >>8)};};};func _eegc (_fbe CMYK ,_cadd NRGBA ,_gdga _ac .Rectangle ){for _gcfb :=0;_gcfb < _gdga .Max .X ;_gcfb ++{for _adeg :=0;_adeg < _gdga .Max .Y ;_adeg ++{_badf :=_fbe .CMYKAt (_gcfb ,_adeg );_cadd .SetNRGBA (_gcfb ,_adeg ,_fae (_badf ));};};};type monochromeModel uint8 ;type ColorConverter interface{Convert (_bbg _ac .Image )(Image ,error );};func _eeadf (_adgf RGBA ,_aef NRGBA ,_cdaa _ac .Rectangle ){for _agc :=0;_agc < _cdaa .Max .X ;_agc ++{for _ccd :=0;_ccd < _cdaa .Max .Y ;_ccd ++{_befc :=_adgf .RGBAAt (_agc ,_ccd );_aef .SetNRGBA (_agc ,_ccd ,_bge (_befc ));};};};func (_faf *Monochrome )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_faf .Width ,Y :_faf .Height }};};func ConverterFunc (converterFunc func (_bgg _ac .Image )(Image ,error ))ColorConverter {return colorConverter {_bfe :converterFunc };};func (_ebcg *NRGBA16 )setNRGBA (_dcea ,_eacb ,_debga int ,_ebg _c .NRGBA ){if _dcea *3%2==0{_ebcg .Data [_debga ]=(_ebg .R >>4)<<4|(_ebg .G >>4);_ebcg .Data [_debga +1]=(_ebg .B >>4)<<4|(_ebcg .Data [_debga +1]&0xf);}else {_ebcg .Data [_debga ]=(_ebcg .Data [_debga ]&0xf0)|(_ebg .R >>4);_ebcg .Data [_debga +1]=(_ebg .G >>4)<<4|(_ebg .B >>4);};if _ebcg .Alpha !=nil {_abgdc :=_eacb *BytesPerLine (_ebcg .Width ,4,1);if _abgdc < len (_ebcg .Alpha ){if _dcea %2==0{_ebcg .Alpha [_abgdc ]=(_ebg .A >>uint (4))<<uint (4)|(_ebcg .Alpha [_debga ]&0xf);}else {_ebcg .Alpha [_abgdc ]=(_ebcg .Alpha [_abgdc ]&0xf0)|(_ebg .A >>uint (4));};};};};func (_ebf *Monochrome )Histogram ()(_bccc [256]int ){for _ ,_fee :=range _ebf .Data {_bccc [0xff]+=int (_addf [_ebf .Data [_fee ]]);};return _bccc ;};var _ Gray =&Monochrome {};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func _aagd (_dgc CMYK ,_dbaa Gray ,_fdbc _ac .Rectangle ){for _gbdd :=0;_gbdd < _fdbc .Max .X ;_gbdd ++{for _bfg :=0;_bfg < _fdbc .Max .Y ;_bfg ++{_ccb :=_fef (_dgc .CMYKAt (_gbdd ,_bfg ));_dbaa .SetGray (_gbdd ,_bfg ,_ccb );};};};func (_ebbb *Gray2 )Validate ()error {if len (_ebbb .Data )!=_ebbb .Height *_ebbb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_acbf *ImageBase )GetAlpha ()[]byte {return _acbf .Alpha };func (_eac *Monochrome )GrayAt (x ,y int )_c .Gray {_efg ,_ :=ColorAtGray1BPC (x ,y ,_eac .BytesPerLine ,_eac .Data ,_eac .Decode );return _efg ;};func _cgc (_eaa _ac .Image )(Image ,error ){if _eeg ,_gfbc :=_eaa .(*Gray16 );_gfbc {return _eeg .Copy (),nil ;};_ecf :=_eaa .Bounds ();_egad ,_gebf :=NewImage (_ecf .Max .X ,_ecf .Max .Y ,16,1,nil ,nil ,nil );if _gebf !=nil {return nil ,_gebf ;};_fac (_eaa ,_egad ,_ecf );return _egad ,nil ;};var _ Gray =&Gray2 {};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_fgg :=y *bytesPerLine +x >>3;if _fgg >=len (data ){return _c .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_cbed :=data [_fgg ]>>uint (7-(x &7))&1;if len (decode )==2{_cbed =uint8 (LinearInterpolate (float64 (_cbed ),0.0,1.0,decode [0],decode [1]))&1;};return _c .Gray {Y :_cbed *255},nil ;};var _ Gray =&Gray4 {};func (_dcc *NRGBA16 )ColorModel ()_c .Model {return NRGBA16Model };type Gray8 struct{ImageBase };func (_cfga *Gray16 )GrayAt (x ,y int )_c .Gray {_dfda ,_ :=_cfga .ColorAt (x ,y );return _c .Gray {Y :uint8 (_dfda .(_c .Gray16 ).Y >>8)};};func _gdce (_bgdf _ac .Image )(Image ,error ){if _dgga ,_bfda :=_bgdf .(*NRGBA16 );_bfda {return _dgga .Copy (),nil ;};_aeee :=_bgdf .Bounds ();_cfc ,_bbff :=NewImage (_aeee .Max .X ,_aeee .Max .Y ,4,3,nil ,nil ,nil );if _bbff !=nil {return nil ,_bbff ;};_daff (_bgdf ,_cfc ,_aeee );return _cfc ,nil ;};func (_bcc *Monochrome )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray1BPC (x ,y ,_bcc .BytesPerLine ,_bcc .Data ,_bcc .Decode );};func (_bfa *Gray2 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_bfa .Width ,Y :_bfa .Height }};};func (_badg *Gray2 )GrayAt (x ,y int )_c .Gray {_eecc ,_ :=ColorAtGray2BPC (x ,y ,_badg .BytesPerLine ,_badg .Data ,_badg .Decode );return _eecc ;};func (_abe *Gray8 )GrayAt (x ,y int )_c .Gray {_febf ,_ :=ColorAtGray8BPC (x ,y ,_abe .BytesPerLine ,_abe .Data ,_abe .Decode );return _febf ;};func _baac (_eaag *_ac .Gray ,_bcfe uint8 )*_ac .Gray {_ffb :=_eaag .Bounds ();_gbbd :=_ac .NewGray (_ffb );for _ggdb :=0;_ggdb < _ffb .Dx ();_ggdb ++{for _gabe :=0;_gabe < _ffb .Dy ();_gabe ++{_dbbc :=_eaag .GrayAt (_ggdb ,_gabe );_gbbd .SetGray (_ggdb ,_gabe ,_c .Gray {Y :_dcgb (_dbbc .Y ,_bcfe )});};};return _gbbd ;};func (_gdcg *Gray8 )Validate ()error {if len (_gdcg .Data )!=_gdcg .Height *_gdcg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func init (){_dbf ()};type CMYK32 struct{ImageBase };func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_ece :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _ece ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_aafa :=width *colorComponents *bitsPerComponent ;_dfeb :=_ece *8;_badc :=8-(_dfeb -_aafa );_cbcg :=_cb .NewReader (data );_bdac :=_ece -1;_eabd :=make ([]byte ,_bdac );_gdcb :=make ([]byte ,height *_ece );_ebc :=_cb .NewWriterMSB (_gdcb );var _bade uint64 ;var _bdb error ;for _bfba :=0;_bfba < height ;_bfba ++{_ ,_bdb =_cbcg .Read (_eabd );if _bdb !=nil {return nil ,_bdb ;};_ ,_bdb =_ebc .Write (_eabd );if _bdb !=nil {return nil ,_bdb ;};_bade ,_bdb =_cbcg .ReadBits (byte (_badc ));if _bdb !=nil {return nil ,_bdb ;};_ ,_bdb =_ebc .WriteBits (_bade ,_badc );if _bdb !=nil {return nil ,_bdb ;};_ebc .FinishByte ();};return _gdcb ,nil ;};func _cef (_efa _c .Gray )_c .NRGBA {return _c .NRGBA {R :_efa .Y ,G :_efa .Y ,B :_efa .Y ,A :0xff}};func (_dcaa *NRGBA16 )At (x ,y int )_c .Color {_daec ,_ :=_dcaa .ColorAt (x ,y );return _daec };func (_eega *NRGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };var ErrInvalidImage =_b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func _daff (_ede _ac .Image ,_gca Image ,_deaf _ac .Rectangle ){if _bgad ,_gcbg :=_ede .(SMasker );_gcbg &&_bgad .HasAlpha (){_gca .(SMasker ).MakeAlpha ();};switch _egb :=_ede .(type ){case Gray :_bgb (_egb ,_gca .(NRGBA ),_deaf );case NRGBA :_eed (_egb ,_gca .(NRGBA ),_deaf );case *_ac .NYCbCrA :_badd (_egb ,_gca .(NRGBA ),_deaf );case CMYK :_eegc (_egb ,_gca .(NRGBA ),_deaf );case RGBA :_eeadf (_egb ,_gca .(NRGBA ),_deaf );case nrgba64 :_fgdd (_egb ,_gca .(NRGBA ),_deaf );default:_gcb (_ede ,_gca ,_deaf );};};func (_ddg *Monochrome )setBit (_fbf ,_bca int ){_ddg .Data [_fbf ]|=0x80>>uint (_bca &7)};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_bc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};type nrgba64 interface{NRGBA64At (_dabd ,_dggf int )_c .NRGBA64 ;SetNRGBA64 (_bdfc ,_dcec int ,_abf _c .NRGBA64 );};func (_eccb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_eccb .copy ()}};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_bc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_acb *Monochrome )setGray (_efb int ,_gba _c .Gray ,_dca int ){if _gba .Y ==0{_acb .clearBit (_dca ,_efb );}else {_acb .setBit (_dca ,_efb );};};func (_dfd *Monochrome )Validate ()error {if len (_dfd .Data )!=_dfd .Height *_dfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};type NRGBA32 struct{ImageBase };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_cgf *Monochrome )clearBit (_ddf ,_bcad int ){_cgf .Data [_ddf ]&=^(0x80>>uint (_bcad &7))};func (_ebb *Gray2 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray2BPC (x ,y ,_ebb .BytesPerLine ,_ebb .Data ,_ebb .Decode );};func _cga (_acf _c .RGBA )_c .CMYK {_bbebb ,_aad ,_dce ,_gbg :=_c .RGBToCMYK (_acf .R ,_acf .G ,_acf .B );return _c .CMYK {C :_bbebb ,M :_aad ,Y :_dce ,K :_gbg };};func _fff (_efd _c .Color )_c .Color {_fcg :=_c .GrayModel .Convert (_efd ).(_c .Gray );return _ecg (_fcg )};func (_acd *Gray16 )SetGray (x ,y int ,g _c .Gray ){_bacf :=(y *_acd .BytesPerLine /2+x )*2;if _bacf +1>=len (_acd .Data ){return ;};_acd .Data [_bacf ]=g .Y ;_acd .Data [_bacf +1]=g .Y ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_bc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func _cgcg (_cce _ac .Image ,_baa int )(_ac .Rectangle ,bool ,[]byte ){_dbcd :=_cce .Bounds ();var (_gdfc bool ;_dac []byte ;);switch _gbga :=_cce .(type ){case SMasker :_gdfc =_gbga .HasAlpha ();case NRGBA ,RGBA ,*_ac .RGBA64 ,nrgba64 ,*_ac .NYCbCrA :_dac =make ([]byte ,_dbcd .Max .X *_dbcd .Max .Y *_baa );case *_ac .Paletted :var _deag bool ;for _ ,_efgg :=range _gbga .Palette {_aggd ,_eddd ,_ddbf ,_bdgb :=_efgg .RGBA ();if _aggd ==0&&_eddd ==0&&_ddbf ==0&&_bdgb !=0{_deag =true ;break ;};};if _deag {_dac =make ([]byte ,_dbcd .Max .X *_dbcd .Max .Y *_baa );};};return _dbcd ,_gdfc ,_dac ;};func (_cfg *Gray4 )Validate ()error {if len (_cfg .Data )!=_cfg .Height *_cfg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cd *CMYK32 )At (x ,y int )_c .Color {_ab ,_ :=_cd .ColorAt (x ,y );return _ab };func _ddc (_fbac []byte ,_gcfg Image )error {_cbag :=true ;for _bbfce :=0;_bbfce < len (_fbac );_bbfce ++{if _fbac [_bbfce ]!=0xff{_cbag =false ;break ;};};if _cbag {switch _dcdd :=_gcfg .(type ){case *NRGBA32 :_dcdd .Alpha =nil ;case *NRGBA64 :_dcdd .Alpha =nil ;default:return _bc .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_gcfg );};};return nil ;};type Gray16 struct{ImageBase };func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA64 ,error ){_aegf :=(y *width +x )*2;_ggf :=_aegf *3;if _ggf +5>=len (data ){return _c .NRGBA64 {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _cfgad =0xffff;_daafd :=uint16 (_cfgad );if alpha !=nil &&len (alpha )> _aegf +1{_daafd =uint16 (alpha [_aegf ])<<8|uint16 (alpha [_aegf +1]);};_ggbg :=uint16 (data [_ggf ])<<8|uint16 (data [_ggf +1]);_gff :=uint16 (data [_ggf +2])<<8|uint16 (data [_ggf +3]);_faagbc :=uint16 (data [_ggf +4])<<8|uint16 (data [_ggf +5]);if len (decode )==6{_ggbg =uint16 (uint64 (LinearInterpolate (float64 (_ggbg ),0,65535,decode [0],decode [1]))&_cfgad );_gff =uint16 (uint64 (LinearInterpolate (float64 (_gff ),0,65535,decode [2],decode [3]))&_cfgad );_faagbc =uint16 (uint64 (LinearInterpolate (float64 (_faagbc ),0,65535,decode [4],decode [5]))&_cfgad );};return _c .NRGBA64 {R :_ggbg ,G :_gff ,B :_faagbc ,A :_daafd },nil ;};func _ccba (_aece _ac .Image ,_eaed Image ,_gfcbb _ac .Rectangle ){if _bdd ,_bee :=_aece .(SMasker );_bee &&_bdd .HasAlpha (){_eaed .(SMasker ).MakeAlpha ();};_gcb (_aece ,_eaed ,_gfcbb );};func (_bdag *Gray4 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray4BPC (x ,y ,_bdag .BytesPerLine ,_bdag .Data ,_bdag .Decode );};func _bgce (_gegc _ac .Image )(Image ,error ){if _cbce ,_gaa :=_gegc .(*NRGBA64 );_gaa {return _cbce .Copy (),nil ;};_acdd ,_agd ,_bag :=_cgcg (_gegc ,2);_ggdc ,_gebfg :=NewImage (_acdd .Max .X ,_acdd .Max .Y ,16,3,nil ,_bag ,nil );if _gebfg !=nil {return nil ,_gebfg ;};_ccba (_gegc ,_ggdc ,_acdd );if len (_bag )!=0&&!_agd {if _cdec :=_ddc (_bag ,_ggdc );_cdec !=nil {return nil ,_cdec ;};};return _ggdc ,nil ;};func _feg (_efff _c .Gray )_c .CMYK {return _c .CMYK {K :0xff-_efff .Y }};var _ _ac .Image =&Gray16 {};func _beb (_cbdg NRGBA ,_gbd Gray ,_bfeg _ac .Rectangle ){for _dcfa :=0;_dcfa < _bfeg .Max .X ;_dcfa ++{for _geca :=0;_geca < _bfeg .Max .Y ;_geca ++{_egf :=_gf (_cbdg .NRGBAAt (_dcfa ,_geca ));_gbd .SetGray (_dcfa ,_geca ,_egf );};};};func (_cbf *Gray4 )GrayAt (x ,y int )_c .Gray {_ae ,_ :=ColorAtGray4BPC (x ,y ,_cbf .BytesPerLine ,_cbf .Data ,_cbf .Decode );return _ae ;};func (_ec *CMYK32 )Set (x ,y int ,c _c .Color ){_bac :=4*(y *_ec .Width +x );if _bac +3>=len (_ec .Data ){return ;};_bba :=_c .CMYKModel .Convert (c ).(_c .CMYK );_ec .Data [_bac ]=_bba .C ;_ec .Data [_bac +1]=_bba .M ;_ec .Data [_bac +2]=_bba .Y ;_ec .Data [_bac +3]=_bba .K ;};func (_feef *NRGBA16 )SetNRGBA (x ,y int ,c _c .NRGBA ){_acbde :=y *_feef .BytesPerLine +x *3/2;if _acbde +1>=len (_feef .Data ){return ;};c =_edd (c );_feef .setNRGBA (x ,y ,_acbde ,c );};func (_daaf *NRGBA32 )setRGBA (_gdd int ,_cca _c .NRGBA ){_bcf :=3*_gdd ;_daaf .Data [_bcf ]=_cca .R ;_daaf .Data [_bcf +1]=_cca .G ;_daaf .Data [_bcf +2]=_cca .B ;if _gdd < len (_daaf .Alpha ){_daaf .Alpha [_gdd ]=_cca .A ;};};func (_eea *Gray16 )Histogram ()(_ggc [256]int ){for _gefc :=0;_gefc < _eea .Width ;_gefc ++{for _dgfa :=0;_dgfa < _eea .Height ;_dgfa ++{_ggc [_eea .GrayAt (_gefc ,_dgfa ).Y ]++;};};return _ggc ;};var _ Image =&NRGBA16 {};func (_edg *Gray16 )Set (x ,y int ,c _c .Color ){_abgdd :=(y *_edg .BytesPerLine /2+x )*2;if _abgdd +1>=len (_edg .Data ){return ;};_dgbg :=_c .Gray16Model .Convert (c ).(_c .Gray16 );_edg .Data [_abgdd ],_edg .Data [_abgdd +1]=uint8 (_dgbg .Y >>8),uint8 (_dgbg .Y &0xff);};func (_bec *Gray4 )ColorModel ()_c .Model {return Gray4Model };func (_gdf *CMYK32 )Validate ()error {if len (_gdf .Data )!=4*_gdf .Width *_gdf .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_ggbcb *NRGBA64 )Validate ()error {if len (_ggbcb .Data )!=3*2*_ggbcb .Width *_ggbcb .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};var _ Image =&Gray2 {};type Histogramer interface{Histogram ()[256]int ;};func _fae (_gfd _c .CMYK )_c .NRGBA {_dfc ,_fgd ,_age :=_c .CMYKToRGB (_gfd .C ,_gfd .M ,_gfd .Y ,_gfd .K );return _c .NRGBA {R :_dfc ,G :_fgd ,B :_age ,A :0xff};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_aee *ImageBase )MakeAlpha (){_aee .newAlpha ()};func _edd (_ebdd _c .NRGBA )_c .NRGBA {_ebdd .R =_ebdd .R >>4|(_ebdd .R >>4)<<4;_ebdd .G =_ebdd .G >>4|(_ebdd .G >>4)<<4;_ebdd .B =_ebdd .B >>4|(_ebdd .B >>4)<<4;return _ebdd ;};func (_debaf *Gray16 )ColorModel ()_c .Model {return _c .Gray16Model };func ImgToBinary (i _ac .Image ,threshold uint8 )*_ac .Gray {switch _abec :=i .(type ){case *_ac .Gray :if _fgb (_abec ){return _abec ;};return _baac (_abec ,threshold );case *_ac .Gray16 :return _gfcg (_abec ,threshold );default:return _ebba (_abec ,threshold );};};var _ Image =&Gray4 {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_eaff :=y *bytesPerLine +x >>1;if _eaff >=len (data ){return _c .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_cgb :=data [_eaff ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_cgb =uint8 (uint32 (LinearInterpolate (float64 (_cgb ),0,15,decode [0],decode [1]))&0xf);};return _c .Gray {Y :_cgb *17&0xff},nil ;};func (_ecbd *NRGBA32 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_ecbd .Width ,Y :_ecbd .Height }};};var _ _ac .Image =&Monochrome {};var _ NRGBA =&NRGBA16 {};func (_fba *Gray2 )ColorModel ()_c .Model {return Gray2Model };func (_cfge *Gray16 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_cfge .Width ,Y :_cfge .Height }};};func (_bgef *Gray2 )Histogram ()(_faagb [256]int ){for _acbd :=0;_acbd < _bgef .Width ;_acbd ++{for _badb :=0;_badb < _bgef .Height ;_badb ++{_faagb [_bgef .GrayAt (_acbd ,_badb ).Y ]++;};};return _faagb ;};func (_af *CMYK32 )CMYKAt (x ,y int )_c .CMYK {_abg ,_ :=ColorAtCMYK (x ,y ,_af .Width ,_af .Data ,_af .Decode );return _abg ;};func (_fgde *Gray4 )Base ()*ImageBase {return &_fgde .ImageBase };func (_bbfcf *NRGBA64 )NRGBA64At (x ,y int )_c .NRGBA64 {_debf ,_ :=ColorAtNRGBA64 (x ,y ,_bbfcf .Width ,_bbfcf .Data ,_bbfcf .Alpha ,_bbfcf .Decode );return _debf ;};func (_de *CMYK32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtCMYK (x ,y ,_de .Width ,_de .Data ,_de .Decode );};func (_fffd *Gray8 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray8BPC (x ,y ,_fffd .BytesPerLine ,_fffd .Data ,_fffd .Decode );};func _dgbc (_dfe ,_fadd Gray ,_edcf _ac .Rectangle ){for _ggee :=0;_ggee < _edcf .Max .X ;_ggee ++{for _fccf :=0;_fccf < _edcf .Max .Y ;_fccf ++{_fadd .SetGray (_ggee ,_fccf ,_dfe .GrayAt (_ggee ,_fccf ));};};};func (_ecc monochromeModel )Convert (c _c .Color )_c .Color {_eccf :=_c .GrayModel .Convert (c ).(_c .Gray );return _bgge (_eccf ,_ecc );};func (_dabb *Monochrome )Base ()*ImageBase {return &_dabb .ImageBase };func (_eaeg *NRGBA64 )Base ()*ImageBase {return &_eaeg .ImageBase };func (_dba *Monochrome )Set (x ,y int ,c _c .Color ){_ade :=y *_dba .BytesPerLine +x >>3;if _ade > len (_dba .Data )-1{return ;};_bfb :=_dba .ColorModel ().Convert (c ).(_c .Gray );_dba .setGray (x ,_bfb ,_ade );};func _gcb (_geb _ac .Image ,_bbf Image ,_cba _ac .Rectangle ){for _bed :=0;_bed < _cba .Max .X ;_bed ++{for _ff :=0;_ff < _cba .Max .Y ;_ff ++{_bbeb :=_geb .At (_bed ,_ff );_bbf .Set (_bed ,_ff ,_bbeb );};};};func _egc (_ee NRGBA ,_ggb CMYK ,_cee _ac .Rectangle ){for _da :=0;_da < _cee .Max .X ;_da ++{for _gad :=0;_gad < _cee .Max .Y ;_gad ++{_be :=_ee .NRGBAAt (_da ,_gad );_ggb .SetCMYK (_da ,_gad ,_eb (_be ));};};};func (_cgd *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cgd .copy ()}};var _ _ac .Image =&NRGBA32 {};func (_eecg *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_eecg .copy ()}};func _ebba (_gfaa _ac .Image ,_aaba uint8 )*_ac .Gray {_ffba :=_gfaa .Bounds ();_fge :=_ac .NewGray (_ffba );var (_adag _c .Color ;_bcee _c .Gray ;);for _daecg :=0;_daecg < _ffba .Max .X ;_daecg ++{for _ggde :=0;_ggde < _ffba .Max .Y ;_ggde ++{_adag =_gfaa .At (_daecg ,_ggde );_fge .Set (_daecg ,_ggde ,_adag );_bcee =_fge .GrayAt (_daecg ,_ggde );_fge .SetGray (_daecg ,_ggde ,_c .Gray {Y :_dcgb (_bcee .Y ,_aaba )});};};return _fge ;};func _cbe (_ad _ac .Image )(Image ,error ){if _begg ,_fca :=_ad .(*Monochrome );_fca {return _begg ,nil ;};_caa ,_cf :=_ad .(Gray );if !_cf {_gfc ,_gfe :=GrayConverter .Convert (_ad );if _gfe !=nil {return nil ,_gfe ;};_caa =_gfc .(Gray );};_eab :=_ad .Bounds ();_bdeb ,_ged :=NewImage (_eab .Max .X ,_eab .Max .Y ,1,1,nil ,nil ,nil );if _ged !=nil {return nil ,_ged ;};_daa :=_bdeb .(*Monochrome );_cea :=AutoThresholdTriangle (GrayHistogram (_caa ));for _bbc :=0;_bbc < _eab .Max .X ;_bbc ++{for _afa :=0;_afa < _eab .Max .Y ;_afa ++{_ddd :=_bgge (_caa .GrayAt (_bbc ,_afa ),monochromeModel (_cea ));_daa .SetGray (_bbc ,_afa ,_ddd );};};return _bdeb ,nil ;};func (_gdc *monochromeThresholdConverter )Convert (img _ac .Image )(Image ,error ){if _fbd ,_dfff :=img .(*Monochrome );_dfff {return _fbd .Copy (),nil ;};_gbe :=img .Bounds ();_faa ,_gcd :=NewImage (_gbe .Max .X ,_gbe .Max .Y ,1,1,nil ,nil ,nil );if _gcd !=nil {return nil ,_gcd ;};_faa .(*Monochrome ).ModelThreshold =_gdc .Threshold ;for _edf :=0;_edf < _gbe .Max .X ;_edf ++{for _dgf :=0;_dgf < _gbe .Max .Y ;_dgf ++{_edc :=img .At (_edf ,_dgf );_faa .Set (_edf ,_dgf ,_edc );};};return _faa ,nil ;};func _eg (_baf ,_ef CMYK ,_gaf _ac .Rectangle ){for _ge :=0;_ge < _gaf .Max .X ;_ge ++{for _bbe :=0;_bbe < _gaf .Max .Y ;_bbe ++{_ef .SetCMYK (_ge ,_bbe ,_baf .CMYKAt (_ge ,_bbe ));};};};func (_afe *NRGBA64 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA64 (x ,y ,_afe .Width ,_afe .Data ,_afe .Alpha ,_afe .Decode );};func _badd (_fada *_ac .NYCbCrA ,_gac NRGBA ,_gafa _ac .Rectangle ){for _agaf :=0;_agaf < _gafa .Max .X ;_agaf ++{for _ddcb :=0;_ddcb < _gafa .Max .Y ;_ddcb ++{_bbgb :=_fada .NYCbCrAAt (_agaf ,_ddcb );_gac .SetNRGBA (_agaf ,_ddcb ,_aff (_bbgb ));};};};func (_gdcgg *Gray8 )Histogram ()(_fdb [256]int ){for _cfe :=0;_cfe < len (_gdcgg .Data );_cfe ++{_fdb [_gdcgg .Data [_cfe ]]++;};return _fdb ;};func _ecg (_bfad _c .Gray )_c .Gray {_abdg :=_bfad .Y >>6;_abdg |=_abdg <<2;_bfad .Y =_abdg |_abdg <<4;return _bfad ;};func (_bff *Monochrome )ColorModel ()_c .Model {return MonochromeModel (_bff .ModelThreshold )};func _fgdd (_ccae nrgba64 ,_dbbd NRGBA ,_cadf _ac .Rectangle ){for _defg :=0;_defg < _cadf .Max .X ;_defg ++{for _eafd :=0;_eafd < _cadf .Max .Y ;_eafd ++{_fabc :=_ccae .NRGBA64At (_defg ,_eafd );_dbbd .SetNRGBA (_defg ,_eafd ,_ceb (_fabc ));};};};func _ceb (_dgg _c .NRGBA64 )_c .NRGBA {return _c .NRGBA {R :uint8 (_dgg .R >>8),G :uint8 (_dgg .G >>8),B :uint8 (_dgg .B >>8),A :uint8 (_dgg .A >>8)};};func (_dcda *NRGBA64 )ColorModel ()_c .Model {return _c .NRGBA64Model };func _dfcg (_bef int ,_ead int )error {return _bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bef ,_ead );};func (_bdbg *NRGBA16 )Validate ()error {if len (_bdbg .Data )!=3*_bdbg .Width *_bdbg .Height /2{return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _eb (_gge _c .NRGBA )_c .CMYK {_dab ,_dcf ,_aa ,_ :=_gge .RGBA ();_bgd ,_abb ,_cde ,_dcg :=_c .RGBToCMYK (uint8 (_dab >>8),uint8 (_dcf >>8),uint8 (_aa >>8));return _c .CMYK {C :_bgd ,M :_abb ,Y :_cde ,K :_dcg };};func _fef (_cgg _c .CMYK )_c .Gray {_dfca ,_fd ,_dea :=_c .CMYKToRGB (_cgg .C ,_cgg .M ,_cgg .Y ,_cgg .K );_agb :=(19595*uint32 (_dfca )+38470*uint32 (_fd )+7471*uint32 (_dea )+1<<7)>>16;return _c .Gray {Y :uint8 (_agb )};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_gbad :=y *bytesPerLine +x ;if _gbad >=len (data ){return _c .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_gdfd :=data [_gbad ];if len (decode )==2{_gdfd =uint8 (uint32 (LinearInterpolate (float64 (_gdfd ),0,255,decode [0],decode [1]))&0xff);};return _c .Gray {Y :_gdfd },nil ;};func (_gafc *Gray2 )Set (x ,y int ,c _c .Color ){if x >=_gafc .Width ||y >=_gafc .Height {return ;};_aac :=Gray2Model .Convert (c ).(_c .Gray );_aag :=y *_gafc .BytesPerLine ;_aab :=_aag +(x >>2);_faag :=_aac .Y >>6;_gafc .Data [_aab ]=(_gafc .Data [_aab ]&(^(0xc0>>uint (2*((x )&3)))))|(_faag <<uint (6-2*(x &3)));};func (_efaa *Gray16 )Base ()*ImageBase {return &_efaa .ImageBase };func (_fabf *Gray8 )Base ()*ImageBase {return &_fabf .ImageBase };func (_abfg *NRGBA64 )Set (x ,y int ,c _c .Color ){_ffab :=(y *_abfg .Width +x )*2;_ebce :=_ffab *3;if _ebce +5>=len (_abfg .Data ){return ;};_beca :=_c .NRGBA64Model .Convert (c ).(_c .NRGBA64 );_abfg .setNRGBA64 (_ebce ,_beca ,_ffab );};type Image interface{_g .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_eaab ,_fcec int )(_c .Color ,error );Validate ()error ;};func _bgb (_dbad Gray ,_bafe NRGBA ,_gede _ac .Rectangle ){for _bbcb :=0;_bbcb < _gede .Max .X ;_bbcb ++{for _addfd :=0;_addfd < _gede .Max .Y ;_addfd ++{_fccg :=_dbad .GrayAt (_bbcb ,_addfd );_bafe .SetNRGBA (_bbcb ,_addfd ,_cef (_fccg ));};};};var _ Image =&Monochrome {};type NRGBA interface{NRGBAAt (_daac ,_fggb int )_c .NRGBA ;SetNRGBA (_cbb ,_gfcb int ,_dgfb _c .NRGBA );};func (_daee *Monochrome )At (x ,y int )_c .Color {_gbgd ,_ :=_daee .ColorAt (x ,y );return _gbgd };type Gray2 struct{ImageBase };func (_fegg *NRGBA64 )At (x ,y int )_c .Color {_fggc ,_ :=_fegg .ColorAt (x ,y );return _fggc };func (_decc *Gray8 )Set (x ,y int ,c _c .Color ){_bgc :=y *_decc .BytesPerLine +x ;if _bgc > len (_decc .Data )-1{return ;};_cda :=_c .GrayModel .Convert (c );_decc .Data [_bgc ]=_cda .(_c .Gray ).Y ;};func (_cbfa *ImageBase )copy ()ImageBase {_bcg :=*_cbfa ;_bcg .Data =make ([]byte ,len (_cbfa .Data ));copy (_bcg .Data ,_cbfa .Data );return _bcg ;};func (_bfea *Gray4 )At (x ,y int )_c .Color {_eda ,_ :=_bfea .ColorAt (x ,y );return _eda };func (_ccg *Gray4 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_ccg .Width ,Y :_ccg .Height }};};var _ Gray =&Gray8 {};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray16 ,error ){_bga :=(y *bytesPerLine /2+x )*2;if _bga +1>=len (data ){return _c .Gray16 {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bggf :=uint16 (data [_bga ])<<8|uint16 (data [_bga +1]);if len (decode )==2{_bggf =uint16 (uint64 (LinearInterpolate (float64 (_bggf ),0,65535,decode [0],decode [1])));};return _c .Gray16 {Y :_bggf },nil ;};type RGBA interface{RGBAAt (_ecb ,_eafbd int )_c .RGBA ;SetRGBA (_abgg ,_fcca int ,_dbe _c .RGBA );};var _addf [256]uint8 ;func ImgToGray (i _ac .Image )*_ac .Gray {if _ffgd ,_eaac :=i .(*_ac .Gray );_eaac {return _ffgd ;};_agbd :=i .Bounds ();_bgac :=_ac .NewGray (_agbd );for _eaee :=0;_eaee < _agbd .Max .X ;_eaee ++{for _gdcf :=0;_gdcf < _agbd .Max .Y ;_gdcf ++{_afdd :=i .At (_eaee ,_gdcf );_bgac .Set (_eaee ,_gdcf ,_afdd );};};return _bgac ;};func (_bdaf *Gray16 )Validate ()error {if len (_bdaf .Data )!=_bdaf .Height *_bdaf .BytesPerLine {return ErrInvalidImage ;};return nil ;};type Gray interface{GrayAt (_abda ,_fc int )_c .Gray ;SetGray (_fag ,_efag int ,_bfd _c .Gray );};var _ Image =&Gray8 {};func (_eecgb *NRGBA16 )Set (x ,y int ,c _c .Color ){_aaef :=y *_eecgb .BytesPerLine +x *3/2;if _aaef +1>=len (_eecgb .Data ){return ;};_bbcg :=NRGBA16Model .Convert (c ).(_c .NRGBA );_eecgb .setNRGBA (x ,y ,_aaef ,_bbcg );};func (_gdgb *Gray8 )SetGray (x ,y int ,g _c .Gray ){_eaec :=y *_gdgb .BytesPerLine +x ;if _eaec > len (_gdgb .Data )-1{return ;};_gdgb .Data [_eaec ]=g .Y ;};func _bede (_acbc _c .Color )_c .Color {_bdg :=_c .GrayModel .Convert (_acbc ).(_c .Gray );return _bgdga (_bdg );};func _gfcg (_ebga *_ac .Gray16 ,_bfce uint8 )*_ac .Gray {_agfb :=_ebga .Bounds ();_ddbe :=_ac .NewGray (_agfb );for _begd :=0;_begd < _agfb .Dx ();_begd ++{for _aea :=0;_aea < _agfb .Dy ();_aea ++{_facd :=_ebga .Gray16At (_begd ,_aea );_ddbe .SetGray (_begd ,_aea ,_c .Gray {Y :_dcgb (uint8 (_facd .Y /256),_bfce )});};};return _ddbe ;};func (_fbc *Gray2 )At (x ,y int )_c .Color {_bad ,_ :=_fbc .ColorAt (x ,y );return _bad };func (_aaff *NRGBA16 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_aaff .Width ,Y :_aaff .Height }};};func (_bead *Gray8 )At (x ,y int )_c .Color {_agae ,_ :=_bead .ColorAt (x ,y );return _agae };func _bgge (_cdg _c .Gray ,_cefg monochromeModel )_c .Gray {if _cdg .Y > uint8 (_cefg ){return _c .Gray {Y :_a .MaxUint8 };};return _c .Gray {};};func _aff (_ea _c .NYCbCrA )_c .NRGBA {_fdg :=int32 (_ea .Y )*0x10101;_dbb :=int32 (_ea .Cb )-128;_eaf :=int32 (_ea .Cr )-128;_feb :=_fdg +91881*_eaf ;if uint32 (_feb )&0xff000000==0{_feb >>=8;}else {_feb =^(_feb >>31)&0xffff;};_dg :=_fdg -22554*_dbb -46802*_eaf ;if uint32 (_dg )&0xff000000==0{_dg >>=8;}else {_dg =^(_dg >>31)&0xffff;};_bgdg :=_fdg +116130*_dbb ;if uint32 (_bgdg )&0xff000000==0{_bgdg >>=8;}else {_bgdg =^(_bgdg >>31)&0xffff;};return _c .NRGBA {R :uint8 (_feb >>8),G :uint8 (_dg >>8),B :uint8 (_bgdg >>8),A :_ea .A };};type colorConverter struct{_bfe func (_ggbc _ac .Image )(Image ,error );};func (_fggbc *NRGBA64 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_fggbc .Width ,Y :_fggbc .Height }};};var _ Gray =&Gray16 {};func (_fab *Monochrome )SetGray (x ,y int ,g _c .Gray ){_deb :=y *_fab .BytesPerLine +x >>3;if _deb > len (_fab .Data )-1{return ;};g =_bgge (g ,monochromeModel (_fab .ModelThreshold ));_fab .setGray (x ,g ,_deb );};var _ _ac .Image =&Gray2 {};var _ Image =&NRGBA32 {};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_afb :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _gafca Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_gafca =&Monochrome {ImageBase :_afb ,ModelThreshold :0x0f};case 2:_gafca =&Gray2 {ImageBase :_afb };case 4:_gafca =&Gray4 {ImageBase :_afb };case 8:_gafca =&Gray8 {ImageBase :_afb };case 16:_gafca =&Gray16 {ImageBase :_afb };};case 3:switch bitsPerComponent {case 4:_gafca =&NRGBA16 {ImageBase :_afb };case 8:_gafca =&NRGBA32 {ImageBase :_afb };case 16:_gafca =&NRGBA64 {ImageBase :_afb };};case 4:_gafca =&CMYK32 {ImageBase :_afb };};if _gafca ==nil {return nil ,ErrInvalidImage ;};return _gafca ,nil ;};func (_cag *Gray16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray16BPC (x ,y ,_cag .BytesPerLine ,_cag .Data ,_cag .Decode );};func (_dad *Gray16 )At (x ,y int )_c .Color {_fcc ,_ :=_dad .ColorAt (x ,y );return _fcc };var _ Image =&CMYK32 {};func _eed (_ecdb ,_aaaf NRGBA ,_gdge _ac .Rectangle ){for _ggbd :=0;_ggbd < _gdge .Max .X ;_ggbd ++{for _ffde :=0;_ffde < _gdge .Max .Y ;_ffde ++{_aaaf .SetNRGBA (_ggbd ,_ffde ,_ecdb .NRGBAAt (_ggbd ,_ffde ));};};};func _acc (_eagg _c .Color )_c .Color {_dbc :=_c .NRGBAModel .Convert (_eagg ).(_c .NRGBA );return _edd (_dbc );};func (_abd *CMYK32 )SetCMYK (x ,y int ,c _c .CMYK ){_ga :=4*(y *_abd .Width +x );if _ga +3>=len (_abd .Data ){return ;};_abd .Data [_ga ]=c .C ;_abd .Data [_ga +1]=c .M ;_abd .Data [_ga +2]=c .Y ;_abd .Data [_ga +3]=c .K ;};func (_gfa *Gray4 )Set (x ,y int ,c _c .Color ){if x >=_gfa .Width ||y >=_gfa .Height {return ;};_gfb :=Gray4Model .Convert (c ).(_c .Gray );_gfa .setGray (x ,y ,_gfb );};func (_aafe *NRGBA64 )SetNRGBA64 (x ,y int ,c _c .NRGBA64 ){_bfde :=(y *_aafe .Width +x )*2;_cceb :=_bfde *3;if _cceb +5>=len (_aafe .Data ){return ;};_aafe .setNRGBA64 (_cceb ,c ,_bfde );};var _ _ac .Image =&NRGBA64 {};func (_gdb *NRGBA16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA16 (x ,y ,_gdb .Width ,_gdb .BytesPerLine ,_gdb .Data ,_gdb .Alpha ,_gdb .Decode );};func AutoThresholdTriangle (histogram [256]int )uint8 {var _bbffb ,_egaa ,_cdfd ,_dddg int ;for _fcgd :=0;_fcgd < len (histogram );_fcgd ++{if histogram [_fcgd ]> 0{_bbffb =_fcgd ;break ;};};if _bbffb > 0{_bbffb --;};for _cbbb :=255;_cbbb > 0;_cbbb --{if histogram [_cbbb ]> 0{_dddg =_cbbb ;break ;};};if _dddg < 255{_dddg ++;};for _ccbd :=0;_ccbd < 256;_ccbd ++{if histogram [_ccbd ]> _egaa {_cdfd =_ccbd ;_egaa =histogram [_ccbd ];};};var _gdea bool ;if (_cdfd -_bbffb )< (_dddg -_cdfd ){_gdea =true ;var _ddcf int ;_egac :=255;for _ddcf < _egac {_dfgg :=histogram [_ddcf ];histogram [_ddcf ]=histogram [_egac ];histogram [_egac ]=_dfgg ;_ddcf ++;_egac --;};_bbffb =255-_dddg ;_cdfd =255-_cdfd ;};if _bbffb ==_cdfd {return uint8 (_bbffb );};_gbeg :=float64 (histogram [_cdfd ]);_efda :=float64 (_bbffb -_cdfd );_gfcf :=_a .Sqrt (_gbeg *_gbeg +_efda *_efda );_gbeg /=_gfcf ;_efda /=_gfcf ;_gfcf =_gbeg *float64 (_bbffb )+_efda *float64 (histogram [_bbffb ]);_dfbb :=_bbffb ;var _gccd float64 ;for _ggcd :=_bbffb +1;_ggcd <=_cdfd ;_ggcd ++{_fcab :=_gbeg *float64 (_ggcd )+_efda *float64 (histogram [_ggcd ])-_gfcf ;if _fcab > _gccd {_dfbb =_ggcd ;_gccd =_fcab ;};};_dfbb --;if _gdea {var _eacbf int ;_dgdge :=255;for _eacbf < _dgdge {_bdfa :=histogram [_eacbf ];histogram [_eacbf ]=histogram [_dgdge ];histogram [_dgdge ]=_bdfa ;_eacbf ++;_dgdge --;};return uint8 (255-_dfbb );};return uint8 (_dfbb );};var (Gray2Model =_c .ModelFunc (_fff );Gray4Model =_c .ModelFunc (_bede );NRGBA16Model =_c .ModelFunc (_acc ););func (_adga *NRGBA64 )setNRGBA64 (_abfc int ,_dbeb _c .NRGBA64 ,_ceff int ){_adga .Data [_abfc ]=uint8 (_dbeb .R >>8);_adga .Data [_abfc +1]=uint8 (_dbeb .R &0xff);_adga .Data [_abfc +2]=uint8 (_dbeb .G >>8);_adga .Data [_abfc +3]=uint8 (_dbeb .G &0xff);_adga .Data [_abfc +4]=uint8 (_dbeb .B >>8);_adga .Data [_abfc +5]=uint8 (_dbeb .B &0xff);if _ceff +1< len (_adga .Alpha ){_adga .Alpha [_ceff ]=uint8 (_dbeb .A >>8);_adga .Alpha [_ceff +1]=uint8 (_dbeb .A &0xff);};};func (_aaa *Gray4 )setGray (_edad int ,_ffd int ,_ggdd _c .Gray ){_ddgf :=_ffd *_aaa .BytesPerLine ;_edadf :=_ddgf +(_edad >>1);if _edadf >=len (_aaa .Data ){return ;};_dec :=_ggdd .Y >>4;_aaa .Data [_edadf ]=(_aaa .Data [_edadf ]&(^(0xf0>>uint (4*(_edad &1)))))|(_dec <<uint (4-4*(_edad &1)));};func IsGrayImgBlackAndWhite (i *_ac .Gray )bool {return _fgb (i )};func (_febb *NRGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA32 (x ,y ,_febb .Width ,_febb .Data ,_febb .Alpha ,_febb .Decode );};func _fac (_aeg _ac .Image ,_abgb Image ,_fce _ac .Rectangle ){switch _gag :=_aeg .(type ){case Gray :_dgbc (_gag ,_abgb .(Gray ),_fce );case NRGBA :_beb (_gag ,_abgb .(Gray ),_fce );case CMYK :_aagd (_gag ,_abgb .(Gray ),_fce );case RGBA :_cbcf (_gag ,_abgb .(Gray ),_fce );default:_gcb (_aeg ,_abgb .(Image ),_fce );};};func (_fegc *NRGBA16 )NRGBAAt (x ,y int )_c .NRGBA {_gce ,_ :=ColorAtNRGBA16 (x ,y ,_fegc .Width ,_fegc .BytesPerLine ,_fegc .Data ,_fegc .Alpha ,_fegc .Decode );return _gce ;};func (_aga *Gray2 )Base ()*ImageBase {return &_aga .ImageBase };func FromGoImage (i _ac .Image )(Image ,error ){switch _bgcd :=i .(type ){case Image :return _bgcd .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_ac .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_ac .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_geg *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_geg .copy ()}};func (_gdg *Gray2 )SetGray (x ,y int ,gray _c .Gray ){_egg :=_ecg (gray );_gcg :=y *_gdg .BytesPerLine ;_adc :=_gcg +(x >>2);if _adc >=len (_gdg .Data ){return ;};_cebe :=_egg .Y >>6;_gdg .Data [_adc ]=(_gdg .Data [_adc ]&(^(0xc0>>uint (2*((x )&3)))))|(_cebe <<uint (6-2*(x &3)));};type NRGBA16 struct{ImageBase };var _ _ac .Image =&Gray4 {};type NRGBA64 struct{ImageBase };func (_bb *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bb .copy ()}};func (_gga *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_gga .copy ()}};func _gf (_ega _c .NRGBA )_c .Gray {_gef ,_def ,_ced ,_ :=_ega .RGBA ();_fg :=(19595*_gef +38470*_def +7471*_ced +1<<15)>>24;return _c .Gray {Y :uint8 (_fg )};};func (_df *CMYK32 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_df .Width ,Y :_df .Height }};};func _cfa (_bfcc _ac .Image )(Image ,error ){if _aaae ,_dgb :=_bfcc .(*Gray8 );_dgb {return _aaae .Copy (),nil ;};_acbb :=_bfcc .Bounds ();_bab ,_becc :=NewImage (_acbb .Max .X ,_acbb .Max .Y ,8,1,nil ,nil ,nil );if _becc !=nil {return nil ,_becc ;};_fac (_bfcc ,_bab ,_acbb );return _bab ,nil ;};func _bcgb (_acdb _ac .Image )(Image ,error ){if _aec ,_dabc :=_acdb .(*NRGBA32 );_dabc {return _aec .Copy (),nil ;};_gefd ,_befa ,_eead :=_cgcg (_acdb ,1);_aacc ,_bdaa :=NewImage (_gefd .Max .X ,_gefd .Max .Y ,8,3,nil ,_eead ,nil );if _bdaa !=nil {return nil ,_bdaa ;};_daff (_acdb ,_aacc ,_gefd );if len (_eead )!=0&&!_befa {if _eegg :=_ddc (_eead ,_aacc );_eegg !=nil {return nil ,_eegg ;};};return _aacc ,nil ;};var _ Image =&NRGBA64 {};type CMYK interface{CMYKAt (_e ,_ba int )_c .CMYK ;SetCMYK (_gd ,_d int ,_fa _c .CMYK );};func _dgfc (_agg _ac .Image )(Image ,error ){if _fde ,_bbaf :=_agg .(*Gray2 );_bbaf {return _fde .Copy (),nil ;};_dfb :=_agg .Bounds ();_ggef ,_bfcb :=NewImage (_dfb .Max .X ,_dfb .Max .Y ,2,1,nil ,nil ,nil );if _bfcb !=nil {return nil ,_bfcb ;};_fac (_agg ,_ggef ,_dfb );return _ggef ,nil ;};var _ NRGBA =&NRGBA32 {};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gab :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_gab .Data =make ([]byte ,height *_gab .BytesPerLine );};return _gab ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};var (MonochromeConverter =ConverterFunc (_cbe );Gray2Converter =ConverterFunc (_dgfc );Gray4Converter =ConverterFunc (_gbee );GrayConverter =ConverterFunc (_cfa );Gray16Converter =ConverterFunc (_cgc );NRGBA16Converter =ConverterFunc (_gdce );NRGBAConverter =ConverterFunc (_bcgb );NRGBA64Converter =ConverterFunc (_bgce );CMYKConverter =ConverterFunc (_ed ););var _ _ac .Image =&Gray8 {};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_gabg :=y *bytesPerLine +x *3/2;if _gabg +1>=len (data ){return _c .NRGBA {},_dfcg (x ,y );};const (_feed =0xf;_gdfg =uint8 (0xff););_debb :=_gdfg ;if alpha !=nil {_cgcd :=y *BytesPerLine (width ,4,1);if _cgcd < len (alpha ){if x %2==0{_debb =(alpha [_cgcd ]>>uint (4))&_feed ;}else {_debb =alpha [_cgcd ]&_feed ;};_debb |=_debb <<4;};};var _fagb ,_cbdgd ,_fbfc uint8 ;if x *3%2==0{_fagb =(data [_gabg ]>>uint (4))&_feed ;_cbdgd =data [_gabg ]&_feed ;_fbfc =(data [_gabg +1]>>uint (4))&_feed ;}else {_fagb =data [_gabg ]&_feed ;_cbdgd =(data [_gabg +1]>>uint (4))&_feed ;_fbfc =data [_gabg +1]&_feed ;};if len (decode )==6{_fagb =uint8 (uint32 (LinearInterpolate (float64 (_fagb ),0,15,decode [0],decode [1]))&0xf);_cbdgd =uint8 (uint32 (LinearInterpolate (float64 (_cbdgd ),0,15,decode [2],decode [3]))&0xf);_fbfc =uint8 (uint32 (LinearInterpolate (float64 (_fbfc ),0,15,decode [4],decode [5]))&0xf);};return _c .NRGBA {R :(_fagb <<4)|(_fagb &0xf),G :(_cbdgd <<4)|(_cbdgd &0xf),B :(_fbfc <<4)|(_fbfc &0xf),A :_debb },nil ;};func (_fdd *NRGBA32 )NRGBAAt (x ,y int )_c .NRGBA {_eggc ,_ :=ColorAtNRGBA32 (x ,y ,_fdd .Width ,_fdd .Data ,_fdd .Alpha ,_fdd .Decode );return _eggc ;};func (_daf colorConverter )Convert (src _ac .Image )(Image ,error ){return _daf ._bfe (src )};func _dff (_dc RGBA ,_eec CMYK ,_bbd _ac .Rectangle ){for _cg :=0;_cg < _bbd .Max .X ;_cg ++{for _beg :=0;_beg < _bbd .Max .Y ;_beg ++{_bfc :=_dc .RGBAAt (_cg ,_beg );_eec .SetCMYK (_cg ,_beg ,_cga (_bfc ));};};};func (_cagc *NRGBA32 )At (x ,y int )_c .Color {_adg ,_ :=_cagc .ColorAt (x ,y );return _adg };func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_c .CMYK ,error ){_cbc :=4*(y *width +x );if _cbc +3>=len (data ){return _c .CMYK {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_cbc ]&0xff;M :=data [_cbc +1]&0xff;Y :=data [_cbc +2]&0xff;K :=data [_cbc +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _c .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};var _ _ac .Image =&NRGBA16 {};func (_ffa *NRGBA32 )SetNRGBA (x ,y int ,c _c .NRGBA ){_bfge :=y *_ffa .Width +x ;_fbg :=3*_bfge ;if _fbg +2>=len (_ffa .Data ){return ;};_ffa .setRGBA (_bfge ,c );};func (_bdba *NRGBA32 )Set (x ,y int ,c _c .Color ){_fbfb :=y *_bdba .Width +x ;_afd :=3*_fbfb ;if _afd +2>=len (_bdba .Data ){return ;};_ccc :=_c .NRGBAModel .Convert (c ).(_c .NRGBA );_bdba .setRGBA (_fbfb ,_ccc );};func _dbf (){for _gfg :=0;_gfg < 256;_gfg ++{_addf [_gfg ]=uint8 (_gfg &0x1)+(uint8 (_gfg >>1)&0x1)+(uint8 (_gfg >>2)&0x1)+(uint8 (_gfg >>3)&0x1)+(uint8 (_gfg >>4)&0x1)+(uint8 (_gfg >>5)&0x1)+(uint8 (_gfg >>6)&0x1)+(uint8 (_gfg >>7)&0x1);};};func (_abgd *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_abgd .copy ()}};func GrayHistogram (g Gray )(_cge [256]int ){switch _eage :=g .(type ){case Histogramer :return _eage .Histogram ();case _ac .Image :_gbac :=_eage .Bounds ();for _aaffa :=0;_aaffa < _gbac .Max .X ;_aaffa ++{for _ebge :=0;_ebge < _gbac .Max .Y ;_ebge ++{_cge [g .GrayAt (_aaffa ,_ebge ).Y ]++;};};return _cge ;default:return [256]int {};};};var _ Image =&Gray16 {};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_bc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_fe *CMYK32 )ColorModel ()_c .Model {return _c .CMYKModel };func (_fb *CMYK32 )Base ()*ImageBase {return &_fb .ImageBase };func (_ggae *NRGBA32 )Validate ()error {if len (_ggae .Data )!=3*_ggae .Width *_ggae .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _ag (_bea Gray ,_bd CMYK ,_eff _ac .Rectangle ){for _db :=0;_db < _eff .Max .X ;_db ++{for _gde :=0;_gde < _eff .Max .Y ;_gde ++{_bf :=_bea .GrayAt (_db ,_gde );_bd .SetCMYK (_db ,_gde ,_feg (_bf ));};};};func (_eae *Gray4 )Histogram ()(_deba [256]int ){for _agf :=0;_agf < _eae .Width ;_agf ++{for _gfeb :=0;_gfeb < _eae .Height ;_gfeb ++{_deba [_eae .GrayAt (_agf ,_gfeb ).Y ]++;};};return _deba ;};func (_dee *Gray8 )Bounds ()_ac .Rectangle {return _ac .Rectangle {Max :_ac .Point {X :_dee .Width ,Y :_dee .Height }};};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _ed (_bce _ac .Image )(Image ,error ){if _ecd ,_gg :=_bce .(*CMYK32 );_gg {return _ecd .Copy (),nil ;};_cdb :=_bce .Bounds ();_fad ,_bg :=NewImage (_cdb .Max .X ,_cdb .Max .Y ,8,4,nil ,nil ,nil );if _bg !=nil {return nil ,_bg ;};switch _gc :=_bce .(type ){case CMYK :_eg (_gc ,_fad .(CMYK ),_cdb );case Gray :_ag (_gc ,_fad .(CMYK ),_cdb );case NRGBA :_egc (_gc ,_fad .(CMYK ),_cdb );case RGBA :_dff (_gc ,_fad .(CMYK ),_cdb );default:_gcb (_bce ,_fad ,_cdb );};return _fad ,nil ;};func _bgdga (_dgff _c .Gray )_c .Gray {_dgff .Y >>=4;_dgff .Y |=_dgff .Y <<4;return _dgff };func _gb (_bcb _c .RGBA )_c .Gray {_cdeb :=(19595*uint32 (_bcb .R )+38470*uint32 (_bcb .G )+7471*uint32 (_bcb .B )+1<<7)>>16;return _c .Gray {Y :uint8 (_cdeb )};};func (_cegf *ImageBase )Pix ()[]byte {return _cegf .Data };func _fgb (_eece *_ac .Gray )bool {for _edgb :=0;_edgb < len (_eece .Pix );_edgb ++{if !_edgg (_eece .Pix [_edgb ]){return false ;};};return true ;};func _dcgb (_fcd ,_egcf uint8 )uint8 {if _fcd < _egcf {return 255;};return 0;};func (_babf *NRGBA32 )Base ()*ImageBase {return &_babf .ImageBase };func (_bbfa *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_bbfa .copy ()}};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_bdc :=y *width +x ;_dcd :=3*_bdc ;if _dcd +2>=len (data ){return _c .NRGBA {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dcfe :=uint8 (0xff);if alpha !=nil &&len (alpha )> _bdc {_dcfe =alpha [_bdc ];};_bbdf ,_fda ,_gea :=data [_dcd ],data [_dcd +1],data [_dcd +2];if len (decode )==6{_bbdf =uint8 (uint32 (LinearInterpolate (float64 (_bbdf ),0,255,decode [0],decode [1]))&0xff);_fda =uint8 (uint32 (LinearInterpolate (float64 (_fda ),0,255,decode [2],decode [3]))&0xff);_gea =uint8 (uint32 (LinearInterpolate (float64 (_gea ),0,255,decode [4],decode [5]))&0xff);};return _c .NRGBA {R :_bbdf ,G :_fda ,B :_gea ,A :_dcfe },nil ;};func (_gdgf *ImageBase )newAlpha (){_deg :=BytesPerLine (_gdgf .Width ,_gdgf .BitsPerComponent ,1);_gdgf .Alpha =make ([]byte ,_gdgf .Height *_deg );};