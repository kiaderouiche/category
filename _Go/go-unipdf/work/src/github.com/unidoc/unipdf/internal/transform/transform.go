//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_d "github.com/unidoc/unipdf/v3/common";_c "math";);func (_bcd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bcd .X +t *b .X ,Y :(1-t )*_bcd .Y +t *b .Y };};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ec :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ec .clampRange ();return _ec ;};func (_cg Matrix )Mult (b Matrix )Matrix {_cg .Concat (b );return _cg };func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func RotationMatrix (angle float64 )Matrix {_ab :=_c .Cos (angle );_abc :=_c .Sin (angle );return NewMatrix (_ab ,_abc ,-_abc ,_ab ,0,0);};func (_bcdf *Point )transformByMatrix (_ed Matrix ){_bcdf .X ,_bcdf .Y =_ed .Transform (_bcdf .X ,_bcdf .Y )};func (_ddg *Matrix )clampRange (){for _fce ,_daf :=range _ddg {if _daf > _fbd {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_daf ,_fbd );_ddg [_fce ]=_fbd ;}else if _daf < -_fbd {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_daf ,-_fbd );_ddg [_fce ]=-_fbd ;};};};func (_gd *Matrix )Shear (x ,y float64 ){_gd .Concat (ShearMatrix (x ,y ))};func (_dd Matrix )Translation ()(float64 ,float64 ){return _dd [6],_dd [7]};func (_b Matrix )Translate (tx ,ty float64 )Matrix {return _b .Mult (TranslationMatrix (tx ,ty ))};func (_gf Matrix )Identity ()bool {return _gf [0]==1&&_gf [1]==0&&_gf [2]==0&&_gf [3]==0&&_gf [4]==1&&_gf [5]==0&&_gf [6]==0&&_gf [7]==0&&_gf [8]==1;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ged Matrix )Transform (x ,y float64 )(float64 ,float64 ){_eg :=x *_ged [0]+y *_ged [3]+_ged [6];_cc :=x *_ged [1]+y *_ged [4]+_ged [7];return _eg ,_cc ;};const _gdb =1e-10;func (_gfb Point )Distance (b Point )float64 {return _c .Hypot (_gfb .X -b .X ,_gfb .Y -b .Y )};func (_de *Matrix )Concat (b Matrix ){*_de =Matrix {b [0]*_de [0]+b [1]*_de [3],b [0]*_de [1]+b [1]*_de [4],0,b [3]*_de [0]+b [4]*_de [3],b [3]*_de [1]+b [4]*_de [4],0,b [6]*_de [0]+b [7]*_de [3]+_de [6],b [6]*_de [1]+b [7]*_de [4]+_de [7],1};_de .clampRange ();};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ga *Matrix )Clone ()Matrix {return NewMatrix (_ga [0],_ga [1],_ga [3],_ga [4],_ga [6],_ga [7])};const _ad =1e-6;func (_g Matrix )Round (precision float64 )Matrix {for _f :=range _g {_g [_f ]=_c .Round (_g [_f ]/precision )*precision ;};return _g ;};const _fbd =1e9;func (_af Matrix )Unrealistic ()bool {_bf ,_ege ,_aea ,_aed :=_c .Abs (_af [0]),_c .Abs (_af [1]),_c .Abs (_af [3]),_c .Abs (_af [4]);_cgb :=_bf > _ad &&_aed > _ad ;_egd :=_ege > _ad &&_aea > _ad ;return !(_cgb ||_egd );};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_gg Matrix )ScalingFactorY ()float64 {return _c .Hypot (_gg [3],_gg [4])};func (_eae Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_eae .X ,_eae .Y );};type Matrix [9]float64 ;func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_dcd Matrix )Singular ()bool {return _c .Abs (_dcd [0]*_dcd [4]-_dcd [1]*_dcd [3])< _gdb };type Point struct{X float64 ;Y float64 ;};func (_fcb Point )Rotate (theta float64 )Point {_gb :=_c .Hypot (_fcb .X ,_fcb .Y );_cbc :=_c .Atan2 (_fcb .Y ,_fcb .X );_eeb ,_dcc :=_c .Sincos (_cbc +theta /180.0*_c .Pi );return Point {_gb *_dcc ,_gb *_eeb };};const _abg =1.0e-6;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_eca *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_eca [0],_eca [1]=a ,b ;_eca [3],_eca [4]=c ,d ;_eca [6],_eca [7]=tx ,ty ;_eca .clampRange ();};func (_gedf *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_eaa :=NewMatrix (a ,b ,c ,d ,tx ,ty );_gedf .transformByMatrix (_eaa );};func (_ff Matrix )Scale (xScale ,yScale float64 )Matrix {return _ff .Mult (ScaleMatrix (xScale ,yScale ))};func (_fe Matrix )ScalingFactorX ()float64 {return _c .Hypot (_fe [0],_fe [1])};func (_ae Matrix )String ()string {_abd ,_fg ,_fd ,_ee ,_dc ,_ge :=_ae [0],_ae [1],_ae [3],_ae [4],_ae [6],_ae [7];return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_abd ,_fg ,_fd ,_ee ,_dc ,_ge );};func (_ca *Point )Set (x ,y float64 ){_ca .X ,_ca .Y =x ,y };func (_bc Matrix )Inverse ()(Matrix ,bool ){_cb ,_fb :=_bc [0],_bc [1];_ba ,_gef :=_bc [3],_bc [4];_egb ,_egbc :=_bc [6],_bc [7];_ea :=_cb *_gef -_fb *_ba ;if _c .Abs (_ea )< _abg {return Matrix {},false ;};_fda ,_bae :=_gef /_ea ,-_fb /_ea ;_fc ,_dee :=-_ba /_ea ,_cb /_ea ;_ag :=-(_fda *_egb +_fc *_egbc );_abe :=-(_bae *_egb +_dee *_egbc );return NewMatrix (_fda ,_bae ,_fc ,_dee ,_ag ,_abe ),true ;};func (_daa Point )Displace (delta Point )Point {return Point {_daa .X +delta .X ,_daa .Y +delta .Y }};func (_ce Matrix )Rotate (theta float64 )Matrix {return _ce .Mult (RotationMatrix (theta ))};func (_da Matrix )Angle ()float64 {_cd :=_c .Atan2 (-_da [1],_da [0]);if _cd < 0.0{_cd +=2*_c .Pi ;};return _cd /_c .Pi *180.0;};