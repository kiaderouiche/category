//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_e "bytes";_cb "errors";_dg "fmt";_bf "github.com/unidoc/unipdf/v3/common";_bc "github.com/unidoc/unipdf/v3/contentstream";_a "github.com/unidoc/unipdf/v3/contentstream/draw";_ag "github.com/unidoc/unipdf/v3/core";_fd "github.com/unidoc/unipdf/v3/model";_bd "image";_b "io";_f "math";_d "os";_cc "sort";_ce "strconv";_bg "strings";_eb "unicode";);

// AddLine appends a new line to the invoice line items table.
func (_fcag *Invoice )AddLine (values ...string )[]*InvoiceCell {_dccc :=len (_fcag ._cagd );var _ccfe []*InvoiceCell ;for _fbbg ,_deaga :=range values {_dedc :=_fcag .newCell (_deaga ,_fcag ._ecag );if _fbbg < _dccc {_dedc .Alignment =_fcag ._cagd [_fbbg ].Alignment ;};_ccfe =append (_ccfe ,_dedc );};_fcag ._gaac =append (_fcag ._gaac ,_ccfe );return _ccfe ;};func (_ecbf *StyledParagraph )getTextLineWidth (_daaab []*TextChunk )float64 {var _ffcf float64 ;_cbgc :=len (_daaab );for _ccfb ,_gegf :=range _daaab {_cded :=&_gegf .Style ;_cfeb :=len (_gegf .Text );for _fgba ,_feeg :=range _gegf .Text {if _feeg =='\u000A'{continue ;};_aede ,_ceba :=_cded .Font .GetRuneMetrics (_feeg );if !_ceba {_bf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_feeg );return -1;};_ffcf +=_cded .FontSize *_aede .Wx ;if _feeg !=' '&&(_ccfb !=_cbgc -1||_fgba !=_cfeb -1){_ffcf +=_cded .CharSpacing *1000.0;};};};return _ffcf ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_dgbd *Image )SetMargins (left ,right ,top ,bottom float64 ){_dgbd ._ecba ._ddcg =left ;_dgbd ._ecba ._bcde =right ;_dgbd ._ecba ._fdfb =top ;_dgbd ._ecba ._dfbb =bottom ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_deee []*_fd .PdfPage ;_dag map[*_fd .PdfPage ]*Block ;_fcae *_fd .PdfPage ;_adbd PageSize ;_gfg DrawContext ;_bcg margins ;_eggf ,_gce float64 ;_abaf int ;_fbcg func (_gfbce FrontpageFunctionArgs );_ebb func (_cbd *TOC )error ;_gfc func (_cgce *Block ,_caae HeaderFunctionArgs );_gff func (_eccg *Block ,_ebda FooterFunctionArgs );_ffga func (_gab *_fd .PdfWriter )error ;_dbgc bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_fgbg *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_egcg *_fd .Outline ;_bcf *_fd .PdfOutlineTreeNode ;_gcf *_fd .PdfAcroForm ;_efcc _ag .PdfObject ;_ecbe _fd .Optimizer ;_acag []*_fd .PdfFont ;_afeb *_fd .PdfFont ;_dadd *_fd .PdfFont ;};

// SetBorder sets the cell's border style.
func (_cfgba *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_cfgba ._begbb =CellBorderStyleSingle ;_cfgba ._dfee =width ;_cfgba ._cdea =CellBorderStyleSingle ;_cfgba ._ebce =width ;_cfgba ._dage =CellBorderStyleSingle ;_cfgba ._facge =width ;_cfgba ._bcgbe =CellBorderStyleSingle ;_cfgba ._aece =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_cfgba ._begbb =CellBorderStyleDouble ;_cfgba ._dfee =width ;_cfgba ._cdea =CellBorderStyleDouble ;_cfgba ._ebce =width ;_cfgba ._dage =CellBorderStyleDouble ;_cfgba ._facge =width ;_cfgba ._bcgbe =CellBorderStyleDouble ;_cfgba ._aece =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_cfgba ._begbb =style ;_cfgba ._dfee =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_cfgba ._cdea =style ;_cfgba ._ebce =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_cfgba ._dage =style ;_cfgba ._facge =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_cfgba ._bcgbe =style ;_cfgba ._aece =width ;};};type listItem struct{_bfea VectorDrawable ;_bfdc TextChunk ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_eaedg float64 ;_gaba float64 ;_gcge float64 ;_fffef float64 ;_bbag *_fd .PdfColorDeviceRGB ;_facgb float64 ;_dfe *_fd .PdfColorDeviceRGB ;_bffd float64 ;_ggfdd float64 ;};func _fcfg (_gbaa TextStyle )*StyledParagraph {return &StyledParagraph {_dddd :[]*TextChunk {},_agde :_gbaa ,_beaag :_ebdaa (_gbaa .Font ),_bacad :1.0,_adfac :TextAlignmentLeft ,_caeb :true ,_fcdg :true ,_ebae :0,_bacae :1,_fggd :1,_ggec :_ffgbd };};func (_bgfbg *StyledParagraph )getTextHeight ()float64 {var _dacb float64 ;for _ ,_acfg :=range _bgfbg ._dddd {_bdce :=_acfg .Style .FontSize *_bgfbg ._bacad ;if _bdce > _dacb {_dacb =_bdce ;};};return _dacb ;};func (_fdaa *StyledParagraph )appendChunk (_cdfdc *TextChunk )*TextChunk {_fdaa ._dddd =append (_fdaa ._dddd ,_cdfdc );_fdaa .wrapText ();return _cdfdc ;};

// WriteToFile writes the Creator output to file specified by path.
func (_dgcb *Creator )WriteToFile (outputPath string )error {_dfbg ,_eeaf :=_d .Create (outputPath );if _eeaf !=nil {return _eeaf ;};defer _dfbg .Close ();return _dgcb .Write (_dfbg );};

// SetBorderColor sets the border color.
func (_fcc *Ellipse )SetBorderColor (col Color ){_fcc ._begg =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// SkipRows skips over a specified number of rows in the table.
func (_befed *Table )SkipRows (num int ){_dbce :=num *_befed ._ecad -1;if _dbce < 0{_bf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_befed ._cbfc +=_dbce ;};

// SetRowHeight sets the height for a specified row.
func (_caefc *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_caefc ._badeg ){return _cb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_caefc ._badeg [row -1]=h ;return nil ;};

// Add adds a new Drawable to the chapter.
func (_fabc *Chapter )Add (d Drawable )error {if Drawable (_fabc )==d {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _cb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_fabc ._cfd =append (_fabc ._cfd ,d );default:_bf .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _cb .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_afdd *List )Width ()float64 {return 0};

// SetBorderColor sets the border color for the path.
func (_eff *FilledCurve )SetBorderColor (color Color ){_eff ._bfa =_fd .NewPdfColorDeviceRGB (color .ToRGB ());};func (_debga *Creator )getActivePage ()*_fd .PdfPage {if _debga ._fcae ==nil {if len (_debga ._deee )==0{return nil ;};return _debga ._deee [len (_debga ._deee )-1];};return _debga ._fcae ;};

// Context returns the current drawing context.
func (_dbd *Creator )Context ()DrawContext {return _dbd ._gfg };

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_f .Max (_f .Min (r ,1.0),0.0);g =_f .Max (_f .Min (g ,1.0),0.0);b =_f .Max (_f .Min (b ,1.0),0.0);_caf :=rgbColor {};_caf ._fffg =r ;_caf ._cdgb =g ;_caf ._cbc =b ;return _caf ;};func (_ffaef *Creator )setActivePage (_abgc *_fd .PdfPage ){_ffaef ._fcae =_abgc };

// SetColorRight sets border color for right.
func (_fdbd *border )SetColorRight (col Color ){_fdbd ._cdb =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_afbb *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bade :=_a .Circle {X :_afbb ._gaab -_afbb ._agea /2,Y :ctx .PageHeight -_afbb ._aagd -_afbb ._ababc /2,Width :_afbb ._agea ,Height :_afbb ._ababc ,Opacity :1.0,BorderWidth :_afbb ._dece };if _afbb ._cffd !=nil {_bade .FillEnabled =true ;_bade .FillColor =_afbb ._cffd ;};if _afbb ._begg !=nil {_bade .BorderEnabled =true ;_bade .BorderColor =_afbb ._begg ;_bade .BorderWidth =_afbb ._dece ;};_dcgf ,_ ,_fdfd :=_bade .Draw ("");if _fdfd !=nil {return nil ,ctx ,_fdfd ;};_fdfd =_cdca .addContentsByString (string (_dcgf ));if _fdfd !=nil {return nil ,ctx ,_fdfd ;};return []*Block {_cdca },ctx ,nil ;};

// NewColumn returns a new column for the line items invoice table.
func (_bffa *Invoice )NewColumn (description string )*InvoiceCell {return _bffa .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_efaa *Creator )SetForms (form *_fd .PdfAcroForm )error {_efaa ._gcf =form ;return nil };

// AppendCurve appends a Bezier curve to the filled curve.
func (_ggag *FilledCurve )AppendCurve (curve _a .CubicBezierCurve )*FilledCurve {_ggag ._ggca =append (_ggag ._ggca ,curve );return _ggag ;};func (_cebcc *TOCLine )getLineLink ()*_fd .PdfAnnotation {if _cebcc ._afccd <=0{return nil ;};return _gfdb (_cebcc ._afccd -1,_cebcc ._cdaage ,_cebcc ._gdfcc ,0);};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// Height returns Image's document height.
func (_afeeb *Image )Height ()float64 {return _afeeb ._efgg };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_cbb *Creator )SetOutlineTree (outlineTree *_fd .PdfOutlineTreeNode ){_cbb ._bcf =outlineTree };func (_dgce *Invoice )generateHeaderBlocks (_fdda DrawContext )([]*Block ,DrawContext ,error ){_abcdg :=_fcfg (_dgce ._fec );_abcdg .SetEnableWrap (true );_abcdg .Append (_dgce ._fdaf );_ebfe :=_egge (2);if _dgce ._dgcga !=nil {_gddac :=_ebfe .NewCell ();_gddac .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_gddac .SetVerticalAlignment (CellVerticalAlignmentMiddle );_gddac .SetIndent (0);_gddac .SetContent (_dgce ._dgcga );_dgce ._dgcga .ScaleToHeight (_abcdg .Height ()+20);}else {_ebfe .SkipCells (1);};_fadg :=_ebfe .NewCell ();_fadg .SetHorizontalAlignment (CellHorizontalAlignmentRight );_fadg .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fadg .SetContent (_abcdg );return _ebfe .GeneratePageBlocks (_fdda );};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_ddbf *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_ddbf ._bcg ._ddcg =left ;_ddbf ._bcg ._bcde =right ;_ddbf ._bcg ._fdfb =top ;_ddbf ._bcg ._dfbb =bottom ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_ccba *TOC )SetLineLevelOffset (levelOffset float64 ){_ccba ._ababg =levelOffset };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_aaca *Invoice )AddressHeadingStyle ()TextStyle {return _aaca ._eadcg };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ed *_bc .ContentStreamOperations ;_eg *_fd .PdfPageResources ;_db positioning ;_cd ,_bcc float64 ;_bfd float64 ;_cea float64 ;_fa float64 ;_faf margins ;_fb []*_fd .PdfAnnotation ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};func _gaede (_fdga ,_decb ,_ggfg ,_ddfc float64 )*Line {_bdefe :=&Line {};_bdefe ._faee =_fdga ;_bdefe ._becdc =_decb ;_bdefe ._gadfd =_ggfg ;_bdefe ._daaaf =_ddfc ;_bdefe ._eaad =_fd .NewPdfColorDeviceRGB (0,0,0);_bdefe ._fedg =1.0;return _bdefe ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_deced *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_deced ._bdba =alignment };var PPMM =float64 (72*1.0/25.4);func _beda (_agf ,_ca ,_gdcc ,_bfga float64 )*border {_deag :=&border {};_deag ._dgbg =_agf ;_deag ._daaa =_ca ;_deag ._gag =_gdcc ;_deag ._bdf =_bfga ;_deag ._edf =_fd .NewPdfColorDeviceRGB (0,0,0);_deag ._bfdb =_fd .NewPdfColorDeviceRGB (0,0,0);_deag ._ebe =_fd .NewPdfColorDeviceRGB (0,0,0);_deag ._cdb =_fd .NewPdfColorDeviceRGB (0,0,0);_deag ._cebd =0;_deag ._eccb =0;_deag ._fef =0;_deag ._gdec =0;_deag .LineStyle =_a .LineStyleSolid ;return _deag ;};

// AddPage adds the specified page to the creator.
// NOTE: When working with arbitrary PDF files, it may be helpful to
// normalize the pages prior to adding them to the creator in order
// to avoid any unexpected geometric effects from the page properties.
// Example:
//   pdfutil.NormalizePage(page)
//   c.AddPage(page)
func (_dgcc *Creator )AddPage (page *_fd .PdfPage )error {_acf ,_faff :=page .GetMediaBox ();if _faff !=nil {_bf .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_faff );return _faff ;};_dgcc ._gfg .X =_acf .Llx +_dgcc ._bcg ._ddcg ;_dgcc ._gfg .Y =_dgcc ._bcg ._fdfb ;_dgcc ._gfg .PageHeight =_acf .Ury -_acf .Lly ;_dgcc ._gfg .PageWidth =_acf .Urx -_acf .Llx ;_dgcc ._deee =append (_dgcc ._deee ,page );_dgcc ._gfg .Page ++;return nil ;};func (_gade *Paragraph )getMaxLineWidth ()float64 {if _gade ._eedg ==nil ||len (_gade ._eedg )==0{_gade .wrapText ();};var _dbcc float64 ;for _ ,_dgeb :=range _gade ._eedg {_dcb :=_gade .getTextLineWidth (_dgeb );if _dcb > _dbcc {_dbcc =_dcb ;};};return _dbcc ;};

// SetWidth sets line width.
func (_ebcg *Curve )SetWidth (width float64 ){_ebcg ._fbdc =width };

// SetNotes sets the notes section of the invoice.
func (_bbff *Invoice )SetNotes (title ,content string ){_bbff ._cgfc =[2]string {title ,content }};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_bdcb *Creator )SetPageSize (size PageSize ){_bdcb ._adbd =size ;_bdcb ._eggf =size [0];_bdcb ._gce =size [1];_addb :=0.1*_bdcb ._eggf ;_bdcb ._bcg ._ddcg =_addb ;_bdcb ._bcg ._bcde =_addb ;_bdcb ._bcg ._fdfb =_addb ;_bdcb ._bcg ._dfbb =_addb ;};

// AppendColumn appends a column to the line items table.
func (_facg *Invoice )AppendColumn (description string )*InvoiceCell {_cgeg :=_facg .NewColumn (description );_facg ._cagd =append (_facg ._cagd ,_cgeg );return _cgeg ;};

// Height returns the Block's height.
func (_aac *Block )Height ()float64 {return _aac ._cea };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_cdaed *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bgg *_fd .PdfWriter )error ){_cdaed ._ffga =pdfWriterAccessFunc ;};func (_fab *Block )addContents (_abg *_bc .ContentStreamOperations ){_fab ._ed .WrapIfNeeded ();_abg .WrapIfNeeded ();*_fab ._ed =append (*_fab ._ed ,*_abg ...);};func (_cbgd *Paragraph )getTextWidth ()float64 {_eaac :=0.0;for _ ,_dgde :=range _cbgd ._cgag {if _dgde =='\u000A'{continue ;};_eddaf ,_dffga :=_cbgd ._adfg .GetRuneMetrics (_dgde );if !_dffga {_bf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dgde ,_dgde );return -1;};_eaac +=_cbgd ._abeb *_eddaf .Wx ;};return _eaac ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_geag *TOC )SetLineStyle (style TextStyle ){_geag .SetLineNumberStyle (style );_geag .SetLineTitleStyle (style );_geag .SetLineSeparatorStyle (style );_geag .SetLinePageStyle (style );};

// NewTOCLine creates a new table of contents line with the default style.
func (_aae *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _agadg (number ,title ,page ,level ,_aae .NewTextStyle ());};var PPI float64 =72;

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_bece *Paragraph )SetColor (col Color ){_cdaag :=_fd .NewPdfColorDeviceRGB (col .ToRGB ());_bece ._edccg =*_cdaag ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_fcd :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_bf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcd ;};var _cag ,_eddf ,_fdca int ;if len (hexStr )==4{var _fbe ,_bfe ,_dae int ;_efgb ,_fde :=_dg .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_fbe ,&_bfe ,&_dae );if _fde !=nil {_bf .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_fde );return _fcd ;};if _efgb !=3{_bf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcd ;};_cag =_fbe *16+_fbe ;_eddf =_bfe *16+_bfe ;_fdca =_dae *16+_dae ;}else {_gef ,_caa :=_dg .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_cag ,&_eddf ,&_fdca );if _caa !=nil {_bf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcd ;};if _gef !=3{_bf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_gef );return _fcd ;};};_daef :=float64 (_cag )/255.0;_fcab :=float64 (_eddf )/255.0;_gfd :=float64 (_fdca )/255.0;_fcd ._fffg =_daef ;_fcd ._cdgb =_fcab ;_fcd ._cbc =_gfd ;return _fcd ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fbfgf *TOC )SetLineSeparator (separator string ){_fbfgf ._adfee =separator };

// MoveY moves the drawing context to absolute position y.
func (_eagb *Creator )MoveY (y float64 ){_eagb ._gfg .Y =y };

// SetIndent sets the left offset of the list when nested into another list.
func (_dcde *List )SetIndent (indent float64 ){_dcde ._fgce =indent ;_dcde ._bfeb =false };

// Length calculates and returns the line length.
func (_cbaf *Line )Length ()float64 {return _f .Sqrt (_f .Pow (_cbaf ._gadfd -_cbaf ._faee ,2.0)+_f .Pow (_cbaf ._daaaf -_cbaf ._becdc ,2.0));};

// Append adds a new text chunk to the paragraph.
func (_gcad *StyledParagraph )Append (text string )*TextChunk {_cggb :=NewTextChunk (text ,_gcad ._agde );return _gcad .appendChunk (_cggb );};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_aege *Invoice )NoteStyle ()TextStyle {return _aege ._bcaea };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_egdb *Creator )NewImageFromGoImage (goimg _bd .Image )(*Image ,error ){return _gdfg (goimg )};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_fcb *Creator )Draw (d Drawable )error {if _fcb .getActivePage ()==nil {_fcb .NewPage ();};_eceb ,_fgbge ,_acd :=d .GeneratePageBlocks (_fcb ._gfg );if _acd !=nil {return _acd ;};for _eaed ,_cdff :=range _eceb {if _eaed > 0{_fcb .NewPage ();};_bfbc :=_fcb .getActivePage ();if _ccggc ,_gceb :=_fcb ._dag [_bfbc ];_gceb {if _dgcg :=_ccggc .mergeBlocks (_cdff );_dgcg !=nil {return _dgcg ;};if _bedag :=_gcbg (_cdff ._eg ,_ccggc ._eg );_bedag !=nil {return _bedag ;};}else {_fcb ._dag [_bfbc ]=_cdff ;};};_fcb ._gfg .X =_fgbge .X ;_fcb ._gfg .Y =_fgbge .Y ;_fcb ._gfg .Height =_fgbge .PageHeight -_fgbge .Y -_fgbge .Margins ._dfbb ;return nil ;};

// GeneratePageBlocks implements drawable interface.
func (_beb *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eag :=_beb ._dgbg ;_cee :=ctx .PageHeight -_beb ._daaa ;if _beb ._ddg !=nil {_adf :=_a .Rectangle {Opacity :1.0,X :_beb ._dgbg ,Y :ctx .PageHeight -_beb ._daaa -_beb ._bdf ,Height :_beb ._bdf ,Width :_beb ._gag };_adf .FillEnabled =true ;_adf .FillColor =_beb ._ddg ;_adf .BorderEnabled =false ;_cbea ,_ ,_egbe :=_adf .Draw ("");if _egbe !=nil {return nil ,ctx ,_egbe ;};_egbe =_aba .addContentsByString (string (_cbea ));if _egbe !=nil {return nil ,ctx ,_egbe ;};};_afb :=_beb ._cebd ;_ffgb :=_beb ._eccb ;_abad :=_beb ._fef ;_edb :=_beb ._gdec ;_fac :=_beb ._cebd ;if _beb ._debg ==CellBorderStyleDouble {_fac +=2*_afb ;};_bbce :=_beb ._eccb ;if _beb ._acge ==CellBorderStyleDouble {_bbce +=2*_ffgb ;};_deaa :=_beb ._fef ;if _beb ._ad ==CellBorderStyleDouble {_deaa +=2*_abad ;};_cbg :=_beb ._gdec ;if _beb ._eggd ==CellBorderStyleDouble {_cbg +=2*_edb ;};if _beb ._cebd !=0{_bbe :=_eag ;_bdff :=_cee ;if _beb ._debg ==CellBorderStyleDouble {_bdff -=_afb ;_ddc :=_a .BasicLine {};_ddc .X1 =_bbe -_fac /2;_ddc .Y1 =_bdff +2*_afb ;_ddc .X2 =_bbe +_beb ._gag +_fac /2;_ddc .Y2 =_bdff +2*_afb ;_ddc .LineColor =_beb ._edf ;_ddc .LineWidth =_beb ._cebd ;_ddc .LineStyle =_beb .LineStyle ;_bcca ,_ ,_aed :=_ddc .Draw ("");if _aed !=nil {return nil ,ctx ,_aed ;};_aed =_aba .addContentsByString (string (_bcca ));if _aed !=nil {return nil ,ctx ,_aed ;};};_fff :=_a .BasicLine {LineWidth :_beb ._cebd ,Opacity :1.0,LineColor :_beb ._edf ,X1 :_bbe -_fac /2+(_deaa -_beb ._fef ),Y1 :_bdff ,X2 :_bbe +_beb ._gag +_fac /2-(_cbg -_beb ._gdec ),Y2 :_bdff ,LineStyle :_beb .LineStyle };_bgc ,_ ,_gcbd :=_fff .Draw ("");if _gcbd !=nil {return nil ,ctx ,_gcbd ;};_gcbd =_aba .addContentsByString (string (_bgc ));if _gcbd !=nil {return nil ,ctx ,_gcbd ;};};if _beb ._eccb !=0{_dffc :=_eag ;_bgd :=_cee -_beb ._bdf ;if _beb ._acge ==CellBorderStyleDouble {_bgd +=_ffgb ;_bbf :=_a .BasicLine {LineWidth :_beb ._eccb ,Opacity :1.0,LineColor :_beb ._bfdb ,X1 :_dffc -_bbce /2,Y1 :_bgd -2*_ffgb ,X2 :_dffc +_beb ._gag +_bbce /2,Y2 :_bgd -2*_ffgb ,LineStyle :_beb .LineStyle };_adfa ,_ ,_aeb :=_bbf .Draw ("");if _aeb !=nil {return nil ,ctx ,_aeb ;};_aeb =_aba .addContentsByString (string (_adfa ));if _aeb !=nil {return nil ,ctx ,_aeb ;};};_ccg :=_a .BasicLine {LineWidth :_beb ._eccb ,Opacity :1.0,LineColor :_beb ._bfdb ,X1 :_dffc -_bbce /2+(_deaa -_beb ._fef ),Y1 :_bgd ,X2 :_dffc +_beb ._gag +_bbce /2-(_cbg -_beb ._gdec ),Y2 :_bgd ,LineStyle :_beb .LineStyle };_aca ,_ ,_efc :=_ccg .Draw ("");if _efc !=nil {return nil ,ctx ,_efc ;};_efc =_aba .addContentsByString (string (_aca ));if _efc !=nil {return nil ,ctx ,_efc ;};};if _beb ._fef !=0{_fcg :=_eag ;_cgdb :=_cee ;if _beb ._ad ==CellBorderStyleDouble {_fcg +=_abad ;_edcb :=_a .BasicLine {LineWidth :_beb ._fef ,Opacity :1.0,LineColor :_beb ._ebe ,X1 :_fcg -2*_abad ,Y1 :_cgdb +_deaa /2,X2 :_fcg -2*_abad ,Y2 :_cgdb -_beb ._bdf -_deaa /2,LineStyle :_beb .LineStyle };_dad ,_ ,_gbb :=_edcb .Draw ("");if _gbb !=nil {return nil ,ctx ,_gbb ;};_gbb =_aba .addContentsByString (string (_dad ));if _gbb !=nil {return nil ,ctx ,_gbb ;};};_gegc :=_a .BasicLine {LineWidth :_beb ._fef ,Opacity :1.0,LineColor :_beb ._ebe ,X1 :_fcg ,Y1 :_cgdb +_deaa /2-(_fac -_beb ._cebd ),X2 :_fcg ,Y2 :_cgdb -_beb ._bdf -_deaa /2+(_bbce -_beb ._eccb ),LineStyle :_beb .LineStyle };_gfbc ,_ ,_cfe :=_gegc .Draw ("");if _cfe !=nil {return nil ,ctx ,_cfe ;};_cfe =_aba .addContentsByString (string (_gfbc ));if _cfe !=nil {return nil ,ctx ,_cfe ;};};if _beb ._gdec !=0{_cae :=_eag +_beb ._gag ;_abb :=_cee ;if _beb ._eggd ==CellBorderStyleDouble {_cae -=_edb ;_edba :=_a .BasicLine {LineWidth :_beb ._gdec ,Opacity :1.0,LineColor :_beb ._cdb ,X1 :_cae +2*_edb ,Y1 :_abb +_cbg /2,X2 :_cae +2*_edb ,Y2 :_abb -_beb ._bdf -_cbg /2,LineStyle :_beb .LineStyle };_ggae ,_ ,_fgaf :=_edba .Draw ("");if _fgaf !=nil {return nil ,ctx ,_fgaf ;};_fgaf =_aba .addContentsByString (string (_ggae ));if _fgaf !=nil {return nil ,ctx ,_fgaf ;};};_abea :=_a .BasicLine {LineWidth :_beb ._gdec ,Opacity :1.0,LineColor :_beb ._cdb ,X1 :_cae ,Y1 :_abb +_cbg /2-(_fac -_beb ._cebd ),X2 :_cae ,Y2 :_abb -_beb ._bdf -_cbg /2+(_bbce -_beb ._eccb ),LineStyle :_beb .LineStyle };_egbg ,_ ,_bfgb :=_abea .Draw ("");if _bfgb !=nil {return nil ,ctx ,_bfgb ;};_bfgb =_aba .addContentsByString (string (_egbg ));if _bfgb !=nil {return nil ,ctx ,_bfgb ;};};return []*Block {_aba },ctx ,nil ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_agaf *Invoice )TitleStyle ()TextStyle {return _agaf ._fec };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_beac *Paragraph )SetWidth (width float64 ){_beac ._bae =width ;_beac .wrapText ()};func _acfc (_abfd ,_cdcb ,_gbbga ,_bbaf ,_bbaa ,_gfgg float64 )*Curve {_cac :=&Curve {};_cac ._decd =_abfd ;_cac ._ddbc =_cdcb ;_cac ._cdge =_gbbga ;_cac ._ffe =_bbaf ;_cac ._caee =_bbaa ;_cac ._cadd =_gfgg ;_cac ._fgcf =_fd .NewPdfColorDeviceRGB (0,0,0);_cac ._fbdc =1.0;return _cac ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_caddbd *TableCell )SetBorderLineStyle (style _a .LineStyle ){_caddbd ._ccca =style };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_daddb *Creator )MoveTo (x ,y float64 ){_daddb ._gfg .X =x ;_daddb ._gfg .Y =y };func _dcfb (_bbaef ,_ggecc ,_eefa float64 )(_bebf ,_aaag ,_gacd ,_cfge float64 ){if _eefa ==0{return 0,0,_bbaef ,_ggecc ;};_decda :=_a .Path {Points :[]_a .Point {_a .NewPoint (0,0).Rotate (_eefa ),_a .NewPoint (_bbaef ,0).Rotate (_eefa ),_a .NewPoint (0,_ggecc ).Rotate (_eefa ),_a .NewPoint (_bbaef ,_ggecc ).Rotate (_eefa )}}.GetBoundingBox ();return _decda .X ,_decda .Y ,_decda .Width ,_decda .Height ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_ceg *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_fagec :=&InvoiceCell {_ceg ._cbccg ,desc };_gad :=&InvoiceCell {_ceg ._cbccg ,value };_ceg ._fbbc =append (_ceg ._fbbc ,[2]*InvoiceCell {_fagec ,_gad });return _fagec ,_gad ;};const (_ffgbd positioning =iota ;_cead ;);

// MoveX moves the drawing context to absolute position x.
func (_faaa *Creator )MoveX (x float64 ){_faaa ._gfg .X =x };func (_fega *Invoice )generateInformationBlocks (_ddga DrawContext )([]*Block ,DrawContext ,error ){_begb :=_fcfg (_fega ._cfcd );_begb .SetMargins (0,0,0,20);_bdee :=_fega .drawAddress (_fega ._deab );_bdee =append (_bdee ,_begb );_bdee =append (_bdee ,_fega .drawAddress (_fega ._edg )...);_beffe :=_bdef ();for _ ,_fecd :=range _bdee {_beffe .Add (_fecd );};_fgff :=_fega .drawInformation ();_adaa :=_egge (2);_adaa .SetMargins (0,0,25,0);_gcdeg :=_adaa .NewCell ();_gcdeg .SetIndent (0);_gcdeg .SetContent (_beffe );_gcdeg =_adaa .NewCell ();_gcdeg .SetContent (_fgff );return _adaa .GeneratePageBlocks (_ddga );};

// SetWidthLeft sets border width for left.
func (_cab *border )SetWidthLeft (bw float64 ){_cab ._fef =bw };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_eaae *Invoice )Sections ()[][2]string {return _eaae ._aaac };

// GetMargins returns the left, right, top, bottom Margins.
func (_ccgc *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ccgc ._gefb ._ddcg ,_ccgc ._gefb ._bcde ,_ccgc ._gefb ._fdfb ,_ccgc ._gefb ._dfbb ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_gdgfc *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _dgg (xc ,yc ,width ,height );};

// SkipOver skips over a specified number of rows and cols.
func (_fabca *Table )SkipOver (rows ,cols int ){_abed :=rows *_fabca ._ecad +cols -1;if _abed < 0{_bf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_fabca ._cbfc +=_abed ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_bcce *Block )drawToPage (_gdd *_fd .PdfPage )error {_cgb ,_ead :=_gdd .GetAllContentStreams ();if _ead !=nil {return _ead ;};_ba :=_bc .NewContentStreamParser (_cgb );_gc ,_ead :=_ba .Parse ();if _ead !=nil {return _ead ;};_gc .WrapIfNeeded ();if _gdd .Resources ==nil {_gdd .Resources =_fd .NewPdfPageResources ();};_ead =_cgd (_gc ,_gdd .Resources ,_bcce ._ed ,_bcce ._eg );if _ead !=nil {return _ead ;};if _ead =_gcbg (_bcce ._eg ,_gdd .Resources );_ead !=nil {return _ead ;};_ead =_gdd .SetContentStreams ([]string {string (_gc .Bytes ())},_ag .NewFlateEncoder ());if _ead !=nil {return _ead ;};for _ ,_dbe :=range _bcce ._fb {_gdd .AddAnnotation (_dbe );};return nil ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_bdbge *_a .Polyline ;_egga float64 ;};func (_gaa *Creator )initContext (){_gaa ._gfg .X =_gaa ._bcg ._ddcg ;_gaa ._gfg .Y =_gaa ._bcg ._fdfb ;_gaa ._gfg .Width =_gaa ._eggf -_gaa ._bcg ._bcde -_gaa ._bcg ._ddcg ;_gaa ._gfg .Height =_gaa ._gce -_gaa ._bcg ._dfbb -_gaa ._bcg ._fdfb ;_gaa ._gfg .PageHeight =_gaa ._gce ;_gaa ._gfg .PageWidth =_gaa ._eggf ;_gaa ._gfg .Margins =_gaa ._bcg ;};

// GetCoords returns coordinates of border.
func (_cba *border )GetCoords ()(float64 ,float64 ){return _cba ._dgbg ,_cba ._daaa };type positioning int ;

// New creates a new instance of the PDF Creator.
func New ()*Creator {_dffd :=&Creator {};_dffd ._deee =[]*_fd .PdfPage {};_dffd ._dag =map[*_fd .PdfPage ]*Block {};_dffd .SetPageSize (PageSizeLetter );_dada :=0.1*_dffd ._eggf ;_dffd ._bcg ._ddcg =_dada ;_dffd ._bcg ._bcde =_dada ;_dffd ._bcg ._fdfb =_dada ;_dffd ._bcg ._dfbb =_dada ;var _ffcb error ;_dffd ._afeb ,_ffcb =_fd .NewStandard14Font (_fd .HelveticaName );if _ffcb !=nil {_dffd ._afeb =_fd .DefaultFont ();};_dffd ._dadd ,_ffcb =_fd .NewStandard14Font (_fd .HelveticaBoldName );if _ffcb !=nil {_dffd ._afeb =_fd .DefaultFont ();};_dffd ._fgbg =_dffd .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_dffd .AddOutlines =true ;_dffd ._egcg =_fd .NewOutline ();return _dffd ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_fbfda *TOCLine )SetLink (page int64 ,x ,y float64 ){_fbfda ._cdaage =x ;_fbfda ._gdfcc =y ;_fbfda ._afccd =page ;_gdfd :=_fbfda ._fdbdg ._beaag .Color ;_fbfda .Number .Style .Color =_gdfd ;_fbfda .Title .Style .Color =_gdfd ;_fbfda .Separator .Style .Color =_gdfd ;_fbfda .Page .Style .Color =_gdfd ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_bbfd *Creator )NewParagraph (text string )*Paragraph {return _cbaec (text ,_bbfd .NewTextStyle ())};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_decd float64 ;_ddbc float64 ;_cdge float64 ;_ffe float64 ;_caee float64 ;_cadd float64 ;_fgcf *_fd .PdfColorDeviceRGB ;_fbdc float64 ;};

// SetSellerAddress sets the seller address of the invoice.
func (_bfde *Invoice )SetSellerAddress (address *InvoiceAddress ){_bfde ._deab =address };func (_ffgfb *StyledParagraph )getLineHeight (_aedb int )(_agec ,_efbd float64 ){if _ffgfb ._cfbb ==nil ||len (_ffgfb ._cfbb )==0{_ffgfb .wrapText ();};if _aedb < 0||_aedb > len (_ffgfb ._cfbb )-1{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_aedb );return 0,0;};_deed :=_ffgfb ._cfbb [_aedb ];for _ ,_dbebg :=range _deed {_cbed ,_ecfc :=_dbebg .Style .Font .GetFontDescriptor ();if _ecfc !=nil {_bf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _fegf float64 ;if _cbed !=nil {if _fegf ,_ecfc =_cbed .GetCapHeight ();_ecfc !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_ecfc );};};if int (_fegf )<=0{_bf .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_fegf =1000;};_bded :=_fegf /1000.0*_dbebg .Style .FontSize *_ffgfb ._bacad ;if _bded > _agec {_agec =_bded ;};_bded =_ffgfb ._bacad *_dbebg .Style .FontSize ;if _bded > _efbd {_efbd =_bded ;};};return _agec ,_efbd ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_ggbab *Paragraph )SetEnableWrap (enableWrap bool ){_ggbab ._bffef =enableWrap ;_ggbab ._adgd =false ;};func (_aaf *Block )translate (_ee ,_cefc float64 ){_da :=_bc .NewContentCreator ().Translate (_ee ,-_cefc ).Operations ();*_aaf ._ed =append (*_da ,*_aaf ._ed ...);_aaf ._ed .WrapIfNeeded ();};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_aaba *Table )SetPos (x ,y float64 ){_aaba ._ecee =_cead ;_aaba ._ggcag =x ;_aaba ._gfbfg =y };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_dfc *Creator )RotateDeg (angleDeg int64 )error {_cbbf :=_dfc .getActivePage ();if _cbbf ==nil {_bf .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _cb .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _cb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _gbbg int64 ;if _cbbf .Rotate !=nil {_gbbg =*(_cbbf .Rotate );};_gbbg +=angleDeg ;_cbbf .Rotate =&_gbbg ;return nil ;};

// SetBorderOpacity sets the border opacity.
func (_bccg *Rectangle )SetBorderOpacity (opacity float64 ){_bccg ._ggfdd =opacity };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aeaf *Creator )NewStyledParagraph ()*StyledParagraph {return _fcfg (_aeaf .NewTextStyle ())};

// NewPolygon creates a new polygon.
func (_fbfg *Creator )NewPolygon (points [][]_a .Point )*Polygon {return _ddef (points )};func _dgf (_acbd []byte )(*Image ,error ){_ggcg :=_e .NewReader (_acbd );_gafd ,_dge :=_fd .ImageHandling .Read (_ggcg );if _dge !=nil {_bf .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dge );return nil ,_dge ;};return _bffed (_gafd );};

// SetBorderColor sets the cell's border color.
func (_adddc *TableCell )SetBorderColor (col Color ){_adddc ._gfcd =_fd .NewPdfColorDeviceRGB (col .ToRGB ());_adddc ._cgfcg =_fd .NewPdfColorDeviceRGB (col .ToRGB ());_adddc ._cfcgf =_fd .NewPdfColorDeviceRGB (col .ToRGB ());_adddc ._ecgc =_fd .NewPdfColorDeviceRGB (col .ToRGB ());};

// SetFillColor sets the fill color.
func (_ggaea *Polygon )SetFillColor (color Color ){_ggaea ._fbcf .FillColor =_fd .NewPdfColorDeviceRGB (color .ToRGB ());};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_dbb *Block )AddAnnotation (annotation *_fd .PdfAnnotation ){for _ ,_be :=range _dbb ._fb {if _be ==annotation {return ;};};_dbb ._fb =append (_dbb ._fb ,annotation );};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_fdeec *TableCell )SetContent (vd VectorDrawable )error {switch _fggf :=vd .(type ){case *Paragraph :if _fggf ._adgd {_fggf ._bffef =true ;};_fdeec ._abeag =vd ;case *StyledParagraph :if _fggf ._fcdg {_fggf ._caeb =true ;};_fdeec ._abeag =vd ;case *Image :_fdeec ._abeag =vd ;case *Table :_fdeec ._abeag =vd ;case *List :_fdeec ._abeag =vd ;case *Division :_fdeec ._abeag =vd ;default:_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _ag .ErrTypeError ;};return nil ;};func (_cfcb positioning )isAbsolute ()bool {return _cfcb ==_cead };

// SetAnnotation sets a annotation on a TextChunk.
func (_gbfc *TextChunk )SetAnnotation (annotation *_fd .PdfAnnotation ){_gbfc ._edgdf =annotation };

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_gbd DrawContext )([]*Block ,DrawContext ,error );};func (_dgcgg *Invoice )setCellBorder (_bdabf *TableCell ,_cdaea *InvoiceCell ){for _ ,_dgdd :=range _cdaea .BorderSides {_bdabf .SetBorder (_dgdd ,CellBorderStyleSingle ,_cdaea .BorderWidth );};_bdabf .SetBorderColor (_cdaea .BorderColor );};

// SetAngle sets Image rotation angle in degrees.
func (_afff *Image )SetAngle (angle float64 ){_afff ._aggb =angle };

// SetLineWidth sets the line width.
func (_bcfg *Polyline )SetLineWidth (lineWidth float64 ){_bcfg ._bdbge .LineWidth =lineWidth };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_beg *Creator )SetOptimizer (optimizer _fd .Optimizer ){_beg ._ecbe =optimizer };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetColorLeft sets border color for left.
func (_eafd *border )SetColorLeft (col Color ){_eafd ._ebe =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_gadb *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aabd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gaad :=_a .Rectangle {Opacity :1.0,X :_gadb ._eaedg ,Y :ctx .PageHeight -_gadb ._gaba -_gadb ._fffef ,Height :_gadb ._fffef ,Width :_gadb ._gcge };if _gadb ._bbag !=nil {_gaad .FillEnabled =true ;_gaad .FillColor =_gadb ._bbag ;};if _gadb ._dfe !=nil &&_gadb ._bffd > 0{_gaad .BorderEnabled =true ;_gaad .BorderColor =_gadb ._dfe ;_gaad .BorderWidth =_gadb ._bffd ;};_egfc ,_ecec :=_aabd .setOpacity (_gadb ._facgb ,_gadb ._ggfdd );if _ecec !=nil {return nil ,ctx ,_ecec ;};_dbfa ,_ ,_ecec :=_gaad .Draw (_egfc );if _ecec !=nil {return nil ,ctx ,_ecec ;};if _ecec =_aabd .addContentsByString (string (_dbfa ));_ecec !=nil {return nil ,ctx ,_ecec ;};return []*Block {_aabd },ctx ,nil ;};

// SetDate sets the date of the invoice.
func (_cefa *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_cefa ._agae [1].Value =date ;return _cefa ._agae [0],_cefa ._agae [1];};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_affge *Invoice )NoteHeadingStyle ()TextStyle {return _affge ._acfa };

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_bab *Rectangle )GetCoords ()(float64 ,float64 ){return _bab ._eaedg ,_bab ._gaba };

// SetFillColor sets the fill color.
func (_ebgg *PolyBezierCurve )SetFillColor (color Color ){_ebgg ._ebca .FillColor =_fd .NewPdfColorDeviceRGB (color .ToRGB ());};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_gaab float64 ;_aagd float64 ;_agea float64 ;_ababc float64 ;_cffd *_fd .PdfColorDeviceRGB ;_begg *_fd .PdfColorDeviceRGB ;_dece float64 ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_dea *Block )Draw (d Drawable )error {_dfa :=DrawContext {};_dfa .Width =_dea ._bfd ;_dfa .Height =_dea ._cea ;_dfa .PageWidth =_dea ._bfd ;_dfa .PageHeight =_dea ._cea ;_dfa .X =0;_dfa .Y =0;_egd ,_ ,_fbd :=d .GeneratePageBlocks (_dfa );if _fbd !=nil {return _fbd ;};if len (_egd )!=1{return _cb .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_cbe :=range _egd {if _bbb :=_dea .mergeBlocks (_cbe );_bbb !=nil {return _bbb ;};};return nil ;};

// SetTotal sets the total of the invoice.
func (_fdgb *Invoice )SetTotal (value string ){_fdgb ._egef [1].Value =value };

// SetFillColor sets the fill color for the path.
func (_ggcd *FilledCurve )SetFillColor (color Color ){_ggcd ._dbgcc =_fd .NewPdfColorDeviceRGB (color .ToRGB ());};

// BuyerAddress returns the buyer address used in the invoice template.
func (_adg *Invoice )BuyerAddress ()*InvoiceAddress {return _adg ._edg };func _cbaec (_bfae string ,_gfac TextStyle )*Paragraph {_cfcg :=&Paragraph {_cgag :_bfae ,_adfg :_gfac .Font ,_abeb :_gfac .FontSize ,_fffc :1.0,_bffef :true ,_adgd :true ,_ffaa :TextAlignmentLeft ,_gcfcg :0,_badaa :1,_dddf :1,_fdab :_ffgbd };_cfcg .SetColor (_gfac .Color );return _cfcg ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_deaac *Image )ScaleToHeight (h float64 ){_bfbe :=_deaac ._aggc /_deaac ._efgg ;_deaac ._efgg =h ;_deaac ._aggc =h *_bfbe ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// NewDivision returns a new Division container component.
func (_gbc *Creator )NewDivision ()*Division {return _bdef ()};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func _gfdb (_fdbce int64 ,_bged ,_fcggd ,_dfcec float64 )*_fd .PdfAnnotation {_fedd :=_fd .NewPdfAnnotationLink ();_edbgc :=_fd .NewBorderStyle ();_edbgc .SetBorderWidth (0);_fedd .BS =_edbgc .ToPdfObject ();if _fdbce < 0{_fdbce =0;};_fedd .Dest =_ag .MakeArray (_ag .MakeInteger (_fdbce ),_ag .MakeName ("\u0058\u0059\u005a"),_ag .MakeFloat (_bged ),_ag .MakeFloat (_fcggd ),_ag .MakeFloat (_dfcec ));return _fedd .PdfAnnotation ;};func (_eaba *Invoice )generateLineBlocks (_aaed DrawContext )([]*Block ,DrawContext ,error ){_bfgc :=_egge (len (_eaba ._cagd ));_bfgc .SetMargins (0,0,25,0);for _ ,_gbff :=range _eaba ._cagd {_adgb :=_fcfg (_gbff .TextStyle );_adgb .SetMargins (0,0,1,0);_adgb .Append (_gbff .Value );_gdag :=_bfgc .NewCell ();_gdag .SetHorizontalAlignment (_gbff .Alignment );_gdag .SetBackgroundColor (_gbff .BackgroundColor );_eaba .setCellBorder (_gdag ,_gbff );_gdag .SetContent (_adgb );};for _ ,_acec :=range _eaba ._gaac {for _ ,_bbbb :=range _acec {_ebgd :=_fcfg (_bbbb .TextStyle );_ebgd .SetMargins (0,0,3,2);_ebgd .Append (_bbbb .Value );_ggg :=_bfgc .NewCell ();_ggg .SetHorizontalAlignment (_bbbb .Alignment );_ggg .SetBackgroundColor (_bbbb .BackgroundColor );_eaba .setCellBorder (_ggg ,_bbbb );_ggg .SetContent (_ebgd );};};return _bfgc .GeneratePageBlocks (_aaed );};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_ffef *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_ffef ._aabb =halign };func _def ()*FilledCurve {_cgba :=FilledCurve {};_cgba ._ggca =[]_a .CubicBezierCurve {};return &_cgba ;};

// SetFillColor sets background color for border.
func (_ecg *border )SetFillColor (col Color ){_ecg ._ddg =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_afda *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgdb :=ctx ;var _ecgd []*Block ;_egbgf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _afda ._fdab .isRelative (){ctx .X +=_afda ._gca ._ddcg ;ctx .Y +=_afda ._gca ._fdfb ;ctx .Width -=_afda ._gca ._ddcg +_afda ._gca ._bcde ;ctx .Height -=_afda ._gca ._fdfb +_afda ._gca ._dfbb ;_afda .SetWidth (ctx .Width );if _afda .Height ()> ctx .Height {_ecgd =append (_ecgd ,_egbgf );_egbgf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ffde :=ctx ;_ffde .Y =ctx .Margins ._fdfb ;_ffde .X =ctx .Margins ._ddcg +_afda ._gca ._ddcg ;_ffde .Height =ctx .PageHeight -ctx .Margins ._fdfb -ctx .Margins ._dfbb -_afda ._gca ._dfbb ;_ffde .Width =ctx .PageWidth -ctx .Margins ._ddcg -ctx .Margins ._bcde -_afda ._gca ._ddcg -_afda ._gca ._bcde ;ctx =_ffde ;};}else {if int (_afda ._bae )<=0{_afda .SetWidth (_afda .getTextWidth ());};ctx .X =_afda ._fcce ;ctx .Y =_afda ._gdca ;};ctx ,_ffdg :=_fegg (_egbgf ,_afda ,ctx );if _ffdg !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffdg );return nil ,ctx ,_ffdg ;};_ecgd =append (_ecgd ,_egbgf );if _afda ._fdab .isRelative (){ctx .X -=_afda ._gca ._ddcg ;ctx .Width =_fgdb .Width ;return _ecgd ,ctx ,nil ;};return _ecgd ,_fgdb ,nil ;};

// Inline returns whether the inline mode of the division is active.
func (_aefg *Division )Inline ()bool {return _aefg ._ggfb };

// SetAngle sets the rotation angle of the text.
func (_ffbad *StyledParagraph )SetAngle (angle float64 ){_ffbad ._ebae =angle };

// Width returns the width of the Paragraph.
func (_gbde *StyledParagraph )Width ()float64 {if _gbde ._caeb &&int (_gbde ._caga )> 0{return _gbde ._caga ;};return _gbde .getTextWidth ()/1000.0;};

// NewImageFromFile creates an Image from a file.
func (_dgcca *Creator )NewImageFromFile (path string )(*Image ,error ){return _gdcf (path )};func _gdfg (_dfdb _bd .Image )(*Image ,error ){_aagb ,_gfaa :=_fd .ImageHandling .NewImageFromGoImage (_dfdb );if _gfaa !=nil {return nil ,_gfaa ;};return _bffed (_aagb );};func (_bada *Invoice )drawSection (_dcdd ,_ggfbe string )[]*StyledParagraph {var _agd []*StyledParagraph ;if _dcdd !=""{_fdff :=_fcfg (_bada ._acfa );_fdff .SetMargins (0,0,0,5);_fdff .Append (_dcdd );_agd =append (_agd ,_fdff );};if _ggfbe !=""{_caaa :=_fcfg (_bada ._bcaea );_caaa .Append (_ggfbe );_agd =append (_agd ,_caaa );};return _agd ;};func (_aa *Block )setOpacity (_dff float64 ,_bce float64 )(string ,error ){if (_dff < 0||_dff >=1.0)&&(_bce < 0||_bce >=1.0){return "",nil ;};_bff :=0;_agc :=_dg .Sprintf ("\u0047\u0053\u0025\u0064",_bff );for _aa ._eg .HasExtGState (_ag .PdfObjectName (_agc )){_bff ++;_agc =_dg .Sprintf ("\u0047\u0053\u0025\u0064",_bff );};_ea :=_ag .MakeDict ();if _dff >=0&&_dff < 1.0{_ea .Set ("\u0063\u0061",_ag .MakeFloat (_dff ));};if _bce >=0&&_bce < 1.0{_ea .Set ("\u0043\u0041",_ag .MakeFloat (_bce ));};_ga :=_aa ._eg .AddExtGState (_ag .PdfObjectName (_agc ),_ea );if _ga !=nil {return "",_ga ;};return _agc ,nil ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bed *Block )ScaleToWidth (w float64 ){_gee :=w /_bed ._bfd ;_bed .Scale (_gee ,_gee )};

// SetMargins sets the margins of the paragraph.
func (_fccg *List )SetMargins (left ,right ,top ,bottom float64 ){_fccg ._egda ._ddcg =left ;_fccg ._egda ._bcde =right ;_fccg ._egda ._fdfb =top ;_fccg ._egda ._dfbb =bottom ;};func _fegg (_dead *Block ,_aadbe *Paragraph ,_bgcc DrawContext )(DrawContext ,error ){_cbda :=1;_aafe :=_ag .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ce .Itoa (_cbda ));for _dead ._eg .HasFontByName (_aafe ){_cbda ++;_aafe =_ag .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ce .Itoa (_cbda ));};_cgdgb :=_dead ._eg .SetFontByName (_aafe ,_aadbe ._adfg .ToPdfObject ());if _cgdgb !=nil {return _bgcc ,_cgdgb ;};_aadbe .wrapText ();_baec :=_bc .NewContentCreator ();_baec .Add_q ();_beaf :=_bgcc .PageHeight -_bgcc .Y -_aadbe ._abeb *_aadbe ._fffc ;_baec .Translate (_bgcc .X ,_beaf );if _aadbe ._gcfcg !=0{_baec .RotateDeg (_aadbe ._gcfcg );};_baec .Add_BT ().Add_rg (_aadbe ._edccg .R (),_aadbe ._edccg .G (),_aadbe ._edccg .B ()).Add_Tf (_aafe ,_aadbe ._abeb ).Add_TL (_aadbe ._abeb *_aadbe ._fffc );for _fcbcg ,_bgcb :=range _aadbe ._eedg {if _fcbcg !=0{_baec .Add_Tstar ();};_gdaaf :=[]rune (_bgcb );_cbdg :=0.0;_ffbb :=0;for _ebfbd ,_baf :=range _gdaaf {if _baf ==' '{_ffbb ++;continue ;};if _baf =='\u000A'{continue ;};_fbaed ,_eebce :=_aadbe ._adfg .GetRuneMetrics (_baf );if !_eebce {_bf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_ebfbd ,_baf ,_baf ,_aadbe ._adfg .BaseFont (),_aadbe ._adfg .Subtype ());return _bgcc ,_cb .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_cbdg +=_aadbe ._abeb *_fbaed .Wx ;};var _abga []_ag .PdfObject ;_facf ,_afef :=_aadbe ._adfg .GetRuneMetrics (' ');if !_afef {return _bgcc ,_cb .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_cfeg :=_facf .Wx ;switch _aadbe ._ffaa {case TextAlignmentJustify :if _ffbb > 0&&_fcbcg < len (_aadbe ._eedg )-1{_cfeg =(_aadbe ._bae *1000.0-_cbdg )/float64 (_ffbb )/_aadbe ._abeb ;};case TextAlignmentCenter :_geffe :=_cbdg +float64 (_ffbb )*_cfeg *_aadbe ._abeb ;_abfde :=(_aadbe ._bae *1000.0-_geffe )/2/_aadbe ._abeb ;_abga =append (_abga ,_ag .MakeFloat (-_abfde ));case TextAlignmentRight :_cfff :=_cbdg +float64 (_ffbb )*_cfeg *_aadbe ._abeb ;_dedf :=(_aadbe ._bae *1000.0-_cfff )/_aadbe ._abeb ;_abga =append (_abga ,_ag .MakeFloat (-_dedf ));};_aeff :=_aadbe ._adfg .Encoder ();var _acda []byte ;for _ ,_cdcad :=range _gdaaf {if _cdcad =='\u000A'{continue ;};if _cdcad ==' '{if len (_acda )> 0{_abga =append (_abga ,_ag .MakeStringFromBytes (_acda ));_acda =nil ;};_abga =append (_abga ,_ag .MakeFloat (-_cfeg ));}else {if _ ,_dbeb :=_aeff .RuneToCharcode (_cdcad );!_dbeb {_bf .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cdcad ,_cdcad );continue ;};_acda =append (_acda ,_aeff .Encode (string (_cdcad ))...);};};if len (_acda )> 0{_abga =append (_abga ,_ag .MakeStringFromBytes (_acda ));};_baec .Add_TJ (_abga ...);};_baec .Add_ET ();_baec .Add_Q ();_adgf :=_baec .Operations ();_adgf .WrapIfNeeded ();_dead .addContents (_adgf );if _aadbe ._fdab .isRelative (){_gffd :=_aadbe .Height ()+_aadbe ._gca ._dfbb ;_bgcc .Y +=_gffd ;_bgcc .Height -=_gffd ;if _bgcc .Inline {_bgcc .X +=_aadbe .Width ()+_aadbe ._gca ._bcde ;};};return _bgcc ,nil ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_edcd *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_edcd ._ecad {_bf .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _cb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_edcd ._ggdf =widths ;return nil ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_fceg *StyledParagraph )SetText (text string )*TextChunk {_fceg .Reset ();return _fceg .Append (text );};

// DrawFooter sets a function to draw a footer on created output pages.
func (_gdge *Creator )DrawFooter (drawFooterFunc func (_cga *Block ,_cdfd FooterFunctionArgs )){_gdge ._gff =drawFooterFunc ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_ebf *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_abag :=uint (len (_ebf ._cagd ));if index > _abag {index =_abag ;};_gdgc :=_ebf .NewColumn (description );_ebf ._cagd =append (_ebf ._cagd [:index ],append ([]*InvoiceCell {_gdgc },_ebf ._cagd [index :]...)...);return _gdgc ;};

// SetStyleRight sets border style for right side.
func (_gfb *border )SetStyleRight (style CellBorderStyle ){_gfb ._eggd =style };func (_bcdc *Paragraph )getTextLineWidth (_gdcb string )float64 {var _aegda float64 ;for _ ,_face :=range _gdcb {if _face =='\u000A'{continue ;};_fbfc ,_fecce :=_bcdc ._adfg .GetRuneMetrics (_face );if !_fecce {_bf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_face ,_face );return -1;};_aegda +=_bcdc ._abeb *_fbfc .Wx ;};return _aegda ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_gcbb *TOC )SetLineTitleStyle (style TextStyle ){_gcbb ._bfad =style };

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_cfedf *Division )Width ()float64 {return 0};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ddcc *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fee float64 ;var _fccd []*StyledParagraph ;for _ ,_fecc :=range _ddcc ._eebf {_eggb :=_fcfg (_ddcc ._ebfa );_eggb .SetEnableWrap (false );_eggb .SetTextAlignment (TextAlignmentRight );_eggb .Append (_fecc ._bfdc .Text ).Style =_fecc ._bfdc .Style ;_gafe :=_eggb .getTextWidth ()/1000.0/ctx .Width ;if _fee < _gafe {_fee =_gafe ;};_fccd =append (_fccd ,_eggb );};_ccfc :=_egge (2);_ccfc .SetColumnWidths (_fee ,1-_fee );_ccfc .SetMargins (_ddcc ._fgce ,0,0,0);for _ffba ,_cfb :=range _ddcc ._eebf {_gccb :=_ccfc .NewCell ();_gccb .SetIndent (0);_gccb .SetContent (_fccd [_ffba ]);_gccb =_ccfc .NewCell ();_gccb .SetIndent (0);_gccb .SetContent (_cfb ._bfea );};return _ccfc .GeneratePageBlocks (ctx );};

// SetFillColor sets the fill color.
func (_gba *Ellipse )SetFillColor (col Color ){_gba ._cffd =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};func (_ffbf *StyledParagraph )getTextWidth ()float64 {var _efgf float64 ;_edff :=len (_ffbf ._dddd );for _dfbe ,_fdee :=range _ffbf ._dddd {_afg :=&_fdee .Style ;_dded :=len (_fdee .Text );for _agag ,_adfe :=range _fdee .Text {if _adfe =='\u000A'{continue ;};_dabg ,_bcbg :=_afg .Font .GetRuneMetrics (_adfe );if !_bcbg {_bf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_adfe );return -1;};_efgf +=_afg .FontSize *_dabg .Wx ;if _adfe !=' '&&(_dfbe !=_edff -1||_agag !=_dded -1){_efgf +=_afg .CharSpacing *1000.0;};};};return _efgf ;};

// SetBorderOpacity sets the border opacity.
func (_fdgaf *Polygon )SetBorderOpacity (opacity float64 ){_fdgaf ._acdab =opacity };

// DrawHeader sets a function to draw a header on created output pages.
func (_faca *Creator )DrawHeader (drawHeaderFunc func (_abab *Block ,_aebc HeaderFunctionArgs )){_faca ._gfc =drawHeaderFunc ;};

// SetLineColor sets the line color.
func (_abbaf *Polyline )SetLineColor (color Color ){_abbaf ._bdbge .LineColor =_fd .NewPdfColorDeviceRGB (color .ToRGB ());};func _ggdg (_fdafb *_fd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_fdafb ,FontSize :10};};

// SetBuyerAddress sets the buyer address of the invoice.
func (_adffa *Invoice )SetBuyerAddress (address *InvoiceAddress ){_adffa ._edg =address };

// SetBorderOpacity sets the border opacity.
func (_fece *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_fece ._dfgd =opacity };

// Scale scales Image by a constant factor, both width and height.
func (_egcf *Image )Scale (xFactor ,yFactor float64 ){_egcf ._aggc =xFactor *_egcf ._aggc ;_egcf ._efgg =yFactor *_egcf ._efgg ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_faab *Invoice )SetNoteStyle (style TextStyle ){_faab ._bcaea =style };

// AddSection adds a new content section at the end of the invoice.
func (_fdgf *Invoice )AddSection (title ,content string ){_fdgf ._aaac =append (_fdgf ._aaac ,[2]string {title ,content });};

// NewCellProps returns the default properties of an invoice cell.
func (_acgae *Invoice )NewCellProps ()InvoiceCellProps {_badg :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_acgae ._cfcd ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_badg ,BorderColor :_badg ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};func (_agb *List )tableHeight (_cefb float64 )float64 {var _gdfa float64 ;for _ ,_ecdc :=range _agb ._eebf {switch _aadc :=_ecdc ._bfea .(type ){case *Paragraph :_cafc :=_aadc ;if _cafc ._bffef {_cafc .SetWidth (_cefb );};_gdfa +=_cafc .Height ()+_cafc ._gca ._dfbb +_cafc ._gca ._dfbb ;_gdfa +=0.5*_cafc ._abeb *_cafc ._fffc ;case *StyledParagraph :_bdd :=_aadc ;if _bdd ._caeb {_bdd .SetWidth (_cefb );};_gdfa +=_bdd .Height ()+_bdd ._egeg ._fdfb +_bdd ._egeg ._dfbb ;_gdfa +=0.5*_bdd .getTextHeight ();default:_gdfa +=_ecdc ._bfea .Height ();};};return _gdfa ;};

// SetFillOpacity sets the fill opacity.
func (_ffdbe *Rectangle )SetFillOpacity (opacity float64 ){_ffdbe ._facgb =opacity };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_ggde *Paragraph )Height ()float64 {_ggde .wrapText ();return float64 (len (_ggde ._eedg ))*_ggde ._fffc *_ggde ._abeb ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_ffcbc *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _cb .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _cb .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _cb .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_ffcbc ._gffc =true ;_ffcbc ._ddgf =startRow ;_ffcbc ._fcfgg =endRow ;return nil ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_aeag :=rgbColor {};_aeag ._fffg =float64 (r )/255.0;_aeag ._cdgb =float64 (g )/255.0;_aeag ._cbc =float64 (b )/255.0;return _aeag ;};

// Height returns the height of the list.
func (_edaff *List )Height ()float64 {var _bbbee float64 ;for _ ,_beaa :=range _edaff ._eebf {_bbbee +=_beaa ._bfea .Height ();};return _bbbee ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_fbfgb *Table )MultiColCell (colspan int )*TableCell {return _fbfgb .newCell (colspan )};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_cdcgf *Invoice )AddressStyle ()TextStyle {return _cdcgf ._eaca };

// RotatedSize returns the width and height of the rotated block.
func (_gd *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_bfg ,_cda :=_dcfb (_gd ._bfd ,_gd ._cea ,_gd ._fa );return _bfg ,_cda ;};func _ebdaa (_fgbe *_fd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_fgbe ,FontSize :10};};func _aabg (_edgd []_a .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_ebca :&_a .PolyBezierCurve {Curves :_edgd ,BorderColor :_fd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_ggfd :1.0,_dfgd :1.0};};type margins struct{_ddcg float64 ;_bcde float64 ;_fdfb float64 ;_dfbb float64 ;};

// Height returns the current page height.
func (_ada *Creator )Height ()float64 {return _ada ._gce };

// SetWidthBottom sets border width for bottom.
func (_gdbf *border )SetWidthBottom (bw float64 ){_gdbf ._eccb =bw };

// Level returns the indentation level of the TOC line.
func (_debfa *TOCLine )Level ()uint {return _debfa ._efdc };func (_cgbd *Invoice )newCell (_fad string ,_gffa InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_gffa ,_fad };};

// SetWidthRight sets border width for right.
func (_abe *border )SetWidthRight (bw float64 ){_abe ._gdec =bw };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_adc *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _adc ._ffdb [0],_adc ._ffdb [1]};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_dddd []*TextChunk ;_agde TextStyle ;_beaag TextStyle ;_adfac TextAlignment ;_bacad float64 ;_caeb bool ;_caga float64 ;_fcdg bool ;_ebae float64 ;_egeg margins ;_ggec positioning ;_afbf float64 ;_edbad float64 ;_bacae float64 ;_fggd float64 ;_cfbb [][]*TextChunk ;_fdabb func (_eedd *StyledParagraph ,_febe DrawContext );};func (_aagdb *TOCLine )prepareParagraph (_eegfe *StyledParagraph ,_cgdd DrawContext ){_aeafe :=_aagdb .Title .Text ;if _aagdb .Number .Text !=""{_aeafe ="\u0020"+_aeafe ;};_aeafe +="\u0020";_fcgb :=_aagdb .Page .Text ;if _fcgb !=""{_fcgb ="\u0020"+_fcgb ;};_eegfe ._dddd =[]*TextChunk {{Text :_aagdb .Number .Text ,Style :_aagdb .Number .Style ,_edgdf :_aagdb .getLineLink ()},{Text :_aeafe ,Style :_aagdb .Title .Style ,_edgdf :_aagdb .getLineLink ()},{Text :_fcgb ,Style :_aagdb .Page .Style ,_edgdf :_aagdb .getLineLink ()}};_eegfe .wrapText ();_ecbg :=len (_eegfe ._cfbb );if _ecbg ==0{return ;};_fdfc :=_cgdd .Width *1000-_eegfe .getTextLineWidth (_eegfe ._cfbb [_ecbg -1]);_bgedd :=_eegfe .getTextLineWidth ([]*TextChunk {&_aagdb .Separator });_ddgga :=int (_fdfc /_bgedd );_bcgda :=_bg .Repeat (_aagdb .Separator .Text ,_ddgga );_bfc :=_aagdb .Separator .Style ;_gabd :=_eegfe .Insert (2,_bcgda );_gabd .Style =_bfc ;_gabd ._edgdf =_aagdb .getLineLink ();_fdfc =_fdfc -float64 (_ddgga )*_bgedd ;if _fdfc > 500{_fcge ,_eddb :=_bfc .Font .GetRuneMetrics (' ');if _eddb &&_fdfc > _fcge .Wx {_bffge :=int (_fdfc /_fcge .Wx );if _bffge > 0{_cgcb :=_bfc ;_cgcb .FontSize =1;_gabd =_eegfe .Insert (2,_bg .Repeat ("\u0020",_bffge ));_gabd .Style =_cgcb ;_gabd ._edgdf =_aagdb .getLineLink ();};};};};

// Heading returns the heading component of the table of contents.
func (_dacd *TOC )Heading ()*StyledParagraph {return _dacd ._ebcb };

// SetText sets the text content of the Paragraph.
func (_aebe *Paragraph )SetText (text string ){_aebe ._cgag =text };

// NewList creates a new list.
func (_cff *Creator )NewList ()*List {return _ebfc (_cff .NewTextStyle ())};

// Add adds a new line with the default style to the table of contents.
func (_gac *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_bbedf :=_gac .AddLine (_feddb (TextChunk {Text :number ,Style :_gac ._dege },TextChunk {Text :title ,Style :_gac ._bfad },TextChunk {Text :page ,Style :_gac ._gggd },level ,_gac ._bffg ));if _bbedf ==nil {return nil ;};_ebbd :=&_gac ._ecgfe ;_bbedf .SetMargins (_ebbd ._ddcg ,_ebbd ._bcde ,_ebbd ._fdfb ,_ebbd ._dfbb );_bbedf .SetLevelOffset (_gac ._ababg );_bbedf .Separator .Text =_gac ._adfee ;_bbedf .Separator .Style =_gac ._ecbb ;return _bbedf ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_fdbb *Invoice )InfoLines ()[][2]*InvoiceCell {_abbc :=[][2]*InvoiceCell {_fdbb ._aafc ,_fdbb ._agae ,_fdbb ._ffdb };return append (_abbc ,_fdbb ._abcf ...);};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_de :=&Block {};_de ._ed =&_bc .ContentStreamOperations {};_de ._eg =_fd .NewPdfPageResources ();_de ._bfd =width ;_de ._cea =height ;return _de ;};func _ebfc (_ggacd TextStyle )*List {return &List {_dfba :TextChunk {Text :"\u2022\u0020",Style :_ggacd },_fgce :0,_bfeb :true ,_befb :_ffgbd ,_ebfa :_ggacd };};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetWidthTop sets border width for top.
func (_gdff *border )SetWidthTop (bw float64 ){_gdff ._cebd =bw };

// Lines returns all the lines the table of contents has.
func (_gcbf *TOC )Lines ()[]*TOCLine {return _gcbf ._cgee };

// NewCell returns a new invoice table cell.
func (_ffaefe *Invoice )NewCell (value string )*InvoiceCell {return _ffaefe .newCell (value ,_ffaefe .NewCellProps ());};

// Width returns the width of the Paragraph.
func (_cdfg *Paragraph )Width ()float64 {if _cdfg ._bffef &&int (_cdfg ._bae )> 0{return _cdfg ._bae ;};return _cdfg .getTextWidth ()/1000.0;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bedf *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bedf ._gca ._ddcg ,_bedf ._gca ._bcde ,_bedf ._gca ._fdfb ,_bedf ._gca ._dfbb ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_geb *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _geb ._aafc [0],_geb ._aafc [1]};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_gcbdc *Invoice )TotalLines ()[][2]*InvoiceCell {_faffa :=[][2]*InvoiceCell {_gcbdc ._gbgc };_faffa =append (_faffa ,_gcbdc ._fbbc ...);return append (_faffa ,_gcbdc ._egef );};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_eea int ;_bfb string ;_cdf *Paragraph ;_cfd []Drawable ;_abec int ;_ffd bool ;_ggf bool ;_ebg positioning ;_adff ,_cdae float64 ;_deg margins ;_ddfa *Chapter ;_fdc *TOC ;_fffe *_fd .Outline ;_fdbc *_fd .OutlineItem ;_bgfa uint ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_bad *Creator )Finalize ()error {if _bad ._dbgc {return nil ;};_gcg :=len (_bad ._deee );_ece :=0;if _bad ._fbcg !=nil {_ece ++;};if _bad .AddTOC {_bad .initContext ();_bad ._gfg .Page =_ece +1;if _bad ._ebb !=nil {if _egeb :=_bad ._ebb (_bad ._fgbg );_egeb !=nil {return _egeb ;};};_fddb ,_ ,_dga :=_bad ._fgbg .GeneratePageBlocks (_bad ._gfg );if _dga !=nil {_bf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_dga );return _dga ;};_ece +=len (_fddb );_abd :=_bad ._fgbg .Lines ();for _ ,_bdcbe :=range _abd {_dfd ,_eadd :=_ce .Atoi (_bdcbe .Page .Text );if _eadd !=nil {continue ;};_bdcbe .Page .Text =_ce .Itoa (_dfd +_ece );};};_egbd :=false ;if _bad ._fbcg !=nil {_gcg ++;_begf :=_bad .newPage ();_bad ._deee =append ([]*_fd .PdfPage {_begf },_bad ._deee ...);_bad .setActivePage (_begf );_cfce :=FrontpageFunctionArgs {PageNum :1,TotalPages :_gcg };_bad ._fbcg (_cfce );_egbd =true ;};if _bad .AddTOC {_bad .initContext ();if _bad ._ebb !=nil {if _gbbf :=_bad ._ebb (_bad ._fgbg );_gbbf !=nil {_bf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_gbbf );return _gbbf ;};};_gfe :=_bad ._fgbg .Lines ();for _ ,_gdgf :=range _gfe {_gdgf ._afccd +=int64 (_ece );};var _cefe []*_fd .PdfPage ;_eebc ,_ ,_ :=_bad ._fgbg .GeneratePageBlocks (_bad ._gfg );for _ ,_fgbb :=range _eebc {_fgbb .SetPos (0,0);_gcg ++;_fdec :=_bad .newPage ();_cefe =append (_cefe ,_fdec );_bad .setActivePage (_fdec );_bad .Draw (_fgbb );};if _egbd {_fbb :=_bad ._deee [0];_bgb :=_bad ._deee [1:];_bad ._deee =append ([]*_fd .PdfPage {_fbb },_cefe ...);_bad ._deee =append (_bad ._deee ,_bgb ...);}else {_bad ._deee =append (_cefe ,_bad ._deee ...);};};if _bad ._egcg !=nil &&_bad .AddOutlines {var _cad func (_gdeg *_fd .OutlineItem );_cad =func (_ebbb *_fd .OutlineItem ){_ebbb .Dest .Page +=int64 (_ece );if _gbbb :=int (_ebbb .Dest .Page );_gbbb >=0&&_gbbb < len (_bad ._deee ){_ebbb .Dest .PageObj =_bad ._deee [_gbbb ].GetPageAsIndirectObject ();}else {_bf .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gbbb );};_ebbb .Dest .Y =_bad ._gce -_ebbb .Dest .Y ;_edbd :=_ebbb .Items ();for _ ,_ffge :=range _edbd {_cad (_ffge );};};_bgce :=_bad ._egcg .Items ();for _ ,_dcd :=range _bgce {_cad (_dcd );};if _bad .AddTOC {var _acaa int ;if _egbd {_acaa =1;};_eddfe :=_fd .NewOutlineDest (int64 (_acaa ),0,_bad ._gce );if _acaa >=0&&_acaa < len (_bad ._deee ){_eddfe .PageObj =_bad ._deee [_acaa ].GetPageAsIndirectObject ();}else {_bf .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_acaa );};_bad ._egcg .Insert (0,_fd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_eddfe ));};};for _dbbc ,_cbef :=range _bad ._deee {_bad .setActivePage (_cbef );if _bad ._gfc !=nil {_egde :=NewBlock (_bad ._eggf ,_bad ._bcg ._fdfb );_bgfb :=HeaderFunctionArgs {PageNum :_dbbc +1,TotalPages :_gcg };_bad ._gfc (_egde ,_bgfb );_egde .SetPos (0,0);if _gcdg :=_bad .Draw (_egde );_gcdg !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_gcdg );return _gcdg ;};};if _bad ._gff !=nil {_deda :=NewBlock (_bad ._eggf ,_bad ._bcg ._dfbb );_fgag :=FooterFunctionArgs {PageNum :_dbbc +1,TotalPages :_gcg };_bad ._gff (_deda ,_fgag );_deda .SetPos (0,_bad ._gce -_deda ._cea );if _ffgc :=_bad .Draw (_deda );_ffgc !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_ffgc );return _ffgc ;};};_cbcc ,_ddgg :=_bad ._dag [_cbef ];if !_ddgg {continue ;};if _bba :=_cbcc .drawToPage (_cbef );_bba !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_dbbc +1,_bba );return _bba ;};};_bad ._dbgc =true ;return nil ;};func _ebbe (_bgga string ,_cdda ,_egdg TextStyle )*TOC {_adeae :=_egdg ;_adeae .FontSize =14;_aefc :=_fcfg (_adeae );_aefc .SetEnableWrap (true );_aefc .SetTextAlignment (TextAlignmentLeft );_aefc .SetMargins (0,0,0,5);_afffb :=_aefc .Append (_bgga );_afffb .Style =_adeae ;return &TOC {_ebcb :_aefc ,_cgee :[]*TOCLine {},_dege :_cdda ,_bfad :_cdda ,_ecbb :_cdda ,_gggd :_cdda ,_adfee :"\u002e",_ababg :10,_ecgfe :margins {0,0,2,2},_febd :_ffgbd ,_bffg :_cdda ,_efbfc :true };};

// CreateTableOfContents sets a function to generate table of contents.
func (_cgbe *Creator )CreateTableOfContents (genTOCFunc func (_fbac *TOC )error ){_cgbe ._ebb =genTOCFunc ;};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_dbge *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _cdbg []*Block ;_daec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cbebg :=ctx ;if _dbge ._ecee .isAbsolute (){ctx .X =_dbge ._ggcag ;ctx .Y =_dbge ._gfbfg ;}else {ctx .X +=_dbge ._gefb ._ddcg ;ctx .Y +=_dbge ._gefb ._fdfb ;ctx .Width -=_dbge ._gefb ._ddcg +_dbge ._gefb ._bcde ;ctx .Height -=_dbge ._gefb ._dfbb +_dbge ._gefb ._fdfb ;};_cdac :=ctx .Width ;_gffaa :=ctx .X ;_debf :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._dfbb ;_gbdc :=ctx .Height ;_ade :=0;_cgbb :=-1;_gfdc :=-1;for _edea ,_gceg :=range _dbge ._gefc {_defb :=float64 (0.0);for _fecdb :=0;_fecdb < _gceg ._aaec ;_fecdb ++{_defb +=_dbge ._ggdf [_gceg ._ebbf +_fecdb -1];};_eadf :=float64 (0.0);for _ecebg :=0;_ecebg < _gceg ._ebbf -1;_ecebg ++{_eadf +=_dbge ._ggdf [_ecebg ]*_cdac ;};_ceea :=float64 (0.0);for _fcdf :=_ade ;_fcdf < _gceg ._ecef -1;_fcdf ++{_ceea +=_dbge ._badeg [_fcdf ];};_agff :=_defb *_cdac ;_eggdf :=float64 (0.0);for _gfcg :=0;_gfcg < _gceg ._dfge ;_gfcg ++{_eggdf +=_dbge ._badeg [_gceg ._ecef +_gfcg -1];};if _dbge ._gffc {if _gceg ._ecef >=_dbge ._ddgf &&_gceg ._ecef <=_dbge ._fcfgg {if _cgbb < 0{_cgbb =_edea ;};_gfdc =_edea ;};};switch _cdbf :=_gceg ._abeag .(type ){case *Paragraph :_fdcb :=_cdbf ;if _fdcb ._bffef {_fdcb .SetWidth (_agff -_gceg ._dfag );};_gbdb :=_fdcb .Height ()+_fdcb ._gca ._dfbb +_fdcb ._gca ._dfbb ;_gbdb +=0.5*_fdcb ._abeb *_fdcb ._fffc ;if _gbdb > _eggdf {_cfdc :=_gbdb -_eggdf ;_dbge ._badeg [_gceg ._ecef +_gceg ._dfge -2]+=_cfdc ;};case *StyledParagraph :_cdeb :=_cdbf ;if _cdeb ._caeb {_cdeb .SetWidth (_agff -_gceg ._dfag );};_bcdcf :=_cdeb .Height ()+_cdeb ._egeg ._fdfb +_cdeb ._egeg ._dfbb ;_bcdcf +=0.5*_cdeb .getTextHeight ();if _bcdcf > _eggdf {_edfae :=_bcdcf -_eggdf ;_dbge ._badeg [_gceg ._ecef +_gceg ._dfge -2]+=_edfae ;};case *Image :_faggg :=_cdbf ;_fgacg :=_faggg .Height ()+_faggg ._ecba ._fdfb +_faggg ._ecba ._dfbb ;if _fgacg > _eggdf {_gbgb :=_fgacg -_eggdf ;_dbge ._badeg [_gceg ._ecef +_gceg ._dfge -2]+=_gbgb ;};case *Table :_dgfe :=_cdbf ;_ggab :=_dgfe .Height ()+_dgfe ._gefb ._fdfb +_dgfe ._gefb ._dfbb ;if _ggab > _eggdf {_faaf :=_ggab -_eggdf ;_dbge ._badeg [_gceg ._ecef +_gceg ._dfge -2]+=_faaf ;};case *List :_fcec :=_cdbf ;_adea :=_fcec .tableHeight (_agff -_gceg ._dfag )+_fcec ._egda ._fdfb +_fcec ._egda ._dfbb ;if _adea > _eggdf {_bgfde :=_adea -_eggdf ;_dbge ._badeg [_gceg ._ecef +_gceg ._dfge -2]+=_bgfde ;};case *Division :_gbab :=_cdbf ;_bdeg :=ctx ;_bdeg .X =_eadf ;_bdeg .Y =_ceea ;_bdeg .Width =_agff ;_ecdd ,_ ,_bcgd :=_gbab .GeneratePageBlocks (_bdeg );if _bcgd !=nil {return nil ,ctx ,_bcgd ;};if len (_ecdd )> 1{_bbae :=_bdeg .Height -_eggdf ;if _bbae > _eggdf {_bgca :=_bbae -_eggdf ;_dbge ._badeg [_gceg ._ecef +_gceg ._dfge -2]+=_bgca ;};};_dgac :=_gbab .Height ()+_gbab ._dadf ._fdfb +_gbab ._dadf ._dfbb ;if _dgac > _eggdf {_ebdc :=_dgac -_eggdf ;_dbge ._badeg [_gceg ._ecef +_gceg ._dfge -2]+=_ebdc ;};};};var _dcfd bool ;var _edde ,_edbdd int ;for _bffdcf :=0;_bffdcf < len (_dbge ._gefc );_bffdcf ++{_geddb :=_dbge ._gefc [_bffdcf ];_agdc :=float64 (0.0);for _beec :=0;_beec < _geddb ._aaec ;_beec ++{_agdc +=_dbge ._ggdf [_geddb ._ebbf +_beec -1];};_eedc :=float64 (0.0);for _agad :=0;_agad < _geddb ._ebbf -1;_agad ++{_eedc +=_dbge ._ggdf [_agad ]*_cdac ;};_dbef :=float64 (0.0);for _eaaef :=_ade ;_eaaef < _geddb ._ecef -1;_eaaef ++{_dbef +=_dbge ._badeg [_eaaef ];};_ebcgf :=_agdc *_cdac ;_cdcc :=float64 (0.0);for _decba :=0;_decba < _geddb ._dfge ;_decba ++{_cdcc +=_dbge ._badeg [_geddb ._ecef +_decba -1];};ctx .Height =_gbdc -_dbef ;if _cdcc > ctx .Height {_cdbg =append (_cdbg ,_daec );_daec =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gffaa =ctx .Margins ._ddcg ;_debf =ctx .Margins ._fdfb ;ctx .Height =ctx .PageHeight -ctx .Margins ._fdfb -ctx .Margins ._dfbb ;ctx .Page ++;_gbdc =ctx .Height ;_ade =_geddb ._ecef -1;_dbef =0;if _dbge ._gffc &&_cgbb >=0{_edde =_bffdcf ;_bffdcf =_cgbb -1;_edbdd =_ade ;_ade =_dbge ._ddgf -1;_dcfd =true ;continue ;};};ctx .Width =_ebcgf ;ctx .X =_gffaa +_eedc ;ctx .Y =_debf +_dbef ;_fcbf :=_beda (ctx .X ,ctx .Y ,_ebcgf ,_cdcc );if _geddb ._ebeg !=nil {_cbgcf :=_geddb ._ebeg .R ();_faac :=_geddb ._ebeg .G ();_eddcc :=_geddb ._ebeg .B ();_fcbf .SetFillColor (ColorRGBFromArithmetic (_cbgcf ,_faac ,_eddcc ));};_fcbf .LineStyle =_geddb ._ccca ;_fcbf ._ad =_geddb ._begbb ;_fcbf ._eggd =_geddb ._dage ;_fcbf ._debg =_geddb ._bcgbe ;_fcbf ._acge =_geddb ._cdea ;if _geddb ._gfcd !=nil {_fcbf .SetColorLeft (ColorRGBFromArithmetic (_geddb ._gfcd .R (),_geddb ._gfcd .G (),_geddb ._gfcd .B ()));};if _geddb ._cgfcg !=nil {_fcbf .SetColorBottom (ColorRGBFromArithmetic (_geddb ._cgfcg .R (),_geddb ._cgfcg .G (),_geddb ._cgfcg .B ()));};if _geddb ._cfcgf !=nil {_fcbf .SetColorRight (ColorRGBFromArithmetic (_geddb ._cfcgf .R (),_geddb ._cfcgf .G (),_geddb ._cfcgf .B ()));};if _geddb ._ecgc !=nil {_fcbf .SetColorTop (ColorRGBFromArithmetic (_geddb ._ecgc .R (),_geddb ._ecgc .G (),_geddb ._ecgc .B ()));};_fcbf .SetWidthBottom (_geddb ._ebce );_fcbf .SetWidthLeft (_geddb ._dfee );_fcbf .SetWidthRight (_geddb ._facge );_fcbf .SetWidthTop (_geddb ._aece );_cfag :=_daec .Draw (_fcbf );if _cfag !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cfag );};if _geddb ._abeag !=nil {_ddfaed :=_geddb ._abeag .Width ();_efaf :=_geddb ._abeag .Height ();_ddgd :=0.0;switch _baff :=_geddb ._abeag .(type ){case *Paragraph :if _baff ._bffef {_ddfaed =_baff .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _baff ._caeb {_ddfaed =_baff .getMaxLineWidth ()/1000.0;};_gbabb ,_cbebc :=_baff .getLineHeight (0);if len (_baff ._cfbb )==1{_efaf =_gbabb ;}else {_efaf =_efaf -_cbebc +_gbabb ;};_ddgd =_gbabb -_cbebc ;switch _geddb ._deegc {case CellVerticalAlignmentTop :_ddgd +=_gbabb *0.5;case CellVerticalAlignmentBottom :_ddgd -=_gbabb *0.5;};case *Table :_ddfaed =_ebcgf ;case *List :_ddfaed =_ebcgf ;};switch _geddb ._aabb {case CellHorizontalAlignmentLeft :ctx .X +=_geddb ._dfag ;ctx .Width -=_geddb ._dfag ;case CellHorizontalAlignmentCenter :_abeeg :=_ebcgf -_ddfaed ;if _abeeg > 0{ctx .X +=_abeeg /2;ctx .Width -=_abeeg /2;};case CellHorizontalAlignmentRight :if _ebcgf > _ddfaed {ctx .X =ctx .X +_ebcgf -_ddfaed -_geddb ._dfag ;ctx .Width -=_geddb ._dfag ;};};ctx .Y +=_ddgd ;switch _geddb ._deegc {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_daeb :=_cdcc -_efaf ;if _daeb > 0{ctx .Y +=_daeb /2;ctx .Height -=_daeb /2;};case CellVerticalAlignmentBottom :if _cdcc > _efaf {ctx .Y =ctx .Y +_cdcc -_efaf ;ctx .Height =_cdcc ;};};_ffdbg :=_daec .DrawWithContext (_geddb ._abeag ,ctx );if _ffdbg !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffdbg );};ctx .Y -=_ddgd ;};ctx .Y +=_cdcc ;ctx .Height -=_cdcc ;if _dcfd &&_bffdcf +1> _gfdc {_debf +=_dbef +_cdcc ;_gbdc -=_cdcc +_dbef ;_ade =_edbdd ;_bffdcf =_edde -1;_dcfd =false ;};};_cdbg =append (_cdbg ,_daec );if _dbge ._ecee .isAbsolute (){return _cdbg ,_cbebg ,nil ;};ctx .X =_cbebg .X ;ctx .Width =_cbebg .Width ;ctx .Y +=_dbge ._gefb ._dfbb ;ctx .Height -=_dbge ._gefb ._dfbb ;return _cdbg ,ctx ,nil ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_dedb *Division )Add (d VectorDrawable )error {_afa :=false ;switch d .(type ){case *Paragraph :_afa =true ;case *StyledParagraph :_afa =true ;case *Image :_afa =true ;};if !_afa {return _cb .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_dedb ._fced =append (_dedb ._fced ,d );return nil ;};

// CurRow returns the currently active cell's row number.
func (_feef *Table )CurRow ()int {_cfaa :=(_feef ._cbfc -1)/_feef ._ecad +1;return _cfaa };const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func _aggbb (_dgcee *_d .File )([]*_fd .PdfPage ,error ){_fcgbf ,_cdecd :=_fd .NewPdfReader (_dgcee );if _cdecd !=nil {return nil ,_cdecd ;};_agbc ,_cdecd :=_fcgbf .GetNumPages ();if _cdecd !=nil {return nil ,_cdecd ;};var _dccad []*_fd .PdfPage ;for _gcdea :=0;_gcdea < _agbc ;_gcdea ++{_abdd ,_ggcc :=_fcgbf .GetPage (_gcdea +1);if _ggcc !=nil {return nil ,_ggcc ;};_dccad =append (_dccad ,_abdd );};return _dccad ,nil ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_dbba *List )Add (item VectorDrawable )(*TextChunk ,error ){_cgdg :=&listItem {_bfea :item ,_bfdc :_dbba ._dfba };switch _ebff :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _ebff ._bfeb {_ebff ._fgce =15;};default:return nil ,_cb .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_dbba ._eebf =append (_dbba ._eebf ,_cgdg );return &_cgdg ._bfdc ,nil ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_fcgg *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcgg ._deg ._ddcg ,_fcgg ._deg ._bcde ,_fcgg ._deg ._fdfb ,_fcgg ._deg ._dfbb ;};func (_fabb *Image )makeXObject ()error {_gaga :=_fabb ._gaec ;if _gaga ==nil {_gaga =_ag .NewFlateEncoder ();};_afebg ,_dggf :=_fd .NewXObjectImageFromImage (_fabb ._ffab ,nil ,_gaga );if _dggf !=nil {_bf .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dggf );return _dggf ;};_fabb ._eddc =_afebg ;return nil ;};

// NewPolyline creates a new polyline.
func (_gfed *Creator )NewPolyline (points []_a .Point )*Polyline {return _feaff (points )};func (_bedaa *Invoice )newColumn (_daff string ,_geba CellHorizontalAlignment )*InvoiceCell {_dda :=&InvoiceCell {_bedaa ._afbc ,_daff };_dda .Alignment =_geba ;return _dda ;};

// SetBorderColor sets the border color.
func (_efge *Polygon )SetBorderColor (color Color ){_efge ._fbcf .BorderColor =_fd .NewPdfColorDeviceRGB (color .ToRGB ());};func _feddb (_cdcae ,_bage ,_dbgf TextChunk ,_efeg uint ,_cbagb TextStyle )*TOCLine {_bdgc :=_fcfg (_cbagb );_bdgc .SetEnableWrap (true );_bdgc .SetTextAlignment (TextAlignmentLeft );_bdgc .SetMargins (0,0,2,2);_faeb :=&TOCLine {_fdbdg :_bdgc ,Number :_cdcae ,Title :_bage ,Page :_dbgf ,Separator :TextChunk {Text :"\u002e",Style :_cbagb },_gbgbd :0,_efdc :_efeg ,_gaade :10,_dbde :_ffgbd };_bdgc ._egeg ._ddcg =_faeb ._gbgbd +float64 (_faeb ._efdc -1)*_faeb ._gaade ;_bdgc ._fdabb =_faeb .prepareParagraph ;return _faeb ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_bfaec *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bafa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fagc ,_egcfg :=_bafa .setOpacity (_bfaec ._ggfd ,_bfaec ._dfgd );if _egcfg !=nil {return nil ,ctx ,_egcfg ;};_egfa :=_bfaec ._ebca ;_egfa .FillEnabled =_egfa .FillColor !=nil ;_ffgf :=_egfa .Curves ;_ddeb :=ctx .PageHeight ;for _cfgf :=range _ffgf {_bdabc :=&_ffgf [_cfgf ];_bdabc .P0 .Y =_ddeb -_bdabc .P0 .Y ;_bdabc .P1 .Y =_ddeb -_bdabc .P1 .Y ;_bdabc .P2 .Y =_ddeb -_bdabc .P2 .Y ;_bdabc .P3 .Y =_ddeb -_bdabc .P3 .Y ;};_fgagg ,_ ,_egcfg :=_egfa .Draw (_fagc );if _egcfg !=nil {return nil ,ctx ,_egcfg ;};if _egcfg =_bafa .addContentsByString (string (_fgagg ));_egcfg !=nil {return nil ,ctx ,_egcfg ;};return []*Block {_bafa },ctx ,nil ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_eae *Block )SetPos (x ,y float64 ){_eae ._db =_cead ;_eae ._cd =x ;_eae ._bcc =y };

// SetAngle sets the rotation angle in degrees.
func (_ege *Block )SetAngle (angleDeg float64 ){_ege ._fa =angleDeg };

// SetInline sets the inline mode of the division.
func (_cadb *Division )SetInline (inline bool ){_cadb ._ggfb =inline };

// SetIndent sets the cell's left indent.
func (_cfca *TableCell )SetIndent (indent float64 ){_cfca ._dfag =indent };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_bbd *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_ccb ,_afge :=_bbd .Wrap (width );if _afge !=nil {return nil ,_afge ;};_defe :=int (height /_bbd .Style .FontSize );if _defe >=len (_ccb ){return nil ,nil ;};_ffda :="\u000a";_bbd .Text =_bg .Replace (_bg .Join (_ccb [:_defe ],"\u0020"),_ffda +"\u0020",_ffda ,-1);_dcfe :=_bg .Replace (_bg .Join (_ccb [_defe :],"\u0020"),_ffda +"\u0020",_ffda ,-1);return NewTextChunk (_dcfe ,_bbd .Style ),nil ;};func (_cdbe *Paragraph )wrapText ()error {if !_cdbe ._bffef ||int (_cdbe ._bae )<=0{_cdbe ._eedg =[]string {_cdbe ._cgag };return nil ;};_bggb :=NewTextChunk (_cdbe ._cgag ,TextStyle {Font :_cdbe ._adfg ,FontSize :_cdbe ._abeb });_gabf ,_effda :=_bggb .Wrap (_cdbe ._bae );if _effda !=nil {return _effda ;};if _cdbe ._dbecd > 0&&len (_gabf )> _cdbe ._dbecd {_gabf =_gabf [:_cdbe ._dbecd ];};_cdbe ._eedg =_gabf ;return nil ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_adb *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_adb ._deg ._ddcg =left ;_adb ._deg ._bcde =right ;_adb ._deg ._fdfb =top ;_adb ._deg ._dfbb =bottom ;};

// Width returns Image's document width.
func (_dfca *Image )Width ()float64 {return _dfca ._aggc };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_cefcb *Image )SetEncoder (encoder _ag .StreamEncoder ){_cefcb ._gaec =encoder };

// NewImage create a new image from a unidoc image (model.Image).
func (_ccfa *Creator )NewImage (img *_fd .Image )(*Image ,error ){return _bffed (img )};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_abgb *Block )ScaleToHeight (h float64 ){_af :=h /_abgb ._cea ;_abgb .Scale (_af ,_af )};func (_gb *Block )duplicate ()*Block {_cf :=&Block {};*_cf =*_gb ;_ecc :=_bc .ContentStreamOperations {};for _ ,_ge :=range *_gb ._ed {_ecc =append (_ecc ,_ge );};_cf ._ed =&_ecc ;return _cf ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_fba *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fba ._faf ._ddcg ,_fba ._faf ._bcde ,_fba ._faf ._fdfb ,_fba ._faf ._dfbb ;};

// CurCol returns the currently active cell's column number.
func (_aedc *Table )CurCol ()int {_eagd :=(_aedc ._cbfc -1)%(_aedc ._ecad )+1;return _eagd };

// TOC returns the table of contents component of the creator.
func (_fcde *Creator )TOC ()*TOC {return _fcde ._fgbg };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fbff *Paragraph )SetTextAlignment (align TextAlignment ){_fbff ._ffaa =align };type border struct{_dgbg float64 ;_daaa float64 ;_gag float64 ;_bdf float64 ;_ddg *_fd .PdfColorDeviceRGB ;_ebe *_fd .PdfColorDeviceRGB ;_fef float64 ;_bfdb *_fd .PdfColorDeviceRGB ;_eccb float64 ;_cdb *_fd .PdfColorDeviceRGB ;_gdec float64 ;_edf *_fd .PdfColorDeviceRGB ;_cebd float64 ;LineStyle _a .LineStyle ;_ad CellBorderStyle ;_eggd CellBorderStyle ;_debg CellBorderStyle ;_acge CellBorderStyle ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_cbag *Invoice )SetTitleStyle (style TextStyle ){_cbag ._fec =style };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_dagc *Creator )EnableFontSubsetting (font *_fd .PdfFont ){_dagc ._acag =append (_dagc ._acag ,font );};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_eeed *Image )GetHorizontalAlignment ()HorizontalAlignment {return _eeed ._bdba };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_edgdf *_fd .PdfAnnotation ;_ffca bool ;};type rgbColor struct{_fffg ,_cdgb ,_cbc float64 };

// Scale block by specified factors in the x and y directions.
func (_ff *Block )Scale (sx ,sy float64 ){_cg :=_bc .NewContentCreator ().Scale (sx ,sy ).Operations ();*_ff ._ed =append (*_cg ,*_ff ._ed ...);_ff ._ed .WrapIfNeeded ();_ff ._bfd *=sx ;_ff ._cea *=sy ;};

// SetLineHeight sets the line height (1.0 default).
func (_aab *Paragraph )SetLineHeight (lineheight float64 ){_aab ._fffc =lineheight };func _egge (_eefe int )*Table {_bbed :=&Table {_ecad :_eefe ,_cade :10.0,_ggdf :[]float64 {},_badeg :[]float64 {},_gefc :[]*TableCell {}};_bbed .resetColumnWidths ();return _bbed ;};

// Width returns the current page width.
func (_cgg *Creator )Width ()float64 {return _cgg ._eggf };

// SetPos sets absolute positioning with specified coordinates.
func (_gdfc *StyledParagraph )SetPos (x ,y float64 ){_gdfc ._ggec =_cead ;_gdfc ._afbf =x ;_gdfc ._edbad =y ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_ecac *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gfea :=ctx ;var _acdf []*Block ;_dbbcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ecac ._ggec .isRelative (){ctx .X +=_ecac ._egeg ._ddcg ;ctx .Y +=_ecac ._egeg ._fdfb ;ctx .Width -=_ecac ._egeg ._ddcg +_ecac ._egeg ._bcde ;ctx .Height -=_ecac ._egeg ._fdfb +_ecac ._egeg ._dfbb ;_ecac .SetWidth (ctx .Width );}else {if int (_ecac ._caga )<=0{_ecac .SetWidth (_ecac .getTextWidth ());};ctx .X =_ecac ._afbf ;ctx .Y =_ecac ._edbad ;};if _ecac ._fdabb !=nil {_ecac ._fdabb (_ecac ,ctx );};if _gfaad :=_ecac .wrapText ();_gfaad !=nil {return nil ,ctx ,_gfaad ;};_addf :=_ecac ._cfbb ;for {_dabd ,_dgfd ,_cce :=_bgff (_dbbcg ,_ecac ,_addf ,ctx );if _cce !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cce );return nil ,ctx ,_cce ;};ctx =_dabd ;_acdf =append (_acdf ,_dbbcg );if _addf =_dgfd ;len (_dgfd )==0{break ;};_dbbcg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dabd =ctx ;_dabd .Y =ctx .Margins ._fdfb ;_dabd .X =ctx .Margins ._ddcg +_ecac ._egeg ._ddcg ;_dabd .Height =ctx .PageHeight -ctx .Margins ._fdfb -ctx .Margins ._dfbb -_ecac ._egeg ._dfbb ;_dabd .Width =ctx .PageWidth -ctx .Margins ._ddcg -ctx .Margins ._bcde -_ecac ._egeg ._ddcg -_ecac ._egeg ._bcde ;ctx =_dabd ;};if _ecac ._ggec .isRelative (){ctx .X -=_ecac ._egeg ._ddcg ;ctx .Width =_gfea .Width ;return _acdf ,ctx ,nil ;};return _acdf ,_gfea ,nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_deaf *StyledParagraph )SetLineHeight (lineheight float64 ){_deaf ._bacad =lineheight };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_faffad *StyledParagraph )SetWidth (width float64 ){_faffad ._caga =width ;_faffad .wrapText ()};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_gbaf *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cadc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ddd :=_a .Line {LineWidth :_gbaf ._fedg ,Opacity :1.0,LineColor :_gbaf ._eaad ,LineEndingStyle1 :_a .LineEndingStyleNone ,LineEndingStyle2 :_a .LineEndingStyleNone ,X1 :_gbaf ._faee ,Y1 :ctx .PageHeight -_gbaf ._becdc ,X2 :_gbaf ._gadfd ,Y2 :ctx .PageHeight -_gbaf ._daaaf };_fbgf ,_ ,_bgdea :=_ddd .Draw ("");if _bgdea !=nil {return nil ,ctx ,_bgdea ;};_bgdea =_cadc .addContentsByString (string (_fbgf ));if _bgdea !=nil {return nil ,ctx ,_bgdea ;};return []*Block {_cadc },ctx ,nil ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_dcee *Image )SetPos (x ,y float64 ){_dcee ._cgdc =_cead ;_dcee ._dggc =x ;_dcee ._bdbg =y };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_eedga *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dafb ,_gbag :=_edeb .setOpacity (_eedga ._afac ,_eedga ._acdab );if _gbag !=nil {return nil ,ctx ,_gbag ;};_geaa :=_eedga ._fbcf ;_geaa .FillEnabled =_geaa .FillColor !=nil ;_geaa .BorderEnabled =_geaa .BorderColor !=nil &&_geaa .BorderWidth > 0;_ggcdc :=_geaa .Points ;for _adcc :=range _ggcdc {for _gadea :=range _ggcdc [_adcc ]{_dfdbd :=&_ggcdc [_adcc ][_gadea ];_dfdbd .Y =ctx .PageHeight -_dfdbd .Y ;};};_edfa ,_ ,_gbag :=_geaa .Draw (_dafb );if _gbag !=nil {return nil ,ctx ,_gbag ;};if _gbag =_edeb .addContentsByString (string (_edfa ));_gbag !=nil {return nil ,ctx ,_gbag ;};return []*Block {_edeb },ctx ,nil ;};

// SetNumber sets the number of the invoice.
func (_bacd *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_bacd ._aafc [1].Value =number ;return _bacd ._aafc [0],_bacd ._aafc [1];};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_gfbb *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddfae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _cbccb []string ;_cbccb =append (_cbccb ,_dg .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_gfbb ._fbdc ));_cbccb =append (_cbccb ,_dg .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_gfbb ._fgcf [0],_gfbb ._fgcf [1],_gfbb ._fgcf [2]));_cbccb =append (_cbccb ,_dg .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_gfbb ._decd ,ctx .PageHeight -_gfbb ._ddbc ));_cbccb =append (_cbccb ,_dg .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_gfbb ._cdge ,ctx .PageHeight -_gfbb ._ffe ,_gfbb ._caee ,ctx .PageHeight -_gfbb ._cadd ));_dbbcd :=_ddfae .addContentsByString (_bg .Join (_cbccb ,"\u000a"));if _dbbcd !=nil {return nil ,ctx ,_dbbcd ;};return []*Block {_ddfae },ctx ,nil ;};func (_edbg *Invoice )generateNoteBlocks (_becd DrawContext )([]*Block ,DrawContext ,error ){_efbe :=_bdef ();_fecf :=append ([][2]string {_edbg ._cgfc ,_edbg ._aeea },_edbg ._aaac ...);for _ ,_dcec :=range _fecf {if _dcec [1]!=""{_ggfe :=_edbg .drawSection (_dcec [0],_dcec [1]);for _ ,_bfbf :=range _ggfe {_efbe .Add (_bfbf );};_facc :=_fcfg (_edbg ._cfcd );_facc .SetMargins (0,0,10,0);_efbe .Add (_facc );};};return _efbe .GeneratePageBlocks (_becd );};

// SetBorderWidth sets the border width.
func (_eacg *Rectangle )SetBorderWidth (bw float64 ){_eacg ._bffd =bw };

// Width returns the Block's width.
func (_fdd *Block )Width ()float64 {return _fdd ._bfd };

// SetMargins sets the Paragraph's margins.
func (_bfee *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_bfee ._egeg ._ddcg =left ;_bfee ._egeg ._bcde =right ;_bfee ._egeg ._fdfb =top ;_bfee ._egeg ._dfbb =bottom ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_dce *Creator )NewChapter (title string )*Chapter {_dce ._abaf ++;_bcgb :=_dce .NewTextStyle ();_bcgb .FontSize =16;return _faga (nil ,_dce ._fgbg ,_dce ._egcg ,title ,_dce ._abaf ,_bcgb );};

// DrawWithContext draws the Block using the specified drawing context.
func (_gae *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_dd ,_ ,_fc :=d .GeneratePageBlocks (ctx );if _fc !=nil {return _fc ;};if len (_dd )!=1{return _cb .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_gda :=range _dd {if _dc :=_gae .mergeBlocks (_gda );_dc !=nil {return _dc ;};};return nil ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_egae *TOC )SetLinePageStyle (style TextStyle ){_egae ._gggd =style };

// Cols returns the total number of columns the table has.
func (_ccggd *Table )Cols ()int {return _ccggd ._ecad };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_ggca []_a .CubicBezierCurve ;FillEnabled bool ;_dbgcc *_fd .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_bfa *_fd .PdfColorDeviceRGB ;};func (_gge *Block )addContentsByString (_dgd string )error {_bb :=_bc .NewContentStreamParser (_dgd );_gaf ,_edc :=_bb .Parse ();if _edc !=nil {return _edc ;};_gge ._ed .WrapIfNeeded ();_gaf .WrapIfNeeded ();*_gge ._ed =append (*_gge ._ed ,*_gaf ...);return nil ;};

// GeneratePageBlocks generates a page break block.
func (_eabg *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abff :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_efce :=ctx ;_efce .Y =ctx .Margins ._fdfb ;_efce .X =ctx .Margins ._ddcg ;_efce .Height =ctx .PageHeight -ctx .Margins ._fdfb -ctx .Margins ._dfbb ;_efce .Width =ctx .PageWidth -ctx .Margins ._ddcg -ctx .Margins ._bcde ;ctx =_efce ;return _abff ,ctx ,nil ;};

// SetColorBottom sets border color for bottom.
func (_ggd *border )SetColorBottom (col Color ){_ggd ._bfdb =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetFillOpacity sets the fill opacity.
func (_dabc *Polygon )SetFillOpacity (opacity float64 ){_dabc ._afac =opacity };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetTerms sets the terms and conditions section of the invoice.
func (_fgee *Invoice )SetTerms (title ,content string ){_fgee ._aeea =[2]string {title ,content }};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_fdad *Invoice )SetColumns (cols []*InvoiceCell ){_fdad ._cagd =cols };

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_fced []VectorDrawable ;_geff positioning ;_dadf margins ;_ggfb bool ;};

// SetFillColor sets the fill color.
func (_gaecd *Rectangle )SetFillColor (col Color ){_gaecd ._bbag =_fd .NewPdfColorDeviceRGB (col .ToRGB ());};

// SetEnableWrap sets the line wrapping enabled flag.
func (_eaaea *StyledParagraph )SetEnableWrap (enableWrap bool ){_eaaea ._caeb =enableWrap ;_eaaea ._fcdg =false ;};

// SetFillOpacity sets the fill opacity.
func (_badd *PolyBezierCurve )SetFillOpacity (opacity float64 ){_badd ._ggfd =opacity };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_dffb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _feddb (number ,title ,page ,level ,style );};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_fea *Chapter )SetShowNumbering (show bool ){_fea ._ffd =show ;_fea ._cdf .SetText (_fea .headingText ());};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_gec *Ellipse )GetCoords ()(float64 ,float64 ){return _gec ._gaab ,_gec ._aagd };

// LevelOffset returns the amount of space an indentation level occupies.
func (_caebb *TOCLine )LevelOffset ()float64 {return _caebb ._gaade };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_faadf *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbaee :=ctx ;_dgbe ,ctx ,_ebdf :=_faadf ._ebcb .GeneratePageBlocks (ctx );if _ebdf !=nil {return _dgbe ,ctx ,_ebdf ;};for _ ,_fegd :=range _faadf ._cgee {_adcbf :=_fegd ._afccd ;if !_faadf ._efbfc {_fegd ._afccd =0;};_acad ,_ggddg ,_fffgc :=_fegd .GeneratePageBlocks (ctx );_fegd ._afccd =_adcbf ;if _fffgc !=nil {return _dgbe ,ctx ,_fffgc ;};if len (_acad )< 1{continue ;};_dgbe [len (_dgbe )-1].mergeBlocks (_acad [0]);_dgbe =append (_dgbe ,_acad [1:]...);ctx =_ggddg ;};if _faadf ._febd .isRelative (){ctx .X =_gbaee .X ;};if _faadf ._febd .isAbsolute (){return _dgbe ,_gbaee ,nil ;};return _dgbe ,ctx ,nil ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetColorTop sets border color for top.
func (_ffb *border )SetColorTop (col Color ){_ffb ._edf =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_agfd *Invoice )SetAddressStyle (style TextStyle ){_agfd ._eaca =style };func (_aag *Chapter )headingNumber ()string {var _cfaf string ;if _aag ._ffd {if _aag ._eea !=0{_cfaf =_ce .Itoa (_aag ._eea )+"\u002e";};if _aag ._ddfa !=nil {_afc :=_aag ._ddfa .headingNumber ();if _afc !=""{_cfaf =_afc +_cfaf ;};};};return _cfaf ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;func _cgd (_gcb *_bc .ContentStreamOperations ,_age *_fd .PdfPageResources ,_fga *_bc .ContentStreamOperations ,_eccc *_fd .PdfPageResources )error {_fbab :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_fgf :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_daa :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_bceb :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_ef :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_dbee :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};for _ ,_gga :=range *_fga {switch _gga .Operand {case "\u0044\u006f":if len (_gga .Params )==1{if _gafg ,_egg :=_gga .Params [0].(*_ag .PdfObjectName );_egg {if _ ,_fdg :=_fbab [*_gafg ];!_fdg {var _ded _ag .PdfObjectName ;_cgda ,_ :=_eccc .GetXObjectByName (*_gafg );if _cgda !=nil {_ded =*_gafg ;for {_eee ,_ :=_age .GetXObjectByName (_ded );if _eee ==nil ||_eee ==_cgda {break ;};_ded =_ded +"\u0030";};};_age .SetXObjectByName (_ded ,_cgda );_fbab [*_gafg ]=_ded ;};_fca :=_fbab [*_gafg ];_gga .Params [0]=&_fca ;};};case "\u0054\u0066":if len (_gga .Params )==2{if _cfc ,_edaf :=_gga .Params [0].(*_ag .PdfObjectName );_edaf {if _ ,_gdg :=_fgf [*_cfc ];!_gdg {_dfg ,_dcg :=_eccc .GetFontByName (*_cfc );_bef :=*_cfc ;if _dcg &&_dfg !=nil {_bef =_ffae (_cfc .String (),_dfg ,_age );};_age .SetFontByName (_bef ,_dfg );_fgf [*_cfc ]=_bef ;};_deb :=_fgf [*_cfc ];_gga .Params [0]=&_deb ;};};case "\u0043\u0053","\u0063\u0073":if len (_gga .Params )==1{if _fdf ,_fbae :=_gga .Params [0].(*_ag .PdfObjectName );_fbae {if _ ,_eca :=_daa [*_fdf ];!_eca {var _dbbg _ag .PdfObjectName ;_egb ,_acga :=_eccc .GetColorspaceByName (*_fdf );if _acga {_dbbg =*_fdf ;for {_ggb ,_bea :=_age .GetColorspaceByName (_dbbg );if !_bea ||_egb ==_ggb {break ;};_dbbg =_dbbg +"\u0030";};_age .SetColorspaceByName (_dbbg ,_egb );_daa [*_fdf ]=_dbbg ;}else {_bf .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _efb ,_gcc :=_daa [*_fdf ];_gcc {_gga .Params [0]=&_efb ;}else {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_fdf );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gga .Params )==1{if _fbdg ,_ebc :=_gga .Params [0].(*_ag .PdfObjectName );_ebc {if _ ,_cca :=_bceb [*_fbdg ];!_cca {var _gdf _ag .PdfObjectName ;_eeea ,_fdb :=_eccc .GetPatternByName (*_fbdg );if _fdb {_gdf =*_fbdg ;for {_bbc ,_eeb :=_age .GetPatternByName (_gdf );if !_eeb ||_bbc ==_eeea {break ;};_gdf =_gdf +"\u0030";};_ccc :=_age .SetPatternByName (_gdf ,_eeea .ToPdfObject ());if _ccc !=nil {return _ccc ;};_bceb [*_fbdg ]=_gdf ;};};if _ae ,_ceaf :=_bceb [*_fbdg ];_ceaf {_gga .Params [0]=&_ae ;};};};case "\u0073\u0068":if len (_gga .Params )==1{if _aacb ,_gde :=_gga .Params [0].(*_ag .PdfObjectName );_gde {if _ ,_ggc :=_ef [*_aacb ];!_ggc {var _bda _ag .PdfObjectName ;_gdc ,_efg :=_eccc .GetShadingByName (*_aacb );if _efg {_bda =*_aacb ;for {_ffa ,_eab :=_age .GetShadingByName (_bda );if !_eab ||_gdc ==_ffa {break ;};_bda =_bda +"\u0030";};_cfg :=_age .SetShadingByName (_bda ,_gdc .ToPdfObject ());if _cfg !=nil {_bf .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_cfg );return _cfg ;};_ef [*_aacb ]=_bda ;}else {_bf .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _efd ,_fcf :=_ef [*_aacb ];_fcf {_gga .Params [0]=&_efd ;}else {_bf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_aacb );};};};case "\u0067\u0073":if len (_gga .Params )==1{if _ccf ,_dee :=_gga .Params [0].(*_ag .PdfObjectName );_dee {if _ ,_dbec :=_dbee [*_ccf ];!_dbec {var _ebd _ag .PdfObjectName ;_ffc ,_gfa :=_eccc .GetExtGState (*_ccf );if _gfa {_ebd =*_ccf ;_dgdf :=1;for {_gcd ,_aea :=_age .GetExtGState (_ebd );if !_aea ||_ffc ==_gcd {break ;};_ebd =_ag .PdfObjectName (_dg .Sprintf ("\u0047\u0053\u0025\u0064",_dgdf ));_dgdf ++;};};_age .AddExtGState (_ebd ,_ffc );_dbee [*_ccf ]=_ebd ;};_bbg :=_dbee [*_ccf ];_gga .Params [0]=&_bbg ;};};};*_gcb =append (*_gcb ,_gga );};return nil ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_faec *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_abbe :=&_faec ._ecgfe ;_abbe ._ddcg =left ;_abbe ._bcde =right ;_abbe ._fdfb =top ;_abbe ._dfbb =bottom ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_bbea *Invoice )Terms ()(string ,string ){return _bbea ._aeea [0],_bbea ._aeea [1]};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gbeb *StyledParagraph )SetTextAlignment (align TextAlignment ){_gbeb ._adfac =align };func (_fccc *Invoice )drawAddress (_fdgd *InvoiceAddress )[]*StyledParagraph {var _caff []*StyledParagraph ;if _fdgd .Heading !=""{_ccda :=_fcfg (_fccc ._addd );_ccda .SetMargins (0,0,0,7);_ccda .Append (_fdgd .Heading );_caff =append (_caff ,_ccda );};_cccf :=_fcfg (_fccc ._eaca );_cccf .SetLineHeight (1.2);_eeafb :=_fdgd .Separator ;if _eeafb ==""{_eeafb =_fccc ._eega ;};_cedf :=_fdgd .City ;if _fdgd .State !=""{if _cedf !=""{_cedf +=_eeafb ;};_cedf +=_fdgd .State ;};if _fdgd .Zip !=""{if _cedf !=""{_cedf +=_eeafb ;};_cedf +=_fdgd .Zip ;};if _fdgd .Name !=""{_cccf .Append (_fdgd .Name +"\u000a");};if _fdgd .Street !=""{_cccf .Append (_fdgd .Street +"\u000a");};if _fdgd .Street2 !=""{_cccf .Append (_fdgd .Street2 +"\u000a");};if _cedf !=""{_cccf .Append (_cedf +"\u000a");};if _fdgd .Country !=""{_cccf .Append (_fdgd .Country +"\u000a");};_acde :=_fcfg (_fccc ._eaca );_acde .SetLineHeight (1.2);_acde .SetMargins (0,0,7,0);if _fdgd .Phone !=""{_acde .Append (_dg .Sprintf ("\u0050\u0068\u006f\u006e\u0065\u003a\u0020\u0025\u0073\u000a",_fdgd .Phone ));};if _fdgd .Email !=""{_acde .Append (_dg .Sprintf ("\u0045\u006d\u0061\u0069\u006c\u003a\u0020\u0025\u0073\u000a",_fdgd .Email ));};_caff =append (_caff ,_cccf ,_acde );return _caff ;};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_bfdg *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _eedge (x ,y ,width ,height );};

// SetBorderColor sets the border color.
func (_gdegd *PolyBezierCurve )SetBorderColor (color Color ){_gdegd ._ebca .BorderColor =_fd .NewPdfColorDeviceRGB (color .ToRGB ());};func _gcbg (_eadc ,_gbf *_fd .PdfPageResources )error {_ggbg ,_ :=_eadc .GetColorspaces ();if _ggbg !=nil &&len (_ggbg .Colorspaces )> 0{for _efde ,_fbg :=range _ggbg .Colorspaces {_fge :=*_ag .MakeName (_efde );if _gbf .HasColorspaceByName (_fge ){continue ;};_cge :=_gbf .SetColorspaceByName (_fge ,_fbg );if _cge !=nil {return _cge ;};};};return nil ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_gfcf *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _acfc (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// SetStyleBottom sets border style for bottom side.
func (_cgc *border )SetStyleBottom (style CellBorderStyle ){_cgc ._acge =style };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_eeafd *StyledParagraph )Height ()float64 {_eeafd .wrapText ();var _cadbd float64 ;for _ ,_deca :=range _eeafd ._cfbb {var _dffcd float64 ;for _ ,_agbg :=range _deca {_dgad :=_eeafd ._bacad *_agbg .Style .FontSize ;if _dgad > _dffcd {_dffcd =_dgad ;};};_cadbd +=_dffcd ;};return _cadbd ;};

// SetLineOpacity sets the line opacity.
func (_bfedf *Polyline )SetLineOpacity (opacity float64 ){_bfedf ._egga =opacity };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_ggecf *TOC )SetHeading (text string ,style TextStyle ){_ffed :=_ggecf .Heading ();_ffed .Reset ();_fdea :=_ffed .Append (text );_fdea .Style =style ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_ebcb *StyledParagraph ;_cgee []*TOCLine ;_dege TextStyle ;_bfad TextStyle ;_ecbb TextStyle ;_gggd TextStyle ;_adfee string ;_ababg float64 ;_ecgfe margins ;_febd positioning ;_bffg TextStyle ;_efbfc bool ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_cdaedb *Invoice )Notes ()(string ,string ){return _cdaedb ._cgfc [0],_cdaedb ._cgfc [1]};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_bfed *Image )ConvertToBinary ()error {return _bfed ._ffab .ConvertToBinary ()};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_dbac *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_egagb :=NewTextChunk (text ,_dbac ._beaag );_egagb ._edgdf =_egebc (url );return _dbac .appendChunk (_egagb );};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_dabbe *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_caddb :=range subtable ._gefc {_edebf :=&TableCell {};*_edebf =*_caddb ;_edebf ._dcdea =_dabbe ;_edebf ._ebbf +=col -1;if _ffgaf :=_dabbe ._ecad -(_edebf ._ebbf -1);_ffgaf < _edebf ._aaec {_dabbe ._ecad +=_edebf ._aaec -_ffgaf ;_dabbe .resetColumnWidths ();_bf .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_dabbe ._ecad );};_edebf ._ecef +=row -1;_bbcea :=subtable ._badeg [_caddb ._ecef -1];if _edebf ._ecef > _dabbe ._dadg {for _edebf ._ecef > _dabbe ._dadg {_dabbe ._dadg ++;_dabbe ._badeg =append (_dabbe ._badeg ,_dabbe ._cade );};_dabbe ._badeg [_edebf ._ecef -1]=_bbcea ;}else {_dabbe ._badeg [_edebf ._ecef -1]=_f .Max (_dabbe ._badeg [_edebf ._ecef -1],_bbcea );};_dabbe ._gefc =append (_dabbe ._gefc ,_edebf );};_cc .Slice (_dabbe ._gefc ,func (_cegf ,_fcfb int )bool {_beea :=_dabbe ._gefc [_cegf ]._ecef ;_dgdfb :=_dabbe ._gefc [_fcfb ]._ecef ;if _beea < _dgdfb {return true ;};if _beea > _dgdfb {return false ;};return _dabbe ._gefc [_cegf ]._ebbf < _dabbe ._gefc [_fcfb ]._ebbf ;});};

// SetHeight sets the Image's document height to specified h.
func (_bbceb *Image )SetHeight (h float64 ){_bbceb ._efgg =h };func (_fbacg *Table )resetColumnWidths (){_fbacg ._ggdf =[]float64 {};_geffa :=float64 (1.0)/float64 (_fbacg ._ecad );for _deeca :=0;_deeca < _fbacg ._ecad ;_deeca ++{_fbacg ._ggdf =append (_fbacg ._ggdf ,_geffa );};};

// Reset removes all the text chunks the paragraph contains.
func (_dcbd *StyledParagraph )Reset (){_dcbd ._dddd =[]*TextChunk {}};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetMargins sets the Paragraph's margins.
func (_ebfb *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_ebfb ._gca ._ddcg =left ;_ebfb ._gca ._bcde =right ;_ebfb ._gca ._fdfb =top ;_ebfb ._gca ._dfbb =bottom ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ebeg *_fd .PdfColorDeviceRGB ;_ccca _a .LineStyle ;_begbb CellBorderStyle ;_gfcd *_fd .PdfColorDeviceRGB ;_dfee float64 ;_cdea CellBorderStyle ;_cgfcg *_fd .PdfColorDeviceRGB ;_ebce float64 ;_dage CellBorderStyle ;_cfcgf *_fd .PdfColorDeviceRGB ;_facge float64 ;_bcgbe CellBorderStyle ;_ecgc *_fd .PdfColorDeviceRGB ;_aece float64 ;_ecef ,_ebbf int ;_dfge int ;_aaec int ;_abeag VectorDrawable ;_aabb CellHorizontalAlignment ;_deegc CellVerticalAlignment ;_dfag float64 ;_dcdea *Table ;};func (_ceeg *Table )newCell (_egdc int )*TableCell {_ceeg ._cbfc ++;_dgacc :=(_ceeg ._cbfc -1)/_ceeg ._ecad +1;for _dgacc > _ceeg ._dadg {_ceeg ._dadg ++;_ceeg ._badeg =append (_ceeg ._badeg ,_ceeg ._cade );};_fcdd :=(_ceeg ._cbfc -1)%(_ceeg ._ecad )+1;_ggbc :=&TableCell {};_ggbc ._ecef =_dgacc ;_ggbc ._ebbf =_fcdd ;_ggbc ._dfge =1;_ggbc ._dfag =5;_ggbc ._begbb =CellBorderStyleNone ;_ggbc ._ccca =_a .LineStyleSolid ;_ggbc ._aabb =CellHorizontalAlignmentLeft ;_ggbc ._deegc =CellVerticalAlignmentTop ;_ggbc ._dfee =0;_ggbc ._ebce =0;_ggbc ._facge =0;_ggbc ._aece =0;_fgfe :=ColorBlack ;_ggbc ._gfcd =_fd .NewPdfColorDeviceRGB (_fgfe .ToRGB ());_ggbc ._cgfcg =_fd .NewPdfColorDeviceRGB (_fgfe .ToRGB ());_ggbc ._cfcgf =_fd .NewPdfColorDeviceRGB (_fgfe .ToRGB ());_ggbc ._ecgc =_fd .NewPdfColorDeviceRGB (_fgfe .ToRGB ());if _egdc < 1{_bf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_egdc );_egdc =1;};_gbgcg :=_ceeg ._ecad -(_ggbc ._ebbf -1);if _egdc > _gbgcg {_bf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_egdc ,_gbgcg );_egdc =_gbgcg ;};_ggbc ._aaec =_egdc ;_ceeg ._cbfc +=_egdc -1;_ceeg ._gefc =append (_ceeg ._gefc ,_ggbc );_ggbc ._dcdea =_ceeg ;return _ggbc ;};func _agadg (_acea ,_egdae ,_fgeecf string ,_fcagf uint ,_cbfb TextStyle )*TOCLine {return _feddb (TextChunk {Text :_acea ,Style :_cbfb },TextChunk {Text :_egdae ,Style :_cbfb },TextChunk {Text :_fgeecf ,Style :_cbfb },_fcagf ,_cbfb );};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fae *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _fae ._egef [0],_fae ._egef [1]};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_bga *Invoice )SetNoteHeadingStyle (style TextStyle ){_bga ._acfa =style };

// SetBorderWidth sets the border width.
func (_becg *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_becg ._ebca .BorderWidth =borderWidth ;};

// SetSubtotal sets the subtotal of the invoice.
func (_cgcegc *Invoice )SetSubtotal (value string ){_cgcegc ._gbgc [1].Value =value };

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_egcge *Division )Height ()float64 {_ebef :=0.0;_beee :=0.0;for _ ,_dedad :=range _egcge ._fced {_gbed ,_fdece :=_dedad .Width (),_dedad .Height ();switch _bac :=_dedad .(type ){case *Paragraph :_aebb :=_bac ;_gbed +=_aebb ._gca ._ddcg +_aebb ._gca ._bcde ;_fdece +=_aebb ._gca ._fdfb +_aebb ._gca ._dfbb ;case *StyledParagraph :_bec :=_bac ;_gbed +=_bec ._egeg ._ddcg +_bec ._egeg ._bcde ;_fdece +=_bec ._egeg ._fdfb +_bec ._egeg ._dfbb ;};_ebef +=_fdece ;_beee =_ebef ;};return _beee ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ffea *Image )ScaleToWidth (w float64 ){_fbfd :=_ffea ._efgg /_ffea ._aggc ;_ffea ._aggc =w ;_ffea ._efgg =w *_fbfd ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ab *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gg :=_bc .NewContentCreator ();_abf ,_egc :=_ab .Width (),_ab .Height ();if _ab ._db .isRelative (){_gg .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_egc );}else {_gg .Translate (_ab ._cd ,ctx .PageHeight -_ab ._bcc -_egc );};_bdb :=_egc ;if _ab ._fa !=0{_gg .Translate (_abf /2,_egc /2);_gg .RotateDeg (_ab ._fa );_gg .Translate (-_abf /2,-_egc /2);_ ,_bdb =_ab .RotatedSize ();};if _ab ._db .isRelative (){ctx .Y +=_bdb ;};_dgc :=_ab .duplicate ();_eda :=append (*_gg .Operations (),*_dgc ._ed ...);_eda .WrapIfNeeded ();_dgc ._ed =&_eda ;return []*Block {_dgc },ctx ,nil ;};func (_eceba *Image )rotatedSize ()(float64 ,float64 ){_efef :=_eceba ._aggc ;_bcae :=_eceba ._efgg ;_cbge :=_eceba ._aggb ;if _cbge ==0{return _efef ,_bcae ;};_gbgf :=_a .Path {Points :[]_a .Point {_a .NewPoint (0,0).Rotate (_cbge ),_a .NewPoint (_efef ,0).Rotate (_cbge ),_a .NewPoint (0,_bcae ).Rotate (_cbge ),_a .NewPoint (_efef ,_bcae ).Rotate (_cbge )}}.GetBoundingBox ();return _gbgf .Width ,_gbgf .Height ;};

// Logo returns the logo of the invoice.
func (_gbae *Invoice )Logo ()*Image {return _gbae ._dgcga };func (_bcb *Chapter )headingText ()string {_ffbe :=_bcb ._bfb ;if _bee :=_bcb .headingNumber ();_bee !=""{_ffbe =_dg .Sprintf ("\u0025\u0073\u0020%\u0073",_bee ,_ffbe );};return _ffbe ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_aggd *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agfba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eabgd ,_gdef :=_agfba .setOpacity (_aggd ._egga ,_aggd ._egga );if _gdef !=nil {return nil ,ctx ,_gdef ;};_bgae :=_aggd ._bdbge .Points ;for _beedf :=range _bgae {_adba :=&_bgae [_beedf ];_adba .Y =ctx .PageHeight -_adba .Y ;};_gabc ,_ ,_gdef :=_aggd ._bdbge .Draw (_eabgd );if _gdef !=nil {return nil ,ctx ,_gdef ;};if _gdef =_agfba .addContentsByString (string (_gabc ));_gdef !=nil {return nil ,ctx ,_gdef ;};return []*Block {_agfba },ctx ,nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_dab *Paragraph )SetPos (x ,y float64 ){_dab ._fdab =_cead ;_dab ._fcce =x ;_dab ._gdca =y };

// SetBorderColor sets border color.
func (_dac *Rectangle )SetBorderColor (col Color ){_dac ._dfe =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetMargins sets the margins TOC line.
func (_bgaf *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_bgaf ._gbgbd =left ;_bdcc :=&_bgaf ._fdbdg ._egeg ;_bdcc ._ddcg =_bgaf ._gbgbd +float64 (_bgaf ._efdc -1)*_bgaf ._gaade ;_bdcc ._bcde =right ;_bdcc ._fdfb =top ;_bdcc ._dfbb =bottom ;};func _feaff (_bcef []_a .Point )*Polyline {return &Polyline {_bdbge :&_a .Polyline {Points :_bcef ,LineColor :_fd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_egga :1.0};};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_ggff *TOCLine )SetStyle (style TextStyle ){_ggff .Number .Style =style ;_ggff .Title .Style =style ;_ggff .Separator .Style =style ;_ggff .Page .Style =style ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_edcc *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bffb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aceg ,_ ,_fed :=_edcc .draw ("");_fed =_bffb .addContentsByString (string (_aceg ));if _fed !=nil {return nil ,ctx ,_fed ;};return []*Block {_bffb },ctx ,nil ;};

// GetRowHeight returns the height of the specified row.
func (_cced *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_cced ._badeg ){return 0,_cb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _cced ._badeg [row -1],nil ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);func _gbfb (_begd *Block ,_gdabg *Image ,_fdcf DrawContext )(DrawContext ,error ){_gdba :=_fdcf ;_feb :=1;_beed :=_ag .PdfObjectName (_dg .Sprintf ("\u0049\u006d\u0067%\u0064",_feb ));for _begd ._eg .HasXObjectByName (_beed ){_feb ++;_beed =_ag .PdfObjectName (_dg .Sprintf ("\u0049\u006d\u0067%\u0064",_feb ));};_ggba :=_begd ._eg .SetXObjectImageByName (_beed ,_gdabg ._eddc );if _ggba !=nil {return _fdcf ,_ggba ;};_cfafb :=0;_ffdc :=_ag .PdfObjectName (_dg .Sprintf ("\u0047\u0053\u0025\u0064",_cfafb ));for _begd ._eg .HasExtGState (_ffdc ){_cfafb ++;_ffdc =_ag .PdfObjectName (_dg .Sprintf ("\u0047\u0053\u0025\u0064",_cfafb ));};_agac :=_ag .MakeDict ();_agac .Set ("\u0042\u004d",_ag .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _gdabg ._gdab < 1.0{_agac .Set ("\u0043\u0041",_ag .MakeFloat (_gdabg ._gdab ));_agac .Set ("\u0063\u0061",_ag .MakeFloat (_gdabg ._gdab ));};_ggba =_begd ._eg .AddExtGState (_ffdc ,_ag .MakeIndirectObject (_agac ));if _ggba !=nil {return _fdcf ,_ggba ;};_dceea :=_gdabg .Width ();_bebd :=_gdabg .Height ();_ ,_affg :=_gdabg .rotatedSize ();_eabce :=_fdcf .X ;_ebbg :=_fdcf .PageHeight -_fdcf .Y -_bebd ;if _gdabg ._cgdc .isRelative (){_ebbg -=(_affg -_bebd )/2;switch _gdabg ._bdba {case HorizontalAlignmentCenter :_eabce +=(_fdcf .Width -_dceea )/2;case HorizontalAlignmentRight :_eabce =_fdcf .PageWidth -_fdcf .Margins ._bcde -_gdabg ._ecba ._bcde -_dceea ;};};_gedd :=_gdabg ._aggb ;_cdaa :=_bc .NewContentCreator ();_cdaa .Add_gs (_ffdc );_cdaa .Translate (_eabce ,_ebbg );if _gedd !=0{_cdaa .Translate (_dceea /2,_bebd /2);_cdaa .RotateDeg (_gedd );_cdaa .Translate (-_dceea /2,-_bebd /2);};_cdaa .Scale (_dceea ,_bebd ).Add_Do (_beed );_aafd :=_cdaa .Operations ();_aafd .WrapIfNeeded ();_begd .addContents (_aafd );if _gdabg ._cgdc .isRelative (){_fdcf .Y +=_affg ;_fdcf .Height -=_affg ;return _fdcf ,nil ;};return _gdba ,nil ;};func (_bgfaf *StyledParagraph )getMaxLineWidth ()float64 {if _bgfaf ._cfbb ==nil ||len (_bgfaf ._cfbb )==0{_bgfaf .wrapText ();};var _gcaf float64 ;for _ ,_gfdg :=range _bgfaf ._cfbb {_ffcd :=_bgfaf .getTextLineWidth (_gfdg );if _ffcd > _gcaf {_gcaf =_ffcd ;};};return _gcaf ;};func (_cde rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _cde ._fffg ,_cde ._cdgb ,_cde ._cbc };

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_dadg int ;_ecad int ;_cbfc int ;_ggdf []float64 ;_badeg []float64 ;_cade float64 ;_gefc []*TableCell ;_ecee positioning ;_ggcag ,_gfbfg float64 ;_gefb margins ;_gffc bool ;_ddgf int ;_fcfgg int ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_bbcd *Table )Width ()float64 {return 0};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_gbda *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_gbda ._deegc =valign };

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_cgag string ;_adfg *_fd .PdfFont ;_abeb float64 ;_fffc float64 ;_edccg _fd .PdfColorDeviceRGB ;_ffaa TextAlignment ;_bffef bool ;_bae float64 ;_dbecd int ;_adgd bool ;_gcfcg float64 ;_gca margins ;_fdab positioning ;_fcce float64 ;_gdca float64 ;_badaa ,_dddf float64 ;_eedg []string ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gdege *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _gdege ._agae [0],_gdege ._agae [1]};

// NewPageBreak create a new page break.
func (_afee *Creator )NewPageBreak ()*PageBreak {return _ecebe ()};

// Columns returns all the columns in the invoice line items table.
func (_ccd *Invoice )Columns ()[]*InvoiceCell {return _ccd ._cagd };

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_dgdb *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _deea []*Block ;_fddbb :=ctx ;if _dgdb ._geff .isRelative (){ctx .X +=_dgdb ._dadf ._ddcg ;ctx .Y +=_dgdb ._dadf ._fdfb ;ctx .Width -=_dgdb ._dadf ._ddcg +_dgdb ._dadf ._bcde ;ctx .Height -=_dgdb ._dadf ._fdfb +_dgdb ._dadf ._dfbb ;};ctx .Inline =_dgdb ._ggfb ;_ccab :=ctx ;_fbbe :=ctx ;var _bgde float64 ;for _ ,_acdg :=range _dgdb ._fced {if ctx .Inline {if (ctx .X -_ccab .X )+_acdg .Width ()<=ctx .Width {ctx .Y =_fbbe .Y ;ctx .Height =_fbbe .Height ;}else {ctx .X =_ccab .X ;ctx .Width =_ccab .Width ;_fbbe .Y +=_bgde ;_fbbe .Height -=_bgde ;_bgde =0;};};_fefd ,_cdffe ,_aaaf :=_acdg .GeneratePageBlocks (ctx );if _aaaf !=nil {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_aaaf );return nil ,ctx ,_aaaf ;};if len (_fefd )< 1{continue ;};if len (_deea )> 0{_deea [len (_deea )-1].mergeBlocks (_fefd [0]);_deea =append (_deea ,_fefd [1:]...);}else {_deea =append (_deea ,_fefd [0:]...);};if ctx .Inline {if ctx .Page !=_cdffe .Page {_ccab .Y =ctx .Margins ._fdfb ;_ccab .Height =ctx .PageHeight -ctx .Margins ._fdfb ;_fbbe .Y =_ccab .Y ;_fbbe .Height =_ccab .Height ;_bgde =_cdffe .Height -_ccab .Height ;}else {if _befe :=ctx .Height -_cdffe .Height ;_befe > _bgde {_bgde =_befe ;};};}else {_cdffe .X =ctx .X ;};ctx =_cdffe ;};ctx .Inline =_fddbb .Inline ;if _dgdb ._geff .isRelative (){ctx .X =_fddbb .X ;};if _dgdb ._geff .isAbsolute (){return _deea ,_fddbb ,nil ;};return _deea ,ctx ,nil ;};

// SetStyleTop sets border style for top side.
func (_bccc *border )SetStyleTop (style CellBorderStyle ){_bccc ._debg =style };

// NewImageFromData creates an Image from image data.
func (_gcfc *Creator )NewImageFromData (data []byte )(*Image ,error ){return _dgf (data )};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_fbcf *_a .Polygon ;_afac float64 ;_acdab float64 ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_fbf *Chapter )GetHeading ()*Paragraph {return _fbf ._cdf };

// NewSubchapter creates a new child chapter with the specified title.
func (_edca *Chapter )NewSubchapter (title string )*Chapter {_eabc :=_ggdg (_edca ._cdf ._adfg );_eabc .FontSize =14;_edca ._abec ++;_gcda :=_faga (_edca ,_edca ._fdc ,_edca ._fffe ,title ,_edca ._abec ,_eabc );_edca .Add (_gcda );return _gcda ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_fage *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _fage ._eddc ==nil {if _fgge :=_fage .makeXObject ();_fgge !=nil {return nil ,ctx ,_fgge ;};};var _efff []*Block ;_eeg :=ctx ;_bbfg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fage ._cgdc .isRelative (){if _fage ._efgg > ctx .Height {_efff =append (_efff ,_bbfg );_bbfg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cbf :=ctx ;_cbf .Y =ctx .Margins ._fdfb ;_cbf .X =ctx .Margins ._ddcg +_fage ._ecba ._ddcg ;_cbf .Height =ctx .PageHeight -ctx .Margins ._fdfb -ctx .Margins ._dfbb -_fage ._ecba ._dfbb ;_cbf .Width =ctx .PageWidth -ctx .Margins ._ddcg -ctx .Margins ._bcde -_fage ._ecba ._ddcg -_fage ._ecba ._bcde ;ctx =_cbf ;}else {ctx .Y +=_fage ._ecba ._fdfb ;ctx .Height -=_fage ._ecba ._fdfb +_fage ._ecba ._dfbb ;ctx .X +=_fage ._ecba ._ddcg ;ctx .Width -=_fage ._ecba ._ddcg +_fage ._ecba ._bcde ;};}else {ctx .X =_fage ._dggc ;ctx .Y =_fage ._bdbg ;};ctx ,_cfaff :=_gbfb (_bbfg ,_fage ,ctx );if _cfaff !=nil {return nil ,ctx ,_cfaff ;};_efff =append (_efff ,_bbfg );if _fage ._cgdc .isAbsolute (){ctx =_eeg ;}else {ctx .Y +=_fage ._ecba ._dfbb ;ctx .Height -=_fage ._ecba ._dfbb ;};return _efff ,ctx ,nil ;};

// SetTitle sets the title of the invoice.
func (_egag *Invoice )SetTitle (title string ){_egag ._fdaf =title };

// Lines returns all the rows of the invoice line items table.
func (_cdcg *Invoice )Lines ()[][]*InvoiceCell {return _cdcg ._gaac };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_abfe *TOC )SetShowLinks (showLinks bool ){_abfe ._efbfc =showLinks };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_cafe *Creator )NewPage ()*_fd .PdfPage {_faa :=_cafe .newPage ();_cafe ._deee =append (_cafe ._deee ,_faa );_cafe ._gfg .Page ++;return _faa ;};func (_aeed *Invoice )drawInformation ()*Table {_fgac :=_egge (2);_abcd :=append ([][2]*InvoiceCell {_aeed ._aafc ,_aeed ._agae ,_aeed ._ffdb },_aeed ._abcf ...);for _ ,_gdaa :=range _abcd {_bcec ,_gadf :=_gdaa [0],_gdaa [1];if _gadf .Value ==""{continue ;};_afdf :=_fgac .NewCell ();_afdf .SetBackgroundColor (_bcec .BackgroundColor );_aeed .setCellBorder (_afdf ,_bcec );_feg :=_fcfg (_bcec .TextStyle );_feg .Append (_bcec .Value );_feg .SetMargins (0,0,2,1);_afdf .SetContent (_feg );_afdf =_fgac .NewCell ();_afdf .SetBackgroundColor (_gadf .BackgroundColor );_aeed .setCellBorder (_afdf ,_gadf );_feg =_fcfg (_gadf .TextStyle );_feg .Append (_gadf .Value );_feg .SetMargins (0,0,2,1);_afdf .SetContent (_feg );};return _fgac ;};

// NewFilledCurve returns a instance of filled curve.
func (_adac *Creator )NewFilledCurve ()*FilledCurve {return _def ()};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_deeg *StyledParagraph )Insert (index uint ,text string )*TextChunk {_gbaad :=uint (len (_deeg ._dddd ));if index > _gbaad {index =_gbaad ;};_gdefe :=NewTextChunk (text ,_deeg ._agde );_deeg ._dddd =append (_deeg ._dddd [:index ],append ([]*TextChunk {_gdefe },_deeg ._dddd [index :]...)...);_deeg .wrapText ();return _gdefe ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_bdab *Creator )SetPageLabels (pageLabels _ag .PdfObject ){_bdab ._efcc =pageLabels };func _gefe (_gcde ,_fcda TextStyle )*Invoice {_caddg :=&Invoice {_fdaf :"\u0049N\u0056\u004f\u0049\u0043\u0045",_eega :"\u002c\u0020",_cfcd :_gcde ,_eadcg :_fcda };_caddg ._deab =&InvoiceAddress {Separator :_caddg ._eega };_caddg ._edg =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_caddg ._eega };_dafa :=ColorRGBFrom8bit (245,245,245);_gcgg :=ColorRGBFrom8bit (155,155,155);_caddg ._fec =_fcda ;_caddg ._fec .Color =_gcgg ;_caddg ._fec .FontSize =20;_caddg ._eaca =_gcde ;_caddg ._addd =_fcda ;_caddg ._bcaea =_gcde ;_caddg ._acfa =_fcda ;_caddg ._edfb =_caddg .NewCellProps ();_caddg ._edfb .BackgroundColor =_dafa ;_caddg ._edfb .TextStyle =_fcda ;_caddg ._afbc =_caddg .NewCellProps ();_caddg ._afbc .TextStyle =_fcda ;_caddg ._afbc .BackgroundColor =_dafa ;_caddg ._afbc .BorderColor =_dafa ;_caddg ._ecag =_caddg .NewCellProps ();_caddg ._ecag .BorderColor =_dafa ;_caddg ._ecag .BorderSides =[]CellBorderSide {CellBorderSideBottom };_caddg ._ecag .Alignment =CellHorizontalAlignmentRight ;_caddg ._cbccg =_caddg .NewCellProps ();_caddg ._cbccg .Alignment =CellHorizontalAlignmentRight ;_caddg ._aafc =[2]*InvoiceCell {_caddg .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_caddg ._edfb ),_caddg .newCell ("",_caddg ._edfb )};_caddg ._agae =[2]*InvoiceCell {_caddg .newCell ("\u0044\u0061\u0074\u0065",_caddg ._edfb ),_caddg .newCell ("",_caddg ._edfb )};_caddg ._ffdb =[2]*InvoiceCell {_caddg .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_caddg ._edfb ),_caddg .newCell ("",_caddg ._edfb )};_caddg ._gbgc =[2]*InvoiceCell {_caddg .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_caddg ._cbccg ),_caddg .newCell ("",_caddg ._cbccg )};_faad :=_caddg ._cbccg ;_faad .TextStyle =_fcda ;_faad .BackgroundColor =_dafa ;_faad .BorderColor =_dafa ;_caddg ._egef =[2]*InvoiceCell {_caddg .newCell ("\u0054\u006f\u0074a\u006c",_faad ),_caddg .newCell ("",_faad )};_caddg ._cgfc =[2]string {"\u004e\u006f\u0074e\u0073",""};_caddg ._aeea =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_caddg ._cagd =[]*InvoiceCell {_caddg .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_caddg .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_caddg .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_caddg .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _caddg ;};func _ffae (_agef string ,_gaed _ag .PdfObject ,_ega *_fd .PdfPageResources )_ag .PdfObjectName {_fgb :=_bg .TrimRightFunc (_bg .TrimSpace (_agef ),func (_agg rune )bool {return _eb .IsNumber (_agg )});if _fgb ==""{_fgb ="\u0046\u006f\u006e\u0074";};_ccce :=0;_ffg :=_ag .PdfObjectName (_agef );for {_ceb ,_eaf :=_ega .GetFontByName (_ffg );if !_eaf ||_ceb ==_gaed {break ;};_ccce ++;_ffg =_ag .PdfObjectName (_dg .Sprintf ("\u0025\u0073\u0025\u0064",_fgb ,_ccce ));};return _ffg ;};func (_fdde *Invoice )generateTotalBlocks (_ecf DrawContext )([]*Block ,DrawContext ,error ){_addg :=_egge (4);_addg .SetMargins (0,0,10,10);_dafd :=[][2]*InvoiceCell {_fdde ._gbgc };_dafd =append (_dafd ,_fdde ._fbbc ...);_dafd =append (_dafd ,_fdde ._egef );for _ ,_dcca :=range _dafd {_cebc ,_ddad :=_dcca [0],_dcca [1];if _ddad .Value ==""{continue ;};_addg .SkipCells (2);_cgcee :=_addg .NewCell ();_cgcee .SetBackgroundColor (_cebc .BackgroundColor );_cgcee .SetHorizontalAlignment (_ddad .Alignment );_fdde .setCellBorder (_cgcee ,_cebc );_dcge :=_fcfg (_cebc .TextStyle );_dcge .SetMargins (0,0,2,1);_dcge .Append (_cebc .Value );_cgcee .SetContent (_dcge );_cgcee =_addg .NewCell ();_cgcee .SetBackgroundColor (_ddad .BackgroundColor );_cgcee .SetHorizontalAlignment (_ddad .Alignment );_fdde .setCellBorder (_cgcee ,_cebc );_dcge =_fcfg (_ddad .TextStyle );_dcge .SetMargins (0,0,2,1);_dcge .Append (_ddad .Value );_cgcee .SetContent (_dcge );};return _addg .GeneratePageBlocks (_ecf );};func _dgg (_dcc ,_afcc ,_eac ,_gcgf float64 )*Ellipse {_eed :=&Ellipse {};_eed ._gaab =_dcc ;_eed ._aagd =_afcc ;_eed ._agea =_eac ;_eed ._ababc =_gcgf ;_eed ._begg =_fd .NewPdfColorDeviceRGB (0,0,0);_eed ._dece =1.0;return _eed ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_gacb *TOC )SetLineSeparatorStyle (style TextStyle ){_gacb ._ecbb =style };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_fbaeb *Image )SetWidth (w float64 ){_fbaeb ._aggc =w };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_eaag *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_eaag .Text },nil ;};var _bgfc []string ;var _ecagc []rune ;var _aecd float64 ;var _fbcc []float64 ;_efdb :=_eaag .Style ;_gaea :=[]rune (_eaag .Text );for _ ,_gafgf :=range _gaea {if _gafgf =='\u000A'{_bgfc =append (_bgfc ,_bg .TrimRightFunc (string (_ecagc ),_eb .IsSpace )+string (_gafgf ));_ecagc =nil ;_aecd =0;_fbcc =nil ;continue ;};_feae :=_gafgf ==' ';_cdbb ,_bddc :=_efdb .Font .GetRuneMetrics (_gafgf );if !_bddc {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_gafgf ,_gafgf ,_efdb .Font .BaseFont (),_efdb .Font .Subtype ());_bf .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_efdb .Font );_bf .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_efdb .Font .Encoder ());return nil ,_cb .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_dfdd :=_efdb .FontSize *_cdbb .Wx ;_dgdg :=_dfdd ;if !_feae {_dgdg =_dfdd +_efdb .CharSpacing *1000.0;};if _aecd +_dfdd > width *1000.0{_gcaa :=-1;if !_feae {for _ccdg :=len (_ecagc )-1;_ccdg >=0;_ccdg --{if _ecagc [_ccdg ]==' '{_gcaa =_ccdg ;break ;};};};_dced :=string (_ecagc );if _gcaa > 0{_dced =string (_ecagc [0:_gcaa +1]);_ecagc =append (_ecagc [_gcaa +1:],_gafgf );_fbcc =append (_fbcc [_gcaa +1:],_dgdg );_aecd =0;for _ ,_fcbg :=range _fbcc {_aecd +=_fcbg ;};}else {if _feae {_ecagc =[]rune {};_fbcc =[]float64 {};_aecd =0;}else {_ecagc =[]rune {_gafgf };_fbcc =[]float64 {_dgdg };_aecd =_dgdg ;};};_bgfc =append (_bgfc ,_bg .TrimRightFunc (_dced ,_eb .IsSpace ));}else {_ecagc =append (_ecagc ,_gafgf );_aecd +=_dgdg ;_fbcc =append (_fbcc ,_dgdg );};};if len (_ecagc )> 0{_bgfc =append (_bgfc ,string (_ecagc ));};return _bgfc ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_daee *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gdad :=ctx ;_feff :=[]func (_cgaa DrawContext )([]*Block ,DrawContext ,error ){_daee .generateHeaderBlocks ,_daee .generateInformationBlocks ,_daee .generateLineBlocks ,_daee .generateTotalBlocks ,_daee .generateNoteBlocks };var _egcd []*Block ;for _ ,_cfad :=range _feff {_fdbbe ,_eegf ,_cbae :=_cfad (ctx );if _cbae !=nil {return _egcd ,ctx ,_cbae ;};if len (_egcd )==0{_egcd =_fdbbe ;}else if len (_fdbbe )> 0{_egcd [len (_egcd )-1].mergeBlocks (_fdbbe [0]);_egcd =append (_egcd ,_fdbbe [1:]...);};ctx =_eegf ;};if _daee ._gfec .isRelative (){ctx .X =_gdad .X ;};if _daee ._gfec .isAbsolute (){return _egcd ,_gdad ,nil ;};return _egcd ,ctx ,nil ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aaef *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aaef ._egeg ._ddcg ,_aaef ._egeg ._bcde ,_aaef ._egeg ._fdfb ,_aaef ._egeg ._dfbb ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_dddg *Table )NewCell ()*TableCell {return _dddg .newCell (1)};

// Text sets the text content of the Paragraph.
func (_deecd *Paragraph )Text ()string {return _deecd ._cgag };

// CreateFrontPage sets a function to generate a front Page.
func (_gcdc *Creator )CreateFrontPage (genFrontPageFunc func (_ccaa FrontpageFunctionArgs )){_gcdc ._fbcg =genFrontPageFunc ;};

// SetLevel sets the indentation level of the TOC line.
func (_bdbac *TOCLine )SetLevel (level uint ){_bdbac ._efdc =level ;_bdbac ._fdbdg ._egeg ._ddcg =_bdbac ._gbgbd +float64 (_bdbac ._efdc -1)*_bdbac ._gaade ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_fdaf string ;_dgcga *Image ;_edg *InvoiceAddress ;_deab *InvoiceAddress ;_eega string ;_aafc [2]*InvoiceCell ;_agae [2]*InvoiceCell ;_ffdb [2]*InvoiceCell ;_abcf [][2]*InvoiceCell ;_cagd []*InvoiceCell ;_gaac [][]*InvoiceCell ;_gbgc [2]*InvoiceCell ;_egef [2]*InvoiceCell ;_fbbc [][2]*InvoiceCell ;_cgfc [2]string ;_aeea [2]string ;_aaac [][2]string ;_cfcd TextStyle ;_eadcg TextStyle ;_fec TextStyle ;_eaca TextStyle ;_addd TextStyle ;_bcaea TextStyle ;_acfa TextStyle ;_edfb InvoiceCellProps ;_afbc InvoiceCellProps ;_ecag InvoiceCellProps ;_cbccg InvoiceCellProps ;_gfec positioning ;};

// SetAngle sets the rotation angle of the text.
func (_ggfec *Paragraph )SetAngle (angle float64 ){_ggfec ._gcfcg =angle };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_adacb *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _adacb ._gbgc [0],_adacb ._gbgc [1];};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_ceaa *Line )SetColor (col Color ){_ceaa ._eaad =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_cdc *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afe :=ctx ;if _cdc ._ebg .isRelative (){ctx .X +=_cdc ._deg ._ddcg ;ctx .Y +=_cdc ._deg ._fdfb ;ctx .Width -=_cdc ._deg ._ddcg +_cdc ._deg ._bcde ;ctx .Height -=_cdc ._deg ._fdfb ;};_cdbd ,_abc ,_feag :=_cdc ._cdf .GeneratePageBlocks (ctx );if _feag !=nil {return _cdbd ,ctx ,_feag ;};ctx =_abc ;_cdg :=ctx .X ;_ccgg :=ctx .Y -_cdc ._cdf .Height ();_ecd :=int64 (ctx .Page );_cgde :=_cdc .headingNumber ();_ebgb :=_cdc .headingText ();if _cdc ._ggf {_bdfa :=_cdc ._fdc .Add (_cgde ,_cdc ._bfb ,_ce .FormatInt (_ecd ,10),_cdc ._bgfa );if _cdc ._fdc ._efbfc {_bdfa .SetLink (_ecd ,_cdg ,_ccgg );};};if _cdc ._fdbc ==nil {_cdc ._fdbc =_fd .NewOutlineItem (_ebgb ,_fd .NewOutlineDest (_ecd -1,_cdg ,_ccgg ));if _cdc ._ddfa !=nil {_cdc ._ddfa ._fdbc .Add (_cdc ._fdbc );}else {_cdc ._fffe .Add (_cdc ._fdbc );};}else {_bdc :=&_cdc ._fdbc .Dest ;_bdc .Page =_ecd -1;_bdc .X =_cdg ;_bdc .Y =_ccgg ;};for _ ,_dcf :=range _cdc ._cfd {_fgg ,_daf ,_eaa :=_dcf .GeneratePageBlocks (ctx );if _eaa !=nil {return _cdbd ,ctx ,_eaa ;};if len (_fgg )< 1{continue ;};_cdbd [len (_cdbd )-1].mergeBlocks (_fgg [0]);_cdbd =append (_cdbd ,_fgg [1:]...);ctx =_daf ;};if _cdc ._ebg .isRelative (){ctx .X =_afe .X ;};if _cdc ._ebg .isAbsolute (){return _cdbd ,_afe ,nil ;};return _cdbd ,ctx ,nil ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_acb *Creator )MoveRight (dx float64 ){_acb ._gfg .X +=dx };

// SetStyleLeft sets border style for left side.
func (_acc *border )SetStyleLeft (style CellBorderStyle ){_acc ._ad =style };

// Title returns the title of the invoice.
func (_dbdg *Invoice )Title ()string {return _dbdg ._fdaf };

// SetOpacity sets opacity for Image.
func (_aee *Image )SetOpacity (opacity float64 ){_aee ._gdab =opacity };

// SellerAddress returns the seller address used in the invoice template.
func (_gfcfc *Invoice )SellerAddress ()*InvoiceAddress {return _gfcfc ._deab };

// SetColor sets the line color.
func (_feaf *Curve )SetColor (col Color ){_feaf ._fgcf =_fd .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetDueDate sets the due date of the invoice.
func (_bfef *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_bfef ._ffdb [1].Value =dueDate ;return _bfef ._ffdb [0],_bfef ._ffdb [1];};func (_acaac *StyledParagraph )wrapText ()error {if !_acaac ._caeb ||int (_acaac ._caga )<=0{_acaac ._cfbb =[][]*TextChunk {_acaac ._dddd };return nil ;};_acaac ._cfbb =[][]*TextChunk {};var _ccffg []*TextChunk ;var _gfca float64 ;_fded :=func (_dcdee *_fd .PdfAnnotation )*_fd .PdfAnnotation {if _dcdee ==nil {return nil ;};var _cbeb *_fd .PdfAnnotation ;switch _cdfgb :=_dcdee .GetContext ().(type ){case *_fd .PdfAnnotationLink :if _dfaa :=_fcaf (_cdfgb );_dfaa !=nil {_cbeb =_dfaa .PdfAnnotation ;};};return _cbeb ;};for _ ,_ecga :=range _acaac ._dddd {_fceb :=_ecga .Style ;_ccdf :=_ecga ._edgdf ;var (_bddb []rune ;_ccfbd []float64 ;);for _ ,_abdg :=range _ecga .Text {if _abdg =='\u000A'{_ccffg =append (_ccffg ,&TextChunk {Text :_bg .TrimRightFunc (string (_bddb ),_eb .IsSpace ),Style :_fceb ,_edgdf :_fded (_ccdf )});_acaac ._cfbb =append (_acaac ._cfbb ,_ccffg );_ccffg =nil ;_gfca =0;_bddb =nil ;_ccfbd =nil ;continue ;};_debb :=_abdg ==' ';_cfgb ,_bgad :=_fceb .Font .GetRuneMetrics (_abdg );if !_bgad {_bf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_abdg );return _cb .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_ffgcd :=_fceb .FontSize *_cfgb .Wx ;_fegc :=_ffgcd ;if !_debb {_fegc =_ffgcd +_fceb .CharSpacing *1000.0;};if _gfca +_ffgcd > _acaac ._caga *1000.0{_fbca :=-1;if !_debb {for _fdagc :=len (_bddb )-1;_fdagc >=0;_fdagc --{if _bddb [_fdagc ]==' '{_fbca =_fdagc ;break ;};};};_bcee :=string (_bddb );if _fbca >=0{_bcee =string (_bddb [0:_fbca +1]);_bddb =_bddb [_fbca +1:];_bddb =append (_bddb ,_abdg );_ccfbd =_ccfbd [_fbca +1:];_ccfbd =append (_ccfbd ,_fegc );_gfca =0;for _ ,_gdde :=range _ccfbd {_gfca +=_gdde ;};}else {if _debb {_gfca =0;_bddb =[]rune {};_ccfbd =[]float64 {};}else {_gfca =_fegc ;_bddb =[]rune {_abdg };_ccfbd =[]float64 {_fegc };};};_ccffg =append (_ccffg ,&TextChunk {Text :_bg .TrimRightFunc (string (_bcee ),_eb .IsSpace ),Style :_fceb ,_edgdf :_fded (_ccdf )});_acaac ._cfbb =append (_acaac ._cfbb ,_ccffg );_ccffg =[]*TextChunk {};}else {_gfca +=_fegc ;_bddb =append (_bddb ,_abdg );_ccfbd =append (_ccfbd ,_fegc );};};if len (_bddb )> 0{_ccffg =append (_ccffg ,&TextChunk {Text :string (_bddb ),Style :_fceb ,_edgdf :_fded (_ccdf )});};};if len (_ccffg )> 0{_acaac ._cfbb =append (_acaac ._cfbb ,_ccffg );};return nil ;};func _ecebe ()*PageBreak {return &PageBreak {}};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_eegfd *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _eegfd ._faee ,_eegfd ._becdc ,_eegfd ._gadfd ,_eegfd ._daaaf ;};

// SetFont sets the Paragraph's font.
func (_eegd *Paragraph )SetFont (font *_fd .PdfFont ){_eegd ._adfg =font };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_deecb *Creator )NewTextStyle ()TextStyle {return _ggdg (_deecb ._afeb )};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func _eedge (_bgac ,_dedg ,_caef ,_accb float64 )*Rectangle {return &Rectangle {_eaedg :_bgac ,_gaba :_dedg ,_gcge :_caef ,_fffef :_accb ,_dfe :_fd .NewPdfColorDeviceRGB (0,0,0),_bffd :1.0,_facgb :1.0,_ggfdd :1.0};};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ggac *Creator )MoveDown (dy float64 ){_ggac ._gfg .Y +=dy };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_bgcea *TOCLine )SetLevelOffset (levelOffset float64 ){_bgcea ._gaade =levelOffset ;_bgcea ._fdbdg ._egeg ._ddcg =_bgcea ._gbgbd +float64 (_bgcea ._efdc -1)*_bgcea ._gaade ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_aegd *Invoice )SetAddressHeadingStyle (style TextStyle ){_aegd ._addd =style };

// Angle returns the block rotation angle in degrees.
func (_fg *Block )Angle ()float64 {return _fg ._fa };func _gdcf (_dcef string )(*Image ,error ){_gdda ,_ebea :=_d .Open (_dcef );if _ebea !=nil {return nil ,_ebea ;};defer _gdda .Close ();_dagb ,_ebea :=_fd .ImageHandling .Read (_gdda );if _ebea !=nil {_bf .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ebea );return nil ,_ebea ;};return _bffed (_dagb );};func _bdef ()*Division {return &Division {_fced :[]VectorDrawable {}}};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_bgfd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_bgfd ._fgbg =toc ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_eccf *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _gaede (x1 ,y1 ,x2 ,y2 )};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_aada *List )Marker ()*TextChunk {return &_aada ._dfba };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cbga *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_beff :=[2]*InvoiceCell {_cbga .newCell (description ,_cbga ._edfb ),_cbga .newCell (value ,_cbga ._edfb )};_cbga ._abcf =append (_cbga ._abcf ,_beff );return _beff [0],_beff [1];};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_gedb *Paragraph )SetMaxLines (maxLines int ){_gedb ._dbecd =maxLines ;_gedb .wrapText ()};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_egdf *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ccfeeb :=ctx ;_aggf ,ctx ,_gace :=_egdf ._fdbdg .GeneratePageBlocks (ctx );if _gace !=nil {return _aggf ,ctx ,_gace ;};if _egdf ._dbde .isRelative (){ctx .X =_ccfeeb .X ;};if _egdf ._dbde .isAbsolute (){return _aggf ,_ccfeeb ,nil ;};return _aggf ,ctx ,nil ;};

// Width returns the cell's width based on the input draw context.
func (_babc *TableCell )Width (ctx DrawContext )float64 {_cdec :=float64 (0.0);for _adad :=0;_adad < _babc ._aaec ;_adad ++{_cdec +=_babc ._dcdea ._ggdf [_babc ._ebbf +_adad -1];};_gdfb :=ctx .Width *_cdec ;return _gdfb ;};

// NewTOC creates a new table of contents.
func (_cbeg *Creator )NewTOC (title string )*TOC {_edbc :=_cbeg .NewTextStyle ();_edbc .Font =_cbeg ._dadd ;return _ebbe (title ,_cbeg .NewTextStyle (),_edbc );};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_bffe *Block )SetMargins (left ,right ,top ,bottom float64 ){_bffe ._faf ._ddcg =left ;_bffe ._faf ._bcde =right ;_bffe ._faf ._fdfb =top ;_bffe ._faf ._dfbb =bottom ;};func _egebc (_gbcc string )*_fd .PdfAnnotation {_fagggc :=_fd .NewPdfAnnotationLink ();_fedf :=_fd .NewBorderStyle ();_fedf .SetBorderWidth (0);_fagggc .BS =_fedf .ToPdfObject ();_dffe :=_fd .NewPdfActionURI ();_dffe .URI =_ag .MakeString (_gbcc );_fagggc .SetAction (_dffe .PdfAction );return _fagggc .PdfAnnotation ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_cegc *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _cegc ._egda ._ddcg ,_cegc ._egda ._bcde ,_cegc ._egda ._fdfb ,_cegc ._egda ._dfbb ;};

// SkipCells skips over a specified number of cells in the table.
func (_bge *Table )SkipCells (num int ){if num < 0{_bf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_bge ._cbfc +=num ;};func _fcaf (_fade *_fd .PdfAnnotationLink )*_fd .PdfAnnotationLink {if _fade ==nil {return nil ;};_eada :=_fd .NewPdfAnnotationLink ();_eada .BS =_fade .BS ;_eada .A =_fade .A ;if _deecg ,_gdbd :=_fade .GetAction ();_gdbd ==nil &&_deecg !=nil {_eada .SetAction (_deecg );};if _dfeb ,_ebab :=_fade .Dest .(*_ag .PdfObjectArray );_ebab {_eada .Dest =_ag .MakeArray (_dfeb .Elements ()...);};return _eada ;};

// Rows returns the total number of rows the table has.
func (_adcb *Table )Rows ()int {return _adcb ._dadg };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_aacg *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_aadb :=_fcfg (_aacg ._ebfa );_aadb .Append (text );_adcf ,_degg :=_aacg .Add (_aadb );return _aadb ,_adcf ,_degg ;};

// Height returns the total height of all rows.
func (_fbfb *Table )Height ()float64 {_eebcd :=float64 (0.0);for _ ,_dabb :=range _fbfb ._badeg {_eebcd +=_dabb ;};return _eebcd ;};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_faee float64 ;_becdc float64 ;_gadfd float64 ;_daaaf float64 ;_eaad *_fd .PdfColorDeviceRGB ;_fedg float64 ;};

// SetBorderWidth sets the border width.
func (_fcad *Ellipse )SetBorderWidth (bw float64 ){_fcad ._dece =bw };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_ebca *_a .PolyBezierCurve ;_ggfd float64 ;_dfgd float64 ;};

// SetLogo sets the logo of the invoice.
func (_beeeb *Invoice )SetLogo (logo *Image ){_beeeb ._dgcga =logo };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_eebf []*listItem ;_egda margins ;_dfba TextChunk ;_fgce float64 ;_bfeb bool ;_befb positioning ;_ebfa TextStyle ;};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_fd .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;func (_ggdd positioning )isRelative ()bool {return _ggdd ==_ffgbd };

// SetFontSize sets the font size in document units (points).
func (_febf *Paragraph )SetFontSize (fontSize float64 ){_febf ._abeb =fontSize };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_faaae *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _faaae ._ecba ._ddcg ,_faaae ._ecba ._bcde ,_faaae ._ecba ._fdfb ,_faaae ._ecba ._dfbb ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_fdbdg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gbgbd float64 ;_efdc uint ;_gaade float64 ;_dbde positioning ;_cdaage float64 ;_gdfcc float64 ;_afccd int64 ;};

// Write output of creator to io.Writer interface.
func (_edbaa *Creator )Write (ws _b .Writer )error {if _eadg :=_edbaa .Finalize ();_eadg !=nil {return _eadg ;};_ecgf :=_fd .NewPdfWriter ();_ecgf .SetOptimizer (_edbaa ._ecbe );if _edbaa ._gcf !=nil {_cgef :=_ecgf .SetForms (_edbaa ._gcf );if _cgef !=nil {_bf .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cgef );return _cgef ;};};if _edbaa ._bcf !=nil {_ecgf .AddOutlineTree (_edbaa ._bcf );}else if _edbaa ._egcg !=nil &&_edbaa .AddOutlines {_ecgf .AddOutlineTree (&_edbaa ._egcg .ToPdfOutline ().PdfOutlineTreeNode );};if _edbaa ._efcc !=nil {if _ged :=_ecgf .SetPageLabels (_edbaa ._efcc );_ged !=nil {_bf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_ged );return _ged ;};};if _edbaa ._acag !=nil {for _ ,_gfbf :=range _edbaa ._acag {_dec :=_gfbf .SubsetRegistered ();if _dec !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_dec );return _dec ;};};};if _edbaa ._ffga !=nil {_cgefe :=_edbaa ._ffga (&_ecgf );if _cgefe !=nil {_bf .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cgefe );return _cgefe ;};};for _ ,_bbfe :=range _edbaa ._deee {_dbf :=_ecgf .AddPage (_bbfe );if _dbf !=nil {_bf .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_dbf );return _dbf ;};};_fgde :=_ecgf .Write (ws );if _fgde !=nil {return _fgde ;};return nil ;};

// SetBackgroundColor sets the cell's background color.
func (_bbgf *TableCell )SetBackgroundColor (col Color ){_bbgf ._ebeg =_fd .NewPdfColorDeviceRGB (col .ToRGB ());};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// The Image type is used to draw an image onto PDF.
type Image struct{_eddc *_fd .XObjectImage ;_ffab *_fd .Image ;_aggb float64 ;_aggc ,_efgg float64 ;_gbba ,_abfb float64 ;_cgdc positioning ;_bdba HorizontalAlignment ;_dggc float64 ;_bdbg float64 ;_gdab float64 ;_ecba margins ;_aace ,_bcad float64 ;_gaec _ag .StreamEncoder ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_cgfbf *Table )SetMargins (left ,right ,top ,bottom float64 ){_cgfbf ._gefb ._ddcg =left ;_cgfbf ._gefb ._bcde =right ;_cgfbf ._gefb ._fdfb =top ;_cgfbf ._gefb ._dfbb =bottom ;};func _bffed (_ffbd *_fd .Image )(*Image ,error ){_gea :=float64 (_ffbd .Width );_afeea :=float64 (_ffbd .Height );return &Image {_ffab :_ffbd ,_gbba :_gea ,_abfb :_afeea ,_aggc :_gea ,_efgg :_afeea ,_aggb :0,_gdab :1.0,_cgdc :_ffgbd },nil ;};

// NewInvoice returns an instance of an empty invoice.
func (_cbbe *Creator )NewInvoice ()*Invoice {_agfb :=_cbbe .NewTextStyle ();_agfb .Font =_cbbe ._dadd ;return _gefe (_cbbe .NewTextStyle (),_agfb );};func (_aeg *Creator )newPage ()*_fd .PdfPage {_gddg :=_fd .NewPdfPage ();_gbg :=_aeg ._adbd [0];_egf :=_aeg ._adbd [1];_ace :=_fd .PdfRectangle {Llx :0,Lly :0,Urx :_gbg ,Ury :_egf };_gddg .MediaBox =&_ace ;_aeg ._eggf =_gbg ;_aeg ._gce =_egf ;_aeg .initContext ();return _gddg ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_fd .PdfPage )(*Block ,error ){_df :=&Block {};_ec ,_dgb :=page .GetAllContentStreams ();if _dgb !=nil {return nil ,_dgb ;};_cef :=_bc .NewContentStreamParser (_ec );_fag ,_dgb :=_cef .Parse ();if _dgb !=nil {return nil ,_dgb ;};_fag .WrapIfNeeded ();_df ._ed =_fag ;if page .Resources !=nil {_df ._eg =page .Resources ;}else {_df ._eg =_fd .NewPdfPageResources ();};_g ,_dgb :=page .GetMediaBox ();if _dgb !=nil {return nil ,_dgb ;};if _g .Llx !=0||_g .Lly !=0{_df .translate (-_g .Llx ,_g .Lly );};_df ._bfd =_g .Urx -_g .Llx ;_df ._cea =_g .Ury -_g .Lly ;if page .Rotate !=nil {_df ._fa =-float64 (*page .Rotate );};return _df ,nil ;};func (_afd *Block )mergeBlocks (_ac *Block )error {_ddf :=_cgd (_afd ._ed ,_afd ._eg ,_ac ._ed ,_ac ._eg );if _ddf !=nil {return _ddf ;};for _ ,_bca :=range _ac ._fb {_afd .AddAnnotation (_bca );};return nil ;};

// GetOptimizer returns current PDF optimizer.
func (_cfed *Creator )GetOptimizer ()_fd .Optimizer {return _cfed ._ecbe };func _ddef (_fdcg [][]_a .Point )*Polygon {return &Polygon {_fbcf :&_a .Polygon {Points :_fdcg },_afac :1.0,_acdab :1.0};};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// Indent returns the left offset of the list when nested into another list.
func (_agcb *List )Indent ()float64 {return _agcb ._fgce };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_aegc *TOC )SetLineNumberStyle (style TextStyle ){_aegc ._dege =style };func (_abee *FilledCurve )draw (_fdbg string )([]byte ,*_fd .PdfRectangle ,error ){_cbcd :=_a .NewCubicBezierPath ();for _ ,_gfbfc :=range _abee ._ggca {_cbcd =_cbcd .AppendCurve (_gfbfc );};creator :=_bc .NewContentCreator ();creator .Add_q ();if _abee .FillEnabled {creator .Add_rg (_abee ._dbgcc .R (),_abee ._dbgcc .G (),_abee ._dbgcc .B ());};if _abee .BorderEnabled {creator .Add_RG (_abee ._bfa .R (),_abee ._bfa .G (),_abee ._bfa .B ());creator .Add_w (_abee .BorderWidth );};if len (_fdbg )> 1{creator .Add_gs (_ag .PdfObjectName (_fdbg ));};_a .DrawBezierPathWithCreator (_cbcd ,creator );creator .Add_h ();if _abee .FillEnabled &&_abee .BorderEnabled {creator .Add_B ();}else if _abee .FillEnabled {creator .Add_f ();}else if _abee .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_affa :=_cbcd .GetBoundingBox ();if _abee .BorderEnabled {_affa .Height +=_abee .BorderWidth ;_affa .Width +=_abee .BorderWidth ;_affa .X -=_abee .BorderWidth /2;_affa .Y -=_abee .BorderWidth /2;};_cgf :=&_fd .PdfRectangle {};_cgf .Llx =_affa .X ;_cgf .Lly =_affa .Y ;_cgf .Urx =_affa .X +_affa .Width ;_cgf .Ury =_affa .Y +_affa .Height ;return creator .Bytes (),_cgf ,nil ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_fgdc *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_cccc :=&_fgdc ._fdbdg ._egeg ;return _fgdc ._gbgbd ,_cccc ._bcde ,_cccc ._fdfb ,_cccc ._dfbb ;};

// SetLineWidth sets the line width.
func (_dede *Line )SetLineWidth (lw float64 ){_dede ._fedg =lw };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_aga *Creator )NewPolyBezierCurve (curves []_a .CubicBezierCurve )*PolyBezierCurve {return _aabg (curves );};func _bgff (_bcff *Block ,_bgbb *StyledParagraph ,_gddea [][]*TextChunk ,_bbbc DrawContext )(DrawContext ,[][]*TextChunk ,error ){_fggea :=1;_egaa :=_ag .PdfObjectName (_dg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fggea ));for _bcff ._eg .HasFontByName (_egaa ){_fggea ++;_egaa =_ag .PdfObjectName (_dg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fggea ));};_agba :=_bcff ._eg .SetFontByName (_egaa ,_bgbb ._agde .Font .ToPdfObject ());if _agba !=nil {return _bbbc ,nil ,_agba ;};_fggea ++;_cafg :=_egaa ;_dafc :=_bgbb ._agde .FontSize ;_bfff :=_bgbb ._ggec .isRelative ();var _fcfd [][]_ag .PdfObjectName ;var _bbbea float64 ;var _fbag [][]*TextChunk ;var _bcfff float64 ;for _bced ,_bccee :=range _gddea {var _fgfb []_ag .PdfObjectName ;var _ffeg float64 ;for _ ,_bgdf :=range _bccee {_bdbd :=_bgdf .Style ;if _bced ==0&&_bdbd .FontSize > _bbbea {_bbbea =_bdbd .FontSize ;};if _bdbd .FontSize > _ffeg {_ffeg =_bdbd .FontSize ;};_egaa =_ag .PdfObjectName (_dg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fggea ));_ccde :=_bcff ._eg .SetFontByName (_egaa ,_bdbd .Font .ToPdfObject ());if _ccde !=nil {return _bbbc ,nil ,_ccde ;};_fgfb =append (_fgfb ,_egaa );_fggea ++;};_ffeg *=_bgbb ._bacad ;if _bfff &&_bcfff +_ffeg > _bbbc .Height {_fbag =_gddea [_bced :];_gddea =_gddea [:_bced ];break ;};_bcfff +=_ffeg ;_fcfd =append (_fcfd ,_fgfb );};_aec :=_bc .NewContentCreator ();_aec .Add_q ();_acab :=_bbbc .PageHeight -_bbbc .Y -_bbbea *_bgbb ._bacad ;_aec .Translate (_bbbc .X ,_acab );if _bgbb ._ebae !=0{_aec .RotateDeg (_bgbb ._ebae );};_aec .Add_BT ();_dcfa :=_acab ;for _dbda ,_bdge :=range _gddea {_gcab :=_bbbc .X ;if _dbda !=0{_aec .Add_Tstar ();};_ecbc :=_dbda ==len (_gddea )-1;var (_edbcf float64 ;_geae float64 ;_cgaf float64 ;_cdd uint ;);var _bfba []float64 ;for _ ,_afdde :=range _bdge {_bcfa :=&_afdde .Style ;if _bcfa .FontSize > _geae {_geae =_bcfa .FontSize ;};_aeaa ,_egad :=_bcfa .Font .GetRuneMetrics (' ');if !_egad {return _bbbc ,nil ,_cb .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _agab uint ;var _ageg float64 ;_ceed :=len (_afdde .Text );for _cebda ,_fedc :=range _afdde .Text {if _fedc ==' '{_agab ++;continue ;};if _fedc =='\u000A'{continue ;};_beaab ,_bafb :=_bcfa .Font .GetRuneMetrics (_fedc );if !_bafb {_bf .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_fedc );return _bbbc ,nil ,_cb .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_ageg +=_bcfa .FontSize *_beaab .Wx ;if _cebda !=_ceed -1{_ageg +=_bcfa .CharSpacing *1000.0;};};_bfba =append (_bfba ,_ageg );_edbcf +=_ageg ;_cgaf +=float64 (_agab )*_aeaa .Wx *_bcfa .FontSize ;_cdd +=_agab ;};_geae *=_bgbb ._bacad ;var _cgad []_ag .PdfObject ;_fggc :=_bgbb ._caga *1000.0;if _bgbb ._adfac ==TextAlignmentJustify {if _cdd > 0&&!_ecbc {_cgaf =(_fggc -_edbcf )/float64 (_cdd )/_dafc ;};}else if _bgbb ._adfac ==TextAlignmentCenter {_cadg :=(_fggc -_edbcf -_cgaf )/2;_bffdc :=_cadg /_dafc ;_cgad =append (_cgad ,_ag .MakeFloat (-_bffdc ));_gcab +=_cadg /1000.0;}else if _bgbb ._adfac ==TextAlignmentRight {_bfefc :=(_fggc -_edbcf -_cgaf );_cbce :=_bfefc /_dafc ;_cgad =append (_cgad ,_ag .MakeFloat (-_cbce ));_gcab +=_bfefc /1000.0;};if len (_cgad )> 0{_aec .Add_Tf (_cafg ,_dafc ).Add_TL (_dafc *_bgbb ._bacad ).Add_TJ (_cgad ...);};for _fcabc ,_bgdg :=range _bdge {_cebb :=&_bgdg .Style ;_cgebd ,_abeab ,_afdc :=_cebb .Color .ToRGB ();_dfce :=_cafg ;_egcb :=_dafc ;_aec .Add_Tr (int64 (_cebb .RenderingMode ));_aec .Add_Tc (_cebb .CharSpacing );if _bgbb ._adfac !=TextAlignmentJustify ||_ecbc {_abebb ,_adcg :=_cebb .Font .GetRuneMetrics (' ');if !_adcg {return _bbbc ,nil ,_cb .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_dfce =_fcfd [_dbda ][_fcabc ];_egcb =_cebb .FontSize ;_cgaf =_abebb .Wx ;};_eebd :=_cebb .Font .Encoder ();var _cgfb []byte ;for _ ,_edfbg :=range _bgdg .Text {if _cgebd =='\u000A'{continue ;};if _edfbg ==' '{if len (_cgfb )> 0{_aec .Add_rg (_cgebd ,_abeab ,_afdc ).Add_Tf (_fcfd [_dbda ][_fcabc ],_cebb .FontSize ).Add_TL (_cebb .FontSize *_bgbb ._bacad ).Add_TJ ([]_ag .PdfObject {_ag .MakeStringFromBytes (_cgfb )}...);_cgfb =nil ;};_aec .Add_Tf (_dfce ,_egcb ).Add_TL (_egcb *_bgbb ._bacad ).Add_TJ ([]_ag .PdfObject {_ag .MakeFloat (-_cgaf )}...);_bfba [_fcabc ]+=_cgaf *_egcb ;}else {if _ ,_dddda :=_eebd .RuneToCharcode (_edfbg );!_dddda {_bf .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_edfbg ,_edfbg );continue ;};_cgfb =append (_cgfb ,_eebd .Encode (string (_edfbg ))...);};};if len (_cgfb )> 0{_aec .Add_rg (_cgebd ,_abeab ,_afdc ).Add_Tf (_fcfd [_dbda ][_fcabc ],_cebb .FontSize ).Add_TL (_cebb .FontSize *_bgbb ._bacad ).Add_TJ ([]_ag .PdfObject {_ag .MakeStringFromBytes (_cgfb )}...);};_badeb :=_bfba [_fcabc ]/1000.0;if _bgdg ._edgdf !=nil {var _eefb *_ag .PdfObjectArray ;if !_bgdg ._ffca {switch _aebd :=_bgdg ._edgdf .GetContext ().(type ){case *_fd .PdfAnnotationLink :_eefb =_ag .MakeArray ();_aebd .Rect =_eefb ;_aacf ,_daeff :=_aebd .Dest .(*_ag .PdfObjectArray );if _daeff &&_aacf .Len ()==5{_ddccb ,_cggc :=_aacf .Get (1).(*_ag .PdfObjectName );if _cggc &&_ddccb .String ()=="\u0058\u0059\u005a"{_efee ,_dagd :=_ag .GetNumberAsFloat (_aacf .Get (3));if _dagd ==nil {_aacf .Set (3,_ag .MakeFloat (_bbbc .PageHeight -_efee ));};};};};_bgdg ._ffca =true ;};if _eefb !=nil {_fgeec :=_a .NewPoint (_gcab -_bbbc .X ,_dcfa -_acab ).Rotate (_bgbb ._ebae );_fgeec .X +=_bbbc .X ;_fgeec .Y +=_acab ;_ecbaf ,_ggddf ,_cggbf ,_cega :=_dcfb (_badeb ,_geae ,_bgbb ._ebae );_fgeec .X +=_ecbaf ;_fgeec .Y +=_ggddf ;_eefb .Clear ();_eefb .Append (_ag .MakeFloat (_fgeec .X ));_eefb .Append (_ag .MakeFloat (_fgeec .Y ));_eefb .Append (_ag .MakeFloat (_fgeec .X +_cggbf ));_eefb .Append (_ag .MakeFloat (_fgeec .Y +_cega ));};_bcff .AddAnnotation (_bgdg ._edgdf );};_gcab +=_badeb ;_aec .Add_Tr (int64 (TextRenderingModeFill ));_aec .Add_Tc (0);};_dcfa -=_geae ;};_aec .Add_ET ();_aec .Add_Q ();_ffff :=_aec .Operations ();_ffff .WrapIfNeeded ();_bcff .addContents (_ffff );if _bfff {_gccc :=_bcfff +_bgbb ._egeg ._dfbb ;_bbbc .Y +=_gccc ;_bbbc .Height -=_gccc ;if _bbbc .Inline {_bbbc .X +=_bgbb .Width ()+_bgbb ._egeg ._bcde ;};};return _bbbc ,_fbag ,nil ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_cgfa *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_cgfa ._cgee =append (_cgfa ._cgee ,line );return line ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_ggaa *Chapter )SetIncludeInTOC (includeInTOC bool ){_ggaa ._ggf =includeInTOC };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bbee *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_ccfee :=NewTextChunk (text ,_bbee ._beaag );_ccfee ._edgdf =_gfdb (page -1,x ,y ,zoom );return _bbee .appendChunk (_ccfee );};func _faga (_edd *Chapter ,_accc *TOC ,_aad *_fd .Outline ,_bcd string ,_cdfb int ,_fda TextStyle )*Chapter {var _eccbg uint =1;if _edd !=nil {_eccbg =_edd ._bgfa +1;};_eeef :=&Chapter {_eea :_cdfb ,_bfb :_bcd ,_ffd :true ,_ggf :true ,_ddfa :_edd ,_fdc :_accc ,_fffe :_aad ,_cfd :[]Drawable {},_bgfa :_eccbg };_bde :=_cbaec (_eeef .headingText (),_fda );_bde .SetFont (_fda .Font );_bde .SetFontSize (_fda .FontSize );_eeef ._cdf =_bde ;return _eeef ;};

// SetBorderWidth sets the border width.
func (_baca *Polygon )SetBorderWidth (borderWidth float64 ){_baca ._fbcf .BorderWidth =borderWidth };

// NewTable create a new Table with a specified number of columns.
func (_efe *Creator )NewTable (cols int )*Table {return _egge (cols )};