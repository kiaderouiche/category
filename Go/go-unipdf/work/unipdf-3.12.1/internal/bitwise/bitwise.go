//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_ec "encoding/binary";_ea "errors";_f "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_be *BufferedWriter )expandIfNeeded (_ced int ){if !_be .tryGrowByReslice (_ced ){_be .grow (_ced );};};func (_efg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_efg ._dd =-1;var _aaf int64 ;switch whence {case _a .SeekStart :_aaf =offset ;case _a .SeekCurrent :_aaf =_efg ._fec +offset ;case _a .SeekEnd :_aaf =int64 (len (_efg ._dedc ))+offset ;default:return 0,_ea .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _aaf < 0{return 0,_ea .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_efg ._fec =_aaf ;_efg ._faa =0;return _aaf ,nil ;};func (_de *BufferedWriter )FinishByte (){if _de ._ae ==0{return ;};_de ._ae =0;_de ._ce ++;};func (_baaf *Writer )FinishByte (){if _baaf ._gaf ==0{return ;};_baaf ._gaf =0;_baaf ._cff ++;};func (_fccb *SubstreamReader )ReadBits (n byte )(_agg uint64 ,_bef error ){if n < _fccb ._cb {_dgc :=_fccb ._cb -n ;_agg =uint64 (_fccb ._ddb >>_dgc );_fccb ._ddb &=1<<_dgc -1;_fccb ._cb =_dgc ;return _agg ,nil ;};if n > _fccb ._cb {if _fccb ._cb > 0{_agg =uint64 (_fccb ._ddb );n -=_fccb ._cb ;};var _gaa byte ;for n >=8{_gaa ,_bef =_fccb .readBufferByte ();if _bef !=nil {return 0,_bef ;};_agg =_agg <<8+uint64 (_gaa );n -=8;};if n > 0{if _fccb ._ddb ,_bef =_fccb .readBufferByte ();_bef !=nil {return 0,_bef ;};_ecd :=8-n ;_agg =_agg <<n +uint64 (_fccb ._ddb >>_ecd );_fccb ._ddb &=1<<_ecd -1;_fccb ._cb =_ecd ;}else {_fccb ._cb =0;};return _agg ,nil ;};_fccb ._cb =0;return uint64 (_fccb ._ddb ),nil ;};func (_cdca *Writer )writeByte (_fgd byte )error {if _cdca ._cff > len (_cdca ._fcf )-1{return _a .EOF ;};if _cdca ._cff ==len (_cdca ._fcf )-1&&_cdca ._gaf !=0{return _a .EOF ;};if _cdca ._gaf ==0{_cdca ._fcf [_cdca ._cff ]=_fgd ;_cdca ._cff ++;return nil ;};if _cdca ._afag {_cdca ._fcf [_cdca ._cff ]|=_fgd >>_cdca ._gaf ;_cdca ._cff ++;_cdca ._fcf [_cdca ._cff ]=byte (uint16 (_fgd )<<(8-_cdca ._gaf )&0xff);}else {_cdca ._fcf [_cdca ._cff ]|=byte (uint16 (_fgd )<<_cdca ._gaf &0xff);_cdca ._cff ++;_cdca ._fcf [_cdca ._cff ]=_fgd >>(8-_cdca ._gaf );};return nil ;};const (_aa =64;_d =int (^uint (0)>>1););func (_df *BufferedWriter )writeShiftedBytes (_cd []byte )int {for _ ,_bdeg :=range _cd {_df .writeByte (_bdeg );};return len (_cd );};func (_gdb *SubstreamReader )Read (b []byte )(_ddc int ,_ebd error ){if _gdb ._feb >=_gdb ._dagf {_f .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_gdb ._feb ,_gdb ._dagf );return 0,_a .EOF ;};for ;_ddc < len (b );_ddc ++{if b [_ddc ],_ebd =_gdb .readUnalignedByte ();_ebd !=nil {if _ebd ==_a .EOF {return _ddc ,nil ;};return 0,_ebd ;};};return _ddc ,nil ;};func (_bbe *BufferedWriter )tryGrowByReslice (_ga int )bool {if _db :=len (_bbe ._c );_ga <=cap (_bbe ._c )-_db {_bbe ._c =_bbe ._c [:_db +_ga ];return true ;};return false ;};func (_efff *Writer )Data ()[]byte {return _efff ._fcf };func (_dafb *SubstreamReader )ReadBit ()(_gc int ,_gdd error ){_face ,_gdd :=_dafb .readBool ();if _gdd !=nil {return 0,_gdd ;};if _face {_gc =1;};return _gc ,nil ;};var _ BinaryWriter =&Writer {};func (_cgb *Reader )Mark (){_cgb ._fab =_cgb ._fec ;_cgb ._fbg =_cgb ._faa };func (_cdde *Writer )SkipBits (skip int )error {const _ggfa ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_gbg :=int (_cdde ._gaf )+skip ;if _gbg >=0&&_gbg < 8{_cdde ._gaf =uint8 (_gbg );return nil ;};_gbg =int (_cdde ._gaf )+_cdde ._cff *8+skip ;if _gbg < 0{return _b .Errorf (_ggfa ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_eaed :=_gbg /8;_aaa :=_gbg %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_cdde ._gaf ,_cdde ._cff ,int (_cdde ._gaf )+(_cdde ._cff )*8,len (_cdde ._fcf ),cap (_cdde ._fcf ));_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_gbg ,_aaa );_cdde ._gaf =uint8 (_aaa );if _dcg :=_eaed -_cdde ._cff ;_dcg > 0&&len (_cdde ._fcf )-1< _eaed {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dcg );return _b .Errorf (_ggfa ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cdde ._cff =_eaed ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_cdde ._gaf ,_cdde ._cff );return nil ;};func NewReader (data []byte )*Reader {return &Reader {_dedc :data }};func (_fb *BufferedWriter )WriteByte (bt byte )error {if _fb ._ce > len (_fb ._c )-1||(_fb ._ce ==len (_fb ._c )-1&&_fb ._ae !=0){_fb .expandIfNeeded (1);};_fb .writeByte (bt );return nil ;};func (_gfg *BufferedWriter )WriteBits (bits uint64 ,number int )(_ff int ,_gb error ){const _fg ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_b .Errorf (_fg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_ded :=number /8;if _ded > 0{_fa :=number -_ded *8;for _fd :=_ded -1;_fd >=0;_fd --{_daf :=byte ((bits >>uint (_fd *8+_fa ))&0xff);if _gb =_gfg .WriteByte (_daf );_gb !=nil {return _ff ,_b .Wrapf (_gb ,_fg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ded -_fd +1);};};number -=_ded *8;if number ==0{return _ded ,nil ;};};var _eab int ;for _fe :=0;_fe < number ;_fe ++{if _gfg ._fc {_eab =int ((bits >>uint (number -1-_fe ))&0x1);}else {_eab =int (bits &0x1);bits >>=1;};if _gb =_gfg .WriteBit (_eab );_gb !=nil {return _ff ,_b .Wrapf (_gb ,_fg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fe );};};return _ded ,nil ;};func (_bd *BufferedWriter )writeByte (_eg byte ){switch {case _bd ._ae ==0:_bd ._c [_bd ._ce ]=_eg ;_bd ._ce ++;case _bd ._fc :_bd ._c [_bd ._ce ]|=_eg >>_bd ._ae ;_bd ._ce ++;_bd ._c [_bd ._ce ]=byte (uint16 (_eg )<<(8-_bd ._ae )&0xff);default:_bd ._c [_bd ._ce ]|=byte (uint16 (_eg )<<_bd ._ae &0xff);_bd ._ce ++;_bd ._c [_bd ._ce ]=_eg >>(8-_bd ._ae );};};func (_fae *Writer )UseMSB ()bool {return _fae ._afag };func (_gg *BufferedWriter )fullOffset ()int {_ge :=_gg ._ce ;if _gg ._ae !=0{_ge ++;};return _ge ;};func (_bba *SubstreamReader )BitPosition ()int {return int (_bba ._cb )};func (_cc *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ed :=int (_cc ._ae )+skip ;if _ed >=0&&_ed < 8{_cc ._ae =uint8 (_ed );return nil ;};_ed =int (_cc ._ae )+_cc ._ce *8+skip ;if _ed < 0{return _b .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bac :=_ed /8;_aec :=_ed %8;_cc ._ae =uint8 (_aec );if _bb :=_bac -_cc ._ce ;_bb > 0&&len (_cc ._c )-1< _bac {if _cc ._ae !=0{_bb ++;};_cc .expandIfNeeded (_bb );};_cc ._ce =_bac ;return nil ;};var _ BinaryWriter =&BufferedWriter {};func (_ffdc *Reader )ReadBit ()(_fgc int ,_bee error ){_aga ,_bee :=_ffdc .readBool ();if _bee !=nil {return 0,_bee ;};if _aga {_fgc =1;};return _fgc ,nil ;};func (_dff *Reader )StreamPosition ()int64 {return _dff ._fec };func (_dafc *Reader )read (_eeb []byte )(int ,error ){if _dafc ._fec >=int64 (len (_dafc ._dedc )){return 0,_a .EOF ;};_dafc ._dd =-1;_fcc :=copy (_eeb ,_dafc ._dedc [_dafc ._fec :]);_dafc ._fec +=int64 (_fcc );return _fcc ,nil ;};func (_ege *SubstreamReader )Length ()uint64 {return _ege ._dagf };func (_bde *BufferedWriter )writeFullBytes (_bg []byte )int {_eag :=copy (_bde ._c [_bde .fullOffset ():],_bg );_bde ._ce +=_eag ;return _eag ;};func (_gea *Writer )writeBit (_ffe uint8 )error {if len (_gea ._fcf )-1< _gea ._cff {return _a .EOF ;};_dedca :=_gea ._gaf ;if _gea ._afag {_dedca =7-_gea ._gaf ;};_gea ._fcf [_gea ._cff ]|=byte (uint16 (_ffe <<_dedca )&0xff);_gea ._gaf ++;if _gea ._gaf ==8{_gea ._cff ++;_gea ._gaf =0;};return nil ;};var _ _a .Writer =&BufferedWriter {};func (_afb *SubstreamReader )Offset ()uint64 {return _afb ._dfd };func (_cbdg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cbdg .writeBit (uint8 (bit ));};return _b .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_da *BufferedWriter )Write (d []byte )(int ,error ){_da .expandIfNeeded (len (d ));if _da ._ae ==0{return _da .writeFullBytes (d ),nil ;};return _da .writeShiftedBytes (d ),nil ;};func (_cbd *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _a .SeekStart :_cbd ._feb =uint64 (offset );case _a .SeekCurrent :_cbd ._feb +=uint64 (offset );case _a .SeekEnd :_cbd ._feb =_cbd ._dagf +uint64 (offset );default:return 0,_ea .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_cbd ._cb =0;return int64 (_cbd ._feb ),nil ;};type Reader struct{_dedc []byte ;_gff byte ;_faa byte ;_fec int64 ;_ecb int ;_dd int ;_fab int64 ;_fbg byte ;};func (_eebe *SubstreamReader )Align ()(_bga byte ){_bga =_eebe ._cb ;_eebe ._cb =0;return _bga };func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_ea .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_f .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_cfe :r ,_dfd :offset ,_dagf :length ,_beef :make ([]byte ,length )},nil ;};func (_ffde *SubstreamReader )ReadBool ()(bool ,error ){return _ffde .readBool ()};func (_gf *BufferedWriter )Reset (){_gf ._c =_gf ._c [:0];_gf ._ce =0;_gf ._ae =0};var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};_ _a .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ffg *Reader )readBufferByte ()(byte ,error ){if _ffg ._fec >=int64 (len (_ffg ._dedc )){return 0,_a .EOF ;};_ffg ._dd =-1;_bcd :=_ffg ._dedc [_ffg ._fec ];_ffg ._fec ++;_ffg ._ecb =int (_bcd );return _bcd ,nil ;};func (_ccc *Reader )ReadByte ()(byte ,error ){if _ccc ._faa ==0{return _ccc .readBufferByte ();};return _ccc .readUnalignedByte ();};func (_ba *BufferedWriter )Len ()int {return _ba .byteCapacity ()};func (_egae *SubstreamReader )Mark (){_egae ._febg =_egae ._feb ;_egae ._eff =_egae ._cb };func (_ac *SubstreamReader )fillBuffer ()error {if uint64 (_ac ._cfe .StreamPosition ())!=_ac ._feb +_ac ._dfd {_ ,_fca :=_ac ._cfe .Seek (int64 (_ac ._feb +_ac ._dfd ),_a .SeekStart );if _fca !=nil {return _fca ;};};_ac ._aeb =uint64 (_ac ._feb );_ddg :=_cdc (uint64 (len (_ac ._beef )),_ac ._dagf -_ac ._feb );_fad :=make ([]byte ,_ddg );_aca ,_bed :=_ac ._cfe .Read (_fad );if _bed !=nil {return _bed ;};for _cfea :=uint64 (0);_cfea < _ddg ;_cfea ++{_ac ._beef [_cfea ]=_fad [_cfea ];};_ac ._gbf =_ac ._aeb +uint64 (_aca );return nil ;};func (_gad *Reader )ReadBool ()(bool ,error ){return _gad .readBool ()};func (_afg *Reader )Reset (){_afg ._fec =_afg ._fab ;_afg ._faa =_afg ._fbg };func (_ggf *Reader )readBool ()(_gd bool ,_dg error ){if _ggf ._faa ==0{_ggf ._gff ,_dg =_ggf .readBufferByte ();if _dg !=nil {return false ,_dg ;};_gd =(_ggf ._gff &0x80)!=0;_ggf ._gff ,_ggf ._faa =_ggf ._gff &0x7f,7;return _gd ,nil ;};_ggf ._faa --;_gd =(_ggf ._gff &(1<<_ggf ._faa ))!=0;_ggf ._gff &=1<<_ggf ._faa -1;return _gd ,nil ;};func (_caee *SubstreamReader )Reset (){_caee ._feb =_caee ._febg ;_caee ._cb =_caee ._eff };func (_eb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _b .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_eb ._c )-1< _eb ._ce {_eb .expandIfNeeded (1);};_age :=_eb ._ae ;if _eb ._fc {_age =7-_eb ._ae ;};_eb ._c [_eb ._ce ]|=byte (uint16 (bit <<_age )&0xff);_eb ._ae ++;if _eb ._ae ==8{_eb ._ce ++;_eb ._ae =0;};return nil ;};type BitWriter interface{WriteBit (_af int )error ;WriteBits (_ebf uint64 ,_beg int )(_ece int ,_cdd error );FinishByte ();SkipBits (_ee int )error ;};func (_cbg *SubstreamReader )readBool ()(_ffda bool ,_agc error ){if _cbg ._cb ==0{_cbg ._ddb ,_agc =_cbg .readBufferByte ();if _agc !=nil {return false ,_agc ;};_ffda =(_cbg ._ddb &0x80)!=0;_cbg ._ddb ,_cbg ._cb =_cbg ._ddb &0x7f,7;return _ffda ,nil ;};_cbg ._cb --;_ffda =(_cbg ._ddb &(1<<_cbg ._cb ))!=0;_cbg ._ddb &=1<<_cbg ._cb -1;return _ffda ,nil ;};func (_bbc *SubstreamReader )readUnalignedByte ()(_ebdf byte ,_dbd error ){_adeg :=_bbc ._cb ;_ebdf =_bbc ._ddb <<(8-_adeg );_bbc ._ddb ,_dbd =_bbc .readBufferByte ();if _dbd !=nil {return 0,_dbd ;};_ebdf |=_bbc ._ddb >>_adeg ;_bbc ._ddb &=1<<_adeg -1;return _ebdf ,nil ;};func (_baa *SubstreamReader )readBufferByte ()(byte ,error ){if _baa ._feb >=_baa ._dagf {return 0,_a .EOF ;};if _baa ._feb >=_baa ._gbf ||_baa ._feb < _baa ._aeb {if _geg :=_baa .fillBuffer ();_geg !=nil {return 0,_geg ;};};_bdea :=_baa ._beef [_baa ._feb -_baa ._aeb ];_baa ._feb ++;return _bdea ,nil ;};type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;};func (_eae *Reader )Read (p []byte )(_bbec int ,_ega error ){if _eae ._faa ==0{return _eae .read (p );};for ;_bbec < len (p );_bbec ++{if p [_bbec ],_ega =_eae .readUnalignedByte ();_ega !=nil {return 0,_ega ;};};return _bbec ,nil ;};type Writer struct{_fcf []byte ;_gaf uint8 ;_cff int ;_afag bool ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_fcf :data ,_afag :true }};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_fc :true }};func NewWriter (data []byte )*Writer {return &Writer {_fcf :data }};var _ _a .ByteWriter =&BufferedWriter {};func (_ag *BufferedWriter )ResetBitIndex (){_ag ._ae =0};func (_ad *BufferedWriter )byteCapacity ()int {_ffd :=len (_ad ._c )-_ad ._ce ;if _ad ._ae !=0{_ffd --;};return _ffd ;};func (_dda *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cga :=make ([]byte ,4);_ ,_ecf :=_dda .Read (_cga );if _ecf !=nil {return 0,_ecf ;};return _ec .BigEndian .Uint32 (_cga ),nil ;};func (_dafg *BufferedWriter )grow (_cfb int ){if _dafg ._c ==nil &&_cfb < _aa {_dafg ._c =make ([]byte ,_cfb ,_aa );return ;};_ca :=len (_dafg ._c );if _dafg ._ae !=0{_ca ++;};_ab :=cap (_dafg ._c );switch {case _cfb <=_ab /2-_ca :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_dafg ._c ),cap (_dafg ._c ),_cfb );_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ab ,_ca );copy (_dafg ._c ,_dafg ._c [_dafg .fullOffset ():]);case _ab > _d -_ab -_cfb :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ef :=make ([]byte ,2*_ab +_cfb );copy (_ef ,_dafg ._c );_dafg ._c =_ef ;};_dafg ._c =_dafg ._c [:_ca +_cfb ];};func (_bc *Reader )ConsumeRemainingBits (){if _bc ._faa !=0{_ ,_agf :=_bc .ReadBits (_bc ._faa );if _agf !=nil {_f .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_agf );};};};type SubstreamReader struct{_feb uint64 ;_cfe StreamReader ;_dfd uint64 ;_dagf uint64 ;_beef []byte ;_aeb uint64 ;_gbf uint64 ;_ddb byte ;_cb byte ;_febg uint64 ;_eff byte ;};func (_ade *Reader )ReadBits (n byte )(_feg uint64 ,_cea error ){if n < _ade ._faa {_faba :=_ade ._faa -n ;_feg =uint64 (_ade ._gff >>_faba );_ade ._gff &=1<<_faba -1;_ade ._faa =_faba ;return _feg ,nil ;};if n > _ade ._faa {if _ade ._faa > 0{_feg =uint64 (_ade ._gff );n -=_ade ._faa ;};for n >=8{_ageg ,_ede :=_ade .readBufferByte ();if _ede !=nil {return 0,_ede ;};_feg =_feg <<8+uint64 (_ageg );n -=8;};if n > 0{if _ade ._gff ,_cea =_ade .readBufferByte ();_cea !=nil {return 0,_cea ;};_ffb :=8-n ;_feg =_feg <<n +uint64 (_ade ._gff >>_ffb );_ade ._gff &=1<<_ffb -1;_ade ._faa =_ffb ;}else {_ade ._faa =0;};return _feg ,nil ;};_ade ._faa =0;return uint64 (_ade ._gff ),nil ;};func (_cgad *SubstreamReader )StreamPosition ()int64 {return int64 (_cgad ._feb )};func (_bgg *Reader )BitPosition ()int {return int (_bgg ._faa )};func (_ebgd *Writer )WriteBits (bits uint64 ,number int )(_gde int ,_cee error ){const _gge ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_b .Errorf (_gge ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_def :=number /8;if _def > 0{_edec :=number -_def *8;for _cbf :=_def -1;_cbf >=0;_cbf --{_dfb :=byte ((bits >>uint (_cbf *8+_edec ))&0xff);if _cee =_ebgd .WriteByte (_dfb );_cee !=nil {return _gde ,_b .Wrapf (_cee ,_gge ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_def -_cbf +1);};};number -=_def *8;if number ==0{return _def ,nil ;};};var _caef int ;for _dbc :=0;_dbc < number ;_dbc ++{if _ebgd ._afag {_caef =int ((bits >>uint (number -1-_dbc ))&0x1);}else {_caef =int (bits &0x1);bits >>=1;};if _cee =_ebgd .WriteBit (_caef );_cee !=nil {return _gde ,_b .Wrapf (_cee ,_gge ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dbc );};};return _def ,nil ;};func (_ada *Reader )Align ()(_fac byte ){_fac =_ada ._faa ;_ada ._faa =0;return _fac };func (_cg *Reader )Length ()uint64 {return uint64 (len (_cg ._dedc ))};func (_adb *Writer )ResetBit (){_adb ._gaf =0};type StreamReader interface{_a .Reader ;_a .ByteReader ;_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_edc byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_fgf *Writer )byteCapacity ()int {_ecde :=len (_fgf ._fcf )-_fgf ._cff ;if _fgf ._gaf !=0{_ecde --;};return _ecde ;};type BufferedWriter struct{_c []byte ;_ae uint8 ;_ce int ;_fc bool ;};func (_cge *Reader )ReadUint32 ()(uint32 ,error ){_afd :=make ([]byte ,4);_ ,_cae :=_cge .Read (_afd );if _cae !=nil {return 0,_cae ;};return _ec .BigEndian .Uint32 (_afd ),nil ;};func (_fdc *Writer )WriteByte (c byte )error {return _fdc .writeByte (c )};func (_g *BufferedWriter )Data ()[]byte {return _g ._c };func (_gcd *SubstreamReader )ReadByte ()(byte ,error ){if _gcd ._cb ==0{return _gcd .readBufferByte ();};return _gcd .readUnalignedByte ();};func (_dag *Reader )readUnalignedByte ()(_cgc byte ,_ebg error ){_adc :=_dag ._faa ;_cgc =_dag ._gff <<(8-_adc );_dag ._gff ,_ebg =_dag .readBufferByte ();if _ebg !=nil {return 0,_ebg ;};_cgc |=_dag ._gff >>_adc ;_dag ._gff &=1<<_adc -1;return _cgc ,nil ;};func _cdc (_gdde ,_cbe uint64 )uint64 {if _gdde < _cbe {return _gdde ;};return _cbe ;};func (_deb *Writer )Write (p []byte )(int ,error ){if len (p )> _deb .byteCapacity (){return 0,_a .EOF ;};for _ ,_ffdg :=range p {if _fff :=_deb .writeByte (_ffdg );_fff !=nil {return 0,_fff ;};};return len (p ),nil ;};