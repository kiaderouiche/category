//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_fe "github.com/unidoc/unipdf/v3/common";_a "math";);func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_fa Matrix )Mult (b Matrix )Matrix {_fa .Concat (b );return _fa };func (_af *Matrix )Shear (x ,y float64 ){_af .Concat (ShearMatrix (x ,y ))};func (_fbf Matrix )String ()string {_c ,_ab ,_dd ,_ac ,_eb ,_ca :=_fbf [0],_fbf [1],_fbf [3],_fbf [4],_fbf [6],_fbf [7];return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_c ,_ab ,_dd ,_ac ,_eb ,_ca );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_b :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_b .clampRange ();return _b ;};func (_ea Matrix )ScalingFactorX ()float64 {return _a .Hypot (_ea [0],_ea [1])};func (_cec *Point )Set (x ,y float64 ){_cec .X ,_cec .Y =x ,y };type Matrix [9]float64 ;func (_bc Matrix )Angle ()float64 {_afa :=_a .Atan2 (-_bc [1],_bc [0]);if _afa < 0.0{_afa +=2*_a .Pi ;};return _afa /_a .Pi *180.0;};func (_aea *Matrix )clampRange (){for _ddd ,_cc :=range _aea {if _cc > _cg {_fe .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cc ,_cg );_aea [_ddd ]=_cg ;}else if _cc < -_cg {_fe .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cc ,-_cg );_aea [_ddd ]=-_cg ;};};};func (_eg *Matrix )Clone ()Matrix {return NewMatrix (_eg [0],_eg [1],_eg [3],_eg [4],_eg [6],_eg [7])};func (_ccg Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ccg .X +t *b .X ,Y :(1-t )*_ccg .Y +t *b .Y };};func RotationMatrix (angle float64 )Matrix {_fb :=_a .Cos (angle );_e :=_a .Sin (angle );return NewMatrix (_fb ,_e ,-_e ,_fb ,0,0);};func (_dda Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_dda [0],_dda [1],_dda [3],_dda [4],_dda [6]+tx ,_dda [7]+ty );};func (_ef Matrix )Translation ()(float64 ,float64 ){return _ef [6],_ef [7]};func (_g *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_g [0],_g [1]=a ,b ;_g [3],_g [4]=c ,d ;_g [6],_g [7]=tx ,ty ;_g .clampRange ();};func (_bg Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_bg .X ,_bg .Y );};func (_ae Matrix )Inverse ()(Matrix ,bool ){_bb ,_fbd :=_ae [0],_ae [1];_ed ,_gd :=_ae [3],_ae [4];_aa ,_bd :=_ae [6],_ae [7];_egf :=_bb *_gd -_fbd *_ed ;if _a .Abs (_egf )< _db {return Matrix {},false ;};_bcd ,_gb :=_gd /_egf ,-_fbd /_egf ;_abe ,_abea :=-_ed /_egf ,_bb /_egf ;_cb :=-(_bcd *_aa +_abe *_bd );_cf :=-(_gb *_aa +_abea *_bd );return NewMatrix (_bcd ,_gb ,_abe ,_abea ,_cb ,_cf ),true ;};const _gc =1e-6;func (_cgb Point )Rotate (theta float64 )Point {_cbg :=_a .Hypot (_cgb .X ,_cgb .Y );_gac :=_a .Atan2 (_cgb .Y ,_cgb .X );_caeg ,_cd :=_a .Sincos (_gac +theta /180.0*_a .Pi );return Point {_cbg *_cd ,_cbg *_caeg };};const _cg =1e9;func (_ebd *Matrix )Concat (b Matrix ){*_ebd =Matrix {b [0]*_ebd [0]+b [1]*_ebd [3],b [0]*_ebd [1]+b [1]*_ebd [4],0,b [3]*_ebd [0]+b [4]*_ebd [3],b [3]*_ebd [1]+b [4]*_ebd [4],0,b [6]*_ebd [0]+b [7]*_ebd [3]+_ebd [6],b [6]*_ebd [1]+b [7]*_ebd [4]+_ebd [7],1};_ebd .clampRange ();};func (_fbg Matrix )ScalingFactorY ()float64 {return _a .Hypot (_fbg [3],_fbg [4])};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ee Matrix )Rotate (theta float64 )Matrix {_ce ,_acg :=_a .Sincos (theta /180.0*_a .Pi );return _ee .Mult (NewMatrix (_acg ,-_ce ,_ce ,_acg ,0,0));};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};const _db =1.0e-6;func (_fbe Matrix )Scale (xScale ,yScale float64 )Matrix {return _fbe .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_df Point )Displace (delta Point )Point {return Point {_df .X +delta .X ,_df .Y +delta .Y }};func (_ba Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ga :=x *_ba [0]+y *_ba [3]+_ba [6];_fee :=x *_ba [1]+y *_ba [4]+_ba [7];return _ga ,_fee ;};type Point struct{X float64 ;Y float64 ;};func (_ad *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ccd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ad .transformByMatrix (_ccd );};func (_cae Matrix )Unrealistic ()bool {_gg ,_fad ,_aed ,_fg :=_a .Abs (_cae [0]),_a .Abs (_cae [1]),_a .Abs (_cae [3]),_a .Abs (_cae [4]);_aaf :=_gg > _gc &&_fg > _gc ;_ccc :=_fad > _gc &&_aed > _gc ;return !(_aaf ||_ccc );};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_baa Point )Distance (b Point )float64 {return _a .Hypot (_baa .X -b .X ,_baa .Y -b .Y )};func (_aee *Point )transformByMatrix (_gf Matrix ){_aee .X ,_aee .Y =_gf .Transform (_aee .X ,_aee .Y )};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};