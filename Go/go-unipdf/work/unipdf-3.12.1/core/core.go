//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_de "bufio";_bgd "bytes";_bge "compress/lzw";_ggb "compress/zlib";_e "crypto/md5";_dc "crypto/rand";_gg "encoding/hex";_c "errors";_d "fmt";_aab "github.com/unidoc/unipdf/v3/common";_bba "github.com/unidoc/unipdf/v3/core/security";_gfa "github.com/unidoc/unipdf/v3/core/security/crypt";_gcc "github.com/unidoc/unipdf/v3/internal/ccittfax";_aba "github.com/unidoc/unipdf/v3/internal/imageutil";_ab "github.com/unidoc/unipdf/v3/internal/jbig2";_ega "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_dd "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_dce "github.com/unidoc/unipdf/v3/internal/jbig2/document";_df "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_af "github.com/unidoc/unipdf/v3/internal/strutils";_f "golang.org/x/image/tiff/lzw";_gc "golang.org/x/xerrors";_aa "image";_a "image/color";_bb "image/jpeg";_gf "io";_da "os";_b "reflect";_ga "regexp";_cf "sort";_bg "strconv";_eg "strings";_be "time";);

// UpdateParams updates the parameter values of the encoder.
func (_bca *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_fcf ,_fbge :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _fbge ==nil {_bca .Predictor =int (_fcf );};_cfcc ,_fbge :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fbge ==nil {_bca .BitsPerComponent =int (_cfcc );};_aad ,_fbge :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fbge ==nil {_bca .Columns =int (_aad );};_dafg ,_fbge :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fbge ==nil {_bca .Colors =int (_dafg );};_gcbba ,_fbge :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _fbge ==nil {_bca .EarlyChange =int (_gcbba );};};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_fgb encryptDict ;_aace _bba .StdEncryptDict ;_efe string ;_gaf []byte ;_bbd map[PdfObject ]bool ;_abg map[PdfObject ]bool ;_gbe bool ;_adg cryptFilters ;_cbg string ;_ca string ;_adf *PdfParser ;_aaced map[int ]struct{};};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_edbc map[PdfObjectName ]PdfObject ;_fcabe []PdfObjectName ;_ffad *PdfParser ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gfc *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gfc .isDecrypted (obj ){return nil ;};switch _baf :=obj .(type ){case *PdfIndirectObject :_gfc ._bbd [_baf ]=true ;_aab .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_baf .ObjectNumber ,_baf .GenerationNumber );_dfbe :=_baf .ObjectNumber ;_egf :=_baf .GenerationNumber ;_egfc :=_gfc .Decrypt (_baf .PdfObject ,_dfbe ,_egf );if _egfc !=nil {return _egfc ;};return nil ;case *PdfObjectStream :_gfc ._bbd [_baf ]=true ;_bcb :=_baf .PdfObjectDictionary ;if _gfc ._aace .R !=5{if _gfedd ,_gace :=_bcb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gace &&*_gfedd =="\u0058\u0052\u0065\u0066"{return nil ;};};_gadc :=_baf .ObjectNumber ;_eaf :=_baf .GenerationNumber ;_aab .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gadc ,_eaf );_abagd :=_acf ;if _gfc ._fgb .V >=4{_abagd =_gfc ._cbg ;_aab .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gfc ._cbg );if _gcdd ,_bffg :=_bcb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_bffg {if _fab ,_fbc :=GetName (_gcdd .Get (0));_fbc {if *_fab =="\u0043\u0072\u0079p\u0074"{_abagd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cfb ,_geef :=_bcb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_geef {if _edc ,_egff :=_cfb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_egff {if _ ,_bgeb :=_gfc ._adg [string (*_edc )];_bgeb {_aab .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_edc );_abagd =string (*_edc );};};};};};};_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_abagd );if _abagd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bfb :=_gfc .Decrypt (_bcb ,_gadc ,_eaf );if _bfb !=nil {return _bfb ;};_ddg ,_bfb :=_gfc .makeKey (_abagd ,uint32 (_gadc ),uint32 (_eaf ),_gfc ._gaf );if _bfb !=nil {return _bfb ;};_baf .Stream ,_bfb =_gfc .decryptBytes (_baf .Stream ,_abagd ,_ddg );if _bfb !=nil {return _bfb ;};_bcb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_baf .Stream ))));return nil ;case *PdfObjectString :_aab .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_caeg :=_acf ;if _gfc ._fgb .V >=4{_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gfc ._ca );if _gfc ._ca =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_caeg =_gfc ._ca ;};_faeec ,_eadd :=_gfc .makeKey (_caeg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gfc ._gaf );if _eadd !=nil {return _eadd ;};_eagc :=_baf .Str ();_bbcec :=make ([]byte ,len (_eagc ));for _egfg :=0;_egfg < len (_eagc );_egfg ++{_bbcec [_egfg ]=_eagc [_egfg ];};_aab .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bbcec ,_bbcec );_bbcec ,_eadd =_gfc .decryptBytes (_bbcec ,_caeg ,_faeec );if _eadd !=nil {return _eadd ;};_baf ._edfd =string (_bbcec );return nil ;case *PdfObjectArray :for _ ,_abdd :=range _baf .Elements (){_abcf :=_gfc .Decrypt (_abdd ,parentObjNum ,parentGenNum );if _abcf !=nil {return _abcf ;};};return nil ;case *PdfObjectDictionary :_aacc :=false ;if _ede :=_baf .Get ("\u0054\u0079\u0070\u0065");_ede !=nil {_gfeb ,_dacb :=_ede .(*PdfObjectName );if _dacb &&*_gfeb =="\u0053\u0069\u0067"{_aacc =true ;};};for _ ,_cbgf :=range _baf .Keys (){_bfe :=_baf .Get (_cbgf );if _aacc &&string (_cbgf )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_cbgf )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_cbgf )!="\u0050\u0072\u0065\u0076"&&string (_cbgf )!="\u004c\u0061\u0073\u0074"{_dbfb :=_gfc .Decrypt (_bfe ,parentObjNum ,parentGenNum );if _dbfb !=nil {return _dbfb ;};};};return nil ;};return nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_abce *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ab .Globals ,error ){return _ab .DecodeGlobals (encoded );};func (_bbe *PdfCrypt )isDecrypted (_bbed PdfObject )bool {_ ,_afd :=_bbe ._bbd [_bbed ];if _afd {_aab .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _faee :=_bbed .(type ){case *PdfObjectStream :if _bbe ._aace .R !=5{if _fce ,_agc :=_faee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_agc &&*_fce =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_afd =_bbe ._aaced [int (_faee .ObjectNumber )];_afd {return true ;};switch _aebb :=_faee .PdfObject .(type ){case *PdfObjectDictionary :_cgd :=true ;for _ ,_abgf :=range _gfaa {if _aebb .Get (_abgf )==nil {_cgd =false ;break ;};};if _cgd {return true ;};};};_aab .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_abefa *PdfParser )readTextLine ()(string ,error ){var _gdffa _bgd .Buffer ;for {_acdf ,_abb :=_abefa ._fegg .Peek (1);if _abb !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abb .Error ());return _gdffa .String (),_abb ;};if (_acdf [0]!='\r')&&(_acdf [0]!='\n'){_bfgb ,_ :=_abefa ._fegg .ReadByte ();_gdffa .WriteByte (_bfgb );}else {break ;};};return _gdffa .String (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gaaee *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_abca *PdfObjectStreams )Elements ()[]PdfObject {if _abca ==nil {return nil ;};return _abca ._ccfddc ;};

// DecodeStream implements ASCII hex decoding.
func (_dbec *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dbec .DecodeBytes (streamObj .Stream );};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_ccfc :=MakeArray ();for _ ,_cadcb :=range vals {_ccfc .Append (MakeFloat (_cadcb ));};return _ccfc ;};func _cfbd (_adba *PdfObjectStream ,_fbae *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _ebbfee ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_ffgg :=&JBIG2Encoder {};_agag :=_adba .PdfObjectDictionary ;if _agag ==nil {return _ffgg ,nil ;};if _fbae ==nil {_dbc :=_agag .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _dbc !=nil {switch _egc :=_dbc .(type ){case *PdfObjectDictionary :_fbae =_egc ;case *PdfObjectArray :if _egc .Len ()==1{if _abebe ,_dec :=GetDict (_egc .Get (0));_dec {_fbae =_abebe ;};};default:_aab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_dbc );return nil ,_df .Errorf (_ebbfee ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_egc );};};};if _fbae ==nil {return _ffgg ,nil ;};_ffgg .UpdateParams (_fbae );_geda :=_fbae .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _geda ==nil {return _ffgg ,nil ;};var _fedc error ;_edca ,_abda :=_geda .(*PdfObjectStream );if !_abda {_fedc =_df .Error (_ebbfee ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fedc );return nil ,_fedc ;};_ffgg .Globals ,_fedc =_ab .DecodeGlobals (_edca .Stream );if _fedc !=nil {_fedc =_df .Wrap (_fedc ,_ebbfee ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fedc );return nil ,_fedc ;};return _ffgg ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_fagc *PdfParser )GetXrefTable ()XrefTable {return _fagc ._baae };

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_dbffd *PdfObjectInteger ,_dcfc bool ){_dbffd ,_dcfc =TraceToDirectObject (obj ).(*PdfObjectInteger );return _dbffd ,_dcfc ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_aeaf *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aab .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_gcbd :=_bgd .NewReader (encoded );_adc ,_gbb :=_ggb .NewReader (_gcbd );if _gbb !=nil {_aab .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gbb );_aab .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_gbb ;};defer _adc .Close ();var _dca _bgd .Buffer ;_dca .ReadFrom (_adc );return _dca .Bytes (),nil ;};const (_fbg =0;_ecbg =1;_caf =2;_fcga =3;_dacd =4;);func (_ecea *JBIG2Encoder )encodeImage (_bffd _aa .Image )([]byte ,error ){const _gaac ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_cgee ,_dfae :=GoImageToJBIG2 (_bffd ,JB2ImageAutoThreshold );if _dfae !=nil {return nil ,_df .Wrap (_dfae ,_gaac ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _dfae =_ecea .AddPageImage (_cgee ,&_ecea .DefaultPageSettings );_dfae !=nil {return nil ,_df .Wrap (_dfae ,_gaac ,"");};return _ecea .Encode ();};func _fdbe (_ecfb _gf .ReadSeeker ,_ggbb int64 )(*offsetReader ,error ){_eeae :=&offsetReader {_deacd :_ecfb ,_becf :_ggbb };_ ,_baaa :=_eeae .Seek (0,_gf .SeekStart );return _eeae ,_baaa ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fgff *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_gdcdf error ){const _fcde ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _fgff ==nil {return _df .Error (_fcde ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_fgff .DefaultPageSettings ;};if _fgff ._abdg ==nil {_fgff ._abdg =_dce .InitEncodeDocument (settings .FileMode );};if _gdcdf =settings .Validate ();_gdcdf !=nil {return _df .Wrap (_gdcdf ,_fcde ,"");};_gagb ,_gdcdf :=img .toBitmap ();if _gdcdf !=nil {return _df .Wrap (_gdcdf ,_fcde ,"");};switch settings .Compression {case JB2Generic :if _gdcdf =_fgff ._abdg .AddGenericPage (_gagb ,settings .DuplicatedLinesRemoval );_gdcdf !=nil {return _df .Wrap (_gdcdf ,_fcde ,"");};case JB2SymbolCorrelation :return _df .Error (_fcde ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _df .Error (_fcde ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _df .Error (_fcde ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fee *FlateEncoder )MakeDecodeParams ()PdfObject {if _fee .Predictor > 1{_ecb :=MakeDict ();_ecb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fee .Predictor )));if _fee .BitsPerComponent !=8{_ecb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fee .BitsPerComponent )));};if _fee .Columns !=1{_ecb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fee .Columns )));};if _fee .Colors !=1{_ecb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fee .Colors )));};return _ecb ;};return nil ;};func (_bbf *PdfCrypt )isEncrypted (_edce PdfObject )bool {_ ,_bab :=_bbf ._abg [_edce ];if _bab {_aab .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_aab .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cgg *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_dbg :=MakeDict ();_dbg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cgg .GetFilterName ()));_cddc :=_cgg .MakeDecodeParams ();if _cddc !=nil {_dbg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cddc );};_dbg .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_cgg .EarlyChange )));return _dbg ;};func _ceg (_cef *_bba .StdEncryptDict ,_abaa *PdfObjectDictionary ){_abaa .Set ("\u0052",MakeInteger (int64 (_cef .R )));_abaa .Set ("\u0050",MakeInteger (int64 (_cef .P )));_abaa .Set ("\u004f",MakeStringFromBytes (_cef .O ));_abaa .Set ("\u0055",MakeStringFromBytes (_cef .U ));if _cef .R >=5{_abaa .Set ("\u004f\u0045",MakeStringFromBytes (_cef .OE ));_abaa .Set ("\u0055\u0045",MakeStringFromBytes (_cef .UE ));_abaa .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_cef .EncryptMetadata ));if _cef .R > 5{_abaa .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_cef .Perms ));};};};

// String returns a string describing `stream`.
func (_eegg *PdfObjectStream )String ()string {return _d .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_eegg .ObjectNumber ,_eegg .PdfObjectDictionary );};

// WriteString outputs the object as it is to be written to file.
func (_gbcac *PdfObjectArray )WriteString ()string {var _bfdf _eg .Builder ;_bfdf .WriteString ("\u005b");for _fbfg ,_geccc :=range _gbcac .Elements (){_bfdf .WriteString (_geccc .WriteString ());if _fbfg < (_gbcac .Len ()-1){_bfdf .WriteString ("\u0020");};};_bfdf .WriteString ("\u005d");return _bfdf .String ();};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dfcc *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};func _gcbg (_defg *PdfObjectStream ,_ced *PdfObjectDictionary )(*LZWEncoder ,error ){_bged :=NewLZWEncoder ();_fbgeg :=_defg .PdfObjectDictionary ;if _fbgeg ==nil {return _bged ,nil ;};if _ced ==nil {_befc :=TraceToDirectObject (_fbgeg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _befc !=nil {if _cfdb ,_gedg :=_befc .(*PdfObjectDictionary );_gedg {_ced =_cfdb ;}else if _fgd ,_dcge :=_befc .(*PdfObjectArray );_dcge {if _fgd .Len ()==1{if _gddd ,_aabda :=GetDict (_fgd .Get (0));_aabda {_ced =_gddd ;};};};if _ced ==nil {_aab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_befc );return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_dfff :=_fbgeg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _dfff !=nil {_bdc ,_bac :=_dfff .(*PdfObjectInteger );if !_bac {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_dfff );return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_bdc !=0&&*_bdc !=1{return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_bged .EarlyChange =int (*_bdc );}else {_bged .EarlyChange =1;};if _ced ==nil {return _bged ,nil ;};_dfff =_ced .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dfff !=nil {_bdeb ,_adgd :=_dfff .(*PdfObjectInteger );if !_adgd {_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dfff );return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bged .Predictor =int (*_bdeb );};_dfff =_ced .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dfff !=nil {_caea ,_bbee :=_dfff .(*PdfObjectInteger );if !_bbee {_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_d .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bged .BitsPerComponent =int (*_caea );};if _bged .Predictor > 1{_bged .Columns =1;_dfff =_ced .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dfff !=nil {_aadc ,_gdda :=_dfff .(*PdfObjectInteger );if !_gdda {return nil ,_d .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bged .Columns =int (*_aadc );};_bged .Colors =1;_dfff =_ced .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dfff !=nil {_gabe ,_fdg :=_dfff .(*PdfObjectInteger );if !_fdg {return nil ,_d .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_bged .Colors =int (*_gabe );};};_aab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_ced .String ());return _bged ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_eabe *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};func (_gfcd *PdfParser )parseHexString ()(*PdfObjectString ,error ){_gfcd ._fegg .ReadByte ();var _dbga _bgd .Buffer ;for {_dbab ,_bdcfd :=_gfcd ._fegg .Peek (1);if _bdcfd !=nil {return MakeString (""),_bdcfd ;};if _dbab [0]=='>'{_gfcd ._fegg .ReadByte ();break ;};_adge ,_ :=_gfcd ._fegg .ReadByte ();if !IsWhiteSpace (_adge ){_dbga .WriteByte (_adge );};};if _dbga .Len ()%2==1{_dbga .WriteRune ('0');};_cafac ,_ :=_gg .DecodeString (_dbga .String ());return MakeHexString (string (_cafac )),nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_fdb *MultiEncoder )AddEncoder (encoder StreamEncoder ){_fdb ._dgab =append (_fdb ._dgab ,encoder )};

// UpdateParams updates the parameter values of the encoder.
func (_bdga *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_bbaa ,_ccbc :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ccbc ==nil {_bdga .Predictor =int (_bbaa );};_affb ,_ccbc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ccbc ==nil {_bdga .BitsPerComponent =int (_affb );};_gbfe ,_ccbc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ccbc ==nil {_bdga .Columns =int (_gbfe );};_bad ,_ccbc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ccbc ==nil {_bdga .Colors =int (_bad );};};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};var _dbgg =_ga .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_dccf *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_gecc :=PdfIndirectObject {};_gecc ._dfaa =_dccf ;_aab .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_gcbbec ,_ccdc :=_dccf ._fegg .Peek (20);if _ccdc !=nil {if _ccdc !=_gf .EOF {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_gecc ,_ccdc ;};};_aab .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gcbbec ));_cfdd :=_cdad .FindStringSubmatchIndex (string (_gcbbec ));if len (_cfdd )< 6{if _ccdc ==_gf .EOF {return nil ,_ccdc ;};_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gcbbec ));return &_gecc ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dccf ._fegg .Discard (_cfdd [0]);_aab .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_cfdd );_efbfe :=_cfdd [1]-_cfdd [0];_fdca :=make ([]byte ,_efbfe );_ ,_ccdc =_dccf .ReadAtLeast (_fdca ,_efbfe );if _ccdc !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_ccdc );return nil ,_ccdc ;};_aab .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fdca );_aadf :=_cdad .FindStringSubmatch (string (_fdca ));if len (_aadf )< 3{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fdca ));return &_gecc ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_bccc ,_ :=_bg .Atoi (_aadf [1]);_dfbf ,_ :=_bg .Atoi (_aadf [2]);_gecc .ObjectNumber =int64 (_bccc );_gecc .GenerationNumber =int64 (_dfbf );for {_bdfb ,_fegfa :=_dccf ._fegg .Peek (2);if _fegfa !=nil {return &_gecc ,_fegfa ;};_aab .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bdfb ),string (_bdfb ));if IsWhiteSpace (_bdfb [0]){_dccf .skipSpaces ();}else if _bdfb [0]=='%'{_dccf .skipComments ();}else if (_bdfb [0]=='<')&&(_bdfb [1]=='<'){_aab .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_gecc .PdfObject ,_fegfa =_dccf .ParseDict ();_aab .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_fegfa );if _fegfa !=nil {return &_gecc ,_fegfa ;};_aab .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_bdfb [0]=='/')||(_bdfb [0]=='(')||(_bdfb [0]=='[')||(_bdfb [0]=='<'){_gecc .PdfObject ,_fegfa =_dccf .parseObject ();if _fegfa !=nil {return &_gecc ,_fegfa ;};_aab .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _bdfb [0]==']'{_aab .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_dccf ._fegg .Discard (1);}else {if _bdfb [0]=='e'{_fgbae ,_dbea :=_dccf .readTextLine ();if _dbea !=nil {return nil ,_dbea ;};if len (_fgbae )>=6&&_fgbae [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _bdfb [0]=='s'{_bdfb ,_ =_dccf ._fegg .Peek (10);if string (_bdfb [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cba :=6;if len (_bdfb )> 6{if IsWhiteSpace (_bdfb [_cba ])&&_bdfb [_cba ]!='\r'&&_bdfb [_cba ]!='\n'{_aab .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_cba ++;};if _bdfb [_cba ]=='\r'{_cba ++;if _bdfb [_cba ]=='\n'{_cba ++;};}else if _bdfb [_cba ]=='\n'{_cba ++;};};_dccf ._fegg .Discard (_cba );_egae ,_gfae :=_gecc .PdfObject .(*PdfObjectDictionary );if !_gfae {return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_aab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_egae );_eadb ,_ggca :=_dccf .traceStreamLength (_egae .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _ggca !=nil {_aab .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_ggca );return nil ,_ggca ;};_aab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_eadb );_ffbd ,_bece :=_eadb .(*PdfObjectInteger );if !_bece {return nil ,_c .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_ceab :=*_ffbd ;if _ceab < 0{return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_faccc :=_dccf .GetFileOffset ();_gcega :=_dccf .xrefNextObjectOffset (_faccc );if _faccc +int64 (_ceab )> _gcega &&_gcega > _faccc {_aab .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_faccc +int64 (_ceab ));_aab .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_gcega );_eegcb :=_gcega -_faccc -17;if _eegcb < 0{return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_aab .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_eegcb );_ceab =PdfObjectInteger (_eegcb );_egae .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_eegcb ));};if int64 (_ceab )> _dccf ._gbbe {_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_gfbcc :=make ([]byte ,_ceab );_ ,_ggca =_dccf .ReadAtLeast (_gfbcc ,int (_ceab ));if _ggca !=nil {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_gfbcc ),_gfbcc );_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ggca );return nil ,_ggca ;};_abac :=PdfObjectStream {};_abac .Stream =_gfbcc ;_abac .PdfObjectDictionary =_gecc .PdfObject .(*PdfObjectDictionary );_abac .ObjectNumber =_gecc .ObjectNumber ;_abac .GenerationNumber =_gecc .GenerationNumber ;_abac .PdfObjectReference ._dfaa =_dccf ;_dccf .skipSpaces ();_dccf ._fegg .Discard (9);_dccf .skipSpaces ();return &_abac ,nil ;};};_gecc .PdfObject ,_fegfa =_dccf .parseObject ();if _gecc .PdfObject ==nil {_aab .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_gecc .PdfObject =MakeNull ();};return &_gecc ,_fegfa ;};};if _gecc .PdfObject ==nil {_aab .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_gecc .PdfObject =MakeNull ();};_aab .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_gecc ,nil ;};var _ebac =_ga .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _bffed (obj1 ,obj2 ,0)};

// GetXrefType returns the type of the first xref object (table or stream).
func (_fgcd *PdfParser )GetXrefType ()*xrefType {return _fgcd ._bgfaf };

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_bdebe :=&ASCIIHexEncoder {};return _bdebe };

// UpdateParams updates the parameter values of the encoder.
func (_ddca *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_gbga *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_deb :=MakeDict ();_deb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gbga .GetFilterName ()));return _deb ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_fceg *JBIG2Encoder )Encode ()(_acff []byte ,_deab error ){const _dfga ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _fceg ._abdg ==nil {return nil ,_df .Errorf (_dfga ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_fceg ._abdg .FullHeaders =_fceg .DefaultPageSettings .FileMode ;_acff ,_deab =_fceg ._abdg .Encode ();if _deab !=nil {return nil ,_df .Wrap (_deab ,_dfga ,"");};return _acff ,nil ;};func (_fda *PdfCrypt )encryptBytes (_gaec []byte ,_cbgb string ,_ada []byte )([]byte ,error ){_aab .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_bbcb ,_ceffg :=_fda ._adg [_cbgb ];if !_ceffg {return nil ,_d .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cbgb );};return _bbcb .EncryptBytes (_gaec ,_ada );};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_bagb []byte ,_cbeg bool ){_bgea ,_cbeg :=TraceToDirectObject (obj ).(*PdfObjectString );if _cbeg {return _bgea .Bytes (),true ;};return ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_eddd :=PdfObjectNull {};return &_eddd };

// GetFilterName returns the name of the encoding filter.
func (_gbac *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_cgc *FlateEncoder )postDecodePredict (_ccdf []byte )([]byte ,error ){if _cgc .Predictor > 1{if _cgc .Predictor ==2{_aab .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_aab .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_cgc .Colors );_cdff :=int (_cgc .Columns )*_cgc .Colors ;if _cdff < 1{return []byte {},nil ;};_cbf :=len (_ccdf )/_cdff ;if len (_ccdf )%_cdff !=0{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ccdf ),_cdff );};if _cdff %_cgc .Colors !=0{return nil ,_d .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_cdff ,_cgc .Colors );};if _cdff > len (_ccdf ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cdff ,len (_ccdf ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aab .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ccdf ),_ccdf );_dfgb :=_bgd .NewBuffer (nil );for _ecdb :=0;_ecdb < _cbf ;_ecdb ++{_defc :=_ccdf [_cdff *_ecdb :_cdff *(_ecdb +1)];for _gfebg :=_cgc .Colors ;_gfebg < _cdff ;_gfebg ++{_defc [_gfebg ]+=_defc [_gfebg -_cgc .Colors ];};_dfgb .Write (_defc );};_fbac :=_dfgb .Bytes ();_aab .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fbac ),_fbac );return _fbac ,nil ;}else if _cgc .Predictor >=10&&_cgc .Predictor <=15{_aab .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fbe :=int (_cgc .Columns *_cgc .Colors +1);_daf :=len (_ccdf )/_fbe ;if len (_ccdf )%_fbe !=0{return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ccdf ),_fbe );};if _fbe > len (_ccdf ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fbe ,len (_ccdf ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bbdf :=_bgd .NewBuffer (nil );_aab .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cgc .Columns );_aab .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ccdf ),_fbe ,_daf );_aaaf :=make ([]byte ,_fbe );for _bbcc :=0;_bbcc < _fbe ;_bbcc ++{_aaaf [_bbcc ]=0;};_fbga :=_cgc .Colors ;for _ddc :=0;_ddc < _daf ;_ddc ++{_gbea :=_ccdf [_fbe *_ddc :_fbe *(_ddc +1)];_dgd :=_gbea [0];switch _dgd {case _fbg :case _ecbg :for _gbca :=1+_fbga ;_gbca < _fbe ;_gbca ++{_gbea [_gbca ]+=_gbea [_gbca -_fbga ];};case _caf :for _bga :=1;_bga < _fbe ;_bga ++{_gbea [_bga ]+=_aaaf [_bga ];};case _fcga :for _bgfe :=1;_bgfe < _fbga +1;_bgfe ++{_gbea [_bgfe ]+=_aaaf [_bgfe ]/2;};for _gdccb :=_fbga +1;_gdccb < _fbe ;_gdccb ++{_gbea [_gdccb ]+=byte ((int (_gbea [_gdccb -_fbga ])+int (_aaaf [_gdccb ]))/2);};case _dacd :for _agcd :=1;_agcd < _fbe ;_agcd ++{var _aede ,_cafe ,_ecf byte ;_cafe =_aaaf [_agcd ];if _agcd >=_fbga +1{_aede =_gbea [_agcd -_fbga ];_ecf =_aaaf [_agcd -_fbga ];};_gbea [_agcd ]+=_bcgg (_aede ,_cafe ,_ecf );};default:_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_dgd ,_ddc );return nil ,_d .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dgd );};copy (_aaaf ,_gbea );_bbdf .Write (_gbea [1:]);};_gafgd :=_bbdf .Bytes ();return _gafgd ,nil ;}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cgc .Predictor );return nil ,_d .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cgc .Predictor );};};return _ccdf ,nil ;};func _acd (_bgc *PdfObjectStream ,_dgag *PdfObjectDictionary )(*FlateEncoder ,error ){_efea :=NewFlateEncoder ();_ggfae :=_bgc .PdfObjectDictionary ;if _ggfae ==nil {return _efea ,nil ;};_efea ._cdeb =_gfbb (_ggfae );if _dgag ==nil {_bcf :=TraceToDirectObject (_ggfae .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _cdf :=_bcf .(type ){case *PdfObjectArray :_ebg :=_cdf ;if _ebg .Len ()!=1{_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_ebg .Len ());return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bcf =TraceToDirectObject (_ebg .Get (0));case *PdfObjectDictionary :_dgag =_cdf ;case *PdfObjectNull ,nil :default:_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_bcf );return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dgag ==nil {return _efea ,nil ;};_aab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dgag .String ());_dcg :=_dgag .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dcg ==nil {_aab .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_cacg ,_baa :=_dcg .(*PdfObjectInteger );if !_baa {_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dcg );return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_efea .Predictor =int (*_cacg );};_dcg =_dgag .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dcg !=nil {_gdcd ,_fbf :=_dcg .(*PdfObjectInteger );if !_fbf {_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_d .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_efea .BitsPerComponent =int (*_gdcd );};if _efea .Predictor > 1{_efea .Columns =1;_dcg =_dgag .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dcg !=nil {_fdc ,_gafg :=_dcg .(*PdfObjectInteger );if !_gafg {return nil ,_d .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_efea .Columns =int (*_fdc );};_efea .Colors =1;_dcg =_dgag .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dcg !=nil {_abfa ,_bbda :=_dcg .(*PdfObjectInteger );if !_bbda {return nil ,_d .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_efea .Colors =int (*_abfa );};};return _efea ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gbfg *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_fffg :=MakeDict ();_fffg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gbfg .GetFilterName ()));return _fffg ;};

// String returns a string describing `ref`.
func (_bafa *PdfObjectReference )String ()string {return _d .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_bafa .ObjectNumber ,_bafa .GenerationNumber );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gaff *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_ceea :=MakeDict ();_ceea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gaff .GetFilterName ()));_cdd :=_gaff .MakeDecodeParams ();if _cdd !=nil {_ceea .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cdd );};return _ceea ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_efc :=&LZWEncoder {};_efc .Predictor =1;_efc .BitsPerComponent =8;_efc .Colors =1;_efc .Columns =1;_efc .EarlyChange =1;return _efc ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_efac :=_bgd .NewReader ([]byte (txt ));_eeeg :=&PdfParser {ObjCache :objectCache {},_edgge :_efac ,_fegg :_de .NewReader (_efac ),_gbbe :int64 (len (txt )),_deag :map[int64 ]bool {}};_eeeg ._baae .ObjectMap =make (map[int ]XrefObject );return _eeeg ;};func (_gccf *PdfParser )lookupObjectViaOS (_eb int ,_ec int )(PdfObject ,error ){var _gfe *_bgd .Reader ;var _gcg objectStream ;var _bf bool ;_gcg ,_bf =_gccf ._fadad [_eb ];if !_bf {_bc ,_gfed :=_gccf .LookupByNumber (_eb );if _gfed !=nil {_aab .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_eb );return nil ,_gfed ;};_ag ,_ad :=_bc .(*PdfObjectStream );if !_ad {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _gccf ._bfdd !=nil &&!_gccf ._bfdd .isDecrypted (_ag ){return nil ,_c .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_bea :=_ag .PdfObjectDictionary ;_aab .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_bea .String ());_agf ,_ad :=_bea .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ad {_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _eg .ToLower (string (*_agf ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_c .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ad :=_bea .Get ("\u004e").(*PdfObjectInteger );if !_ad {return nil ,_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fa ,_ad :=_bea .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ad {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_aab .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_agf ,*N );_ea ,_gfed :=DecodeStream (_ag );if _gfed !=nil {return nil ,_gfed ;};_aab .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ea );_aabb :=_gccf .GetFileOffset ();defer func (){_gccf .SetFileOffset (_aabb )}();_gfe =_bgd .NewReader (_ea );_gccf ._fegg =_de .NewReader (_gfe );_aab .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_gce :=map[int ]int64 {};for _ge :=0;_ge < int (*N );_ge ++{_gccf .skipSpaces ();_cb ,_aag :=_gccf .parseNumber ();if _aag !=nil {return nil ,_aag ;};_ae ,_gd :=_cb .(*PdfObjectInteger );if !_gd {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_gccf .skipSpaces ();_cb ,_aag =_gccf .parseNumber ();if _aag !=nil {return nil ,_aag ;};_egg ,_gd :=_cb .(*PdfObjectInteger );if !_gd {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_aab .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_ae ,*_egg );_gce [int (*_ae )]=int64 (*_fa +*_egg );};_gcg =objectStream {N :int (*N ),_dea :_ea ,_ee :_gce };_gccf ._fadad [_eb ]=_gcg ;}else {_fc :=_gccf .GetFileOffset ();defer func (){_gccf .SetFileOffset (_fc )}();_gfe =_bgd .NewReader (_gcg ._dea );_gccf ._fegg =_de .NewReader (_gfe );};_ggbe :=_gcg ._ee [_ec ];_aab .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ec ,_ggbe );_gfe .Seek (_ggbe ,_da .SEEK_SET );_gccf ._fegg =_de .NewReader (_gfe );_fe ,_ :=_gccf ._fegg .Peek (100);_aab .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_fe ));_gb ,_cd :=_gccf .parseObject ();if _cd !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cd );return nil ,_cd ;};if _gb ==nil {return nil ,_c .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_gcb :=PdfIndirectObject {};_gcb .ObjectNumber =int64 (_ec );_gcb .PdfObject =_gb ;return &_gcb ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_ccddb *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_gad []XrefObject ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_cbegf :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _cbegf ==nil {return NewRawEncoder (),nil ;};if _ ,_abgg :=_cbegf .(*PdfObjectNull );_abgg {return NewRawEncoder (),nil ;};_fccee ,_eccgb :=_cbegf .(*PdfObjectName );if !_eccgb {_dace ,_feed :=_cbegf .(*PdfObjectArray );if !_feed {return nil ,_d .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _dace .Len ()==0{return NewRawEncoder (),nil ;};if _dace .Len ()!=1{_dbccf ,_agde :=_aceaa (streamObj );if _agde !=nil {_aab .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_agde );return nil ,_agde ;};_aab .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_dbccf );return _dbccf ,nil ;};_cbegf =_dace .Get (0);_fccee ,_feed =_cbegf .(*PdfObjectName );if !_feed {return nil ,_d .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_fccee {case StreamEncodingFilterNameFlate :return _acd (streamObj ,nil );case StreamEncodingFilterNameLZW :return _gcbg (streamObj ,nil );case StreamEncodingFilterNameDCT :return _ebbf (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _ffdb (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _daggg (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _cfbd (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_d .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_fccee );};

// GetFilterName returns the name of the encoding filter.
func (_efeg *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bfcg *PdfCrypt )GetAccessPermissions ()_bba .Permissions {return _bfcg ._aace .P };func (_fbgf *PdfParser )parseArray ()(*PdfObjectArray ,error ){_acgg :=MakeArray ();_fbgf ._fegg .ReadByte ();for {_fbgf .skipSpaces ();_agee ,_ffeb :=_fbgf ._fegg .Peek (1);if _ffeb !=nil {return _acgg ,_ffeb ;};if _agee [0]==']'{_fbgf ._fegg .ReadByte ();break ;};_gggc ,_ffeb :=_fbgf .parseObject ();if _ffeb !=nil {return _acgg ,_ffeb ;};_acgg .Append (_gggc );};return _acgg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_adfb *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// WriteString outputs the object as it is to be written to file.
func (_afabf *PdfIndirectObject )WriteString ()string {var _dcaf _eg .Builder ;_dcaf .WriteString (_bg .FormatInt (_afabf .ObjectNumber ,10));_dcaf .WriteString ("\u0020\u0030\u0020\u0052");return _dcaf .String ();};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fgee :=PdfObjectBool (val );return &_fgee };

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_egfbd *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_aab .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_egfbd .Predictor );_fdge ,_gfcg :=_egfbd .DecodeBytes (streamObj .Stream );if _gfcg !=nil {return nil ,_gfcg ;};_aab .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_aab .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_fdge ),_fdge );if _egfbd .Predictor > 1{if _egfbd .Predictor ==2{_aab .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cdee :=int (_egfbd .Columns )*_egfbd .Colors ;if _cdee < 1{return []byte {},nil ;};_fadb :=len (_fdge )/_cdee ;if len (_fdge )%_cdee !=0{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fdge ),_cdee );};if _cdee %_egfbd .Colors !=0{return nil ,_d .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_cdee ,_egfbd .Colors );};if _cdee > len (_fdge ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cdee ,len (_fdge ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aab .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fdge ),_fdge );_dgaea :=_bgd .NewBuffer (nil );for _fcd :=0;_fcd < _fadb ;_fcd ++{_bgag :=_fdge [_cdee *_fcd :_cdee *(_fcd +1)];for _gcga :=_egfbd .Colors ;_gcga < _cdee ;_gcga ++{_bgag [_gcga ]=byte (int (_bgag [_gcga ]+_bgag [_gcga -_egfbd .Colors ])%256);};_dgaea .Write (_bgag );};_cbb :=_dgaea .Bytes ();_aab .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_cbb ),_cbb );return _cbb ,nil ;}else if _egfbd .Predictor >=10&&_egfbd .Predictor <=15{_aab .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_dfgd :=int (_egfbd .Columns *_egfbd .Colors +1);if _dfgd < 1{return []byte {},nil ;};_bfbc :=len (_fdge )/_dfgd ;if len (_fdge )%_dfgd !=0{return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fdge ),_dfgd );};if _dfgd > len (_fdge ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dfgd ,len (_fdge ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eae :=_bgd .NewBuffer (nil );_aab .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_egfbd .Columns );_aab .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fdge ),_dfgd ,_bfbc );_abfd :=make ([]byte ,_dfgd );for _aabe :=0;_aabe < _dfgd ;_aabe ++{_abfd [_aabe ]=0;};for _cbcf :=0;_cbcf < _bfbc ;_cbcf ++{_abeb :=_fdge [_dfgd *_cbcf :_dfgd *(_cbcf +1)];_dbff :=_abeb [0];switch _dbff {case 0:case 1:for _egga :=2;_egga < _dfgd ;_egga ++{_abeb [_egga ]=byte (int (_abeb [_egga ]+_abeb [_egga -1])%256);};case 2:for _gecg :=1;_gecg < _dfgd ;_gecg ++{_abeb [_gecg ]=byte (int (_abeb [_gecg ]+_abfd [_gecg ])%256);};default:_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dbff );return nil ,_d .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dbff );};for _gadf :=0;_gadf < _dfgd ;_gadf ++{_abfd [_gadf ]=_abeb [_gadf ];};_eae .Write (_abeb [1:]);};_dbd :=_eae .Bytes ();return _dbd ,nil ;}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_egfbd .Predictor );return nil ,_d .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_egfbd .Predictor );};};return _fdge ,nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_ecab *PdfIndirectObject ,_dadd bool ){obj =ResolveReference (obj );_ecab ,_dadd =obj .(*PdfIndirectObject );return _ecab ,_dadd ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_dfef :=TraceToDirectObject (obj ).(*PdfObjectNull );return _dfef ;};func (_fdcgd *PdfParser )inspect ()(map[string ]int ,error ){_aab .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_aab .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_fcgge :=map[string ]int {};_efcbd :=0;_agba :=0;var _cbdge []int ;for _dfcce :=range _fdcgd ._baae .ObjectMap {_cbdge =append (_cbdge ,_dfcce );};_cf .Ints (_cbdge );_abga :=0;for _ ,_eefdb :=range _cbdge {_ffgf :=_fdcgd ._baae .ObjectMap [_eefdb ];if _ffgf .ObjectNumber ==0{continue ;};_efcbd ++;_aab .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_aab .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_ffgf .ObjectNumber );_abdb ,_efae :=_fdcgd .LookupByNumber (_ffgf .ObjectNumber );if _efae !=nil {_aab .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_ffgf .ObjectNumber ,_efae );_agba ++;continue ;};_aab .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_abdb );_deef ,_ffaa :=_abdb .(*PdfIndirectObject );if _ffaa {_aab .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_ffgf .ObjectNumber ,_deef );_fded ,_gccfd :=_deef .PdfObject .(*PdfObjectDictionary );if _gccfd {if _gfeae ,_edbg :=_fded .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_edbg {_ecbbg :=string (*_gfeae );_aab .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_ecbbg );_ ,_fcege :=_fcgge [_ecbbg ];if _fcege {_fcgge [_ecbbg ]++;}else {_fcgge [_ecbbg ]=1;};}else if _dadg ,_dbfd :=_fded .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_dbfd {_cdfd :=string (*_dadg );_aab .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_cdfd );_ ,_gbae :=_fcgge [_cdfd ];if _gbae {_fcgge [_cdfd ]++;}else {_fcgge [_cdfd ]=1;};};if _ceed ,_dbbga :=_fded .Get ("\u0053").(*PdfObjectName );_dbbga &&*_ceed =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_ffead :=_fcgge ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _ffead {_fcgge ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_fcgge ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _edcc ,_fgbaef :=_abdb .(*PdfObjectStream );_fgbaef {if _cade ,_gbba :=_edcc .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gbba {_aab .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_cade );_feac :=string (*_cade );if _ ,_abcd :=_fcgge [_feac ];_abcd {_fcgge [_feac ]++;}else {_fcgge [_feac ]=1;};};}else {_cbdfd ,_cfea :=_abdb .(*PdfObjectDictionary );if _cfea {_caca ,_agae :=_cbdfd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _agae {_dggb :=string (*_caca );_aab .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_dggb );_fcgge [_dggb ]++;};};_aab .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_ffgf .ObjectNumber ,_abdb );};_abga ++;};_aab .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_aab .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_aab .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_efcbd );_aab .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_agba );for _cbcb ,_acabb :=range _fcgge {_aab .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_cbcb ,_acabb );};_aab .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_fdcgd ._baae .ObjectMap )< 1{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_d .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_bbbf ,_beefe :=_fcgge ["\u0046\u006f\u006e\u0074"];if !_beefe ||_bbbf < 2{_aab .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_aab .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _fcgge ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_abcg *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_bgfd :=MakeDict ();_bgfd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_abcg .GetFilterName ()));return _bgfd ;};const _acf ="\u0053\u0074\u0064C\u0046";

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_dedgd *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dedgd .GetFilterName ());return data ,ErrNoJPXDecode ;};func _gfbb (_fffe *PdfObjectDictionary )(_bbfbd *_aba .ImageBase ){var (_dgafe *PdfObjectInteger ;_afcdd bool ;);if _dgafe ,_afcdd =_fffe .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_afcdd {_bbfbd =&_aba .ImageBase {Width :int (*_dgafe )};}else {return nil ;};if _dgafe ,_afcdd =_fffe .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_afcdd {_bbfbd .Height =int (*_dgafe );};if _dgafe ,_afcdd =_fffe .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_afcdd {_bbfbd .BitsPerComponent =int (*_dgafe );};if _dgafe ,_afcdd =_fffe .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_afcdd {_bbfbd .ColorComponents =int (*_dgafe );};return _bbfbd ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_eabd *PdfObjectReference )GetParser ()*PdfParser {return _eabd ._dfaa };

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_deff :=PdfObjectFloat (val );return &_deff };

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _aa .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _agcb ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_df .Error (_agcb ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_ffac uint8 ;_bcae _aba .Image ;_aebd error ;);if bwThreshold ==JB2ImageAutoThreshold {_bcae ,_aebd =_aba .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_df .Error (_agcb ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_ffac =uint8 (255*bwThreshold );_bcae ,_aebd =_aba .MonochromeThresholdConverter (_ffac ).Convert (i );};if _aebd !=nil {return nil ,_aebd ;};return _degg (_bcae ),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_edaa *PdfObjectName )WriteString ()string {var _bbdef _bgd .Buffer ;if len (*_edaa )> 127{_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_edaa );};_bbdef .WriteString ("\u002f");for _cced :=0;_cced < len (*_edaa );_cced ++{_eedc :=(*_edaa )[_cced ];if !IsPrintable (_eedc )||_eedc =='#'||IsDelimiter (_eedc ){_bbdef .WriteString (_d .Sprintf ("\u0023\u0025\u002e2\u0078",_eedc ));}else {_bbdef .WriteByte (_eedc );};};return _bbdef .String ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdfd *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_bda :=MakeDict ();_bda .Set ("\u004b",MakeInteger (int64 (_gdfd .K )));_bda .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gdfd .Columns )));if _gdfd .BlackIs1 {_bda .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_gdfd .BlackIs1 ));};if _gdfd .EncodedByteAlign {_bda .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_gdfd .EncodedByteAlign ));};if _gdfd .EndOfLine &&_gdfd .K >=0{_bda .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_gdfd .EndOfLine ));};if _gdfd .Rows !=0&&!_gdfd .EndOfBlock {_bda .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_gdfd .Rows )));};if !_gdfd .EndOfBlock {_bda .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_gdfd .EndOfBlock ));};if _gdfd .DamagedRowsBeforeError !=0{_bda .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_gdfd .DamagedRowsBeforeError )));};return _bda ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_cfdc []PdfObject };

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_fga *JBIG2Image )ToGoImage ()(_aa .Image ,error ){const _ddd ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _fga .Data ==nil {return nil ,_df .Error (_ddd ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _fga .Width ==0||_fga .Height ==0{return nil ,_df .Error (_ddd ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_ccac ,_cafg :=_aba .NewImage (_fga .Width ,_fga .Height ,1,1,_fga .Data ,nil ,nil );if _cafg !=nil {return nil ,_cafg ;};return _ccac ,nil ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_gfa .FilterDict ;};

// WriteString outputs the object as it is to be written to file.
func (_fage *PdfObjectFloat )WriteString ()string {return _bg .FormatFloat (float64 (*_fage ),'f',-1,64);};func _bef (_fd PdfObject )(int64 ,int64 ,error ){if _fdf ,_ce :=_fd .(*PdfIndirectObject );_ce {return _fdf .ObjectNumber ,_fdf .GenerationNumber ,nil ;};if _fea ,_fcc :=_fd .(*PdfObjectStream );_fcc {return _fea .ObjectNumber ,_fea .GenerationNumber ,nil ;};return 0,0,_c .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// String returns a descriptive information string about the encryption method used.
func (_bbbg *PdfCrypt )String ()string {if _bbbg ==nil {return "";};_adb :=_bbbg ._fgb .Filter +"\u0020\u002d\u0020";if _bbbg ._fgb .V ==0{_adb +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _bbbg ._fgb .V ==1{_adb +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _bbbg ._fgb .V ==2{_adb +=_d .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_bbbg ._fgb .Length );}else if _bbbg ._fgb .V ==3{_adb +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _bbbg ._fgb .V >=4{_adb +=_d .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_bbbg ._cbg ,_bbbg ._ca );_adb +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _efd ,_dcd :=range _bbbg ._adg {_adb +=_d .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_efd ,_dcd .Name (),_dcd .KeyLength ());};};_aee :=_bbbg .GetAccessPermissions ();_adb +=_d .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_aee );return _adb ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func (_afa *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ccec :=_afa ._fegg .Discard (4);return PdfObjectNull {},_ccec ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_efdc *JBIG2Encoder )DecodeImages (encoded []byte )([]_aa .Image ,error ){const _eccd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_eaaf ,_cfef :=_dd .Decode (encoded ,_dd .Parameters {},_efdc .Globals .ToDocumentGlobals ());if _cfef !=nil {return nil ,_df .Wrap (_cfef ,_eccd ,"");};_gdec ,_cfef :=_eaaf .PageNumber ();if _cfef !=nil {return nil ,_df .Wrap (_cfef ,_eccd ,"");};_ccff :=[]_aa .Image {};var _dbef _aa .Image ;for _fgce :=1;_fgce <=_gdec ;_fgce ++{_dbef ,_cfef =_eaaf .DecodePageImage (_fgce );if _cfef !=nil {return nil ,_df .Wrapf (_cfef ,_eccd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fgce );};_ccff =append (_ccff ,_dbef );};return _ccff ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fbed *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_fegf :=MakeDict ();_fegf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fbed .GetFilterName ()));_cefc :=_fbed .MakeDecodeParams ();if _cefc !=nil {_fegf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cefc );};return _fegf ;};

// UpdateParams updates the parameter values of the encoder.
func (_bgab *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _bada ,_dgad :=GetNumberAsInt64 (params .Get ("\u004b"));_dgad ==nil {_bgab .K =int (_bada );};if _adbfe ,_bgda :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_bgda ==nil {_bgab .Columns =int (_adbfe );}else if _adbfe ,_bgda =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_bgda ==nil {_bgab .Columns =int (_adbfe );};if _ecaf ,_ecfd :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ecfd ==nil {_bgab .BlackIs1 =_ecaf > 0;}else {if _bcfc ,_eedg :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eedg {_bgab .BlackIs1 =_bcfc ;}else {if _efgf ,_feea :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_feea {_agef ,_adgc :=_efgf .ToIntegerArray ();if _adgc ==nil {_bgab .BlackIs1 =_agef [0]==1&&_agef [1]==0;};};};};if _fbcc ,_ebc :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ebc ==nil {_bgab .EncodedByteAlign =_fbcc > 0;}else {if _fdae ,_bgdaa :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bgdaa {_bgab .EncodedByteAlign =_fdae ;};};if _bffa ,_ccafc :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ccafc ==nil {_bgab .EndOfLine =_bffa > 0;}else {if _dgbe ,_bffga :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bffga {_bgab .EndOfLine =_dgbe ;};};if _fffaf ,_afga :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_afga ==nil {_bgab .Rows =int (_fffaf );}else if _fffaf ,_afga =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_afga ==nil {_bgab .Rows =int (_fffaf );};if _beaa ,_cbbe :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cbbe ==nil {_bgab .EndOfBlock =_beaa > 0;}else {if _effd ,_gaaef :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gaaef {_bgab .EndOfBlock =_effd ;};};if _cdag ,_fde :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fde !=nil {_bgab .DamagedRowsBeforeError =int (_cdag );};};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_gbebc *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_aab .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_bdf :=MakeDict ();_bdf ._ffad =_gbebc ;_ebad ,_ :=_gbebc ._fegg .ReadByte ();if _ebad !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_ebad ,_ =_gbebc ._fegg .ReadByte ();if _ebad !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_gbebc .skipSpaces ();_gbebc .skipComments ();_ggba ,_dgcg :=_gbebc ._fegg .Peek (2);if _dgcg !=nil {return nil ,_dgcg ;};_aab .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ggba ),string (_ggba ));if (_ggba [0]=='>')&&(_ggba [1]=='>'){_aab .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_gbebc ._fegg .ReadByte ();_gbebc ._fegg .ReadByte ();break ;};_aab .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_fdabd ,_dgcg :=_gbebc .parseName ();_aab .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_fdabd );if _dgcg !=nil {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_dgcg );return nil ,_dgcg ;};if len (_fdabd )> 4&&_fdabd [len (_fdabd )-4:]=="\u006e\u0075\u006c\u006c"{_bfgba :=_fdabd [0:len (_fdabd )-4];_aab .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_fdabd );_aab .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_bfgba );_gbebc .skipSpaces ();_bfac ,_ :=_gbebc ._fegg .Peek (1);if _bfac [0]=='/'{_bdf .Set (_bfgba ,MakeNull ());continue ;};};_gbebc .skipSpaces ();_caae ,_dgcg :=_gbebc .parseObject ();if _dgcg !=nil {return nil ,_dgcg ;};_bdf .Set (_fdabd ,_caae );if _aab .Log .IsLogLevel (_aab .LogLevelTrace ){_aab .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_fdabd ,_caae .String ());};};_aab .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _bdf ,nil ;};

// Clear resets the dictionary to an empty state.
func (_dedcd *PdfObjectDictionary )Clear (){_dedcd ._fcabe =[]PdfObjectName {};_dedcd ._edbc =map[PdfObjectName ]PdfObject {};};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_ecbb *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_edee ,_faga :=_ecbb ._edbc [key ];if !_faga {return nil ;};return _edee ;};func (_fcbf *PdfParser )parseName ()(PdfObjectName ,error ){var _egfd _bgd .Buffer ;_baag :=false ;for {_bdcf ,_agea :=_fcbf ._fegg .Peek (1);if _agea ==_gf .EOF {break ;};if _agea !=nil {return PdfObjectName (_egfd .String ()),_agea ;};if !_baag {if _bdcf [0]=='/'{_baag =true ;_fcbf ._fegg .ReadByte ();}else if _bdcf [0]=='%'{_fcbf .readComment ();_fcbf .skipSpaces ();}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_bdcf ,_bdcf );return PdfObjectName (_egfd .String ()),_d .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_bdcf [0]);};}else {if IsWhiteSpace (_bdcf [0]){break ;}else if (_bdcf [0]=='/')||(_bdcf [0]=='[')||(_bdcf [0]=='(')||(_bdcf [0]==']')||(_bdcf [0]=='<')||(_bdcf [0]=='>'){break ;}else if _bdcf [0]=='#'{_caege ,_afdf :=_fcbf ._fegg .Peek (3);if _afdf !=nil {return PdfObjectName (_egfd .String ()),_afdf ;};_dbed ,_afdf :=_gg .DecodeString (string (_caege [1:3]));if _afdf !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_egfd .WriteByte ('#');_fcbf ._fegg .Discard (1);continue ;};_fcbf ._fegg .Discard (3);_egfd .Write (_dbed );}else {_ecgc ,_ :=_fcbf ._fegg .ReadByte ();_egfd .WriteByte (_ecgc );};};};return PdfObjectName (_egfd .String ()),nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_edfd string ;_dgec bool ;};

// GetFilterName returns the name of the encoding filter.
func (_fdd *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_gfef *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_ecfg :=_gfef ._edbc [key ];if !_ecfg {_gfef ._fcabe =append (_gfef ._fcabe ,key );};_gfef ._edbc [key ]=val ;};func (_deaea *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_deaea ._edgge .Seek (0,_da .SEEK_SET );_deaea ._fegg =_de .NewReader (_deaea ._edgge );_caegd :=20;_gdbc :=make ([]byte ,_caegd );for {_cedc ,_afad :=_deaea ._fegg .ReadByte ();if _afad !=nil {if _afad ==_gf .EOF {break ;}else {return 0,0,_afad ;};};if IsDecimalDigit (_cedc )&&_gdbc [_caegd -1]=='.'&&IsDecimalDigit (_gdbc [_caegd -2])&&_gdbc [_caegd -3]=='-'&&_gdbc [_caegd -4]=='F'&&_gdbc [_caegd -5]=='D'&&_gdbc [_caegd -6]=='P'{_gdbe :=int (_gdbc [_caegd -2]-'0');_ebfa :=int (_cedc -'0');return _gdbe ,_ebfa ,nil ;};_gdbc =append (_gdbc [1:_caegd ],_cedc );};return 0,0,_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};const JB2ImageAutoThreshold =-1.0;

// String returns a string describing `streams`.
func (_ecad *PdfObjectStreams )String ()string {return _d .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_ecad .ObjectNumber );};func _gdag (_bgde *_bba .StdEncryptDict ,_cde *PdfObjectDictionary )error {R ,_ac :=_cde .Get ("\u0052").(*PdfObjectInteger );if !_ac {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_bgde .R =int (*R );O ,_ac :=_cde .GetString ("\u004f");if !_ac {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _bgde .R ==5||_bgde .R ==6{if len (O )< 48{return _d .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _d .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_bgde .O =[]byte (O );U ,_ac :=_cde .GetString ("\u0055");if !_ac {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _bgde .R ==5||_bgde .R ==6{if len (U )< 48{return _d .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_aab .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_bgde .U =[]byte (U );if _bgde .R >=5{OE ,_cegg :=_cde .GetString ("\u004f\u0045");if !_cegg {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _d .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_bgde .OE =[]byte (OE );UE ,_cegg :=_cde .GetString ("\u0055\u0045");if !_cegg {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _d .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_bgde .UE =[]byte (UE );};P ,_ac :=_cde .Get ("\u0050").(*PdfObjectInteger );if !_ac {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_bgde .P =_bba .Permissions (*P );if _bgde .R ==6{Perms ,_ebd :=_cde .GetString ("\u0050\u0065\u0072m\u0073");if !_ebd {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _d .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_bgde .Perms =[]byte (Perms );};if _gafe ,_gab :=_cde .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_gab {_bgde .EncryptMetadata =bool (*_gafe );}else {_bgde .EncryptMetadata =true ;};return nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_dee *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dee .DecodeBytes (streamObj .Stream );};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_bfbce *PdfParser )GetFileOffset ()int64 {_bcac ,_ :=_bfbce ._edgge .Seek (0,_gf .SeekCurrent );_bcac -=int64 (_bfbce ._fegg .Buffered ());return _bcac ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_cggfa *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _aeeef [][]byte ;for _eggf :=0;_eggf < len (data );_eggf +=_cggfa .Columns {_agca :=make ([]byte ,_cggfa .Columns );_fgda :=0;for _ebeff :=0;_ebeff < _cggfa .Columns ;_ebeff ++{if data [_eggf +_ebeff ]==255{_agca [_fgda ]=1;}else {_agca [_fgda ]=0;};_fgda ++;};_aeeef =append (_aeeef ,_agca );};_fbb :=&_gcc .Encoder {K :_cggfa .K ,Columns :_cggfa .Columns ,EndOfLine :_cggfa .EndOfLine ,EndOfBlock :_cggfa .EndOfBlock ,BlackIs1 :_cggfa .BlackIs1 ,DamagedRowsBeforeError :_cggfa .DamagedRowsBeforeError ,Rows :_cggfa .Rows ,EncodedByteAlign :_cggfa .EncodedByteAlign };return _fbb .Encode (_aeeef ),nil ;};func (_eeaef *PdfParser )xrefNextObjectOffset (_fbdcg int64 )int64 {_gfge :=int64 (0);if len (_eeaef ._baae .ObjectMap )==0{return 0;};if len (_eeaef ._baae ._gad )==0{_dece :=0;for _ ,_abdgb :=range _eeaef ._baae .ObjectMap {if _abdgb .Offset > 0{_dece ++;};};if _dece ==0{return 0;};_eeaef ._baae ._gad =make ([]XrefObject ,_dece );_ecaa :=0;for _ ,_gbed :=range _eeaef ._baae .ObjectMap {if _gbed .Offset > 0{_eeaef ._baae ._gad [_ecaa ]=_gbed ;_ecaa ++;};};_cf .Slice (_eeaef ._baae ._gad ,func (_fced ,_adca int )bool {return _eeaef ._baae ._gad [_fced ].Offset < _eeaef ._baae ._gad [_adca ].Offset });};_fdcg :=_cf .Search (len (_eeaef ._baae ._gad ),func (_babc int )bool {return _eeaef ._baae ._gad [_babc ].Offset >=_fbdcg });if _fdcg < len (_eeaef ._baae ._gad ){_gfge =_eeaef ._baae ._gad [_fdcg ].Offset ;};return _gfge ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cacd *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cacd .GetFilterName ());return encoded ,ErrNoJPXDecode ;};func (_ddfa *PdfParser )skipSpaces ()(int ,error ){_befe :=0;for {_agbef ,_fbdc :=_ddfa ._fegg .ReadByte ();if _fbdc !=nil {return 0,_fbdc ;};if IsWhiteSpace (_agbef ){_befe ++;}else {_ddfa ._fegg .UnreadByte ();break ;};};return _befe ,nil ;};func _gfac (_gcbgg int )int {if _gcbgg < 0{return -_gcbgg ;};return _gcbgg ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_dffc :=&PdfObjectDictionary {};_dffc ._edbc =map[PdfObjectName ]PdfObject {};_dffc ._fcabe =[]PdfObjectName {};return _dffc ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// EncodeBytes encodes data into ASCII85 encoded format.
func (_daca *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cdbb _bgd .Buffer ;for _affbb :=0;_affbb < len (data );_affbb +=4{_facd :=data [_affbb ];_cfaa :=1;_addcb :=byte (0);if _affbb +1< len (data ){_addcb =data [_affbb +1];_cfaa ++;};_gbbc :=byte (0);if _affbb +2< len (data ){_gbbc =data [_affbb +2];_cfaa ++;};_dcda :=byte (0);if _affbb +3< len (data ){_dcda =data [_affbb +3];_cfaa ++;};_gbgae :=(uint32 (_facd )<<24)|(uint32 (_addcb )<<16)|(uint32 (_gbbc )<<8)|uint32 (_dcda );if _gbgae ==0{_cdbb .WriteByte ('z');}else {_eed :=_daca .base256Tobase85 (_gbgae );for _ ,_cfgc :=range _eed [:_cfaa +1]{_cdbb .WriteByte (_cfgc +'!');};};};_cdbb .WriteString ("\u007e\u003e");return _cdbb .Bytes (),nil ;};func _ddbbb (_dbbd PdfObject ,_cgeag int )PdfObject {if _cgeag > _cfed {_aab .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cfed );return MakeNull ();};switch _bgae :=_dbbd .(type ){case *PdfIndirectObject :_dbbd =_ddbbb ((*_bgae ).PdfObject ,_cgeag +1);case *PdfObjectArray :for _cbcdf ,_ddfc :=range (*_bgae )._cfdc {(*_bgae )._cfdc [_cbcdf ]=_ddbbb (_ddfc ,_cgeag +1);};case *PdfObjectDictionary :for _ececf ,_eaef :=range (*_bgae )._edbc {(*_bgae )._edbc [_ececf ]=_ddbbb (_eaef ,_cgeag +1);};_cf .Slice ((*_bgae )._fcabe ,func (_debb ,_cgggc int )bool {return (*_bgae )._fcabe [_debb ]< (*_bgae )._fcabe [_cgggc ]});};return _dbbd ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ffb *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ffb .DecodeBytes (streamObj .Stream );};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_geba *PdfParser )Inspect ()(map[string ]int ,error ){return _geba .inspect ()};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_ddcg *PdfObjectDictionary )Keys ()[]PdfObjectName {if _ddcg ==nil {return nil ;};return _ddcg ._fcabe ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_bfbf *PdfParser )Decrypt (password []byte )(bool ,error ){if _bfbf ._bfdd ==nil {return false ,_c .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_fdcf ,_edgc :=_bfbf ._bfdd .authenticate (password );if _edgc !=nil {return false ,_edgc ;};if !_fdcf {_fdcf ,_edgc =_bfbf ._bfdd .authenticate ([]byte (""));};return _fdcf ,_edgc ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_cafa *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bbfd :=&_gcc .Encoder {K :_cafa .K ,Columns :_cafa .Columns ,EndOfLine :_cafa .EndOfLine ,EndOfBlock :_cafa .EndOfBlock ,BlackIs1 :_cafa .BlackIs1 ,DamagedRowsBeforeError :_cafa .DamagedRowsBeforeError ,Rows :_cafa .Rows ,EncodedByteAlign :_cafa .EncodedByteAlign };_ccfd ,_fgfdg :=_bbfd .Decode (encoded );if _fgfdg !=nil {return nil ,_fgfdg ;};var _deae []byte ;_egeb :=0;var _ffg byte ;var _cfbc byte ;for _aefe :=range _ccfd {if _ffg !=0{_deae =append (_deae ,_cfbc );_cfbc =0;_egeb ++;_ffg =0;};for _dbgdb :=range _ccfd [_aefe ]{_cfbc |=_ccfd [_aefe ][_dbgdb ]<<(7-_ffg );_ffg ++;if _ffg ==8{_deae =append (_deae ,_cfbc );_cfbc =0;_egeb ++;_ffg =0;};};};if _ffg > 0{_deae =append (_deae ,_cfbc );};return _deae ,nil ;};

// DecodeStream implements ASCII85 stream decoding.
func (_dfea *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dfea .DecodeBytes (streamObj .Stream );};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_gdfdb bool ,_gedc bool ){_dgcc ,_gedc :=TraceToDirectObject (obj ).(*PdfObjectBool );if _gedc {return bool (*_dgcc ),true ;};return false ,false ;};func _daggg (_eadc *PdfObjectStream ,_egde *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_dfce :=NewCCITTFaxEncoder ();_geca :=_eadc .PdfObjectDictionary ;if _geca ==nil {return _dfce ,nil ;};if _egde ==nil {_efee :=TraceToDirectObject (_geca .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _efee !=nil {switch _aga :=_efee .(type ){case *PdfObjectDictionary :_egde =_aga ;break ;case *PdfObjectArray :if _aga .Len ()==1{if _accd ,_bffe :=GetDict (_aga .Get (0));_bffe {_egde =_accd ;};};default:_aab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_efee );return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _egde ==nil {_aab .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_efee );return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _acea ,_gdg :=GetNumberAsInt64 (_egde .Get ("\u004b"));_gdg ==nil {_dfce .K =int (_acea );};if _fada ,_gfea :=GetNumberAsInt64 (_egde .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gfea ==nil {_dfce .Columns =int (_fada );}else {_dfce .Columns =1728;};if _defge ,_efcb :=GetNumberAsInt64 (_egde .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_efcb ==nil {_dfce .BlackIs1 =_defge > 0;}else {if _eba ,_eeb :=GetBoolVal (_egde .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eeb {_dfce .BlackIs1 =_eba ;}else {if _ffa ,_ccag :=GetArray (_egde .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ccag {_gcbc ,_cfce :=_ffa .ToIntegerArray ();if _cfce ==nil {_dfce .BlackIs1 =_gcbc [0]==1&&_gcbc [1]==0;};};};};if _dcf ,_gafed :=GetNumberAsInt64 (_egde .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gafed ==nil {_dfce .EncodedByteAlign =_dcf > 0;}else {if _ebag ,_gacg :=GetBoolVal (_egde .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gacg {_dfce .EncodedByteAlign =_ebag ;};};if _cfe ,_bfba :=GetNumberAsInt64 (_egde .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bfba ==nil {_dfce .EndOfLine =_cfe > 0;}else {if _cabg ,_bceb :=GetBoolVal (_egde .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bceb {_dfce .EndOfLine =_cabg ;};};if _bfce ,_cgf :=GetNumberAsInt64 (_egde .Get ("\u0052\u006f\u0077\u0073"));_cgf ==nil {_dfce .Rows =int (_bfce );};_dfce .EndOfBlock =true ;if _fgfg ,_adad :=GetNumberAsInt64 (_egde .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_adad ==nil {_dfce .EndOfBlock =_fgfg > 0;}else {if _afg ,_edb :=GetBoolVal (_egde .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_edb {_dfce .EndOfBlock =_afg ;};};if _gcbbe ,_fcgaa :=GetNumberAsInt64 (_egde .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fcgaa !=nil {_dfce .DamagedRowsBeforeError =int (_gcbbe );};_aab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_egde .String ());return _dfce ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_aec *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };const _cfed =10;var _ggfc =_ga .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_aab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dbge ,_adebe :=NewEncoderFromStream (streamObj );if _adebe !=nil {_aab .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_adebe );return _adebe ;};if _dagad ,_ffea :=_dbge .(*LZWEncoder );_ffea {_dagad .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_aab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_dbge );_gfgf ,_adebe :=_dbge .EncodeBytes (streamObj .Stream );if _adebe !=nil {_aab .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_adebe );return _adebe ;};streamObj .Stream =_gfgf ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gfgf ))));return nil ;};func _ageb (_aebc ,_geee ,_bcdg int )error {if _geee < 0||_geee > _aebc {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _bcdg < _geee {return _c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bcdg > _aebc {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};func (_cc *PdfParser )lookupByNumber (_eab int ,_cca bool )(PdfObject ,bool ,error ){_fba ,_abd :=_cc .ObjCache [_eab ];if _abd {_aab .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_eab );return _fba ,false ,nil ;};_cdb ,_abd :=_cc ._baae .ObjectMap [_eab ];if !_abd {_aab .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _gac PdfObjectNull ;return &_gac ,false ,nil ;};_aab .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_eab );if _cdb .XType ==XrefTypeTableEntry {_aab .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_cdb .ObjectNumber );_aab .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_cdb .Generation );_aab .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_cdb .Offset );_cc ._edgge .Seek (_cdb .Offset ,_da .SEEK_SET );_cc ._fegg =_de .NewReader (_cc ._edgge );_cg ,_deg :=_cc .ParseIndirectObject ();if _deg !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_deg );if _cca {_aab .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_dg ,_fef :=_cc .repairRebuildXrefsTopDown ();if _fef !=nil {_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_fef );return nil ,false ,_fef ;};_cc ._baae =*_dg ;return _cc .lookupByNumber (_eab ,false );};return nil ,false ,_deg ;};if _cca {_aeb ,_ ,_ :=_bef (_cg );if int (_aeb )!=_eab {_aab .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_bgf :=_cc .rebuildXrefTable ();if _bgf !=nil {return nil ,false ,_bgf ;};_cc .ObjCache =objectCache {};return _cc .lookupByNumberWrapper (_eab ,false );};};_aab .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_cc .ObjCache [_eab ]=_cg ;return _cg ,false ,nil ;}else if _cdb .XType ==XrefTypeObjectStream {_aab .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_aab .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_aab .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_cdb .OsObjNumber ,_cdb .OsObjIndex );if _cdb .OsObjNumber ==_eab {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_c .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_bbc :=_cc ._baae .ObjectMap [_cdb .OsObjNumber ];_bbc {_abf ,_aef :=_cc .lookupObjectViaOS (_cdb .OsObjNumber ,_eab );if _aef !=nil {_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_aef );return nil ,true ,_aef ;};_aab .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_cc .ObjCache [_eab ]=_abf ;if _cc ._bfdd !=nil {_cc ._bfdd ._bbd [_abf ]=true ;};return _abf ,true ,nil ;};_aab .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_c .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_c .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gaef *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbaf :=MakeDict ();_gbaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_gaef .GetFilterArray ());for _ ,_efab :=range _gaef ._dgab {_fdfgc :=_efab .MakeStreamDict ();for _ ,_addda :=range _fdfgc .Keys (){_dge :=_fdfgc .Get (_addda );if _addda !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_addda !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_gbaf .Set (_addda ,_dge );};};};_acac :=_gaef .MakeDecodeParams ();if _acac !=nil {_gbaf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_acac );};return _gbaf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aefb *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// Append appends PdfObject(s) to the array.
func (_aafg *PdfObjectArray )Append (objects ...PdfObject ){if _aafg ==nil {_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _aafg ._cfdc ==nil {_aafg ._cfdc =[]PdfObject {};};for _ ,_ccfg :=range objects {_aafg ._cfdc =append (_aafg ._cfdc ,_ccfg );};};

// GetFilterName returns the name of the encoding filter.
func (_fgcc *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_ddgg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ab .DecodeBytes (encoded ,_dd .Parameters {},_ddgg .Globals );};var _gfaa =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_abdg *_dce .Document ;

// Globals are the JBIG2 global segments.
Globals _ab .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// WriteString outputs the object as it is to be written to file.
func (_decd *PdfObjectStream )WriteString ()string {var _ddgba _eg .Builder ;_ddgba .WriteString (_bg .FormatInt (_decd .ObjectNumber ,10));_ddgba .WriteString ("\u0020\u0030\u0020\u0052");return _ddgba .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_cgce *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_ccad *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bgef :=_bgd .NewReader (encoded );var _egfe []byte ;for {_edgg ,_ccfe :=_bgef .ReadByte ();if _ccfe !=nil {return nil ,_ccfe ;};if _edgg > 128{_dgbc ,_faeeb :=_bgef .ReadByte ();if _faeeb !=nil {return nil ,_faeeb ;};for _dbgd :=0;_dbgd < 257-int (_edgg );_dbgd ++{_egfe =append (_egfe ,_dgbc );};}else if _edgg < 128{for _dcbd :=0;_dcbd < int (_edgg )+1;_dcbd ++{_fgde ,_gcee :=_bgef .ReadByte ();if _gcee !=nil {return nil ,_gcee ;};_egfe =append (_egfe ,_fgde );};}else {break ;};};return _egfe ,nil ;};func _cbee (_cafgg PdfObject )(*float64 ,error ){switch _eagcc :=_cafgg .(type ){case *PdfObjectFloat :_fecc :=float64 (*_eagcc );return &_fecc ,nil ;case *PdfObjectInteger :_ffbda :=float64 (*_eagcc );return &_ffbda ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// GetFilterName returns the name of the encoding filter.
func (_gfdb *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };func (_adada *offsetReader )Read (p []byte )(_cbdf int ,_cgfe error ){return _adada ._deacd .Read (p )};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gbeed string ,_cabbd bool ){_acad ,_cabbd :=TraceToDirectObject (obj ).(*PdfObjectString );if _cabbd {return _acad .Str (),true ;};return ;};var (ErrUnsupportedEncodingParameters =_c .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_c .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_c .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_c .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_gc .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_c .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_acab *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_gegc *PdfObjectString )Decoded ()string {if _gegc ==nil {return "";};_fffca :=[]byte (_gegc ._edfd );if len (_fffca )>=2&&_fffca [0]==0xFE&&_fffca [1]==0xFF{return _af .UTF16ToString (_fffca [2:]);};return _af .PDFDocEncodingToString (_fffca );};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_ccgb :=&PdfObjectStreams {};_ccgb ._ccfddc =[]PdfObject {};for _ ,_ddag :=range objects {_ccgb ._ccfddc =append (_ccgb ._ccfddc ,_ddag );};return _ccgb ;};var _deeg =_ga .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_fgbg *MultiEncoder )GetFilterArray ()*PdfObjectArray {_feec :=make ([]PdfObject ,len (_fgbg ._dgab ));for _ebcc ,_bgcc :=range _fgbg ._dgab {_feec [_ebcc ]=MakeName (_bgcc .GetFilterName ());};return MakeArray (_feec ...);};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_cbbb *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cbbb .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_ecba *PdfObjectString )Str ()string {return _ecba ._edfd };func (_eafd *PdfParser )parseString ()(*PdfObjectString ,error ){_eafd ._fegg .ReadByte ();var _agff _bgd .Buffer ;_feda :=1;for {_gbfc ,_fcgb :=_eafd ._fegg .Peek (1);if _fcgb !=nil {return MakeString (_agff .String ()),_fcgb ;};if _gbfc [0]=='\\'{_eafd ._fegg .ReadByte ();_aecb ,_fcac :=_eafd ._fegg .ReadByte ();if _fcac !=nil {return MakeString (_agff .String ()),_fcac ;};if IsOctalDigit (_aecb ){_cff ,_agbeb :=_eafd ._fegg .Peek (2);if _agbeb !=nil {return MakeString (_agff .String ()),_agbeb ;};var _dgg []byte ;_dgg =append (_dgg ,_aecb );for _ ,_dbeff :=range _cff {if IsOctalDigit (_dbeff ){_dgg =append (_dgg ,_dbeff );}else {break ;};};_eafd ._fegg .Discard (len (_dgg )-1);_aab .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_dgg );_eee ,_agbeb :=_bg .ParseUint (string (_dgg ),8,32);if _agbeb !=nil {return MakeString (_agff .String ()),_agbeb ;};_agff .WriteByte (byte (_eee ));continue ;};switch _aecb {case 'n':_agff .WriteRune ('\n');case 'r':_agff .WriteRune ('\r');case 't':_agff .WriteRune ('\t');case 'b':_agff .WriteRune ('\b');case 'f':_agff .WriteRune ('\f');case '(':_agff .WriteRune ('(');case ')':_agff .WriteRune (')');case '\\':_agff .WriteRune ('\\');};continue ;}else if _gbfc [0]=='('{_feda ++;}else if _gbfc [0]==')'{_feda --;if _feda ==0{_eafd ._fegg .ReadByte ();break ;};};_acg ,_ :=_eafd ._fegg .ReadByte ();_agff .WriteByte (_acg );};return MakeString (_agff .String ()),nil ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_ccfddc []PdfObject ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_aaba *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_edgff :=range _aaba ._dgab {_edgff .UpdateParams (params );};};type xrefType int ;

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func (_edaca *PdfObjectInteger )String ()string {return _d .Sprintf ("\u0025\u0064",*_edaca )};

// String returns a string describing `d`.
func (_fede *PdfObjectDictionary )String ()string {var _bceg _eg .Builder ;_bceg .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_bdda :=range _fede ._fcabe {_cgef :=_fede ._edbc [_bdda ];_bceg .WriteString ("\u0022"+_bdda .String ()+"\u0022\u003a\u0020");_bceg .WriteString (_cgef .String ());_bceg .WriteString ("\u002c\u0020");};_bceg .WriteString ("\u0029");return _bceg .String ();};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_dde *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bdgf _bgd .Buffer ;for _ ,_bbccf :=range data {_bdgf .WriteString (_d .Sprintf ("\u0025\u002e\u0032X\u0020",_bbccf ));};_bdgf .WriteByte ('>');return _bdgf .Bytes (),nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_gbf :=&PdfCrypt {_gbe :false ,_bbd :make (map[PdfObject ]bool ),_abg :make (map[PdfObject ]bool ),_aaced :make (map[int ]struct{}),_adf :parser };_ace ,_efg :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_efg {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _gbf ,_c .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_ace !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_ace );return _gbf ,_c .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_gbf ._fgb .Filter =string (*_ace );if _ggc ,_gba :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_gba {_gbf ._fgb .SubFilter =_ggc .Str ();_aab .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_ggc );};if L ,_ggf :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_ggf {if (*L %8)!=0{_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _gbf ,_c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_gbf ._fgb .Length =int (*L );}else {_gbf ._fgb .Length =40;};_gbf ._fgb .V =0;if _bbba ,_cae :=ed .Get ("\u0056").(*PdfObjectInteger );_cae {V :=int (*_bbba );_gbf ._fgb .V =V ;if V >=1&&V <=2{_gbf ._adg =_gcbb (_gbf ._fgb .Length );}else if V >=4&&V <=5{if _aaf :=_gbf .loadCryptFilters (ed );_aaf !=nil {return _gbf ,_aaf ;};}else {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _gbf ,_c .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _ceff :=_gdag (&_gbf ._aace ,ed );_ceff !=nil {return _gbf ,_ceff ;};_cfa :="";if _adbf ,_bee :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_bee &&_adbf .Len ()>=1{_adbfd ,_dgae :=GetString (_adbf .Get (0));if !_dgae {return _gbf ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_cfa =_adbfd .Str ();}else {_aab .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_gbf ._efe =_cfa ;return _gbf ,nil ;};func (_acef *PdfParser )resolveReference (_aefg *PdfObjectReference )(PdfObject ,bool ,error ){_begd ,_acec :=_acef .ObjCache [int (_aefg .ObjectNumber )];if _acec {return _begd ,true ,nil ;};_fbfac ,_bdbg :=_acef .LookupByReference (*_aefg );if _bdbg !=nil {return nil ,false ,_bdbg ;};_acef .ObjCache [int (_aefg .ObjectNumber )]=_fbfac ;return _fbfac ,false ,nil ;};var _gedgc =_ga .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// Len returns the number of elements in the streams.
func (_gedaf *PdfObjectStreams )Len ()int {if _gedaf ==nil {return 0;};return len (_gedaf ._ccfddc );};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_gceeg *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdac :=_bgd .NewReader (encoded );var _dagd []byte ;for {_ggda ,_acfg :=_fdac .ReadByte ();if _acfg !=nil {return nil ,_acfg ;};if _ggda =='>'{break ;};if IsWhiteSpace (_ggda ){continue ;};if (_ggda >='a'&&_ggda <='f')||(_ggda >='A'&&_ggda <='F')||(_ggda >='0'&&_ggda <='9'){_dagd =append (_dagd ,_ggda );}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_ggda );return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_ggda );};};if len (_dagd )%2==1{_dagd =append (_dagd ,'0');};_aab .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dagd );_gddad :=make ([]byte ,_gg .DecodedLen (len (_dagd )));_ ,_acc :=_gg .Decode (_gddad ,_dagd );if _acc !=nil {return nil ,_acc ;};return _gddad ,nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _ddbbb (obj ,0)};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _gdfae (o ,0,traversed );};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _gf .ReadSeeker )(*PdfParser ,error ){_gdcfe :=&PdfParser {_edgge :rs ,ObjCache :make (objectCache ),_deag :map[int64 ]bool {}};_fcce ,_abed ,_ffcg :=_gdcfe .parsePdfVersion ();if _ffcg !=nil {_aab .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_ffcg );return nil ,_ffcg ;};_gdcfe ._gafff .Major =_fcce ;_gdcfe ._gafff .Minor =_abed ;if _gdcfe ._dfca ,_ffcg =_gdcfe .loadXrefs ();_ffcg !=nil {_aab .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_ffcg );return nil ,_ffcg ;};_aab .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gdcfe ._dfca );if len (_gdcfe ._baae .ObjectMap )==0{return nil ,_d .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _gdcfe ,nil ;};

// String returns a string describing `ind`.
func (_bege *PdfIndirectObject )String ()string {return _d .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_bege ).ObjectNumber );};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbfc *LZWEncoder )MakeDecodeParams ()PdfObject {if _dbfc .Predictor > 1{_eeff :=MakeDict ();_eeff .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_dbfc .Predictor )));if _dbfc .BitsPerComponent !=8{_eeff .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_dbfc .BitsPerComponent )));};if _dbfc .Columns !=1{_eeff .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dbfc .Columns )));};if _dbfc .Colors !=1{_eeff .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_dbfc .Colors )));};return _eeff ;};return nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_dcgc *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_dcgc ._edgge .Seek (offset ,_gf .SeekStart );_dcgc ._fegg =_de .NewReader (_dcgc ._edgge );};

// GetFilterName returns the name of the encoding filter.
func (_beag *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// WriteString outputs the object as it is to be written to file.
func (_aagb *PdfObjectInteger )WriteString ()string {return _bg .FormatInt (int64 (*_aagb ),10)};func (_fdaeb *PdfParser )parseXrefStream (_fcec *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _fcec !=nil {_aab .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_fcec );_fdaeb ._edgge .Seek (int64 (*_fcec ),_gf .SeekStart );_fdaeb ._fegg =_de .NewReader (_fdaeb ._edgge );};_fcfe :=_fdaeb .GetFileOffset ();_ffdg ,_acae :=_fdaeb .ParseIndirectObject ();if _acae !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_aab .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_ffdg );_cbbc ,_ccddg :=_ffdg .(*PdfObjectStream );if !_ccddg {_aab .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_eadf :=_cbbc .PdfObjectDictionary ;_dbcf ,_ccddg :=_cbbc .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ccddg {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_c .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_dbcf )> 8388607{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_dbcf );return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cddg :=_cbbc .PdfObjectDictionary .Get ("\u0057");_eefd ,_ccddg :=_cddg .(*PdfObjectArray );if !_ccddg {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_eedf :=_eefd .Len ();if _eedf !=3{_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_eedf );return nil ,_c .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _aagdg []int64 ;for _fdbg :=0;_fdbg < 3;_fdbg ++{_bgfec ,_gcca :=GetInt (_eefd .Get (_fdbg ));if !_gcca {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_aagdg =append (_aagdg ,int64 (*_bgfec ));};_cggcg ,_acae :=DecodeStream (_cbbc );if _acae !=nil {_aab .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_acae );return nil ,_acae ;};_bcde :=int (_aagdg [0]);_gfcb :=int (_aagdg [0]+_aagdg [1]);_dbbb :=int (_aagdg [0]+_aagdg [1]+_aagdg [2]);_feb :=int (_aagdg [0]+_aagdg [1]+_aagdg [2]);if _bcde < 0||_gfcb < 0||_dbbb < 0{_aab .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_bcde ,_gfcb ,_dbbb );return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _feb ==0{_aab .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _eadf ,nil ;};_efbff :=len (_cggcg )/_feb ;_ceeg :=0;_eebb :=_cbbc .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _ddggb []int ;if _eebb !=nil {_aab .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_eebb );_gdbb ,_addcg :=_eebb .(*PdfObjectArray );if !_addcg {_aab .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_c .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _gdbb .Len ()%2!=0{_aab .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ceeg =0;_decb ,_edbe :=_gdbb .ToIntegerArray ();if _edbe !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_edbe );return nil ,_edbe ;};for _ddgb :=0;_ddgb < len (_decb );_ddgb +=2{_egcd :=_decb [_ddgb ];_fecdg :=_decb [_ddgb +1];for _daef :=0;_daef < _fecdg ;_daef ++{_ddggb =append (_ddggb ,_egcd +_daef );};_ceeg +=_fecdg ;};}else {for _baaad :=0;_baaad < int (*_dbcf );_baaad ++{_ddggb =append (_ddggb ,_baaad );};_ceeg =int (*_dbcf );};if _efbff ==_ceeg +1{_aab .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_accf :=_ceeg -1;for _ ,_fdda :=range _ddggb {if _fdda > _accf {_accf =_fdda ;};};_ddggb =append (_ddggb ,_accf +1);_ceeg ++;};if _efbff !=len (_ddggb ){_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_efbff ,len (_ddggb ));return nil ,_c .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_aab .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ceeg );_aab .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_ddggb );_debg :=func (_bgedb []byte )int64 {var _decf int64 ;for _cagg :=0;_cagg < len (_bgedb );_cagg ++{_decf +=int64 (_bgedb [_cagg ])*(1<<uint (8*(len (_bgedb )-_cagg -1)));};return _decf ;};_aab .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_cggcg ));_gade :=0;for _edf :=0;_edf < len (_cggcg );_edf +=_feb {_ccfdb :=_ageb (len (_cggcg ),_edf ,_edf +_bcde );if _ccfdb !=nil {_aab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccfdb );return nil ,_ccfdb ;};_ddbb :=_cggcg [_edf :_edf +_bcde ];_ccfdb =_ageb (len (_cggcg ),_edf +_bcde ,_edf +_gfcb );if _ccfdb !=nil {_aab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccfdb );return nil ,_ccfdb ;};_gbegb :=_cggcg [_edf +_bcde :_edf +_gfcb ];_ccfdb =_ageb (len (_cggcg ),_edf +_gfcb ,_edf +_dbbb );if _ccfdb !=nil {_aab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccfdb );return nil ,_ccfdb ;};_aeeg :=_cggcg [_edf +_gfcb :_edf +_dbbb ];_fdag :=_debg (_ddbb );_adcc :=_debg (_gbegb );_baff :=_debg (_aeeg );if _aagdg [0]==0{_fdag =1;};if _gade >=len (_ddggb ){_aab .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_adebb :=_ddggb [_gade ];_gade ++;_aab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_adebb ,_ddbb );_aab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_adebb ,_gbegb );_aab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_adebb ,_aeeg );_aab .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_adebb ,_fdag ,_adcc ,_baff );if _fdag ==0{_aab .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _fdag ==1{_aab .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_gbegb );if _adcc ==_fcfe {_aab .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_adebb ,_cbbc .ObjectNumber );_adebb =int (_cbbc .ObjectNumber );};if _abea ,_gfbc :=_fdaeb ._baae .ObjectMap [_adebb ];!_gfbc ||int (_baff )> _abea .Generation {_dedb :=XrefObject {ObjectNumber :_adebb ,XType :XrefTypeTableEntry ,Offset :_adcc ,Generation :int (_baff )};_fdaeb ._baae .ObjectMap [_adebb ]=_dedb ;};}else if _fdag ==2{_aab .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_eaga :=_fdaeb ._baae .ObjectMap [_adebb ];!_eaga {_edcg :=XrefObject {ObjectNumber :_adebb ,XType :XrefTypeObjectStream ,OsObjNumber :int (_adcc ),OsObjIndex :int (_baff )};_fdaeb ._baae .ObjectMap [_adebb ]=_edcg ;_aab .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_edcg );};}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _fdaeb ._bgfaf ==nil {_dabe :=XrefTypeObjectStream ;_fdaeb ._bgfaf =&_dabe ;};return _eadf ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_cfc *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_gadb ,_ ,_eea :=_cfc .lookupByNumberWrapper (objNumber ,true );return _gadb ,_eea ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_de .Reader )(PdfObject ,error ){_abfgd :=false ;_dadgc :=true ;var _dbcad _bgd .Buffer ;for {if _aab .Log .IsLogLevel (_aab .LogLevelTrace ){_aab .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dbcad .String ());};_geecf ,_ggad :=buf .Peek (1);if _ggad ==_gf .EOF {break ;};if _ggad !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_ggad );return nil ,_ggad ;};if _dadgc &&(_geecf [0]=='-'||_geecf [0]=='+'){_edba ,_ :=buf .ReadByte ();_dbcad .WriteByte (_edba );_dadgc =false ;}else if IsDecimalDigit (_geecf [0]){_edgd ,_ :=buf .ReadByte ();_dbcad .WriteByte (_edgd );}else if _geecf [0]=='.'{_dgdc ,_ :=buf .ReadByte ();_dbcad .WriteByte (_dgdc );_abfgd =true ;}else if _geecf [0]=='e'||_geecf [0]=='E'{_aebbcc ,_ :=buf .ReadByte ();_dbcad .WriteByte (_aebbcc );_abfgd =true ;_dadgc =true ;}else {break ;};};var _ddbc PdfObject ;if _abfgd {_gedgf ,_acffa :=_bg .ParseFloat (_dbcad .String (),64);if _acffa !=nil {_aab .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dbcad .String (),_acffa );_gedgf =0.0;_acffa =nil ;};_dcdfg :=PdfObjectFloat (_gedgf );_ddbc =&_dcdfg ;}else {_defbf ,_gcbggf :=_bg .ParseInt (_dbcad .String (),10,64);if _gcbggf !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dbcad .String (),_gcbggf );_defbf =0;_gcbggf =nil ;};_efca :=PdfObjectInteger (_defbf );_ddbc =&_efca ;};return _ddbc ,nil ;};func _aacfd (_aegg string )(int ,int ,error ){_bbced :=_cdad .FindStringSubmatch (_aegg );if len (_bbced )< 3{return 0,0,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_cdea ,_ :=_bg .Atoi (_bbced [1]);_cafeb ,_ :=_bg .Atoi (_bbced [2]);return _cdea ,_cafeb ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// Append appends PdfObject(s) to the streams.
func (_edae *PdfObjectStreams )Append (objects ...PdfObject ){if _edae ==nil {_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _edae ._ccfddc ==nil {_edae ._ccfddc =[]PdfObject {};};for _ ,_agadb :=range objects {_edae ._ccfddc =append (_edae ._ccfddc ,_agadb );};};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_bae :=&ASCII85Encoder {};return _bae };func (_egfb *FlateEncoder )cleanImageData (_bcfd []byte )([]byte ,error ){if _egfb ._cdeb ==nil {return _bcfd ,nil ;};if _egfb ._cdeb .BitsPerComponent >=8{return _bcfd ,nil ;};_gfdd :=_egfb ._cdeb .BitsPerComponent *_egfb ._cdeb .Width *_egfb ._cdeb .ColorComponents *_egfb ._cdeb .Height /8;_bcfd =_bcfd [:_gfdd ];var _adcd error ;_bcfd ,_adcd =_aba .AddDataPadding (_egfb ._cdeb .Width ,_egfb ._cdeb .Height ,_egfb ._cdeb .BitsPerComponent ,_egfb ._cdeb .ColorComponents ,_bcfd );if _adcd !=nil {return nil ,_adcd ;};return _bcfd ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_begdg *PdfObjectBool )WriteString ()string {if *_begdg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// String returns a string describing `null`.
func (_dgaa *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};var _bfcgg =_ga .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");func (_acb *PdfParser )parseBool ()(PdfObjectBool ,error ){_cafc ,_ccaaa :=_acb ._fegg .Peek (4);if _ccaaa !=nil {return PdfObjectBool (false ),_ccaaa ;};if (len (_cafc )>=4)&&(string (_cafc [:4])=="\u0074\u0072\u0075\u0065"){_acb ._fegg .Discard (4);return PdfObjectBool (true ),nil ;};_cafc ,_ccaaa =_acb ._fegg .Peek (5);if _ccaaa !=nil {return PdfObjectBool (false ),_ccaaa ;};if (len (_cafc )>=5)&&(string (_cafc [:5])=="\u0066\u0061\u006cs\u0065"){_acb ._fegg .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_c .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_cgdc *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbbd :=MakeDict ();_gbbd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cgdc .GetFilterName ()));return _gbbd ;};

// String returns the state of the bool as "true" or "false".
func (_abdf *PdfObjectBool )String ()string {if *_abdf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func (_adag *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_adag ._baae .ObjectMap =make (map[int ]XrefObject );_adag ._fadad =make (objectStreams );_fedd ,_dgf :=_adag ._edgge .Seek (0,_gf .SeekEnd );if _dgf !=nil {return nil ,_dgf ;};_aab .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_fedd );_adag ._gbbe =_fedd ;_dgf =_adag .seekToEOFMarker (_fedd );if _dgf !=nil {_aab .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dgf );return nil ,_dgf ;};_ggfg ,_dgf :=_adag ._edgge .Seek (0,_gf .SeekCurrent );if _dgf !=nil {return nil ,_dgf ;};var _eegc int64 =64;_bagc :=_ggfg -_eegc ;if _bagc < 0{_bagc =0;};_ ,_dgf =_adag ._edgge .Seek (_bagc ,_gf .SeekStart );if _dgf !=nil {return nil ,_dgf ;};_bcdee :=make ([]byte ,_eegc );_ ,_dgf =_adag ._edgge .Read (_bcdee );if _dgf !=nil {_aab .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dgf );return nil ,_dgf ;};_cccad :=_ggfc .FindStringSubmatch (string (_bcdee ));if len (_cccad )< 2{_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_c .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_cccad )> 2{_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_bcdee );return nil ,_c .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_cbdb ,_ :=_bg .ParseInt (_cccad [1],10,64);_aab .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_cbdb );if _cbdb > _fedd {_aab .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_aab .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_cbdb ,_dgf =_adag .repairLocateXref ();if _dgf !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_dgf ;};};_adag ._edgge .Seek (int64 (_cbdb ),_gf .SeekStart );_adag ._fegg =_de .NewReader (_adag ._edgge );_ggbf ,_dgf :=_adag .parseXref ();if _dgf !=nil {return nil ,_dgf ;};_gbee :=_ggbf .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _gbee !=nil {_ffda ,_ebefff :=_gbee .(*PdfObjectInteger );if !_ebefff {return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dgf =_adag .parseXrefStream (_ffda );if _dgf !=nil {return nil ,_dgf ;};};var _bcfa []int64 ;_cgeg :=func (_edac int64 ,_cfdf []int64 )bool {for _ ,_dbcd :=range _cfdf {if _dbcd ==_edac {return true ;};};return false ;};_gbee =_ggbf .Get ("\u0050\u0072\u0065\u0076");for _gbee !=nil {_ddff ,_gbgf :=_gbee .(*PdfObjectInteger );if !_gbgf {_aab .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_gbee );return _ggbf ,nil ;};_ffdd :=*_ddff ;_aab .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_ffdd );_adag ._edgge .Seek (int64 (_ffdd ),_da .SEEK_SET );_adag ._fegg =_de .NewReader (_adag ._edgge );_bcgc ,_eccgg :=_adag .parseXref ();if _eccgg !=nil {_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_aab .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_gbee =_bcgc .Get ("\u0050\u0072\u0065\u0076");if _gbee !=nil {_dadce :=*(_gbee .(*PdfObjectInteger ));if _cgeg (int64 (_dadce ),_bcfa ){_aab .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_bcfa =append (_bcfa ,int64 (_dadce ));};};return _ggbf ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dffa *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _dffa .Predictor !=1&&_dffa .Predictor !=11{_aab .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _dffa .Predictor ==11{_cfd :=int (_dffa .Columns );_dfc :=len (data )/_cfd ;if len (data )%_cfd !=0{_aab .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_abef :=_bgd .NewBuffer (nil );_adee :=make ([]byte ,_cfd );for _adce :=0;_adce < _dfc ;_adce ++{_dfag :=data [_cfd *_adce :_cfd *(_adce +1)];_adee [0]=_dfag [0];for _fffa :=1;_fffa < _cfd ;_fffa ++{_adee [_fffa ]=byte (int (_dfag [_fffa ]-_dfag [_fffa -1])%256);};_abef .WriteByte (1);_abef .Write (_adee );};data =_abef .Bytes ();};var _fbee _bgd .Buffer ;_aeg :=_ggb .NewWriter (&_fbee );_aeg .Write (data );_aeg .Close ();return _fbee .Bytes (),nil ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_fecf *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_aab .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_fecf .Predictor );if _fecf .BitsPerComponent !=8{return nil ,_d .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_fecf .BitsPerComponent );};_cce ,_efed :=_fecf .DecodeBytes (streamObj .Stream );if _efed !=nil {return nil ,_efed ;};_cce ,_efed =_fecf .postDecodePredict (_cce );if _efed !=nil {return nil ,_efed ;};return _fecf .cleanImageData (_cce );};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dae *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func (_fdcbc *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _eaba *PdfObjectDictionary ;_aggg ,_edcab :=_fdcbc .readTextLine ();if _edcab !=nil {return nil ,_edcab ;};_aab .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_aggg );_dcdg :=-1;_dagge :=0;_eecc :=false ;_beeg :="";for {_fdcbc .skipSpaces ();_ ,_bfeddc :=_fdcbc ._fegg .Peek (1);if _bfeddc !=nil {return nil ,_bfeddc ;};_aggg ,_bfeddc =_fdcbc .readTextLine ();if _bfeddc !=nil {return nil ,_bfeddc ;};_abbb :=_gedgc .FindStringSubmatch (_aggg );if len (_abbb )==0{_adbc :=len (_beeg )> 0;_beeg +=_aggg +"\u000a";if _adbc {_abbb =_gedgc .FindStringSubmatch (_beeg );};};if len (_abbb )==3{_bccb ,_ :=_bg .Atoi (_abbb [1]);_bgcd ,_ :=_bg .Atoi (_abbb [2]);_dcdg =_bccb ;_dagge =_bgcd ;_eecc =true ;_beeg ="";_aab .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_dcdg ,_dagge );continue ;};_fbaa :=_ebac .FindStringSubmatch (_aggg );if len (_fbaa )==4{if _eecc ==false {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_c .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_befb ,_ :=_bg .ParseInt (_fbaa [1],10,64);_cdfc ,_ :=_bg .Atoi (_fbaa [2]);_ecfdc :=_fbaa [3];_beeg ="";if _eg .ToLower (_ecfdc )=="\u006e"&&_befb > 1{_gcde ,_adgda :=_fdcbc ._baae .ObjectMap [_dcdg ];if !_adgda ||_cdfc > _gcde .Generation {_ebbc :=XrefObject {ObjectNumber :_dcdg ,XType :XrefTypeTableEntry ,Offset :_befb ,Generation :_cdfc };_fdcbc ._baae .ObjectMap [_dcdg ]=_ebbc ;};};_dcdg ++;continue ;};if (len (_aggg )> 6)&&(_aggg [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_aab .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_aggg );if len (_aggg )> 9{_facf :=_fdcbc .GetFileOffset ();_fdcbc .SetFileOffset (_facf -int64 (len (_aggg ))+7);};_fdcbc .skipSpaces ();_fdcbc .skipComments ();_aab .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_aab .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_aggg );_eaba ,_bfeddc =_fdcbc .ParseDict ();_aab .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _bfeddc !=nil {_aab .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bfeddc );return nil ,_bfeddc ;};break ;};if _aggg =="\u0025\u0025\u0045O\u0046"{_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_c .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_aab .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_aggg );};_aab .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _fdcbc ._bgfaf ==nil {_agfd :=XrefTypeTableEntry ;_fdcbc ._bgfaf =&_agfd ;};return _eaba ,nil ;};func (_gdge *JBIG2Image )toBitmap ()(_gbacg *_ega .Bitmap ,_bfde error ){const _agbeg ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _gdge .Data ==nil {return nil ,_df .Error (_agbeg ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _gdge .Width ==0||_gdge .Height ==0{return nil ,_df .Error (_agbeg ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _gdge .HasPadding {_gbacg ,_bfde =_ega .NewWithData (_gdge .Width ,_gdge .Height ,_gdge .Data );}else {_gbacg ,_bfde =_ega .NewWithUnpaddedData (_gdge .Width ,_gdge .Height ,_gdge .Data );};if _bfde !=nil {return nil ,_df .Wrap (_bfde ,_agbeg ,"");};return _gbacg ,nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_gefd []float64 ,_gbgg error ){for _ ,_fbdb :=range objects {_gddb ,_ecdc :=GetNumberAsFloat (_fbdb );if _ecdc !=nil {return nil ,_ecdc ;};_gefd =append (_gefd ,_gddb );};return _gefd ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gceg *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_badag *PdfParser )GetCrypter ()*PdfCrypt {return _badag ._bfdd };

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _gfa .Filter ,userPass ,ownerPass []byte ,perm _bba .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_aff :=&PdfCrypt {_abg :make (map[PdfObject ]bool ),_adg :make (cryptFilters ),_aace :_bba .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _ccg Version ;if cf !=nil {_egad :=cf .PDFVersion ();_ccg .Major ,_ccg .Minor =_egad [0],_egad [1];V ,R :=cf .HandlerVersion ();_aff ._fgb .V =V ;_aff ._aace .R =R ;_aff ._fgb .Length =cf .KeyLength ()*8;};const (_bcc =_acf ;);_aff ._adg [_bcc ]=cf ;if _aff ._fgb .V >=4{_aff ._cbg =_bcc ;_aff ._ca =_bcc ;};_gcd :=_aff .newEncryptDict ();_dfg :=_e .Sum ([]byte (_be .Now ().Format (_be .RFC850 )));_bbb :=string (_dfg [:]);_gdaeg :=make ([]byte ,100);_dc .Read (_gdaeg );_dfg =_e .Sum (_gdaeg );_aea :=string (_dfg [:]);_aab .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_gdaeg );_aab .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_bbb );_aff ._efe =string (_bbb );_ef :=_aff .generateParams (userPass ,ownerPass );if _ef !=nil {return nil ,nil ,_ef ;};_ceg (&_aff ._aace ,_gcd );if _aff ._fgb .V >=4{if _geg :=_aff .saveCryptFilters (_gcd );_geg !=nil {return nil ,nil ,_geg ;};};return _aff ,&EncryptInfo {Version :_ccg ,Encrypt :_gcd ,ID0 :_bbb ,ID1 :_aea },nil ;};type offsetReader struct{_deacd _gf .ReadSeeker ;_becf int64 ;};func (_eag *PdfCrypt )saveCryptFilters (_cda *PdfObjectDictionary )error {if _eag ._fgb .V < 4{return _c .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_efa :=MakeDict ();_cda .Set ("\u0043\u0046",_efa );for _fgf ,_dac :=range _eag ._adg {if _fgf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_egaf :=_ccb (_dac ,"");_efa .Set (PdfObjectName (_fgf ),_egaf );};_cda .Set ("\u0053\u0074\u0072\u0046",MakeName (_eag ._ca ));_cda .Set ("\u0053\u0074\u006d\u0046",MakeName (_eag ._cbg ));return nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_dedd :=&PdfIndirectObject {};_dedd .PdfObject =obj ;return _dedd ;};const (DefaultJPEGQuality =75;);

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_gcbcd *PdfParser )IsEncrypted ()(bool ,error ){if _gcbcd ._bfdd !=nil {return true ,nil ;}else if _gcbcd ._dfca ==nil {return false ,nil ;};_aab .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_afeb :=_gcbcd ._dfca .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _afeb ==nil {return false ,nil ;};_aab .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_gbfec *PdfObjectDictionary ;);switch _efce :=_afeb .(type ){case *PdfObjectDictionary :_gbfec =_efce ;case *PdfObjectReference :_aab .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_efce );_bbcd ,_geeg :=_gcbcd .LookupByReference (*_efce );_aab .Log .Trace ("\u0031\u003a\u0020%\u0071",_bbcd );if _geeg !=nil {return false ,_geeg ;};_ccadd ,_defca :=_bbcd .(*PdfIndirectObject );if !_defca {_aab .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_egdb ,_defca :=_ccadd .PdfObject .(*PdfObjectDictionary );_aab .Log .Trace ("\u0032\u003a\u0020%\u0071",_egdb );if !_defca {return false ,_c .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_gbfec =_egdb ;case *PdfObjectNull :_aab .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_d .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_efce );};_gfgb ,_ebacc :=PdfCryptNewDecrypt (_gcbcd ,_gbfec ,_gcbcd ._dfca );if _ebacc !=nil {return false ,_ebacc ;};for _ ,_agcc :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_aaab :=_gcbcd ._dfca .Get (PdfObjectName (_agcc ));if _aaab ==nil {continue ;};switch _ebdg :=_aaab .(type ){case *PdfObjectReference :_gfgb ._aaced [int (_ebdg .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_gfgb ._bbd [_ebdg ]=true ;_gfgb ._aaced [int (_ebdg .ObjectNumber )]=struct{}{};};};_gcbcd ._bfdd =_gfgb ;_aab .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_gfgb );return true ,nil ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_egab *FlateEncoder )SetPredictor (columns int ){_egab .Predictor =11;_egab .Columns =columns };

// WriteString outputs the object as it is to be written to file.
func (_gaaaf *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func (_cdcc *PdfParser )traceStreamLength (_afec PdfObject )(PdfObject ,error ){_beee ,_gbce :=_afec .(*PdfObjectReference );if _gbce {_cdac ,_ebba :=_cdcc ._deag [_beee .ObjectNumber ];if _ebba &&_cdac {_aab .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_c .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cdcc ._deag [_beee .ObjectNumber ]=true ;};_geede ,_dfge :=_cdcc .Resolve (_afec );if _dfge !=nil {return nil ,_dfge ;};_aab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_geede );if _gbce {_cdcc ._deag [_beee .ObjectNumber ]=false ;};return _geede ,nil ;};func (_egb *PdfCrypt )generateParams (_facc ,_ecg []byte )error {_fcgd :=_egb .securityHandler ();_babf ,_ecd :=_fcgd .GenerateParams (&_egb ._aace ,_ecg ,_facc );if _ecd !=nil {return _ecd ;};_egb ._gaf =_babf ;return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fgg *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_dbebe *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_bbcg :=range another .Keys (){_daba :=another .Get (_bbcg );_dbebe .Set (_bbcg ,_daba );};};return _dbebe ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_dgab []StreamEncoder };func (_bbfb *PdfParser )parseObject ()(PdfObject ,error ){_aab .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_bbfb .skipSpaces ();for {_ddgge ,_fdadd :=_bbfb ._fegg .Peek (2);if _fdadd !=nil {if _fdadd !=_gf .EOF ||len (_ddgge )==0{return nil ,_fdadd ;};if len (_ddgge )==1{_ddgge =append (_ddgge ,' ');};};_aab .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_ddgge ));if _ddgge [0]=='/'{_bffaf ,_fffc :=_bbfb .parseName ();_aab .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_bffaf );return &_bffaf ,_fffc ;}else if _ddgge [0]=='('{_aab .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_dabg ,_ceggd :=_bbfb .parseString ();return _dabg ,_ceggd ;}else if _ddgge [0]=='['{_aab .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_daffe ,_afed :=_bbfb .parseArray ();return _daffe ,_afed ;}else if (_ddgge [0]=='<')&&(_ddgge [1]=='<'){_aab .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_cfac ,_eggb :=_bbfb .ParseDict ();return _cfac ,_eggb ;}else if _ddgge [0]=='<'{_aab .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_fcdf ,_bafca :=_bbfb .parseHexString ();return _fcdf ,_bafca ;}else if _ddgge [0]=='%'{_bbfb .readComment ();_bbfb .skipSpaces ();}else {_aab .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_ddgge ,_ =_bbfb ._fegg .Peek (15);_aaag :=string (_ddgge );_aab .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_aaag );if (len (_aaag )> 3)&&(_aaag [:4]=="\u006e\u0075\u006c\u006c"){_dcc ,_bdba :=_bbfb .parseNull ();return &_dcc ,_bdba ;}else if (len (_aaag )> 4)&&(_aaag [:5]=="\u0066\u0061\u006cs\u0065"){_dgc ,_fege :=_bbfb .parseBool ();return &_dgc ,_fege ;}else if (len (_aaag )> 3)&&(_aaag [:4]=="\u0074\u0072\u0075\u0065"){_cfbb ,_gbge :=_bbfb .parseBool ();return &_cfbb ,_gbge ;};_egce :=_fdad .FindStringSubmatch (string (_aaag ));if len (_egce )> 1{_ddgge ,_ =_bbfb ._fegg .ReadBytes ('R');_aab .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_ddgge [:]));_deagb ,_ddga :=_dgabg (string (_ddgge ));_deagb ._dfaa =_bbfb ;return &_deagb ,_ddga ;};_eebf :=_ggfe .FindStringSubmatch (string (_aaag ));if len (_eebf )> 1{_aab .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_cggc ,_bcd :=_bbfb .parseNumber ();return _cggc ,_bcd ;};_eebf =_fcb .FindStringSubmatch (string (_aaag ));if len (_eebf )> 1{_aab .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_aab .Log .Trace ("\u0025\u0020\u0073",_eebf );_baagc ,_gfb :=_bbfb .parseNumber ();return _baagc ,_gfb ;};_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_aaag );return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_acga int ,_bcca bool ){_fgec ,_bcca :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _bcca &&_fgec !=nil {return int (*_fgec ),true ;};return 0,false ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_gfg *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_fdcbg ,_fecd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fecd ==nil {_gfg .BitsPerComponent =int (_fdcbg );};_afb ,_fecd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fecd ==nil {_gfg .Width =int (_afb );};_egafb ,_fecd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fecd ==nil {_gfg .Height =int (_egafb );};_eggc ,_fecd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fecd ==nil {_gfg .ColorComponents =int (_eggc );};};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};type objectStream struct{N int ;_dea []byte ;_ee map[int ]int64 ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_bfaa *PdfParser )GetTrailer ()*PdfObjectDictionary {return _bfaa ._dfca };func (_fgdd *PdfParser )repairSeekXrefMarker ()error {_addb ,_gbebcd :=_fgdd ._edgge .Seek (0,_da .SEEK_END );if _gbebcd !=nil {return _gbebcd ;};_ebee :=_ga .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _dbfbg int64 ;var _cfba int64 =1000;for _dbfbg < _addb {if _addb <=(_cfba +_dbfbg ){_cfba =_addb -_dbfbg ;};_ ,_efef :=_fgdd ._edgge .Seek (-_dbfbg -_cfba ,_da .SEEK_END );if _efef !=nil {return _efef ;};_cbff :=make ([]byte ,_cfba );_fgdd ._edgge .Read (_cbff );_aab .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_cbff ));_gfga :=_ebee .FindAllStringIndex (string (_cbff ),-1);if _gfga !=nil {_fgcf :=_gfga [len (_gfga )-1];_aab .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gfga );_fgdd ._edgge .Seek (-_dbfbg -_cfba +int64 (_fgcf [0]),_da .SEEK_END );_fgdd ._fegg =_de .NewReader (_fgdd ._edgge );for {_aefc ,_eege :=_fgdd ._fegg .Peek (1);if _eege !=nil {return _eege ;};_aab .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_aefc [0],_aefc [0]);if !IsWhiteSpace (_aefc [0]){break ;};_fgdd ._fegg .Discard (1);};return nil ;};_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_dbfbg +=_cfba ;};_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _c .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _gfbca _bgd .Buffer ;_gfbca .Write ([]byte {0xFE,0xFF});_gfbca .WriteString (_af .StringToUTF16 (s ));return &PdfObjectString {_edfd :_gfbca .String (),_dgec :true };};return &PdfObjectString {_edfd :string (_af .StringToPDFDocEncoding (s )),_dgec :false };};

// Validate validates the page settings for the JBIG2 encoder.
func (_cbe JBIG2EncoderSettings )Validate ()error {const _gadbe ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _cbe .Threshold < 0||_cbe .Threshold > 1.0{return _df .Errorf (_gadbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_cbe .Threshold );};if _cbe .ResolutionX < 0{return _df .Errorf (_gadbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cbe .ResolutionX );};if _cbe .ResolutionY < 0{return _df .Errorf (_gadbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cbe .ResolutionY );};if _cbe .DefaultPixelValue !=0&&_cbe .DefaultPixelValue !=1{return _df .Errorf (_gadbe ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_cbe .DefaultPixelValue );};if _cbe .Compression !=JB2Generic {return _df .Errorf (_gadbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_eadbd *PdfObjectDictionary ,_aaac bool ){_eadbd ,_aaac =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _eadbd ,_aaac ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_cdeb *_aba .ImageBase ;};func _egba ()string {return _aab .Version };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bgbe *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _abbe []int64 ;for _ ,_cabb :=range _bgbe .Elements (){if _badf ,_ffgd :=_cabb .(*PdfObjectInteger );_ffgd {_abbe =append (_abbe ,int64 (*_badf ));}else {return nil ,ErrTypeError ;};};return _abbe ,nil ;};func (_cfab *PdfParser )seekToEOFMarker (_dadc int64 )error {var _ccgg int64 ;var _ggcb int64 =2048;for _ccgg < _dadc -4{if _dadc <=(_ggcb +_ccgg ){_ggcb =_dadc -_ccgg ;};_ ,_adgce :=_cfab ._edgge .Seek (-_ccgg -_ggcb ,_gf .SeekEnd );if _adgce !=nil {return _adgce ;};_fece :=make ([]byte ,_ggcb );_cfab ._edgge .Read (_fece );_aab .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_fece ));_adbg :=_dbgg .FindAllStringIndex (string (_fece ),-1);if _adbg !=nil {_dbbe :=_adbg [len (_adbg )-1];_aab .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_adbg );_cfab ._edgge .Seek (-_ccgg -_ggcb +int64 (_dbbe [0]),_gf .SeekEnd );return nil ;};_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ccgg +=_ggcb -4;};_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _c .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_ffaf :=MakeArray ();for _ ,_cdbfe :=range vals {_ffaf .Append (MakeInteger (_cdbfe ));};return _ffaf ;};

// String returns a string describing `array`.
func (_acbb *PdfObjectArray )String ()string {_bfacd :="\u005b";for _bgba ,_bgabc :=range _acbb .Elements (){_bfacd +=_bgabc .String ();if _bgba < (_acbb .Len ()-1){_bfacd +="\u002c\u0020";};};_bfacd +="\u005d";return _bfacd ;};var _fdad =_ga .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_dbedb *PdfObjectFloat ,_cdegd bool ){_dbedb ,_cdegd =TraceToDirectObject (obj ).(*PdfObjectFloat );return _dbedb ,_cdegd ;};func _bfa (_cfg *_gfa .FilterDict ,_gafc *PdfObjectDictionary )error {if _feg ,_cab :=_gafc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cab {if _ecec :=string (*_feg );_ecec !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_aab .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_ecec );};};_abag ,_ade :=_gafc .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_ade {return _d .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_cfg .CFM =string (*_abag );if _eeaff ,_ebb :=_gafc .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_ebb {_cfg .AuthEvent =_bba .AuthEvent (*_eeaff );}else {_cfg .AuthEvent =_bba .EventDocOpen ;};if _cad ,_def :=_gafc .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_def {_cfg .Length =int (*_cad );};return nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_abdg :_dce .InitEncodeDocument (false )}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bfdg *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_edcb :=MakeDict ();_edcb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bfdg .GetFilterName ()));return _edcb ;};

// GetFilterName returns the name of the encoding filter.
func (_fad *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func _bffed (_edfb ,_efbe PdfObject ,_aedb int )bool {if _aedb > _cfed {_aab .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cfed );return false ;};if _edfb ==nil &&_efbe ==nil {return true ;}else if _edfb ==nil ||_efbe ==nil {return false ;};if _b .TypeOf (_edfb )!=_b .TypeOf (_efbe ){return false ;};switch _adda :=_edfb .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_adda ==*(_efbe .(*PdfObjectName ));case *PdfObjectString :return *_adda ==*(_efbe .(*PdfObjectString ));case *PdfObjectInteger :return *_adda ==*(_efbe .(*PdfObjectInteger ));case *PdfObjectBool :return *_adda ==*(_efbe .(*PdfObjectBool ));case *PdfObjectFloat :return *_adda ==*(_efbe .(*PdfObjectFloat ));case *PdfIndirectObject :return _bffed (TraceToDirectObject (_edfb ),TraceToDirectObject (_efbe ),_aedb +1);case *PdfObjectArray :_ecca :=_efbe .(*PdfObjectArray );if len ((*_adda )._cfdc )!=len ((*_ecca )._cfdc ){return false ;};for _cadf ,_fbedb :=range (*_adda )._cfdc {if !_bffed (_fbedb ,(*_ecca )._cfdc [_cadf ],_aedb +1){return false ;};};return true ;case *PdfObjectDictionary :_egge :=_efbe .(*PdfObjectDictionary );_gfda ,_ceggb :=(*_adda )._edbc ,(*_egge )._edbc ;if len (_gfda )!=len (_ceggb ){return false ;};for _cfde ,_cfbf :=range _gfda {_ecdf ,_dfd :=_ceggb [_cfde ];if !_dfd ||!_bffed (_cfbf ,_ecdf ,_aedb +1){return false ;};};return true ;case *PdfObjectStream :_gddg :=_efbe .(*PdfObjectStream );return _bffed ((*_adda ).PdfObjectDictionary ,(*_gddg ).PdfObjectDictionary ,_aedb +1);default:_aab .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_edfb );};return false ;};func _gdfae (_aafd PdfObject ,_cdbfea int ,_efaag map[PdfObject ]struct{})error {_aab .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_cdbfea );if _ ,_fdcac :=_efaag [_aafd ];_fdcac {_aab .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_efaag [_aafd ]=struct{}{};switch _dcdga :=_aafd .(type ){case *PdfIndirectObject :_gefg :=_dcdga ;_aab .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_gefg );_aab .Log .Trace ("\u002d\u0020\u0025\u0073",_gefg .PdfObject );return _gdfae (_gefg .PdfObject ,_cdbfea +1,_efaag );case *PdfObjectStream :_gdaa :=_dcdga ;return _gdfae (_gdaa .PdfObjectDictionary ,_cdbfea +1,_efaag );case *PdfObjectDictionary :_cbdg :=_dcdga ;_aab .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_cbdg );for _ ,_gggff :=range _cbdg .Keys (){_abfg :=_cbdg .Get (_gggff );if _abgd ,_dcef :=_abfg .(*PdfObjectReference );_dcef {_cedb :=_abgd .Resolve ();_cbdg .Set (_gggff ,_cedb );_afdfg :=_gdfae (_cedb ,_cdbfea +1,_efaag );if _afdfg !=nil {return _afdfg ;};}else {_aedf :=_gdfae (_abfg ,_cdbfea +1,_efaag );if _aedf !=nil {return _aedf ;};};};return nil ;case *PdfObjectArray :_faa :=_dcdga ;_aab .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_faa );for _fbbc ,_fgef :=range _faa .Elements (){if _eceae ,_dddg :=_fgef .(*PdfObjectReference );_dddg {_adeg :=_eceae .Resolve ();_faa .Set (_fbbc ,_adeg );_ebcd :=_gdfae (_adeg ,_cdbfea +1,_efaag );if _ebcd !=nil {return _ebcd ;};}else {_deed :=_gdfae (_fgef ,_cdbfea +1,_efaag );if _deed !=nil {return _deed ;};};};return nil ;case *PdfObjectReference :_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _c .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_fgc *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ceccc :=encoded ;var _fgba error ;for _ ,_cga :=range _fgc ._dgab {_aab .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_cga ,_cga );_ceccc ,_fgba =_cga .DecodeBytes (_ceccc );if _fgba !=nil {return nil ,_fgba ;};};return _ceccc ,nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_ffgc ,_afbg :=NewEncoderFromStream (streamObj );if _afbg !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_afbg );return nil ,_afbg ;};_aab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_ffgc );_gaed ,_afbg :=_ffgc .DecodeStream (streamObj );if _afbg !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_afbg );return nil ,_afbg ;};return _gaed ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_addd *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_ggd ,_ecgg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ecgg ==nil {_addd .ColorComponents =int (_ggd );};_aedc ,_ecgg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ecgg ==nil {_addd .BitsPerComponent =int (_aedc );};_fabf ,_ecgg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ecgg ==nil {_addd .Width =int (_fabf );};_cag ,_ecgg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ecgg ==nil {_addd .Height =int (_cag );};_cge ,_ecgg :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _ecgg ==nil {_addd .Quality =int (_cge );};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_afcd *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_edg *PdfCrypt )securityHandler ()_bba .StdHandler {if _edg ._aace .R >=5{return _bba .NewHandlerR6 ();};return _bba .NewHandlerR4 (_edg ._efe ,_edg ._fgb .Length );};

// UpdateParams updates the parameter values of the encoder.
func (_dagg *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func _bcgg (_bfg ,_bgaa ,_aeff uint8 )uint8 {_gbeg :=int (_aeff );_ccfdd :=int (_bgaa )-_gbeg ;_cgba :=int (_bfg )-_gbeg ;_gbeg =_ccade (_ccfdd +_cgba );_ccfdd =_ccade (_ccfdd );_cgba =_ccade (_cgba );if _ccfdd <=_cgba &&_ccfdd <=_gbeg {return _bfg ;}else if _cgba <=_gbeg {return _bgaa ;};return _aeff ;};func _ccade (_eacf int )int {_ceceb :=_eacf >>(_dab -1);return (_eacf ^_ceceb )-_ceceb };func (_edggec *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _edggec ._bdb {return nil ,_d .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_edggec ._bdb =true ;_edggec ._edgge .Seek (0,_da .SEEK_SET );_edggec ._fegg =_de .NewReader (_edggec ._edgge );_ffbdf :=20;_bfbcg :=make ([]byte ,_ffbdf );_beb :=XrefTable {};_beb .ObjectMap =make (map[int ]XrefObject );for {_eabaf ,_gcfe :=_edggec ._fegg .ReadByte ();if _gcfe !=nil {if _gcfe ==_gf .EOF {break ;}else {return nil ,_gcfe ;};};if _eabaf =='j'&&_bfbcg [_ffbdf -1]=='b'&&_bfbcg [_ffbdf -2]=='o'&&IsWhiteSpace (_bfbcg [_ffbdf -3]){_accb :=_ffbdf -4;for IsWhiteSpace (_bfbcg [_accb ])&&_accb > 0{_accb --;};if _accb ==0||!IsDecimalDigit (_bfbcg [_accb ]){continue ;};for IsDecimalDigit (_bfbcg [_accb ])&&_accb > 0{_accb --;};if _accb ==0||!IsWhiteSpace (_bfbcg [_accb ]){continue ;};for IsWhiteSpace (_bfbcg [_accb ])&&_accb > 0{_accb --;};if _accb ==0||!IsDecimalDigit (_bfbcg [_accb ]){continue ;};for IsDecimalDigit (_bfbcg [_accb ])&&_accb > 0{_accb --;};if _accb ==0{continue ;};_daea :=_edggec .GetFileOffset ()-int64 (_ffbdf -_accb );_aedcf :=append (_bfbcg [_accb +1:],_eabaf );_fadaa ,_fcea ,_cffcg :=_aacfd (string (_aedcf ));if _cffcg !=nil {_aab .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_cffcg );return nil ,_cffcg ;};if _gbcg ,_feccd :=_beb .ObjectMap [_fadaa ];!_feccd ||_gbcg .Generation < _fcea {_bgabcd :=XrefObject {};_bgabcd .XType =XrefTypeTableEntry ;_bgabcd .ObjectNumber =int (_fadaa );_bgabcd .Generation =int (_fcea );_bgabcd .Offset =_daea ;_beb .ObjectMap [_fadaa ]=_bgabcd ;};};_bfbcg =append (_bfbcg [1:_ffbdf ],_eabaf );};return &_beb ,nil ;};

// LookupByReference looks up a PdfObject by a reference.
func (_dbf *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_aab .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dbf .LookupByNumber (int (ref .ObjectNumber ));};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gaae *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};func _ffdb (_aacfe *PdfObjectStream ,_gge *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_debe *PdfObjectDictionary )WriteString ()string {var _gaaa _eg .Builder ;_gaaa .WriteString ("\u003c\u003c");for _ ,_bcbga :=range _debe ._fcabe {_dgac :=_debe ._edbc [_bcbga ];_gaaa .WriteString (_bcbga .WriteString ());_gaaa .WriteString ("\u0020");_gaaa .WriteString (_dgac .WriteString ());};_gaaa .WriteString ("\u003e\u003e");return _gaaa .String ();};

// String returns a string representation of `name`.
func (_fefa *PdfObjectName )String ()string {return string (*_fefa )};func (_defb *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_gf .SeekStart {offset +=_defb ._becf ;};_cggg ,_fbab :=_defb ._deacd .Seek (offset ,whence );if _fbab !=nil {return _cggg ,_fbab ;};if whence ==_gf .SeekCurrent {_cggg -=_defb ._becf ;};if _cggg < 0{return 0,_c .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _cggg ,nil ;};func (_fddd *PdfParser )rebuildXrefTable ()error {_gedcf :=XrefTable {};_gedcf .ObjectMap =map[int ]XrefObject {};for _cged ,_aade :=range _fddd ._baae .ObjectMap {_cabd ,_ ,_ecde :=_fddd .lookupByNumberWrapper (_cged ,false );if _ecde !=nil {_aab .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_ecde );_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_fbfaf ,_ffga :=_fddd .repairRebuildXrefsTopDown ();if _ffga !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_ffga );return _ffga ;};_fddd ._baae =*_fbfaf ;_aab .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_cbcd ,_aeef ,_ecde :=_bef (_cabd );if _ecde !=nil {return _ecde ;};_aade .ObjectNumber =int (_cbcd );_aade .Generation =int (_aeef );_gedcf .ObjectMap [int (_cbcd )]=_aade ;};_fddd ._baae =_gedcf ;_aab .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_feae (_fddd ._baae );return nil ;};func (_dcec *PdfParser )skipComments ()error {if _ ,_gafec :=_dcec .skipSpaces ();_gafec !=nil {return _gafec ;};_fcab :=true ;for {_dadf ,_fafd :=_dcec ._fegg .Peek (1);if _fafd !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fafd .Error ());return _fafd ;};if _fcab &&_dadf [0]!='%'{return nil ;};_fcab =false ;if (_dadf [0]!='\r')&&(_dadf [0]!='\n'){_dcec ._fegg .ReadByte ();}else {break ;};};return _dcec .skipComments ();};func (_dda *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_add :=MakeDict ();_add .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_add .Set ("\u0056",MakeInteger (int64 (_dda ._fgb .V )));_add .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dda ._fgb .Length )));return _add ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dfbd *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };func _gcbb (_gcf int )cryptFilters {return cryptFilters {_acf :_gfa .NewFilterV2 (_gcf )}};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};func (_aed *PdfCrypt )decryptBytes (_fag []byte ,_cac string ,_gggg []byte )([]byte ,error ){_aab .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_ba ,_gdcc :=_aed ._adg [_cac ];if !_gdcc {return nil ,_d .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cac );};return _ba .DecryptBytes (_fag ,_gggg );};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_gbdgg *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _fgeb []float64 ;for _ ,_gbbdf :=range _gbdgg .Elements (){switch _edbce :=_gbbdf .(type ){case *PdfObjectInteger :_fgeb =append (_fgeb ,float64 (*_edbce ));case *PdfObjectFloat :_fgeb =append (_fgeb ,float64 (*_edbce ));default:return nil ,ErrTypeError ;};};return _fgeb ,nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_febb *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _fedaf []int ;for _ ,_accfe :=range _febb .Elements (){if _fafa ,_egfde :=_accfe .(*PdfObjectInteger );_egfde {_fedaf =append (_fedaf ,int (*_fafa ));}else {return nil ,ErrTypeError ;};};return _fedaf ,nil ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_aged :=MakeArray ();for _ ,_gbdg :=range vals {_aged .Append (MakeInteger (int64 (_gbdg )));};return _aged ;};

// String returns a string representation of the *PdfObjectString.
func (_gded *PdfObjectString )String ()string {return _gded ._edfd };

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _gcdc :=obj .(type ){case *PdfObjectFloat :_aab .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_gcdc ),nil ;case *PdfObjectInteger :return int64 (*_gcdc ),nil ;};return 0,ErrNotANumber ;};type cryptFilters map[string ]_gfa .Filter ;

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_dbe *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_gdae ,_bff :=obj .(*PdfObjectReference );if !_bff {return obj ,nil ;};_dga :=_dbe .GetFileOffset ();defer func (){_dbe .SetFileOffset (_dga )}();_ead ,_gee :=_dbe .LookupByReference (*_gdae );if _gee !=nil {return nil ,_gee ;};_fg ,_dbb :=_ead .(*PdfIndirectObject );if !_dbb {return _ead ,nil ;};_ead =_fg .PdfObject ;_ ,_bff =_ead .(*PdfObjectReference );if _bff {return _fg ,_c .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ead ,nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_bgg *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_efge :=_bgd .NewReader (encoded );_bbbb ,_dedc :=_bb .Decode (_efge );if _dedc !=nil {_aab .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dedc );return nil ,_dedc ;};_gdce :=_bbbb .Bounds ();var _cfae =make ([]byte ,_gdce .Dx ()*_gdce .Dy ()*_bgg .ColorComponents *_bgg .BitsPerComponent /8);_dfcf :=0;for _gddc :=_gdce .Min .Y ;_gddc < _gdce .Max .Y ;_gddc ++{for _bfbg :=_gdce .Min .X ;_bfbg < _gdce .Max .X ;_bfbg ++{_abebb :=_bbbb .At (_bfbg ,_gddc );if _bgg .ColorComponents ==1{if _bgg .BitsPerComponent ==16{_cec ,_afcf :=_abebb .(_a .Gray16 );if !_afcf {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cfae [_dfcf ]=byte ((_cec .Y >>8)&0xff);_dfcf ++;_cfae [_dfcf ]=byte (_cec .Y &0xff);_dfcf ++;}else {_fffaa ,_bcbg :=_abebb .(_a .Gray );if !_bcbg {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cfae [_dfcf ]=byte (_fffaa .Y &0xff);_dfcf ++;};}else if _bgg .ColorComponents ==3{if _bgg .BitsPerComponent ==16{_cacb ,_cggf :=_abebb .(_a .RGBA64 );if !_cggf {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cfae [_dfcf ]=byte ((_cacb .R >>8)&0xff);_dfcf ++;_cfae [_dfcf ]=byte (_cacb .R &0xff);_dfcf ++;_cfae [_dfcf ]=byte ((_cacb .G >>8)&0xff);_dfcf ++;_cfae [_dfcf ]=byte (_cacb .G &0xff);_dfcf ++;_cfae [_dfcf ]=byte ((_cacb .B >>8)&0xff);_dfcf ++;_cfae [_dfcf ]=byte (_cacb .B &0xff);_dfcf ++;}else {_eccc ,_gbeb :=_abebb .(_a .RGBA );if _gbeb {_cfae [_dfcf ]=_eccc .R &0xff;_dfcf ++;_cfae [_dfcf ]=_eccc .G &0xff;_dfcf ++;_cfae [_dfcf ]=_eccc .B &0xff;_dfcf ++;}else {_cea ,_cgeb :=_abebb .(_a .YCbCr );if !_cgeb {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cece ,_cdc ,_egafa ,_ :=_cea .RGBA ();_cfae [_dfcf ]=byte (_cece >>8);_dfcf ++;_cfae [_dfcf ]=byte (_cdc >>8);_dfcf ++;_cfae [_dfcf ]=byte (_egafa >>8);_dfcf ++;};};}else if _bgg .ColorComponents ==4{_dedg ,_ebdc :=_abebb .(_a .CMYK );if !_ebdc {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cfae [_dfcf ]=255-_dedg .C &0xff;_dfcf ++;_cfae [_dfcf ]=255-_dedg .M &0xff;_dfcf ++;_cfae [_dfcf ]=255-_dedg .Y &0xff;_dfcf ++;_cfae [_dfcf ]=255-_dedg .K &0xff;_dfcf ++;};};};return _cfae ,nil ;};func (_fegc *ASCII85Encoder )base256Tobase85 (_bgfa uint32 )[5]byte {_cedg :=[5]byte {0,0,0,0,0};_efda :=_bgfa ;for _bafb :=0;_bafb < 5;_bafb ++{_gbdc :=uint32 (1);for _ddb :=0;_ddb < 4-_bafb ;_ddb ++{_gbdc *=85;};_dcgg :=_efda /_gbdc ;_efda =_efda %_gbdc ;_cedg [_bafb ]=byte (_dcgg );};return _cedg ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_dbca :=&PdfObjectArray {};_dbca ._cfdc =[]PdfObject {};for _ ,_fadg :=range objects {_dbca ._cfdc =append (_dbca ._cfdc ,_fadg );};return _dbca ;};

// Clear resets the array to an empty state.
func (_efeeb *PdfObjectArray )Clear (){_efeeb ._cfdc =[]PdfObject {}};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _eebd ,_fddb :=obj .(*PdfObjectReference );_fddb {obj =_eebd .Resolve ();};_ebge ,_agcaf :=obj .(*PdfIndirectObject );_geea :=0;for _agcaf {obj =_ebge .PdfObject ;_ebge ,_agcaf =GetIndirect (obj );_geea ++;if _geea > _cfed {_aab .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_cfed );return nil ;};};return obj ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_gead *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gead ._ccfddc ){return _c .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gead ._ccfddc [i ]=obj ;return nil ;};const _dab =32<<(^uint (0)>>63);

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_fbce :=PdfObjectName (s );return &_fbce };func (_bbce *PdfCrypt )checkAccessRights (_ccc []byte )(bool ,_bba .Permissions ,error ){_cdbf :=_bbce .securityHandler ();_ffd ,_afcc ,_gdd :=_cdbf .Authenticate (&_bbce ._aace ,_ccc );if _gdd !=nil {return false ,0,_gdd ;}else if _afcc ==0||len (_ffd )==0{return false ,0,nil ;};return true ,_afcc ,nil ;};func (_cdde *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_cdde ._fegg )};func (_adef *PdfCrypt )makeKey (_gea string ,_adec ,_dfgc uint32 ,_aded []byte )([]byte ,error ){_abagg ,_addc :=_adef ._adg [_gea ];if !_addc {return nil ,_d .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_gea );};return _abagg .MakeKey (_adec ,_dfgc ,_aded );};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_a .Model ;Bounds ()_aa .Rectangle ;At (_edd ,_aacg int )_a .Color ;Set (_ccaf ,_gdcf int ,_ebgf _a .Color );};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_fggc *PdfObjectArray )Get (i int )PdfObject {if _fggc ==nil ||i >=len (_fggc ._cfdc )||i < 0{return nil ;};return _fggc ._cfdc [i ];};

// Len returns the number of elements in the array.
func (_edec *PdfObjectArray )Len ()int {if _edec ==nil {return 0;};return len (_edec ._cfdc );};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};func (_cefg *PdfCrypt )authenticate (_beg []byte )(bool ,error ){_cefg ._gbe =false ;_aaa :=_cefg .securityHandler ();_ebdf ,_gfd ,_fcgc :=_aaa .Authenticate (&_cefg ._aace ,_beg );if _fcgc !=nil {return false ,_fcgc ;}else if _gfd ==0||len (_ebdf )==0{return false ,nil ;};_cefg ._gbe =true ;_cefg ._gaf =_ebdf ;return true ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_edbca *PdfObjectReference )WriteString ()string {var _eabab _eg .Builder ;_eabab .WriteString (_bg .FormatInt (_edbca .ObjectNumber ,10));_eabab .WriteString ("\u0020");_eabab .WriteString (_bg .FormatInt (_edbca .GenerationNumber ,10));_eabab .WriteString ("\u0020\u0052");return _eabab .String ();};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_fcdb *JBIG2Encoder )EncodeImage (img _aa .Image )([]byte ,error ){return _fcdb .encodeImage (img )};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_fgga *MultiEncoder )GetFilterName ()string {_ebga :="";for _eagb ,_daff :=range _fgga ._dgab {_ebga +=_daff .GetFilterName ();if _eagb < len (_fgga ._dgab )-1{_ebga +="\u0020";};};return _ebga ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_dag *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _eca _bgd .Buffer ;_fdab :=_bgd .NewReader (encoded );var _aca _gf .ReadCloser ;if _dag .EarlyChange ==1{_aca =_f .NewReader (_fdab ,_f .MSB ,8);}else {_aca =_bge .NewReader (_fdab ,_bge .MSB ,8);};defer _aca .Close ();_ ,_ggab :=_eca .ReadFrom (_aca );if _ggab !=nil {return nil ,_ggab ;};return _eca .Bytes (),nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dfac *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_fgbf string ,_gcfa bool ){_fbca ,_gcfa :=TraceToDirectObject (obj ).(*PdfObjectName );if _gcfa {return string (*_fbca ),true ;};return ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_bbgf :=PdfObjectString {_edfd :s ,_dgec :true };return &_bbgf ;};

// Remove removes an element specified by key.
func (_gcbgd *PdfObjectDictionary )Remove (key PdfObjectName ){_dfcd :=-1;for _baab ,_ceeb :=range _gcbgd ._fcabe {if _ceeb ==key {_dfcd =_baab ;break ;};};if _dfcd >=0{_gcbgd ._fcabe =append (_gcbgd ._fcabe [:_dfcd ],_gcbgd ._fcabe [_dfcd +1:]...);delete (_gcbgd ._edbc ,key );};};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aagd *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func _ebbf (_ecc *PdfObjectStream ,_abde *MultiEncoder )(*DCTEncoder ,error ){_fggb :=NewDCTEncoder ();_cdeg :=_ecc .PdfObjectDictionary ;if _cdeg ==nil {return _fggb ,nil ;};_dfe :=_ecc .Stream ;if _abde !=nil {_cabc ,_ffcf :=_abde .DecodeBytes (_dfe );if _ffcf !=nil {return nil ,_ffcf ;};_dfe =_cabc ;};_bcedc :=_bgd .NewReader (_dfe );_ccee ,_dcb :=_bb .DecodeConfig (_bcedc );if _dcb !=nil {_aab .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dcb );return nil ,_dcb ;};switch _ccee .ColorModel {case _a .RGBAModel :_fggb .BitsPerComponent =8;_fggb .ColorComponents =3;case _a .RGBA64Model :_fggb .BitsPerComponent =16;_fggb .ColorComponents =3;case _a .GrayModel :_fggb .BitsPerComponent =8;_fggb .ColorComponents =1;case _a .Gray16Model :_fggb .BitsPerComponent =16;_fggb .ColorComponents =1;case _a .CMYKModel :_fggb .BitsPerComponent =8;_fggb .ColorComponents =4;case _a .YCbCrModel :_fggb .BitsPerComponent =8;_fggb .ColorComponents =3;default:return nil ,_c .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_fggb .Width =_ccee .Width ;_fggb .Height =_ccee .Height ;_aab .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_fggb );_fggb .Quality =DefaultJPEGQuality ;return _fggb ,nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_efaa *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_gacc :=n ;_bafc :=0;_gfeda :=0;for _gacc > 0{_deca ,_acede :=_efaa ._fegg .Read (p [_bafc :]);if _acede !=nil {_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_deca ,_gfeda ,_acede .Error ());return _bafc ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_gfeda ++;_bafc +=_deca ;_gacc -=_deca ;};return _bafc ,nil ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_eedd *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_aeafg ,_agbf :=_eedd ._edbc [key ].(*PdfObjectString );if !_agbf {return "",false ;};return _aeafg .Str (),true ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _adbaf :=obj .(type ){case *PdfObjectFloat :return float64 (*_adbaf ),nil ;case *PdfObjectInteger :return float64 (*_adbaf ),nil ;};return 0,ErrNotANumber ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_bcea :=&FlateEncoder {};_bcea .Predictor =1;_bcea .BitsPerComponent =8;_bcea .Colors =1;_bcea .Columns =1;return _bcea ;};func _dgabg (_cadd string )(PdfObjectReference ,error ){_baga :=PdfObjectReference {};_gbfb :=_fdad .FindStringSubmatch (string (_cadd ));if len (_gbfb )< 3{_aab .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _baga ,_c .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_cffb ,_ :=_bg .Atoi (_gbfb [1]);_gdb ,_ :=_bg .Atoi (_gbfb [2]);_baga .ObjectNumber =int64 (_cffb );_baga .GenerationNumber =int64 (_gdb );return _baga ,nil ;};func _ccb (_gga _gfa .Filter ,_eec _bba .AuthEvent )*PdfObjectDictionary {if _eec ==""{_eec =_bba .EventDocOpen ;};_gcfd :=MakeDict ();_gcfd .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_gcfd .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_eec )));_gcfd .Set ("\u0043\u0046\u004d",MakeName (_gga .Name ()));_gcfd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gga .KeyLength ())));return _gcfd ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_fceb *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fceb .DecodeBytes (streamObj .Stream );};func (_cddd *PdfParser )readComment ()(string ,error ){var _befed _bgd .Buffer ;_ ,_baca :=_cddd .skipSpaces ();if _baca !=nil {return _befed .String (),_baca ;};_dgaf :=true ;for {_caa ,_aebbc :=_cddd ._fegg .Peek (1);if _aebbc !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_aebbc .Error ());return _befed .String (),_aebbc ;};if _dgaf &&_caa [0]!='%'{return _befed .String (),_c .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_dgaf =false ;if (_caa [0]!='\r')&&(_caa [0]!='\n'){_ffff ,_ :=_cddd ._fegg .ReadByte ();_befed .WriteByte (_ffff );}else {break ;};};return _befed .String (),nil ;};func (_gaeaa *PdfObjectFloat )String ()string {return _d .Sprintf ("\u0025\u0066",*_gaeaa )};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_eccg *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eccg .DecodeBytes (streamObj .Stream );};func (_aac *PdfParser )lookupByNumberWrapper (_fcg int ,_gae bool )(PdfObject ,bool ,error ){_eef ,_fb ,_abc :=_aac .lookupByNumber (_fcg ,_gae );if _abc !=nil {return nil ,_fb ,_abc ;};if !_fb &&_aac ._bfdd !=nil &&!_aac ._bfdd .isDecrypted (_eef ){_db :=_aac ._bfdd .Decrypt (_eef ,0,0);if _db !=nil {return nil ,_fb ,_db ;};};return _eef ,_fb ,nil ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_egag *PdfObjectDictionary );EncodeBytes (_ded []byte )([]byte ,error );DecodeBytes (_agb []byte )([]byte ,error );DecodeStream (_abdc *PdfObjectStream )([]byte ,error );};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_dcbg *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_cgb ,_cabe :=_aba .NewImage (_dcbg .Width ,_dcbg .Height ,_dcbg .BitsPerComponent ,_dcbg .ColorComponents ,data ,nil ,nil );if _cabe !=nil {return nil ,_cabe ;};_cbge :=_bb .Options {};_cbge .Quality =_dcbg .Quality ;var _dfeb _bgd .Buffer ;if _cabe =_bb .Encode (&_dfeb ,_cgb ,&_cbge );_cabe !=nil {return nil ,_cabe ;};return _dfeb .Bytes (),nil ;};

// SetImage sets the image base for given flate encoder.
func (_fed *FlateEncoder )SetImage (img *_aba .ImageBase ){_fed ._cdeb =img };

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_bfga :=PdfObjectString {_edfd :s };return &_bfga };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fabc *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_bcbf :=_bgd .NewReader (data );var _bbde []byte ;var _gdddf []byte ;_fabe ,_dbeb :=_bcbf .ReadByte ();if _dbeb ==_gf .EOF {return []byte {},nil ;}else if _dbeb !=nil {return nil ,_dbeb ;};_gafgc :=1;for {_bcbc ,_faed :=_bcbf .ReadByte ();if _faed ==_gf .EOF {break ;}else if _faed !=nil {return nil ,_faed ;};if _bcbc ==_fabe {if len (_gdddf )> 0{_gdddf =_gdddf [:len (_gdddf )-1];if len (_gdddf )> 0{_bbde =append (_bbde ,byte (len (_gdddf )-1));_bbde =append (_bbde ,_gdddf ...);};_gafgc =1;_gdddf =[]byte {};};_gafgc ++;if _gafgc >=127{_bbde =append (_bbde ,byte (257-_gafgc ),_fabe );_gafgc =0;};}else {if _gafgc > 0{if _gafgc ==1{_gdddf =[]byte {_fabe };}else {_bbde =append (_bbde ,byte (257-_gafgc ),_fabe );};_gafgc =0;};_gdddf =append (_gdddf ,_bcbc );if len (_gdddf )>=127{_bbde =append (_bbde ,byte (len (_gdddf )-1));_bbde =append (_bbde ,_gdddf ...);_gdddf =[]byte {};};};_fabe =_bcbc ;};if len (_gdddf )> 0{_bbde =append (_bbde ,byte (len (_gdddf )-1));_bbde =append (_bbde ,_gdddf ...);}else if _gafgc > 0{_bbde =append (_bbde ,byte (257-_gafgc ),_fabe );};_bbde =append (_bbde ,128);return _bbde ,nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_feece *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _effg ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _feece .ColorComponents !=1||_feece .BitsPerComponent !=1{return nil ,_df .Errorf (_effg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_ebbfe *_ega .Bitmap ;_eggae error ;);_acfd :=(_feece .Width *_feece .Height )==len (data );if _acfd {_ebbfe ,_eggae =_ega .NewWithUnpaddedData (_feece .Width ,_feece .Height ,data );}else {_ebbfe ,_eggae =_ega .NewWithData (_feece .Width ,_feece .Height ,data );};if _eggae !=nil {return nil ,_eggae ;};_adae :=_feece .DefaultPageSettings ;if _eggae =_adae .Validate ();_eggae !=nil {return nil ,_df .Wrap (_eggae ,_effg ,"");};switch _adae .Compression {case JB2Generic :if _eggae =_feece ._abdg .AddGenericPage (_ebbfe ,_adae .DuplicatedLinesRemoval );_eggae !=nil {return nil ,_df .Wrap (_eggae ,_effg ,"");};case JB2SymbolCorrelation :return nil ,_df .Error (_effg ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_df .Error (_effg ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_df .Error (_effg ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _feece .Encode ();};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func _aceaa (_cecc *PdfObjectStream )(*MultiEncoder ,error ){_gdff :=NewMultiEncoder ();_dbfbc :=_cecc .PdfObjectDictionary ;if _dbfbc ==nil {return _gdff ,nil ;};var _efbfb *PdfObjectDictionary ;var _bgebg []PdfObject ;_cdcg :=_dbfbc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cdcg !=nil {_dgadb ,_ddfe :=_cdcg .(*PdfObjectDictionary );if _ddfe {_efbfb =_dgadb ;};_fbgb ,_edgf :=_cdcg .(*PdfObjectArray );if _edgf {for _ ,_cagb :=range _fbgb .Elements (){_cagb =TraceToDirectObject (_cagb );if _gdccd ,_aaca :=_cagb .(*PdfObjectDictionary );_aaca {_bgebg =append (_bgebg ,_gdccd );}else {_bgebg =append (_bgebg ,MakeDict ());};};};};_cdcg =_dbfbc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _cdcg ==nil {return nil ,_d .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_fegb ,_bceae :=_cdcg .(*PdfObjectArray );if !_bceae {return nil ,_d .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _eceb ,_gggf :=range _fegb .Elements (){_eddg ,_fdcb :=_gggf .(*PdfObjectName );if !_fdcb {return nil ,_d .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _cddcd PdfObject ;if _efbfb !=nil {_cddcd =_efbfb ;}else {if len (_bgebg )> 0{if _eceb >=len (_bgebg ){return nil ,_d .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_cddcd =_bgebg [_eceb ];};};var _ffe *PdfObjectDictionary ;if _fcda ,_egef :=_cddcd .(*PdfObjectDictionary );_egef {_ffe =_fcda ;};_aab .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_eddg ,_cddcd ,_ffe );if *_eddg ==StreamEncodingFilterNameFlate {_bec ,_gddcc :=_acd (_cecc ,_ffe );if _gddcc !=nil {return nil ,_gddcc ;};_gdff .AddEncoder (_bec );}else if *_eddg ==StreamEncodingFilterNameLZW {_dagb ,_aabg :=_gcbg (_cecc ,_ffe );if _aabg !=nil {return nil ,_aabg ;};_gdff .AddEncoder (_dagb );}else if *_eddg ==StreamEncodingFilterNameASCIIHex {_bdcg :=NewASCIIHexEncoder ();_gdff .AddEncoder (_bdcg );}else if *_eddg ==StreamEncodingFilterNameASCII85 {_ccaa :=NewASCII85Encoder ();_gdff .AddEncoder (_ccaa );}else if *_eddg ==StreamEncodingFilterNameDCT {_gfaag ,_ffcc :=_ebbf (_cecc ,_gdff );if _ffcc !=nil {return nil ,_ffcc ;};_gdff .AddEncoder (_gfaag );_aab .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_aab .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_gdff );}else {_aab .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_eddg );return nil ,_d .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _gdff ,nil ;};func (_baeb *PdfParser )parsePdfVersion ()(int ,int ,error ){var _cgfa int64 =20;_cdadc :=make ([]byte ,_cgfa );_baeb ._edgge .Seek (0,_da .SEEK_SET );_baeb ._edgge .Read (_cdadc );var _cdegb error ;var _adcg ,_bgeg int ;if _afgf :=_deeg .FindStringSubmatch (string (_cdadc ));len (_afgf )< 3{if _adcg ,_bgeg ,_cdegb =_baeb .seekPdfVersionTopDown ();_cdegb !=nil {_aab .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_cdegb ;};_baeb ._edgge ,_cdegb =_fdbe (_baeb ._edgge ,_baeb .GetFileOffset ()-8);if _cdegb !=nil {return 0,0,_cdegb ;};}else {if _adcg ,_cdegb =_bg .Atoi (_afgf [1]);_cdegb !=nil {return 0,0,_cdegb ;};if _bgeg ,_cdegb =_bg .Atoi (_afgf [2]);_cdegb !=nil {return 0,0,_cdegb ;};_baeb .SetFileOffset (0);};_baeb ._fegg =_de .NewReader (_baeb ._edgge );_aab .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_adcg ,_bgeg );return _adcg ,_bgeg ,nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_efgc *PdfObjectName ,_afda bool ){_efgc ,_afda =TraceToDirectObject (obj ).(*PdfObjectName );return _efgc ,_afda ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_aabag *PdfParser )IsAuthenticated ()bool {return _aabag ._bfdd ._gbe };

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fefg *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fefg .isEncrypted (obj ){return nil ;};switch _eeca :=obj .(type ){case *PdfIndirectObject :_fefg ._abg [_eeca ]=true ;_aab .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eeca .ObjectNumber ,_eeca .GenerationNumber );_deac :=_eeca .ObjectNumber ;_ccf :=_eeca .GenerationNumber ;_fgfd :=_fefg .Encrypt (_eeca .PdfObject ,_deac ,_ccf );if _fgfd !=nil {return _fgfd ;};return nil ;case *PdfObjectStream :_fefg ._abg [_eeca ]=true ;_fcgcf :=_eeca .PdfObjectDictionary ;if _aacf ,_aafad :=_fcgcf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aafad &&*_aacf =="\u0058\u0052\u0065\u0066"{return nil ;};_gdf :=_eeca .ObjectNumber ;_agd :=_eeca .GenerationNumber ;_aab .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gdf ,_agd );_faf :=_acf ;if _fefg ._fgb .V >=4{_faf =_fefg ._cbg ;_aab .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fefg ._cbg );if _aeee ,_gbg :=_fcgcf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_gbg {if _fgfa ,_eff :=GetName (_aeee .Get (0));_eff {if *_fgfa =="\u0043\u0072\u0079p\u0074"{_faf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _egffa ,_ccca :=_fcgcf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_ccca {if _cfca ,_bbae :=_egffa .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bbae {if _ ,_gdaeb :=_fefg ._adg [string (*_cfca )];_gdaeb {_aab .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cfca );_faf =string (*_cfca );};};};};};};_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_faf );if _faf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ccdd :=_fefg .Encrypt (_eeca .PdfObjectDictionary ,_gdf ,_agd );if _ccdd !=nil {return _ccdd ;};_cbc ,_ccdd :=_fefg .makeKey (_faf ,uint32 (_gdf ),uint32 (_agd ),_fefg ._gaf );if _ccdd !=nil {return _ccdd ;};_eeca .Stream ,_ccdd =_fefg .encryptBytes (_eeca .Stream ,_faf ,_cbc );if _ccdd !=nil {return _ccdd ;};_fcgcf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eeca .Stream ))));return nil ;case *PdfObjectString :_aab .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gdfe :=_acf ;if _fefg ._fgb .V >=4{_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fefg ._ca );if _fefg ._ca =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gdfe =_fefg ._ca ;};_ebef ,_bced :=_fefg .makeKey (_gdfe ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fefg ._gaf );if _bced !=nil {return _bced ;};_eadg :=_eeca .Str ();_affe :=make ([]byte ,len (_eadg ));for _fff :=0;_fff < len (_eadg );_fff ++{_affe [_fff ]=_eadg [_fff ];};_aab .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_affe ,_affe );_affe ,_bced =_fefg .encryptBytes (_affe ,_gdfe ,_ebef );if _bced !=nil {return _bced ;};_eeca ._edfd =string (_affe );return nil ;case *PdfObjectArray :for _ ,_gff :=range _eeca .Elements (){_aaad :=_fefg .Encrypt (_gff ,parentObjNum ,parentGenNum );if _aaad !=nil {return _aaad ;};};return nil ;case *PdfObjectDictionary :_ccbf :=false ;if _aabd :=_eeca .Get ("\u0054\u0079\u0070\u0065");_aabd !=nil {_efdg ,_daa :=_aabd .(*PdfObjectName );if _daa &&*_efdg =="\u0053\u0069\u0067"{_ccbf =true ;};};for _ ,_agfa :=range _eeca .Keys (){_eac :=_eeca .Get (_agfa );if _ccbf &&string (_agfa )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_agfa )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_agfa )!="\u0050\u0072\u0065\u0076"&&string (_agfa )!="\u004c\u0061\u0073\u0074"{_ggfa :=_fefg .Encrypt (_eac ,parentObjNum ,parentGenNum );if _ggfa !=nil {return _ggfa ;};};};return nil ;};return nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_fgceg *PdfObjectBool ,_fcgaff bool ){_fgceg ,_fcgaff =TraceToDirectObject (obj ).(*PdfObjectBool );return _fgceg ,_fcgaff ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_bfd :=&DCTEncoder {};_bfd .ColorComponents =3;_bfd .BitsPerComponent =8;_bfd .Quality =DefaultJPEGQuality ;return _bfd ;};func (_ggac *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _gede =20;_gccag ,_ :=_ggac ._fegg .Peek (_gede );for _bded :=0;_bded < 2;_bded ++{if _ggac ._gcgc ==0{_ggac ._gcgc =_ggac .GetFileOffset ();};if _cdad .Match (_gccag ){_aab .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_aab .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gccag ));return _ggac .parseXrefStream (nil );};if _bfcgg .Match (_gccag ){_aab .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _ggac .parseXrefTable ();};_eabc :=_ggac .GetFileOffset ();if _ggac ._gcgc ==0{_ggac ._gcgc =_eabc ;};_ggac .SetFileOffset (_eabc -_gede );defer _ggac .SetFileOffset (_eabc );_bgdf ,_ :=_ggac ._fegg .Peek (_gede );_gccag =append (_bgdf ,_gccag ...);};_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _ebf :=_ggac .repairSeekXrefMarker ();_ebf !=nil {_aab .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_ebf );return nil ,_ebf ;};return _ggac .parseXrefTable ();};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_bfdc :=MultiEncoder {};_bfdc ._dgab =[]StreamEncoder {};return &_bfdc ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_ebbac *PdfObjectStreams ,_cffc bool ){_ebbac ,_cffc =obj .(*PdfObjectStreams );return _ebbac ,_cffc ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_agad float64 ,_fgdc bool ){_gdfa ,_fgdc :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _fgdc {return float64 (*_gdfa ),true ;};return 0,false ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _daeg ,_gedda :=obj .(*PdfObjectReference );_gedda {return _daeg .Resolve ();};return obj ;};

// WriteString outputs the object as it is to be written to file.
func (_egcf *PdfObjectString )WriteString ()string {var _gbfcf _bgd .Buffer ;if _egcf ._dgec {_fbdd :=_gg .EncodeToString (_egcf .Bytes ());_gbfcf .WriteString ("\u003c");_gbfcf .WriteString (_fbdd );_gbfcf .WriteString ("\u003e");return _gbfcf .String ();};_abcc :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_gbfcf .WriteString ("\u0028");for _dacgf :=0;_dacgf < len (_egcf ._edfd );_dacgf ++{_bcff :=_egcf ._edfd [_dacgf ];if _cfcd ,_gaab :=_abcc [_bcff ];_gaab {_gbfcf .WriteString (_cfcd );}else {_gbfcf .WriteByte (_bcff );};};_gbfcf .WriteString ("\u0029");return _gbfcf .String ();};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};var _cdad =_ga .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// WriteString outputs the object as it is to be written to file.
func (_cgbb *PdfObjectStreams )WriteString ()string {var _acage _eg .Builder ;_acage .WriteString (_bg .FormatInt (_cgbb .ObjectNumber ,10));_acage .WriteString ("\u0020\u0030\u0020\u0052");return _acage .String ();};var _fcb =_ga .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_bfee *PdfObjectReference )Resolve ()PdfObject {if _bfee ._dfaa ==nil {return MakeNull ();};_gbec ,_ ,_fbbg :=_bfee ._dfaa .resolveReference (_bfee );if _fbbg !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_fbbg );return MakeNull ();};if _gbec ==nil {_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _gbec ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_gfdc *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_dgdb :=_gfdc .GetFileOffset ();_ ,_fecfd :=_gfdc ._edgge .Seek (offset ,_gf .SeekStart );if _fecfd !=nil {return nil ,_fecfd ;};_cbga :=make ([]byte ,len );_ ,_fecfd =_gf .ReadAtLeast (_gfdc ._edgge ,_cbga ,int (len ));if _fecfd !=nil {return nil ,_fecfd ;};_gfdc .SetFileOffset (_dgdb );return _cbga ,nil ;};

// PdfVersion returns version of the PDF file.
func (_bgb *PdfParser )PdfVersion ()Version {return _bgb ._gafff };

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_afab *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _eeda :=val .(type ){case *PdfObjectName :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectDictionary :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectStream :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectString :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectNull :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectInteger :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectArray :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectBool :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectFloat :if _eeda !=nil {_afab .Set (key ,val );};case *PdfObjectReference :if _eeda !=nil {_afab .Set (key ,val );};case *PdfIndirectObject :if _eeda !=nil {_afab .Set (key ,val );};default:_aab .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gece *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fbfa *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_fbfa ._dgab )==0{return nil ;};if len (_fbfa ._dgab )==1{return _fbfa ._dgab [0].MakeDecodeParams ();};_aabbf :=MakeArray ();for _ ,_bfbcf :=range _fbfa ._dgab {_bag :=_bfbcf .MakeDecodeParams ();if _bag ==nil {_aabbf .Append (MakeNull ());}else {_aabbf .Append (_bag );};};return _aabbf ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// Bytes returns the PdfObjectString content as a []byte array.
func (_gddac *PdfObjectString )Bytes ()[]byte {return []byte (_gddac ._edfd )};

// Elements returns a slice of the PdfObject elements in the array.
func (_gadcd *PdfObjectArray )Elements ()[]PdfObject {if _gadcd ==nil {return nil ;};return _gadcd ._cfdc ;};var _bdff =_ga .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_ebdb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _ebdb .Predictor !=1{return nil ,_d .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _ebdb .EarlyChange ==1{return nil ,_d .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _efb _bgd .Buffer ;_begg :=_bge .NewWriter (&_efb ,_bge .MSB ,8);_begg .Write (data );_begg .Close ();return _efb .Bytes (),nil ;};func _degg (_cadc _aba .Image )*JBIG2Image {_beed :=_cadc .Base ();return &JBIG2Image {Data :_beed .Data ,Width :_beed .Width ,Height :_beed .Height ,HasPadding :true };};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_dddb :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_dddb .PdfObjectDictionary =encoder .MakeStreamDict ();_ccacc ,_egagd :=encoder .EncodeBytes (contents );if _egagd !=nil {return nil ,_egagd ;};_dddb .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ccacc ))));_dddb .Stream =_ccacc ;return _dddb ,nil ;};type objectCache map[int ]PdfObject ;func _feae (_fec XrefTable ){_aab .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_aab .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bd :=0;for _ ,_ed :=range _fec .ObjectMap {_aab .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_bd +1,_ed .ObjectNumber ,_ed .Generation ,_ed .Offset );_bd ++;};};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_eead Version )String ()string {return _d .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_eead .Major ,_eead .Minor );};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_dcca *PdfParser )GetObjectNums ()[]int {var _fcgg []int ;for _ ,_dfcg :=range _dcca ._baae .ObjectMap {_fcgg =append (_fcgg ,_dfcg .ObjectNumber );};_cf .Ints (_fcgg );return _fcgg ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// GetXrefOffset returns the offset of the xref table.
func (_efdad *PdfParser )GetXrefOffset ()int64 {return _efdad ._gcgc };

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_edaf *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _afe []byte ;_aab .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_ceec :=0;_egea :=false ;for _ceec < len (encoded )&&!_egea {_bffgc :=[5]byte {0,0,0,0,0};_efbf :=0;_agbe :=0;_bfag :=4;for _agbe < 5+_efbf {if _ceec +_agbe ==len (encoded ){break ;};_gbef :=encoded [_ceec +_agbe ];if IsWhiteSpace (_gbef ){_efbf ++;_agbe ++;continue ;}else if _gbef =='~'&&_ceec +_agbe +1< len (encoded )&&encoded [_ceec +_agbe +1]=='>'{_bfag =(_agbe -_efbf )-1;if _bfag < 0{_bfag =0;};_egea =true ;break ;}else if _gbef >='!'&&_gbef <='u'{_gbef -='!';}else if _gbef =='z'&&_agbe -_efbf ==0{_bfag =4;_agbe ++;break ;}else {_aab .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_bffgc [_agbe -_efbf ]=_gbef ;_agbe ++;};_ceec +=_agbe ;for _fge :=_bfag +1;_fge < 5;_fge ++{_bffgc [_fge ]=84;};_dbdc :=uint32 (_bffgc [0])*85*85*85*85+uint32 (_bffgc [1])*85*85*85+uint32 (_bffgc [2])*85*85+uint32 (_bffgc [3])*85+uint32 (_bffgc [4]);_bdd :=[]byte {byte ((_dbdc >>24)&0xff),byte ((_dbdc >>16)&0xff),byte ((_dbdc >>8)&0xff),byte (_dbdc &0xff)};_afe =append (_afe ,_bdd [:_bfag ]...);};_aab .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_aab .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_afe );return _afe ,nil ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_dfaa *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};func (_fae *PdfCrypt )loadCryptFilters (_dba *PdfObjectDictionary )error {_fae ._adg =cryptFilters {};_gbc :=_dba .Get ("\u0043\u0046");_gbc =TraceToDirectObject (_gbc );if _dbbg ,_ggg :=_gbc .(*PdfObjectReference );_ggg {_dff ,_gec :=_fae ._adf .LookupByReference (*_dbbg );if _gec !=nil {_aab .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _gec ;};_gbc =TraceToDirectObject (_dff );};_ccd ,_bcef :=_gbc .(*PdfObjectDictionary );if !_bcef {_aab .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_gbc );return _c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_abe :=range _ccd .Keys (){_age :=_ccd .Get (_abe );if _bcg ,_dfa :=_age .(*PdfObjectReference );_dfa {_ged ,_cee :=_fae ._adf .LookupByReference (*_bcg );if _cee !=nil {_aab .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _cee ;};_age =TraceToDirectObject (_ged );};_ff ,_ddf :=_age .(*PdfObjectDictionary );if !_ddf {return _d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_abe ,_age );};if _abe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _eeg _gfa .FilterDict ;if _dfb :=_bfa (&_eeg ,_ff );_dfb !=nil {return _dfb ;};_gdad ,_ege :=_gfa .NewFilter (_eeg );if _ege !=nil {return _ege ;};_fae ._adg [string (_abe )]=_gdad ;};_fae ._adg ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_gfa .NewIdentity ();_fae ._ca ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fdfg ,_afc :=_dba .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_afc {if _ ,_ffc :=_fae ._adg [string (*_fdfg )];!_ffc {return _d .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fdfg );};_fae ._ca =string (*_fdfg );};_fae ._cbg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gaea ,_ccdg :=_dba .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_ccdg {if _ ,_fac :=_fae ._adg [string (*_gaea )];!_fac {return _d .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gaea );};_fae ._cbg =string (*_gaea );};return nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_dcdf *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dcdf ._cfdc ){return _c .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dcdf ._cfdc [i ]=obj ;return nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_dacg :=PdfObjectInteger (val );return &_dacg };

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_abaae *PdfObjectString ,_gagc bool ){_abaae ,_gagc =TraceToDirectObject (obj ).(*PdfObjectString );return _abaae ,_gagc ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_fca *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fca .DecodeBytes (streamObj .Stream );};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_cbfa *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _baba ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _adeb :=_cbfa .AddPageImage (img ,&_cbfa .DefaultPageSettings );_adeb !=nil {return nil ,_df .Wrap (_adeb ,_baba ,"");};return _cbfa .Encode ();};type objectStreams map[int ]objectStream ;

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_ebgg *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_bfed :=data ;var _fbd error ;for _fbad :=len (_ebgg ._dgab )-1;_fbad >=0;_fbad --{_cadb :=_ebgg ._dgab [_fbad ];_bfed ,_fbd =_cadb .EncodeBytes (_bfed );if _fbd !=nil {return nil ,_fbd ;};};return _bfed ,nil ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_ebbaf *PdfObjectArray ,_ceee bool ){_ebbaf ,_ceee =TraceToDirectObject (obj ).(*PdfObjectArray );return _ebbaf ,_ceee ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_gedd *PdfParser )CheckAccessRights (password []byte )(bool ,_bba .Permissions ,error ){if _gedd ._bfdd ==nil {return true ,_bba .PermOwner ,nil ;};return _gedd ._bfdd .checkAccessRights (password );};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_gafff Version ;_edgge _gf .ReadSeeker ;_fegg *_de .Reader ;_gbbe int64 ;_baae XrefTable ;_gcgc int64 ;_bgfaf *xrefType ;_fadad objectStreams ;_dfca *PdfObjectDictionary ;_bfdd *PdfCrypt ;_bdb bool ;ObjCache objectCache ;_deag map[int64 ]bool ;};var _ggfe =_ga .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_acag *PdfObjectStream ,_gggge bool ){obj =ResolveReference (obj );_acag ,_gggge =obj .(*PdfObjectStream );return _acag ,_gggge ;};func (_cgea *PdfParser )repairLocateXref ()(int64 ,error ){_beef :=int64 (1000);_cgea ._edgge .Seek (-_beef ,_da .SEEK_CUR );_geeae ,_dbcc :=_cgea ._edgge .Seek (0,_da .SEEK_CUR );if _dbcc !=nil {return 0,_dbcc ;};_cdef :=make ([]byte ,_beef );_cgea ._edgge .Read (_cdef );_bgebe :=_bdff .FindAllStringIndex (string (_cdef ),-1);if len (_bgebe )< 1{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_c .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_ddfea :=int64 (_bgebe [len (_bgebe )-1][0]);_gccaf :=_geeae +_ddfea ;return _gccaf ,nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_gdgb *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _eaab []float64 ;for _ ,_cgac :=range _gdgb .Elements (){_dgbd ,_afge :=GetNumberAsFloat (TraceToDirectObject (_cgac ));if _afge !=nil {return nil ,_d .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_eaab =append (_eaab ,_dgbd );};return _eaab ,nil ;};