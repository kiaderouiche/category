//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_fa "bytes";_f "crypto/aes";_e "crypto/cipher";_ea "crypto/md5";_ef "crypto/rand";_cd "crypto/rc4";_dc "crypto/sha256";_gc "crypto/sha512";_dca "encoding/binary";_c "errors";_ce "fmt";_a "github.com/unidoc/unipdf/v3/common";_eb "hash";_g "io";_ff "math";);func (_gag errInvalidField )Error ()string {return _ce .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_gag .Func ,_gag .Field ,_gag .Exp ,_gag .Got );};func _aa (_ga _e .Block )_e .BlockMode {return (*ecbDecrypter )(_gg (_ga ))};func _gg (_dcg _e .Block )*ecb {return &ecb {_ad :_dcg ,_de :_dcg .BlockSize ()}};const (PermOwner =Permissions (_ff .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););

// Allowed checks if a set of permissions can be granted.
func (_ba Permissions )Allowed (p2 Permissions )bool {return _ba &p2 ==p2 };func (_dg *ecbEncrypter )BlockSize ()int {return _dg ._de };type stdHandlerR4 struct{Length int ;ID0 string ;};type ecbDecrypter ecb ;func (_ec *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ec ._de !=0{_a .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_a .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ec ._ad .Decrypt (dst ,src [:_ec ._de ]);src =src [_ec ._de :];dst =dst [_ec ._de :];};};func (_eg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_eg ._de !=0{_a .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_a .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_eg ._ad .Encrypt (dst ,src [:_eg ._de ]);src =src [_eg ._de :];dst =dst [_eg ._de :];};};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_cdc stdHandlerR6 )alg8 (_ggbad *StdEncryptDict ,_dac []byte ,_gad []byte )error {if _dacb :=_dga ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_dac );_dacb !=nil {return _dacb ;};var _daa [16]byte ;if _ ,_ada :=_g .ReadFull (_ef .Reader ,_daa [:]);_ada !=nil {return _ada ;};_ecac :=_daa [0:8];_dgbc :=_daa [8:16];_aeeb :=make ([]byte ,len (_gad )+len (_ecac ));_ega :=copy (_aeeb ,_gad );_ega +=copy (_aeeb [_ega :],_ecac );_db ,_cbbg :=_cdc .alg2b (_ggbad .R ,_aeeb ,_gad ,nil );if _cbbg !=nil {return _cbbg ;};U :=make ([]byte ,len (_db )+len (_ecac )+len (_dgbc ));_ega =copy (U ,_db [:32]);_ega +=copy (U [_ega :],_ecac );_ega +=copy (U [_ega :],_dgbc );_ggbad .U =U ;_ega =len (_gad );_ega +=copy (_aeeb [_ega :],_dgbc );_db ,_cbbg =_cdc .alg2b (_ggbad .R ,_aeeb ,_gad ,nil );if _cbbg !=nil {return _cbbg ;};_adaf ,_cbbg :=_adea (_db [:32]);if _cbbg !=nil {return _cbbg ;};_dad :=make ([]byte ,_f .BlockSize );_cff :=_e .NewCBCEncrypter (_adaf ,_dad );UE :=make ([]byte ,32);_cff .CryptBlocks (UE ,_dac [:32]);_ggbad .UE =UE ;return nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_bb stdHandlerR4 )alg3Key (R int ,_ffb []byte )[]byte {_cg :=_ea .New ();_aaa :=_bb .paddedPass (_ffb );_cg .Write (_aaa );if R >=3{for _ae :=0;_ae < 50;_ae ++{_cbb :=_cg .Sum (nil );_cg =_ea .New ();_cg .Write (_cbb );};};_ge :=_cg .Sum (nil );if R ==2{_ge =_ge [0:5];}else {_ge =_ge [0:_bb .Length /8];};return _ge ;};type ecbEncrypter ecb ;var _ StdHandler =stdHandlerR4 {};func (_bdb stdHandlerR4 )alg3 (R int ,_ebc ,_cf []byte )([]byte ,error ){var _dfg []byte ;if len (_cf )> 0{_dfg =_bdb .alg3Key (R ,_cf );}else {_dfg =_bdb .alg3Key (R ,_ebc );};_adf ,_fe :=_cd .NewCipher (_dfg );if _fe !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cdg :=_bdb .paddedPass (_ebc );_ee :=make ([]byte ,len (_cdg ));_adf .XORKeyStream (_ee ,_cdg );if R >=3{_da :=make ([]byte ,len (_dfg ));for _gf :=0;_gf < 19;_gf ++{for _ecg :=0;_ecg < len (_dfg );_ecg ++{_da [_ecg ]=_dfg [_ecg ]^byte (_gf +1);};_eag ,_ded :=_cd .NewCipher (_da );if _ded !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eag .XORKeyStream (_ee ,_ee );};};return _ee ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ggc *StdEncryptDict ,_ead ,_bdc []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fb *StdEncryptDict ,_ed []byte )([]byte ,Permissions ,error );};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_bd *ecbDecrypter )BlockSize ()int {return _bd ._de };func (_fce stdHandlerR6 )alg2a (_beg *StdEncryptDict ,_aef []byte )([]byte ,Permissions ,error ){if _fef :=_dga ("\u0061\u006c\u00672\u0061","\u004f",48,_beg .O );_fef !=nil {return nil ,0,_fef ;};if _cef :=_dga ("\u0061\u006c\u00672\u0061","\u0055",48,_beg .U );_cef !=nil {return nil ,0,_cef ;};if len (_aef )> 127{_aef =_aef [:127];};_gbe ,_fg :=_fce .alg12 (_beg ,_aef );if _fg !=nil {return nil ,0,_fg ;};var (_cga []byte ;_ggba []byte ;_cba []byte ;);var _gcd Permissions ;if len (_gbe )!=0{_gcd =PermOwner ;_fgd :=make ([]byte ,len (_aef )+8+48);_aeb :=copy (_fgd ,_aef );_aeb +=copy (_fgd [_aeb :],_beg .O [40:48]);_aeb +=copy (_fgd [_aeb :],_beg .U [0:48]);_cga =_fgd ;_ggba =_beg .OE ;_cba =_beg .U [0:48];}else {_gbe ,_fg =_fce .alg11 (_beg ,_aef );if _fg ==nil &&len (_gbe )==0{_gbe ,_fg =_fce .alg11 (_beg ,[]byte (""));};if _fg !=nil {return nil ,0,_fg ;}else if len (_gbe )==0{return nil ,0,nil ;};_gcd =_beg .P ;_bfc :=make ([]byte ,len (_aef )+8);_bfg :=copy (_bfc ,_aef );_bfg +=copy (_bfc [_bfg :],_beg .U [40:48]);_cga =_bfc ;_ggba =_beg .UE ;_cba =nil ;};if _bga :=_dga ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_ggba );_bga !=nil {return nil ,0,_bga ;};_ggba =_ggba [:32];_cfc ,_fg :=_fce .alg2b (_beg .R ,_cga ,_aef ,_cba );if _fg !=nil {return nil ,0,_fg ;};_dcd ,_fg :=_f .NewCipher (_cfc [:32]);if _fg !=nil {return nil ,0,_fg ;};_ceg :=make ([]byte ,_f .BlockSize );_acb :=_e .NewCBCDecrypter (_dcd ,_ceg );_dedd :=make ([]byte ,32);_acb .CryptBlocks (_dedd ,_ggba );if _beg .R ==5{return _dedd ,_gcd ,nil ;};_fg =_fce .alg13 (_beg ,_dedd );if _fg !=nil {return nil ,0,_fg ;};return _dedd ,_gcd ,nil ;};func (_egf stdHandlerR4 )alg6 (_cedd *StdEncryptDict ,_bbe []byte )([]byte ,error ){var (_dde []byte ;_cc error ;);_eaf :=_egf .alg2 (_cedd ,_bbe );if _cedd .R ==2{_dde ,_cc =_egf .alg4 (_eaf ,_bbe );}else if _cedd .R >=3{_dde ,_cc =_egf .alg5 (_eaf ,_bbe );}else {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _cc !=nil {return nil ,_cc ;};_a .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dde ),string (_cedd .U ));_gdd :=_dde ;_fea :=_cedd .U ;if _cedd .R >=3{if len (_gdd )> 16{_gdd =_gdd [0:16];};if len (_fea )> 16{_fea =_fea [0:16];};};if !_fa .Equal (_gdd ,_fea ){return nil ,nil ;};return _eaf ,nil ;};func _eea (_cfa []byte ,_eca int ){_fd :=_eca ;for _fd < len (_cfa ){copy (_cfa [_fd :],_cfa [:_fd ]);_fd *=2;};};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ebgd stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_fde :=make ([]byte ,32);if _ ,_dfgb :=_g .ReadFull (_ef .Reader ,_fde );_dfgb !=nil {return nil ,_dfgb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _ddd :=_ebgd .alg8 (d ,_fde ,upass );_ddd !=nil {return nil ,_ddd ;};if _gae :=_ebgd .alg9 (d ,_fde ,opass );_gae !=nil {return nil ,_gae ;};if d .R ==5{return _fde ,nil ;};if _gdf :=_ebgd .alg10 (d ,_fde );_gdf !=nil {return nil ,_gdf ;};return _fde ,nil ;};func (_bc stdHandlerR4 )alg2 (_ffc *StdEncryptDict ,_gb []byte )[]byte {_a .Log .Trace ("\u0061\u006c\u0067\u0032");_eaa :=_bc .paddedPass (_gb );_dcgg :=_ea .New ();_dcgg .Write (_eaa );_dcgg .Write (_ffc .O );var _gd [4]byte ;_dca .LittleEndian .PutUint32 (_gd [:],uint32 (_ffc .P ));_dcgg .Write (_gd [:]);_a .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gd );_dcgg .Write ([]byte (_bc .ID0 ));_a .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ffc .R ,_ffc .EncryptMetadata );if (_ffc .R >=4)&&!_ffc .EncryptMetadata {_dcgg .Write ([]byte {0xff,0xff,0xff,0xff});};_efd :=_dcgg .Sum (nil );if _ffc .R >=3{_dcgg =_ea .New ();for _gdg :=0;_gdg < 50;_gdg ++{_dcgg .Reset ();_dcgg .Write (_efd [0:_bc .Length /8]);_efd =_dcgg .Sum (nil );};};if _ffc .R >=3{return _efd [0:_bc .Length /8];};return _efd [0:5];};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bee stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bcgc :=_bee .alg3 (d .R ,upass ,opass );if _bcgc !=nil {_a .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bcgc );return nil ,_bcgc ;};d .O =O ;_a .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_ecd :=_bee .alg2 (d ,upass );U ,_bcgc :=_bee .alg5 (_ecd ,upass );if _bcgc !=nil {_a .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bcgc );return nil ,_bcgc ;};d .U =U ;_a .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _ecd ,nil ;};func _gge (_bea ,_bdfa ,_ag []byte )([]byte ,error ){var (_bbc ,_bgc ,_beae _eb .Hash ;);_bbc =_dc .New ();_abf :=make ([]byte ,64);_aeg :=_bbc ;_aeg .Write (_bea );K :=_aeg .Sum (_abf [:0]);_bdcd :=make ([]byte ,64*(127+64+48));_aeec :=func (_daf int )([]byte ,error ){_bad :=len (_bdfa )+len (K )+len (_ag );_gff :=_bdcd [:_bad ];_fgdc :=copy (_gff ,_bdfa );_fgdc +=copy (_gff [_fgdc :],K [:]);_fgdc +=copy (_gff [_fgdc :],_ag );if _fgdc !=_bad {_a .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_c .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_bdcd [:_bad *64];_eea (K1 ,_bad );_eee ,_dgb :=_adea (K [0:16]);if _dgb !=nil {return nil ,_dgb ;};_adg :=_e .NewCBCEncrypter (_eee ,K [16:32]);_adg .CryptBlocks (K1 ,K1 );E :=K1 ;_cbaa :=0;for _ccf :=0;_ccf < 16;_ccf ++{_cbaa +=int (E [_ccf ]%3);};var _cfg _eb .Hash ;switch _cbaa %3{case 0:_cfg =_bbc ;case 1:if _bgc ==nil {_bgc =_gc .New384 ();};_cfg =_bgc ;case 2:if _beae ==nil {_beae =_gc .New ();};_cfg =_beae ;};_cfg .Reset ();_cfg .Write (E );K =_cfg .Sum (_abf [:0]);return E ,nil ;};for _ebd :=0;;{E ,_cab :=_aeec (_ebd );if _cab !=nil {return nil ,_cab ;};_bae :=uint8 (E [len (E )-1]);_ebd ++;if _ebd >=64&&_bae <=uint8 (_ebd -32){break ;};};return K [:32],nil ;};func (_aca stdHandlerR6 )alg12 (_aefc *StdEncryptDict ,_bdbe []byte )([]byte ,error ){if _fbfa :=_dga ("\u0061\u006c\u00671\u0032","\u0055",48,_aefc .U );_fbfa !=nil {return nil ,_fbfa ;};if _agg :=_dga ("\u0061\u006c\u00671\u0032","\u004f",48,_aefc .O );_agg !=nil {return nil ,_agg ;};_gbef :=make ([]byte ,len (_bdbe )+8+48);_cbge :=copy (_gbef ,_bdbe );_cbge +=copy (_gbef [_cbge :],_aefc .O [32:40]);_cbge +=copy (_gbef [_cbge :],_aefc .U [0:48]);_cca ,_geba :=_aca .alg2b (_aefc .R ,_gbef ,_bdbe ,_aefc .U [0:48]);if _geba !=nil {return nil ,_geba ;};_cca =_cca [:32];if !_fa .Equal (_cca ,_aefc .O [:32]){return nil ,nil ;};return _cca ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _af (_ccc []byte )([]byte ,error ){_efeg :=_dc .New ();_efeg .Write (_ccc );return _efeg .Sum (nil ),nil ;};func (_eadc stdHandlerR4 )alg5 (_bbd []byte ,_eba []byte )([]byte ,error ){_ced :=_ea .New ();_ced .Write ([]byte (_bdf ));_ced .Write ([]byte (_eadc .ID0 ));_dcag :=_ced .Sum (nil );_a .Log .Trace ("\u0061\u006c\u0067\u0035");_a .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_bbd );_a .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_eadc .ID0 );if len (_dcag )!=16{return nil ,_c .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_feg ,_bda :=_cd .NewCipher (_bbd );if _bda !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_efe :=make ([]byte ,16);_feg .XORKeyStream (_efe ,_dcag );_fac :=make ([]byte ,len (_bbd ));for _aaf :=0;_aaf < 19;_aaf ++{for _edg :=0;_edg < len (_bbd );_edg ++{_fac [_edg ]=_bbd [_edg ]^byte (_aaf +1);};_feg ,_bda =_cd .NewCipher (_fac );if _bda !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_feg .XORKeyStream (_efe ,_efe );_a .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_aaf ,_fac );_a .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_aaf ,_efe );};_dd :=make ([]byte ,32);for _be :=0;_be < 16;_be ++{_dd [_be ]=_efe [_be ];};_ ,_bda =_ef .Read (_dd [16:32]);if _bda !=nil {return nil ,_c .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _dd ,nil ;};func _dga (_cdf ,_cb string ,_gcc int ,_ab []byte )error {if len (_ab )< _gcc {return errInvalidField {Func :_cdf ,Field :_cb ,Exp :_gcc ,Got :len (_ab )};};return nil ;};

// Authenticate implements StdHandler interface.
func (_ged stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _ged .alg2a (d ,pass );};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;type stdHandlerR6 struct{};func _adea (_ac []byte )(_e .Block ,error ){_bcc ,_dfgd :=_f .NewCipher (_ac );if _dfgd !=nil {_a .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_dfgd );return nil ,_dfgd ;};return _bcc ,nil ;};type ecb struct{_ad _e .Block ;_de int ;};func (_gef stdHandlerR6 )alg13 (_gebd *StdEncryptDict ,_aeeba []byte )error {if _caba :=_dga ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_aeeba );_caba !=nil {return _caba ;};if _eae :=_dga ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gebd .Perms );_eae !=nil {return _eae ;};_afc :=make ([]byte ,16);copy (_afc ,_gebd .Perms [:16]);_ffa ,_fefe :=_f .NewCipher (_aeeba [:32]);if _fefe !=nil {return _fefe ;};_ddg :=_aa (_ffa );_ddg .CryptBlocks (_afc ,_afc );if !_fa .Equal (_afc [9:12],[]byte ("\u0061\u0064\u0062")){return _c .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dfb :=Permissions (_dca .LittleEndian .Uint32 (_afc [0:4]));if _dfb !=_gebd .P {return _c .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_dfbc :=true ;if _afc [8]=='T'{_dfbc =true ;}else if _afc [8]=='F'{_dfbc =false ;}else {return _c .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _dfbc !=_gebd .EncryptMetadata {return _c .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func (_debe stdHandlerR6 )alg2b (R int ,_agc ,_aegf ,_eab []byte )([]byte ,error ){if R ==5{return _af (_agc );};return _gge (_agc ,_aegf ,_eab );};

// Authenticate implements StdHandler interface.
func (_eda stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_a .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_cebd ,_ebg :=_eda .alg7 (d ,pass );if _ebg !=nil {return nil ,0,_ebg ;};if _cebd !=nil {_a .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cebd ,PermOwner ,nil ;};_a .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cebd ,_ebg =_eda .alg6 (d ,pass );if _ebg !=nil {return nil ,0,_ebg ;};if _cebd !=nil {_a .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cebd ,d .P ,nil ;};return nil ,0,nil ;};func (_bcg stdHandlerR4 )alg4 (_faf []byte ,_feb []byte )([]byte ,error ){_ade ,_gfc :=_cd .NewCipher (_faf );if _gfc !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fc :=[]byte (_bdf );_gfcf :=make ([]byte ,len (_fc ));_ade .XORKeyStream (_gfcf ,_fc );return _gfcf ,nil ;};func (_egg stdHandlerR6 )alg11 (_bac *StdEncryptDict ,_abbe []byte )([]byte ,error ){if _cdb :=_dga ("\u0061\u006c\u00671\u0031","\u0055",48,_bac .U );_cdb !=nil {return nil ,_cdb ;};_fgf :=make ([]byte ,len (_abbe )+8);_efg :=copy (_fgf ,_abbe );_efg +=copy (_fgf [_efg :],_bac .U [32:40]);_fbf ,_afe :=_egg .alg2b (_bac .R ,_fgf ,_abbe ,nil );if _afe !=nil {return nil ,_afe ;};_fbf =_fbf [:32];if !_fa .Equal (_fbf ,_bac .U [:32]){return nil ,nil ;};return _fbf ,nil ;};const _bdf ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (stdHandlerR4 )paddedPass (_df []byte )[]byte {_ca :=make ([]byte ,32);_bg :=copy (_ca ,_df );for ;_bg < 32;_bg ++{_ca [_bg ]=_bdf [_bg -len (_df )];};return _ca ;};var _ StdHandler =stdHandlerR6 {};func _ggg (_b _e .Block )_e .BlockMode {return (*ecbEncrypter )(_gg (_b ))};func (_abe stdHandlerR6 )alg10 (_fabb *StdEncryptDict ,_aab []byte )error {if _cfcc :=_dga ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_aab );_cfcc !=nil {return _cfcc ;};_dgae :=uint64 (uint32 (_fabb .P ))|(_ff .MaxUint32 <<32);Perms :=make ([]byte ,16);_dca .LittleEndian .PutUint64 (Perms [:8],_dgae );if _fabb .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_bfb :=_g .ReadFull (_ef .Reader ,Perms [12:16]);_bfb !=nil {return _bfb ;};_cgfc ,_aaac :=_adea (_aab [:32]);if _aaac !=nil {return _aaac ;};_fbg :=_ggg (_cgfc );_fbg .CryptBlocks (Perms ,Perms );_fabb .Perms =Perms [:16];return nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_abb stdHandlerR4 )alg7 (_feac *StdEncryptDict ,_dcb []byte )([]byte ,error ){_aea :=_abb .alg3Key (_feac .R ,_dcb );_bba :=make ([]byte ,len (_feac .O ));if _feac .R ==2{_bf ,_aaff :=_cd .NewCipher (_aea );if _aaff !=nil {return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bf .XORKeyStream (_bba ,_feac .O );}else if _feac .R >=3{_baa :=append ([]byte {},_feac .O ...);for _ceb :=0;_ceb < 20;_ceb ++{_aee :=append ([]byte {},_aea ...);for _ffg :=0;_ffg < len (_aea );_ffg ++{_aee [_ffg ]^=byte (19-_ceb );};_egb ,_eada :=_cd .NewCipher (_aee );if _eada !=nil {return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_egb .XORKeyStream (_bba ,_baa );_baa =append ([]byte {},_bba ...);};}else {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_ggb ,_deb :=_abb .alg6 (_feac ,_bba );if _deb !=nil {return nil ,nil ;};return _ggb ,nil ;};func (_fefd stdHandlerR6 )alg9 (_bfcf *StdEncryptDict ,_gggd []byte ,_ebb []byte )error {if _ddeb :=_dga ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gggd );_ddeb !=nil {return _ddeb ;};if _fab :=_dga ("\u0061\u006c\u0067\u0039","\u0055",48,_bfcf .U );_fab !=nil {return _fab ;};var _eec [16]byte ;if _ ,_fcf :=_g .ReadFull (_ef .Reader ,_eec [:]);_fcf !=nil {return _fcf ;};_ggf :=_eec [0:8];_cbg :=_eec [8:16];_dgf :=_bfcf .U [:48];_ggfe :=make ([]byte ,len (_ebb )+len (_ggf )+len (_dgf ));_geb :=copy (_ggfe ,_ebb );_geb +=copy (_ggfe [_geb :],_ggf );_geb +=copy (_ggfe [_geb :],_dgf );_gfd ,_fcg :=_fefd .alg2b (_bfcf .R ,_ggfe ,_ebb ,_dgf );if _fcg !=nil {return _fcg ;};O :=make ([]byte ,len (_gfd )+len (_ggf )+len (_cbg ));_geb =copy (O ,_gfd [:32]);_geb +=copy (O [_geb :],_ggf );_geb +=copy (O [_geb :],_cbg );_bfcf .O =O ;_geb =len (_ebb );_geb +=copy (_ggfe [_geb :],_cbg );_gfd ,_fcg =_fefd .alg2b (_bfcf .R ,_ggfe ,_ebb ,_dgf );if _fcg !=nil {return _fcg ;};_acg ,_fcg :=_adea (_gfd [:32]);if _fcg !=nil {return _fcg ;};_fcec :=make ([]byte ,_f .BlockSize );_dba :=_e .NewCBCEncrypter (_acg ,_fcec );OE :=make ([]byte ,32);_dba .CryptBlocks (OE ,_gggd [:32]);_bfcf .OE =OE ;return nil ;};