

----QUIT----2020-06-05T20:14:26.40086+02:00 Pharo8.0-SNAPSHOT-32bit-5e328f2.image priorSource: 0!

----QUIT----2020-06-05T20:14:49.029284+02:00 Pharo8.0-SNAPSHOT-32bit-5e328f2.image priorSource: 0!

----SNAPSHOT----2020-07-20T13:54:46.020639+02:00 PharoLauncher.image priorSource: 99!
!BaselineOfPharoLauncher methodsFor: 'baselines'!
baseline: spec
	<baseline>

	spec for: #'common' do: [
		spec 
			baseline: #Ston
				with: [ spec repository: 'github://svenvc/ston:master/repository' ];
			baseline: #Spec2
				with: [ spec repository: 'github://pharo-spec/Spec:spec-pharo-launcher/src' ];
			baseline: #OSSubprocess
				with: [ spec repository: 'github://pharo-contributions/OSSubprocess:v1.2' ];
			baseline: #OSWinSubprocess
				with: [ spec repository: 'github://pharo-contributions/OSWinSubprocess:v1' ];
			baseline: #XMLParser
				with: [ spec 
							repository: 'github://pharo-contributions/XML-XMLParser:3.5.x';
							loads: #('Core') ].
		spec
			package: #'PharoLauncher-80Compatibility'; 
			package: #'PharoLauncher-Pharo9ToRemove-FileLocator'; 
			package: #'PharoLauncher-80Compatibility'; 
			package: #'PharoLauncher-Core' with: [
				spec requires: #(#'XMLParser' #'OSSubprocess' #'OSWinSubprocess' #'Ston' #'PharoLauncher-80Compatibility' #'PharoLauncher-Pharo9ToRemove-FileLocator'). ];
			package: #'PharoLauncher-Spec2' with: [ 
				spec requires: #(#'PharoLauncher-Core' #Spec2). ];

			package: #'PharoLauncher-Tests-Core' with: [
				spec requires: #(#'PharoLauncher-Core' ). ];
			package: #'PharoLauncher-Tests-Commands' with: [
				spec requires: #(#'PharoLauncher-Spec2' ). ];
			package: #'PharoLauncher-Tests-SpecUI' with: [
				spec requires: #(#'PharoLauncher-Core' #'PharoLauncher-Spec2'). ];
			package: #'PharoLauncher-Tests-Download' with: [
				spec requires: #(#'PharoLauncher-Tests-Core' ). ];
			package: #'PharoLauncher-Tests-Functional' with: [
				spec requires: #(#'PharoLauncher-Core' #'PharoLauncher-Tests-Download'). ].
		spec 
			group: 'Default' with: #(#'PharoLauncher-Tests-Core' #'PharoLauncher-Tests-Download' #'PharoLauncher-Core' #'PharoLauncher-Spec2' #'PharoLauncher-Tests-SpecUI' #'PharoLauncher-Tests-Functional'). ].! !

"BaselineOfPharoLauncher"!
!BaselineOfSpec2 methodsFor: 'baseline' prior: 18190284!
baseline: spec
	<baseline>
	
	spec for: #common do: [ 
		self commander2: spec.
		self complishon: spec.
		
		spec
			package: 'Spec2-ObservableSlot';
			package: 'Spec2-Core' with: [ 
				spec requires: #(
					'Spec2-ObservableSlot'
					'Spec2-Layout' 
					'Spec2-Transmission' 
					'Spec2-Commands') ];
			package: 'Spec2-CommandLine' with: [ spec requires: #('Spec2-Core') ];
			package: 'Spec2-Commands' with: [ spec requires: #('Commander2') ];
			package: 'Spec2-Layout' with: [ spec requires: #('Spec2-ObservableSlot') ];
			package: 'Spec2-Transmission';
			package: 'Spec2-Code' with: [ spec requires: #('HeuristicCompletion') ];
			package: 'Spec2-Code-Tests' with: [ spec requires: #('Spec2-Code') ];
			package: 'Spec2-Adapters-Morphic' with: [ spec requires: #( 'Spec2-Core' ) ];
			package: 'Spec2-Code-Morphic' with: [ 
				spec requires: #(
					'Spec2-Code' 
					'Spec2-Adapters-Morphic') ];
			package: 'Spec2-Adapters-Stub' with: [ spec requires: #('Spec2-Core') ];
			package: 'Spec2-Interactions' with: [ spec requires: #('Spec2-Core') ];
			package: 'Spec2-Commander2' with: [ 
				spec requires: #(
					'Spec2-Core' 
					'Spec2-Interactions' 
					'Commander2') ];
			package: 'Spec2-Commander2-Tests' with: [ spec requires: #('Spec2-Commander2') ];
			package: 'Spec2-Commander2-ContactBook' with: [ spec requires: #('Spec2-Commander2') ];
			package: 'Spec2-Commander2-ContactBook-Extensions' with: [ spec requires: #('Spec2-Commander2-ContactBook') ];
			package: 'Spec2-Tests' with: [ spec requires: #('Spec2-Examples') ];
			package: 'Spec2-Morphic-Backend-Tests' with: [ spec requires: #('Spec2-Adapters-Morphic') ];
			package: 'Spec2-Backend-Tests' with: [ spec requires: #('Spec2-Adapters-Morphic') ];
			package: 'Spec2-Adapters-Morphic-Tests' with: [ spec requires: #('Spec2-Tests' 'Spec2-Backend-Tests') ];
			package: 'Spec2-Tools' with: [ spec requires: #('Spec2-Core') ];
			package: 'Spec2-Tools-Tests' with: [ spec requires: #('Spec2-Tests' 'Spec2-Tools') ];
			package: 'Spec2-Morphic' with: [ spec requires: #('Spec2-Adapters-Morphic') ];
			package: 'Spec2-Morphic-Tests' with: [ spec requires: #('Spec2-Morphic') ];
			package: 'Spec2-Examples' with: [ spec requires: #('Spec2-Morphic') ].
			"This will extend the help tool, which in boostrap will be loaded a lot later."
			"package: 'Spec2-Help';"		
		 ].
	
	spec group: 'Core' with: #(
		'Spec2-ObservableSlot' 
		'Spec2-Layout' 
		'Spec2-Transmission'
		'Spec2-Commands' 
		'Spec2-Core' 
		'Spec2-CommandLine' 
		'Spec2-Code' 
		'Spec2-Adapters-Stub' 
		'Spec2-Interactions' 
		'Spec2-Commander2' ).
	spec group: 'Morphic' with: #(
		'Core' 
		'Spec2-Morphic'
		'Spec2-Adapters-Morphic' 
		'Spec2-Code-Morphic' ).
	spec group: 'MorphicSupport' with: #( 
		'Core'
		'Morphic'
		'Spec2-Examples'
		'Spec2-Commander2-ContactBook' 
		'Spec2-Commander2-ContactBook-Extensions'  
		'Spec2-Tools' ).
	spec group: 'Tests' with: #( 
		'Core' 
		'Spec2-Tests' 
		'Spec2-Commander2-Tests').
	spec group: 'MorphicSupportTests' with: #( 
		'MorphicSupport' 
		'Spec2-Code-Tests'  
		'Spec2-Tools-Tests' 
		'Spec2-Adapters-Morphic-Tests' 
		'Spec2-Morphic-Tests' 
		'Spec2-Morphic-Backend-Tests' 
		'Spec2-Backend-Tests' ).
	spec group: 'default' with: #(
		'Core'
		'Morphic' 
		'MorphicSupport'
		'Spec2-Tests'
		'Spec2-Morphic-Tests'
		'MorphicSupportTests' ).

	spec for: #'pharo8.x' do: [
		spec
			package: 'Spec2-Tools' with: [ spec requires: #('Spec2-Core') ];
			package: 'Spec2-Tools-Tests' with: [ spec requires: #('Spec2-Tests' 'Spec2-Tools') ];
			package: 'Spec2-Examples' with: [ spec requires: #('Spec2-Tools') ] ].! !
!BaselineOfSpec2 methodsFor: 'dependencies' prior: 18190108!
commander2: spec
	spec
		baseline: 'Commander2'
		with: [ spec repository: 'github://pharo-spec/Commander2:v2.1.x/src'; loads: #('core' 'ui') ]! !
!BaselineOfSpec2 methodsFor: 'dependencies'!
complishon: spec
	
	spec
		baseline: 'HeuristicCompletion'
		with: [ spec repository: 'github://guillep/complishon' ]! !
!BaselineOfSpec2 methodsFor: 'acccessing' prior: 18189221!
project
	"Atomic loading is needed for Spec because we are moving classes of package and it breaks their subclasses. 
	
	Here is an explanation I wrote on Discord:
	
«The problem with Obsolete classes is that classes with subclasses were moved from Spec-Core to Spec-Deprecated80. 

When updating Spec it will first load Spec-Core. This will delete the class and its subclasses will be migrated to an obsolete superclass. 
Then Spec-Deprecated80 is loaded but it does not migrate the subclasses of the obsolete class to it. (Apparently there is an intern working on that Pablo told me).»

We need to use atomic loading only during update of existing Spec upgrade"

	^self class environment at: #SpPresenter 
		ifPresent: [
			super project
				loadType: #atomic;
				yourself ] 
		ifAbsent: [ 		
			super project
				loadType: #linear;
				yourself  ]

	 ! !

BaselineOfSpec2 removeSelector: #parametrizedTests:!

"BaselineOfSpec2"!
!BaselineOfXMLParser commentStamp: '' prior: 0!
Baseline for XML Parser (https://github.com/pharo-contributions/XML-XMLParser)!
!BaselineOfXMLParser methodsFor: 'baselines'!
baselineOf: spec

	<baseline>
	spec
		for: #common
		do: [
			
			self 
				bitmapCharacterSetOn: spec;
				orderPreservingDictionaryOn: spec;
				xmlWriterOn: spec.		
			
			"Packages"
			spec 
				package: 'XML-Parser' with: [ spec requires: #('OrderPreservingDictionary' 'BitmapCharacterSet') ];
				package: 'XML-Parser-Tests' with: [ spec requires: #('XML-Parser' 'OrderPreservingDictionary Tests' 'BitmapCharacterSet Tests') ];
				package: 'XML-Parser-Tests-Conformance' with: [ spec requires: #('XML-Parser' 'XMLWriter Tests' 'XML-Parser-Tests') ];
				package: 'XML-Parser-GTExtensions' with: [ spec requires: #('XML-Parser') ].
			
			"Groups"
			spec
				group: 'Core' with: #('XML-Parser');
				group: 'Tools' with: #(OrderPreservingDictionary Tools 'XMLWriter Tools' 'XML-Parser-GTExtensions'); 
				group: 'Tests' with: #('XML-Parser-Tests' 'XML-Parser-Tests-Conformance');	
				group: 'all' with: #('Core' 'Tools' 'Tests');
				group: 'default' with: #('all')	
	]! !
!BaselineOfXMLParser methodsFor: 'prerequisites '!
bitmapCharacterSetOn: spec
			
	spec
		baseline: 'BitmapCharacterSet'
      with: [ 
			spec
				loads: #('Core');
				repository: 'github://pharo-contributions/BitmapCharacterSet:1.2.x/src' ]. 
				
	spec project: 'BitmapCharacterSet Tests' copyFrom: 'BitmapCharacterSet' with: [ spec loads: #('Tests') ] 			
				
			! !
!BaselineOfXMLParser methodsFor: 'prerequisites '!
orderPreservingDictionaryOn: spec

	spec
		baseline: 'OrderPreservingDictionary'
      with: [ 
			spec
				loads: #('Core');
				repository: 'github://pharo-contributions/OrderPreservingDictionary:1.5.x/src' ]. 
				
	spec 
		project: 'OrderPreservingDictionary Tests' copyFrom: 'OrderPreservingDictionary' with: [ spec loads: #('Tests') ];			
		project: 'OrderPreservingDictionary Tools' copyFrom: 'OrderPreservingDictionary' with: [ spec loads: #('Tools') ]! !
!BaselineOfXMLParser methodsFor: 'prerequisites '!
xmlWriterOn: spec

	spec
		baseline: 'XMLWriter'
      with: [ 
			spec
				loads: #('Core');
				repository: 'github://pharo-contributions/XML-XMLWriter:2.9.x/src' ]. 
				
	spec 
		project: 'XMLWriter Tests' copyFrom: 'XMLWriter' with: [ spec loads: #('Tests') ]; 	
		project: 'XMLWriter Tools' copyFrom: 'XMLWriter' with: [ spec loads: #('Tools') ] ! !

"BaselineOfXMLParser"!
!BaselineOfOSWinSubprocess methodsFor: 'baselines'!
baseline: spec
	<baseline>
	spec
		for: #common
		do: [ 	spec
				package: #OSWinSubprocess;
				package: #'OSWinSubprocess-Tests' with: [ spec requires: #OSWinSubprocess ] ].! !

"BaselineOfOSWinSubprocess"!
!BaselineOfSton commentStamp: 'SvenVanCaekenberghe 10/8/2018 15:45' prior: 0!
I am BaselineOfSton, I load STON (Smalltalk Object Notation).
I am a BaselineOf.!
!BaselineOfSton methodsFor: 'baselines' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
baseline: spec
	<baseline>
	spec
		for: #common
		do: [ spec blessing: #baseline.
			spec
				package: 'STON-Core';
				package: 'STON-Tests';
				package: 'STON-Text support';
				group: 'Core' with: #('STON-Core');
				group: 'default' with: #('STON-Core' 'STON-Text support' 'STON-Tests') ]! !

"BaselineOfSton"!
!BaselineOfOSSubprocess commentStamp: 'MarianoMartinezPeck 1/13/2016 11:20' prior: 0!
I am a baseline of OSSubprocess. 

OSSubprocess is a software project that allows the user to spawn Operatying System processes from within Pharo language. The main usage of forking external OS processes is to be able to execute OS commands (.e.g cat, ls, ps, cp, etc) as well as arbitrary shell scripts (.e.g /etc/myShellScript.sh) from Pharo.

An important part of OSSubprocess is how to manage standard streams (stdin, stdout and stderr) and how to provide an API for reading and writing from them at the language level.

For more details see: https://github.com/marianopeck/OSSubprocess!
!BaselineOfOSSubprocess methodsFor: 'baseline' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
baseline: spec
	<baseline>
	spec
		for: #pharo
		do: [				
			spec
				package: 'OSSubprocess' with: [ spec requires: 'FFICHeaderExtractor' ];
				package: 'OSSubprocess-Tests-Unit' with: [ spec requires: #('OSSubprocess' 'Unicode') ];
				package: 'OSSubprocess-Tests-Stress' with: [ spec requires: 'OSSubprocess-Tests-Unit' ].
			
			spec baseline: 'FFICHeaderExtractor' with: [
    			spec repository: 'github://marianopeck/FFICHeaderExtractor:master/repository' ].
		
			spec project: 'Unicode' with: [
				spec
					className: #ConfigurationOfUnicode;
					versionString: #'stable';
					repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/' ].
			
			spec
				group: 'Core' with: #( 'OSSubprocess' );
				group: 'Tests' with: #( 'OSSubprocess-Tests-Unit' 'OSSubprocess-Tests-Stress' ).
		]
! !

"BaselineOfOSSubprocess"!
!BaselineOfHeuristicCompletion methodsFor: 'baselines'!
baseline: spec
	<baseline>
	
	spec for: #common do: [ 
		spec package: 'HeuristicCompletion-Model'.
		spec package: 'HeuristicCompletion-Morphic' with: [ 
			spec requires: 'HeuristicCompletion-Model' ].
		spec package: 'HeuristicCompletion-Tests' with: [ 
			spec requires: 'HeuristicCompletion-Model' ] ]! !

"BaselineOfHeuristicCompletion"!
!ConfigurationOfUnicode commentStamp: 'SvenVanCaekenberghe 2/17/2016 10:06' prior: 0!
The Pharo Unicode project.

	ConfigurationOfUnicode load.
	ConfigurationOfUnicode loadDevelopment.
	ConfigurationOfUnicode project development load: 'Collate'

More info can be found in the following article

	An Implementation of Unicode Normalization
	Streaming NFC, NFD, NFKC & NFKD, normalization QC and normalization preserving concatenation.
	Sven Van Caekenberghe, Henrik Sperre Johansen
	https://medium.com/concerning-pharo/an-implementation-of-unicode-normalization-7c6719068f43#.qmy18gky0
	
Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!ConfigurationOfUnicode class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
DevelopmentSupport

"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."
	<apiDocumentation>
! !
!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
baseConfigurationClassIfAbsent: aBlock

	^Smalltalk
		at: #MetacelloBaseConfiguration
		ifAbsent: [ 
			self ensureMetacelloBaseConfiguration.
			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].
! !
!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:17'!
catalogDescription
	^ 'The Pharo Unicode project'! !
!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:17'!
catalogKeywords
	^ #(uncode string character)! !
!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
ensureMetacello

	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !
!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
ensureMetacelloBaseConfiguration

	Smalltalk
		at: #MetacelloBaseConfiguration
		ifAbsent: [ 
			| repository version |
			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.
			repository
				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'
				do: [ :reader | 
					version := reader version.
					version load.
					version workingCopy repositoryGroup addRepository: repository ] ]! !
!ConfigurationOfUnicode class methodsFor: 'metacello tool support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
isMetacelloConfig
	"Answer true and the Metacello tools will operate on you"
	
	^true! !
!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:19'!
license
	^ 'The MIT License (MIT)
Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'! !
!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
load
	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."

	"self load"

	<apiDocumentation>
	^(self project version: #stable) load! !
!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
loadBleedingEdge
	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."

	"self loadBleedingEdge"

	<apiDocumentation>
	^(self project version: #bleedingEdge) load! !
!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
loadDevelopment
	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."

	"self loadDevelopment"

	<apiDocumentation>
	^(self project version: #development) load! !
!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
project

	^self new project! !
!ConfigurationOfUnicode class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
validate
	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 
	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 
	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.
	Warnings identify specification issues that are technically correct, but are worth take a look at."

	"self validate"

	<apiDocumentation>
	self ensureMetacello.
	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !
!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 14:23'!
baseline1: spec
	<version: '1-baseline'>
	
	spec for: #common do: [
		spec 
			blessing: #baseline;
			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';
			package: 'Unicode-Character-Data';
			package: 'Unicode-Tests-Character-Data' with: [ spec requires: 'Unicode-Character-Data' ];
			group: 'default' with: #('Unicode-Character-Data' 'Unicode-Tests-Character-Data');
			group: 'Core' with: #('Unicode-Character-Data');
			group: 'Tests' with: #('Unicode-Tests-Character-Data') ]! !
!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 15:32'!
baseline2: spec
	<version: '2-baseline'>
	
	spec for: #common do: [
		spec 
			blessing: #baseline;
			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';

			package: 'Unicode-Character-Data';
			package: 'Unicode-Stream-Support';
			package: 'Unicode-Casing' with: [ 
				spec requires: #('Unicode-Character-Data'  'Unicode-Stream-Support') ];
			package: 'Unicode-Normalization' with: [ 
				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];

			package: 'Unicode-Tests-Character-Data' with: [ 
				spec requires: 'Unicode-Character-Data' ];
			package: 'Unicode-Tests-Casing' with: [ 
				spec requires: 'Unicode-Casing' ];
			package: 'Unicode-Tests-Normalization' with: [ 
				spec requires: 'Unicode-Normalization' ];

			group: 'default' with: #(
				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization'
				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');
			group: 'Core' with: #(
				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');
			group: 'Tests' with: #(
				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization') ]! !
!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 19:21'!
baseline3: spec
	<version: '3-baseline'>
	
	spec for: #common do: [
		spec 
			blessing: #baseline;
			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';

			package: 'Unicode-Character-Data';
			package: 'Unicode-Stream-Support';
			package: 'Unicode-Casing' with: [ 
				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];
			package: 'Unicode-Normalization' with: [ 
				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];

			package: 'Unicode-Tests-Character-Data' with: [ 
				spec requires: 'Unicode-Character-Data' ];
			package: 'Unicode-Tests-Casing' with: [ 
				spec requires: 'Unicode-Casing' ];
			package: 'Unicode-Tests-Normalization' with: [ 
				spec requires: 'Unicode-Normalization' ];

			group: 'default' with: #('Core' 'Tests');
			
			group: 'Core' with: #(
				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');
			group: 'Tests' with: #(
				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization') ]! !
!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 2/15/2016 21:14'!
baseline4: spec
	<version: '4-baseline'>
	
	spec for: #common do: [
		spec 
			blessing: #baseline;
			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';

			package: 'Unicode-Character-Data';
			package: 'Unicode-Stream-Support';
			package: 'Unicode-Casing' with: [ 
				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];
			package: 'Unicode-Normalization' with: [ 
				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];
			package: 'Unicode-Collate' with: [ 
				spec requires: #('Unicode-Normalization') ];

			package: 'Unicode-Tests-Character-Data' with: [ 
				spec requires: 'Unicode-Character-Data' ];
			package: 'Unicode-Tests-Casing' with: [ 
				spec requires: 'Unicode-Casing' ];
			package: 'Unicode-Tests-Normalization' with: [ 
				spec requires: 'Unicode-Normalization' ];
			package: 'Unicode-Tests-Collate' with: [ 
				spec requires: 'Unicode-Collate' ];

			group: 'default' with: #('Core' 'Tests');
			
			group: 'Core' with: #(
				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');
			group: 'Tests' with: #(
				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');
			group: 'Collate' with: #(
				'Unicode-Collate' 'Unicode-Tests-Collate') ]! !
!ConfigurationOfUnicode methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:34'!
development: spec
	<symbolicVersion: #'development'>
	
	spec for: #common version: '8'! !
!ConfigurationOfUnicode methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!
project

	^ project ifNil: [ | constructor |
		"Bootstrap Metacello if it is not already loaded"
		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.
		"Construct Metacello project"
		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
		project := constructor project.
		project loadType: #linear. "change to #atomic if desired"
		project ]! !
!ConfigurationOfUnicode methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:34'!
stable: spec
	<symbolicVersion: #'stable'>
	
	spec for: #common version: '8'! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 14:24'!
version1: spec
	<version: '1' imports: #('1-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1' ]! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:59'!
version2: spec
	<version: '2' imports: #('2-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekebenberghe.3';
			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';
			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.1';

			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:59'!
version3: spec
	<version: '3' imports: #('2-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekebenberghe.4';
			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';
			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.2';

			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:26'!
version4: spec
	<version: '4' imports: #('3-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.5';
			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';
			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.2';

			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/29/2016 11:23'!
version5: spec
	<version: '5' imports: #('3-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';
			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';
			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';
			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.3';

			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2' ]! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/15/2016 21:15'!
version6: spec
	<version: '6' imports: #('4-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';
			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';
			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';
			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.4';
			package: 'Unicode-Collate' with: 'Unicode-Collate-SvenVanCaekenberghe.2';

			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';
			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'HenrikSperreJohansen 2/16/2016 00:29'!
version7: spec
	<version: '7' imports: #('4-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';
			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';
			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';
			package: 'Unicode-Normalization' with: 'Unicode-Normalization-HenrikSperreJohansen.5';
			package: 'Unicode-Collate' with: 'Unicode-Collate-SvenVanCaekenberghe.2';

			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';
			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !
!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:33'!
version8: spec
	<version: '8' imports: #('4-baseline')>
	
	spec for: #common do: [
		spec
			blessing: #release;
			
			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.8';
			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';
			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';
			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.6';
			package: 'Unicode-Collate' with: 'Unicode-Collate-HenrikSperreJohansen.5';

			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';
			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';
			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !

"ConfigurationOfUnicode"!
!BaselineOfFFICHeaderExtractor commentStamp: 'MarianoMartinezPeck 1/27/2016 10:38' prior: 0!
For more details see https://github.com/marianopeck/FFICHeaderExtractor

In short, FFICHeaderExtractor is a program to extract information (e.g. constants) from C headers and integrate that into Smalltalk SharedPools.

When we use FFI to call a certain library, it's quite common that we need to pass specific constants (for example, SIGKILL to kill()). These constants are defined in C header files and can even change their values in different paltforms. Sometimes, these constants also are defined by the C preprocessor and so there is not way to get those values from FFI. If you don't have the value of those constants, you cannot make the FFI call. In other words, if I cannot know that the value of SIGKILL is 9, how do I call kill() from FFI?

This tool allows the developers of a FFI tool (any project which uses FFI to call a certain library), to automatically create a C program that writes all the user-defined constants values, compile it, run it, and create a Smalltalk init method which initializes the shared pool constants based on C program output. This autogenerated init method can then be distributed with the rest of the FFI tool. FFICHeaderExtractor will also automatically initialize (searching and executing the previously autogenerated init method for the current platform) a SharedPool upon system startup.!
!BaselineOfFFICHeaderExtractor methodsFor: 'baseline' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
baseline: spec
	<baseline>
	spec
		for: #common
		do: [ 
			spec
				package: 'FFICHeaderExtractor';
				package: 'FFICHeaderExtractor-Tests' with: [ spec requires: 'FFICHeaderExtractor' ];
				package: 'FFICHeaderExtractor-LibC' with: [ spec requires: 'FFICHeaderExtractor' ].
				]! !

"BaselineOfFFICHeaderExtractor"!
!BaselineOfBitmapCharacterSet commentStamp: '' prior: 0!
A baseline for https://github.com/pharo-contributions/BitmapCharacterSet!
!BaselineOfBitmapCharacterSet methodsFor: 'baselines'!
baseline: spec
	<baseline>
	
	spec for: #common do: [ 
		"Packages and Dependencies"
		spec 
			package: 'Collections-BitmapCharacterSet';
			package: 'Collections-BitmapCharacterSet-Tests' with: [ spec requires: 'Collections-BitmapCharacterSet' ].
			
		"Groups"	
		spec				
				group: 'Core' with: #('Collections-BitmapCharacterSet');
				group: 'Tests' with: #('Collections-BitmapCharacterSet-Tests');
				group: 'all' with: #('Core' 'Tests');
				group: 'default' with: #('all')	
	]! !

"BaselineOfBitmapCharacterSet"!
!BaselineOfOrderPreservingDictionary commentStamp: '' prior: 0!
A baseline for an order preserving dictionary (https://github.com/pharo-contributions/OrderPreservingDictionary)!
!BaselineOfOrderPreservingDictionary methodsFor: 'baselines'!
baseline: spec
	<baseline>
	spec
		for: #common
		do: [ 
			"Packages"
			spec package: 'Collections-OrderPreservingDictionary';
				  package: 'Collections-OrderPreservingDictionary-Tests' with: [ spec requires: #('Collections-OrderPreservingDictionary') ];
				  package: 'Collections-OrderPreservingDictionary-GTExtensions' with: [ spec requires: #('Collections-OrderPreservingDictionary') ].
				
			"Groups"	
			spec
				group: 'Core' with: #('Collections-OrderPreservingDictionary');
				group: 'Tests' with: #('Collections-OrderPreservingDictionary-Tests');
				group: 'Tools' with: #('Collections-OrderPreservingDictionary-GTExtensions');
				group: 'all' with: #('Core' 'Tools' 'Tests');
				group: 'default' with: #('all') ].

	spec
		for: #gemstone
		do: [ 
			spec package: 'Collections-OrderPreservingDictionary' with: [ spec includes: 'Collections-OrderPreservingDictionary-GemstoneCompatibility' ].
			spec package: 'Collections-OrderPreservingDictionary-GemstoneCompatibility' with: [ spec requires: 'Collections-OrderPreservingDictionary' ]].! !
!BaselineOfOrderPreservingDictionary methodsFor: 'accessing'!
customProjectAttributes
	"Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.
	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttributes "

	(Smalltalk globals includesKey: #GTInspector)
		ifTrue: [ ^ #(gt) ]
		ifFalse: [ ^ #() ]! !

"BaselineOfOrderPreservingDictionary"!
!STONZnUrl commentStamp: 'SvenVanCaekenberghe 1/14/2020 13:07' prior: 0!
I am STONZnUrl, I am an implementation artifact to help reading objects with class tag equal to my #stonName.

I am a ZnUrl.!
!SortedCollection class methodsFor: '*STON-Core' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
fromSton: stonReader
	"Overwritten to get back the standard object behavior"
	
	^ self new
		fromSton: stonReader;
		yourself! !
!SortedCollection methodsFor: '*STON-Core' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
fromSton: stonReader
	"Overwritten to get back the standard object behavior"
	
	stonReader parseNamedInstVarsFor: self! !
!SortedCollection methodsFor: '*STON-Core' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
stonOn: stonWriter
	"Overwritten to get back the standard object behavior"

	stonWriter writeObject: self! !
!DefaultSortFunction class methodsFor: '*STON-Core' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
fromSton: stonReader
	"Overwritten to always return the default"
	
	self assert: stonReader parseMap isEmpty.
	^ SortFunction default! !
!STONZnUrl class methodsFor: '*ston-core' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
fromSton: stonReader
	^ ZnUrl fromString: stonReader parseListSingleton ! !
!STONZnUrl class methodsFor: '*ston-core' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
stonName
	^ #URL! !
!ZnUrl methodsFor: '*ston-core' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 88239837!
stonOn: stonWriter
	stonWriter 
		writeObject: self 
		named: STONZnUrl stonName 
		listSingleton: self asString ! !

FileReference removeSelector: #stonContainSubObjects!

ZnUrl removeSelector: #stonContainSubObjects!

ZnUrl class removeSelector: #stonName!

ZnUrl class removeSelector: #fromSton:!

ZnMimeType removeSelector: #stonContainSubObjects!

"STON-Core"!
!STONAlternativeRepresentationTestObject commentStamp: 'SvenVanCaekenberghe 6/10/2020 18:36' prior: 0!
I am STONAlternativeRepresentationTestObject.

My properties are
 - id <Integer>
 - time <DateAndTime> in the local time zone
 - gridReference <Point <Float>@<Float>> in kilometer

My STON representation has the properties
 - id <Integer>
 - time <DateAndTime> in UTC
 - grid_reference <Point <Float>@<Float>> in miles

Note the different key, gridReference vs. grid_reference

Upon serialization, the conversions local time to UTC and kilometer to mile is performed.
Upon materialization, the convertions UTC to local tie and miles to kilometers are performed.
 !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61189849!
testAssociation
	self assert: (self materialize: '''foo'':1') equals: ('foo' -> 1).
	self assert: (self materialize: '#bar:2') equals: (#bar -> 2).
	self assert: (self materialize: '''foo bar'':#ok') equals: ('foo bar' -> #ok).
	self assert: (self materialize: '123:456') equals: (123 -> 456).
	
	self assert: (self materialize: '''foo'' : 1') equals: ('foo' -> 1).
	self assert: (self materialize: '#bar : 2') equals: (#bar -> 2).
	self assert: (self materialize: '''foo bar'' : #ok') equals: ('foo bar' -> #ok).
	self assert: (self materialize: '123 : -456') equals: (123 -> -456).
	
	self assert: (self materialize: '#foo : 1 : 2') equals: (#foo -> (1 -> 2))
! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61190832!
testByteArray
	self assert: (self materialize: 'ByteArray[''010203'']') equals: #(1 2 3) asByteArray
! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61187963!
testCharacter
	self assert: (self materialize: 'Character[''A'']') identicalTo: $A.! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
testColorBackwardsCompatibility
	"ensure the older Color representation still works"
	self 
		assert: (self materialize: 'Color{#rgb:1072693248}')
		equals: Color red.
	self 
		assert: (self materialize: 'Color{#rgb:1072693248}')
		equals: (self materialize: 'Color[#red]').! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61185844!
testDateAndTime
	| dateAndTime |
	dateAndTime := DateAndTime year: 2012 month: 1 day: 1 hour: 6 minute: 30 second: 15 offset: 1 hour.
	self assert: (self materialize: 'DateAndTime[''2012-01-01T06:30:15+01:00'']') equals: dateAndTime! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61190542!
testDictionary
	| collection |
	collection := STON mapClass new at: 1 put: 1; at: 2 put: 2; yourself.
	self assert: (self materialize: '{1:1,2:2}') equals: collection.
	self assert: (self materialize: '{}') equals: STON mapClass new.
! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61184919!
testDictionaryWithComplexKeys
	| collection reader |
	collection := STON mapClass new at: true put: 1; at: #(foo) put: 2; yourself.
	"allowing complex map keys used to be optional, now it is always the default"
	reader := STONReader on: '{true:1,[#foo]:2}' readStream.
	self assert: reader next equals: collection! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
testFileReferenceBackwardsCompatibility
	"we now have FILE, make sure that we support the old generic format"
	| fs |
	fs := STON toString: FileSystem disk.
	self 
		assert: (self materialize: 'FileReference{#path:RelativePath[],#filesystem:', fs, '}')
		equals: FileLocator workingDirectory.
	self 
		assert: (self materialize: 'FileReference{#path:RelativePath[],#filesystem:', fs, '}')
		equals: (self materialize: 'FILE[''.'']').
	self 
		assert: (self materialize: 'FileReference{#path:AbsolutePath[''tmp'',''foo.txt''],#filesystem:', fs, '}')
		equals: '/tmp/foo.txt' asFileReference.
	self 
		assert: (self materialize: 'FileReference{#path:AbsolutePath[''tmp'',''foo.txt''],#filesystem:', fs, '}')
		equals: (self materialize: 'FILE[''/tmp/foo.txt'']').! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61172625!
testIdentityDictionary
	| collection |
	collection := IdentityDictionary new at: 1 put: 1; at: 2 put: 2; yourself.
	self assert: (self materialize: 'IdentityDictionary{1:1,2:2}') equals: collection.
	self assert: (self materialize: 'IdentityDictionary{}') equals: IdentityDictionary new.
! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61185290!
testJsonString
	"Allow double quotes for backwards JSON compatibility"
	
	| string |
	self assert: (self materialize: '"foo"') equals: 'foo'.
	self assert: (self materialize: '"FOO"') equals: 'FOO'.
	self assert: (self materialize: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'élève en Français'.
	string := String withAll: { 
		$". $'. $\. Character tab. Character cr. Character lf.  Character newPage. Character backspace }.
	self assert: (self materialize: '"\"\''\\\t\r\n\f\b"') equals: string.
! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61176188!
testMap
	self assert: (self materialize: '{#foo:1}') equals: (STON mapClass new at: #foo put: 1; yourself).
	self assert: (self materialize: '{}') equals: STON mapClass new! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61176752!
testObject
	self assert: (self materialize: 'Point[1,2]') equals: (1@2).
	self assert: (self materialize: 'Point[1.5,-0.5]') equals: (1.5 @ -0.5).! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61188324!
testOrderedCollection
	| collection |
	collection := OrderedCollection with: 1 with: 2 with: 3.
	self assert: (self materialize: 'OrderedCollection[1,2,3]') equals: collection.
	self assert: (self materialize: 'OrderedCollection[]') equals: OrderedCollection new.! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61180125!
testPoint
	self assert: (self materialize: 'Point[1,2]') equals: (1@2)! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61173557!
testReferenceCycle
	| array |
	array := (self materialize: '[1,@1]').
	self assert: array class equals: STON listClass.
	self assert: array size equals: 2.
	self assert: array first equals: 1.
	self assert: array second identicalTo: array! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61183976!
testReferenceSharing
	| one array |
	one := { #one }.
	array := (self materialize: '[[#one],@2,@2]').
	self assert: array = (STON listClass with: one with: one with: one).
	self assert: array first identicalTo: array second.
	self assert: array first identicalTo: array third! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61187455!
testString
	| string |
	self assert: (self materialize: '''foo''') equals: 'foo'.
	self assert: (self materialize: '''FOO''') equals: 'FOO'.
	self assert: (self materialize: '''\u00E9l\u00E8ve en Fran\u00E7ais''') equals: 'élève en Français'.
	string := String withAll: { 
		$". $'. $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }.
	self assert: (self materialize: '''\"\''\\\/\t\r\n\f\b''') equals: string.
! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61172450!
testSymbol
	self assert: (self materialize: '#''foo''') identicalTo: #foo.
	self assert: (self materialize: '#foo') identicalTo: #foo! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61188097!
testWhitespace
	| whitespace |
	whitespace := { Character space. Character tab. Character cr. Character lf }.
	self assert: (self materialize: whitespace, '123') equals: 123
	! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61174626!
testWideSymbol
	self assert: (self materialize: '#''яблоко''') identicalTo: #яблоко.
	self assert: (self materialize: '#яблоко') identicalTo: #яблоко! !
!STONReaderTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
testZnUrlBackwardsCompatibility
	"We now have URL, make sure we still support the old format"
	self 
		assert: (self materialize: 'ZnUrl{#scheme:#https,#host:''pharo.org'',#segments:OrderedCollection[''files'', ''pharo.png'']}') 
		equals: 'https://pharo.org/files/pharo.png' asUrl.
	self 
		assert: (self materialize: 'ZnUrl{#scheme:#file,#segments:OrderedCollection[''tmp'', ''foo.txt'']}') 
		equals: 'file:///tmp/foo.txt' asUrl.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61253448!
testAssociation
	self assert: (self serialize: 'foo' -> 1) equals: '''foo'':1'.
	self assert: (self serialize: #bar -> 2) equals: '#bar:2'.
	self assert: (self serialize: 'foo bar' -> #ok) equals: '''foo bar'':#ok'.
	self assert: (self serialize: 123 -> 456) equals: '123:456'
! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61254062!
testByteArray
	self assert: (self serialize: #(1 2 3) asByteArray) equals: 'ByteArray[''010203'']' 
! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61250869!
testDateAndTime
	| dateAndTime |
	dateAndTime := DateAndTime year: 2012 month: 1 day: 1 hour: 6 minute: 30 second: 15 offset: 1 hour.
	self assert: (self serialize: dateAndTime) equals: 'DateAndTime[''2012-01-01T06:30:15+01:00'']'! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61253776!
testDictionary
	| collection |
	collection := STON mapClass new at: 1 put: 1; at: 2 put: 2; yourself.
	self assert: (self serialize: collection) equals: '{1:1,2:2}'.
	self assert: (self serialize: STON mapClass new) equals: '{}'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61241737!
testDoubleQuotedString
	| string |
	self assert: (self serializeJson: 'foo') equals: '"foo"'.
	self assert: (self serializeJson: 'FOO') equals: '"FOO"'.
	self assert: (self serializeJson: 'élève en Français') equals: '"élève en Français"'.
	string := String withAll: { 
		$". $'. $\. $/. Character tab. Character cr. Character lf. Character newPage. Character backspace }.
	"Note that in JSON mode, double quotes get escaped, and single quotes not"
	self assert: (self serializeJson: string) equals: '"\"''\\/\t\r\n\f\b"'.
! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61252853!
testFloat
	self assert: (self serialize: 1.5) equals: '1.5'.
	self assert: (self serialize: 0.0) equals: '0.0'.
	self assert: (self serialize: -1.5) equals: '-1.5'.
	self assert: ((self serialize: Float pi) beginsWith:  '3.14159').
	self assert: ((self serialize: (1/3) asFloat) beginsWith:  '0.333').
	self assert: (self serialize: (10 raisedTo: 100) asFloat) equals: '1.0e100'.
	self assert: (self serialize: (10 raisedTo: -50) asFloat) equals: '1.0e-50'.
	self assert: (self serialize: (10 raisedTo: -50) asFloat negated) equals: '-1.0e-50'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61240546!
testIdentityDictionary
	| collection |
	collection := IdentityDictionary new at: 1 put: 1; at: 2 put: 2; yourself.
	self assert: (self serialize: collection) equals: 'IdentityDictionary{1:1,2:2}'.
	self assert: (self serialize: IdentityDictionary new) equals: 'IdentityDictionary{}'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61246589!
testList
	self assert: (self serialize: (STON listClass withAll: #(1 2 3))) equals: '[1,2,3]'.
	self assert: (self serialize: STON listClass new) equals: '[]'.
	self 
		assert: (self serialize: (STON listClass withAll: { 1. -1. 0. #foo. 'a b c'. true. false. nil }))
		equals: '[1,-1,0,#foo,''a b c'',true,false,nil]'! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61242764!
testMap
	| map |
	(map := STON mapClass new)
		at: #foo put: 1;
		at: #bar put: 2.
	self assert: (self serialize: map) equals: '{#foo:1,#bar:2}'.
	self assert: (self serialize: STON mapClass new) equals: '{}'.
	map removeAll.
	map at: 'foo bar' put: #ok.
	self assert: (self serialize: map) equals: '{''foo bar'':#ok}'.
	map removeAll.
	map at: 123 put: 456.
	self assert: (self serialize: map) equals: '{123:456}'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61251763!
testOrderedCollection
	| collection |
	collection := OrderedCollection with: 1 with: 2 with: 3.
	self assert: (self serialize: collection) equals: 'OrderedCollection[1,2,3]'.
	self assert: (self serialize: OrderedCollection new) equals: 'OrderedCollection[]'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61246276!
testPoint
	self assert: (self serialize: 1@2) equals: 'Point[1,2]'! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61241034!
testReferenceCycle
	| array |
	array := STON listClass with: 1 with: nil.
	array at: 2 put: array.
	self assert: (self serialize: array) equals: '[1,@1]'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61248761!
testReferenceSharing
	| array one |
	one := { #one }.
	array := STON listClass with: one with: one with: one.
	self assert: (self serialize: array) equals: '[[#one],@2,@2]'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61250193!
testReferenceSharingIgnore
	| serializer array one |
	serializer := [ :object | 
		String streamContents: [ :stream |
			STON writer 
				on: stream;
				referencePolicy: #ignore; 
				nextPut: object ] ].
	one := { #one }.
	array := STON listClass with: one with: one with: one.
	self assert: (serializer value: array) equals: '[[#one],[#one],[#one]]'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61251165!
testString
	| string |
	self assert: (self serialize: 'foo') equals: '''foo'''.
	self assert: (self serialize: 'FOO') equals: '''FOO'''.
	self assert: (self serializeAsciiOnly: 'élève en Français') equals: '''\u00E9l\u00E8ve en Fran\u00E7ais'''.
	self assert: (self serialize: 'élève en Français') equals: '''élève en Français'''.
	string := String withAll: { 
		$". $'. $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }.
	self assert: (self serialize: string) equals: '''"\''\\/\t\r\n\f\b'''.
! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61238825!
testSymbol
	self assert: (self serialize: #foo) equals: '#foo'.
	self assert: (self serialize: #FOO) equals: '#FOO'.
	self assert: (self serialize: #bytes) equals: '#bytes'.
	self assert: (self serialize: #'foo.bar') equals: '#foo.bar'.
	self assert: (self serialize: #'foo-bar') equals: '#foo-bar'.
	self assert: (self serialize: #'foo_bar') equals: '#foo_bar'.
	self assert: (self serialize: #'foo/bar') equals: '#foo/bar'.
	self assert: (self serialize: #'foo bar') equals: '#''foo bar'''.
	self assert: (self serialize: #foo123) equals: '#foo123'.! !
!STONWriterTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61243438!
testSymbolAsString
	self assert: (self serializeJson: #foo) equals: '"foo"'.
	self assert: (self serializeJson: #'FOO') equals: '"FOO"'.
! !
!STONTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61194093!
testFromString
	| object |
	object := STON listClass withAll: { 1. 0. -1. true. false. nil }.
	self assert: (STON fromString: '[1,0,-1,true,false,nil]') equals: object! !
!STONTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61192745!
testRoomExitCycles
	| model room1 room2 exit1 exit2 ston object |
	(room1 := STONTestMap new) at: #name put: 'Room 1'.
	(room2 := STONTestMap new) at: #name put: 'Room 2'.
	(exit1 := STONTestMap new)
		at: #name put: 'Exit 1';
		at: #origin put: room1;
		at: #destination put: room2.
	(exit2 := STONTestMap new)
		at: #name put: 'Exit 2';
		at: #origin put: room2;
		at: #destination put: room1.
	room1 at: #exit put: exit1.
	room2 at: #exit put: exit2.
	model := Array with: room1 with: room2.
	ston := STON toString: model.
	object := STON fromString: ston.
	"We can't just compare because this is a recursive datastructure"
	self assert: (object first at: #name) equals: 'Room 1'.
	self assert: (object second at: #name) equals: 'Room 2'.
	self assert: ((object first at: #exit) at: #name) equals: 'Exit 1'.
	self assert: ((object second at: #exit) at: #name) equals: 'Exit 2'.
	self assert: ((object first at: #exit) at: #origin) identicalTo: object first.
	self assert: ((object first at: #exit) at: #destination) identicalTo: object second.
	self assert: ((object second at: #exit) at: #origin) identicalTo: object second.
	self assert: ((object second at: #exit) at: #destination) identicalTo: object first.
	"Try writing again the parse model" 
	self assert: (STON toString: object) equals: ston! !
!STONTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61194903!
testToString
	| object |
	object := STON listClass withAll: { 1. 0. -1. true. false. nil }.
	self assert: (STON toString: object) equals: '[1,0,-1,true,false,nil]'! !
!STONJSONTest methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
environment
	^ Smalltalk globals! !
!STONJSONTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61151752!
testOrderedDictionary
	| odictClass odict json dict |
	
	odictClass := self environment at: #OrderedDictionary ifAbsent: [ ^ self skip ].
		
	odict := odictClass newFrom: { 
		'a' -> 42 . 'b' -> 1. 'aa' -> 4. 'c' -> 23 
	}.
	
	"assert that the order is not equal in the dictionary hash table".	
	self 
		assertCollection: odict asArray hasSameElements: odict dictionary asArray;
		deny: odict asArray equals: odict dictionary asArray.
		
	"ordered presevered when encoding:"
	json := STONJSON toString: odict.
	self assert: json equals: '{"a":42,"b":1,"aa":4,"c":23}'.
	
	"lost when decoding"
	dict := STONJSON fromString: json.

	self 
		assertCollection: dict asArray hasSameElements: odict asArray;
		assert: dict equals: odict dictionary;
		deny: dict asArray equals: odict asArray
! !
!STONWriteReadTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
testAlternativeRepresentation
	| testObject resultObject |
	testObject := STONAlternativeRepresentationTestObject example.
	"See the class comment of STONAlternativeRepresentationTestObject
	for a description of how the internal and external representation differ.
	See also STONAlternativeRepresentationTestObject>>#stonOn:
	and STONAlternativeRepresentationTestObject>>#fromSton:"
	resultObject := self materialize: (self serialize: testObject).
	self assert: resultObject id equals: testObject id.
	self assert: resultObject time equals: testObject time.
	self assert: (resultObject gridReference x closeTo: testObject gridReference x).
	self assert: (resultObject gridReference y closeTo: testObject gridReference y).! !
!STONWriteReadTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61222345!
testFloats
	| floats serialization materialization |
	floats := STON listClass withAll: ((-10 to: 10) collect: [ :each | each * Float pi ]).
	serialization := self serialize: floats.
	materialization := self materialize: serialization.
	self assert: floats size equals: materialization size.
	floats with: materialization do: [ :float :materializedFloat |
		"Use #closeTo: instead of #= to increase portability"
		self assert: float closeTo: materializedFloat ]! !
!STONWriteReadTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56' prior: 61215813!
testKnownObjects
	| knownObject ston object |
	knownObject := STONTestKnownObject new.
	"make sure the system of remembering instances works"
	self assert: (STONTestKnownObject fromId: knownObject id asString) equals: knownObject.
	self assert: (STONTestKnownObject fromId: knownObject id asString) identicalTo: knownObject.
	"only the id string is serialized"
	ston := self serialize: knownObject.
	"upon serialization, objects with known id strings come from the remembered instances"
	object := self materialize: ston.
	self assert: object equals: knownObject.
	self assert: object identicalTo: knownObject.
	"not just the id is equal, but the rest of the object too"
	self assert: object description equals: knownObject description.
	
	STONTestKnownObject resetKnownObjects.! !
!STONWriteReadTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
testSortedCollections
	| collections |
	collections := STON listClass withAll: {
		SortedCollection new.
		SortedCollection new: 0.
		#(5 3 7 2 1 4 10 9 8 6) asSortedCollection.
		#(5 3 7 2 1 4 10 9 8 6) asSortedCollection: #yourself ascending.
		#(5 3 7 2 1 4 10 9 8 6) asSortedCollection: #yourself descending.
		#('****' '*' '*****' '**' '***') asSortedCollection: #size ascending.
		#('****' '*' '*****' '**' '***') asSortedCollection: #size descending.
		#(5 3 7 2 1 4 10 nil 9 8 6) asSortedCollection: #yourself ascending undefinedFirst.
		#(5 3 7 2 1 4 10 nil 9 8 6) asSortedCollection: #yourself ascending reversed undefinedLast }.
	self serializeAndMaterialize: collections! !
!STONAlternativeRepresentationTestObject class methodsFor: 'example' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
example
	^ self new
		id: 1e9 atRandom; 
		time: DateAndTime now; 
		gridReference: 150.75@250.25; 
		yourself! !
!STONAlternativeRepresentationTestObject methodsFor: 'ston persistence' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
fromSton: stonReader
	stonReader parseMapDo: [ :key :value |
		key = #id ifTrue: [ self id: value ].
		key = #time ifTrue: [ self timeUTC: value ].
		key = #grid_reference ifTrue: [ self gridReferenceImperial: value ] ]! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
gridReference
	^ gridReference! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
gridReference: value
	gridReference := value! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
gridReferenceImperial
	^ gridReference / 1.609344! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
gridReferenceImperial: value
	gridReference := value * 1.609344! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
id
	^ id! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
id: anObject
	id := anObject! !
!STONAlternativeRepresentationTestObject methodsFor: 'ston persistence' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
stonOn: stonWriter	
	stonWriter writeObject: self streamMap: [ :dictionary |
		dictionary
			at: #id put: self id;
			at: #time put: self timeUTC;
			at: #grid_reference put: self gridReferenceImperial ]! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
time
	^ time! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
time: anObject
	time := anObject! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
timeUTC
	^ time asUTC! !
!STONAlternativeRepresentationTestObject methodsFor: 'accessing' stamp: 'CompatibleUserName 7/3/2020 20:32:56'!
timeUTC: value
	time := value offset: TimeZone local offset ! !

"STON-Tests"!
!CoASTNodeFetcherHeuristic commentStamp: '' prior: 0!
I implement a fetcher heuristic for an AST node.
My responsibility is to build a fetcher for a given node in a given context.
I am implemented as a chain of responsibility: I treat the build request if possible, otherwise I forward the request to the next heuristic.

My main method #fetcherFor:inContext: is a template method.
My subclasses should redefine:
 - #appliesForNode:inContext: returning a boolean if the heuristic applies for context/node
 - #buildFetcherFor:inContext: returning the effective heuristic built!
!CoGlobalVariablesHeuristic commentStamp: '' prior: 0!
I implement an heuristic for global variables accessible in the completion environment.

See my superclass for details.!
!CoInitializeInferencedMessageHeuristic commentStamp: '' prior: 0!
I am an heuristic using depth-bound type inference to type variables.
I autocomplete messages in the hierarchy of the found types.!
!CoInstanceAccessibleVariablesHeuristic commentStamp: '' prior: 0!
I implement an heuristic for variables accessible from the instance side, such as instance variables and class variables.

See my superclass for details.!
!CoLiteralMessageHeuristic commentStamp: '' prior: 0!
I implement an heuristic for messages sent to literals.
If there is a literal as receiver, create a fetcher for messages of its class.

See my superclass for details.!
!CoLocalScopeVariablesHeuristic commentStamp: '' prior: 0!
I implement an heuristic for local variables accessible from the current AST node.

See my superclass for details.!
!CoSelfMessageHeuristic commentStamp: '' prior: 0!
I implement an heuristic for self message sends.
I provide a fetcher for messages for the hierarchy of self class.

See my superclass for details.!
!CoSessionMessagesHeuristic commentStamp: '' prior: 0!
I am an heuristic that autocompletes messages based on a session vocabulary.!
!CoStatisticsHeuristicWrapper commentStamp: '' prior: 0!
I am an heuristic decorator that wraps an heuristic.
When asked to build a fetcher, I build the fetcher of the wrapped heuristic, and decorate it with a mapping fetcher. This mapping fetcher wraps the completion entries returned by the fetcher with a logging entry.

I'm created by the CoStatisticsHeuristicBuilder. See CoStatisticsHeuristicBuilder for more details.!
!CoSuperMessageHeuristic commentStamp: '' prior: 0!
I implement an heuristic for self message sends.
I provide a fetcher for messages for the hierarchy of self class superclass.

See my superclass for details.!
!CoUnknownMessageHeuristic commentStamp: '' prior: 0!
I implement a default heuristic for when nothing else can be done.
I provide a fetcher for messages for the full system.
I am usually at the end of the chain of responsibility.

See my superclass for details.!
!CoVariableMessageHeuristic commentStamp: '' prior: 0!
I am an abstract class for heuristics for messages sent to variables.

See my superclass and concrete subclasses for details.!
!CoGlobalVariableMessageHeuristic commentStamp: '' prior: 0!
I implement an heuristic for messages sent to globals.
If the global object is available in the environment, 
 - if it is a class complete messages in it class side
 - if it is a global object complete messages in the global object's class

See my superclass for details.!
!CoVariableValueMessageHeuristic commentStamp: '' prior: 0!
I implement an heuristic for messages sent to variables whose value is available in the context, for example in a debugger, workspace or inspector.
If there is a value for the variable, create a fetcher for messages of its class.

See my superclass for details.!
!CoVariableWithTypeNameMessageHeuristic commentStamp: '' prior: 0!
I implement an heuristic for messages sent to variables in the form "aX" or "anX".
If a class X is available in the environment, I return a fetcher for X's instance side messages.

See my superclass for details.!
!CoWorkspaceVariablesHeuristic commentStamp: '' prior: 0!
I implement an heuristic for variables in a workspace/playground.

See my superclass for details.!
!CoBenchmarkContext commentStamp: '' prior: 0!
I implement a completion context for benchmark purposes.
I contain an AST and provide information for the autocompletion based on it.
See CoStaticBenchmarks.!
!CoBenchmarkPackage commentStamp: '' prior: 0!
I represent a package for benchmarking.
I mainly give access to methds in the package.
I am required because packages and methods are not polymorphic.!
!CoCompletionContext commentStamp: '' prior: 0!
I am the interface with the System's CompletionEngine, following the API of CompletionContext (entries, entryCount, activateEntryAt:, etc).
I delegate the calculation of the entries completely to a complishon object which is lazily built by a complishon builder.
The complishonBuilder instance can be specialized or replaced to change the search heuristics.!
!CoStatisticsCompletionContext commentStamp: '' prior: 0!
I am a completion context that tells a CoStatisticsCompletionEntry its index before being activated.
This is required because completion entries could be shown in different positions of the candidates, depending on the filters.!
!CoFetcher commentStamp: '' prior: 0!
I'm a kind of iterator (in the sense of GoF) that goes one by one over "a stream" of entities that can be consumed by the completion engine within a completion context.

I provide access to the elements I return one by one (using the next message) in a controlled manner. 
At the root, I define the architecture to yield one entry at a time. 
The next method invokes the hook method #entriesDo: with a generator yielding capability.
This way any use of #next will be done step by step. 

My subclasses implement the following method entriesDo: aBlock which defines the semantics of element fetching
Here is a simple example where a generic fetcher is used on a collection, and wrapped by a fetcher that avoids returning duplicate elements.

[[[
fetcher := AvoidRepeatedComplishonFetcher new
	complishonFetcher: (GenericComplishonFetcher onCollection: #( a b b a c )).
]]]
	
Here are two examples of definition

[[[
AvoidRepeatedComplishonFecther >> entriesDo: aBlock
	decoree
		entriesDo: [ :elem | 
			(self hasAlreadyReturned: elem)
				ifFalse: [ elements add: elem.
					aBlock value: elem ] ]
]]]

[[[
GenericComplishonFetcher >> entriesDo: aBlock

	collection do: aBlock
]]]



	
!
!CoClassBasedFetcher commentStamp: '' prior: 0!
I am an abstract complishon fetcher that looks for things inside a class.
My subclasses will, for example, fetch a class' class variables, messages implemented in the class, instance variables.

I am explicitly created with the superclass I will look into.
This allows other combinators to act upon me.
- I define #onSuperclass that creates a copy of myself but acting on my superclass.
- I define #forHierarchy that decorates myself with a HierarchyComplishonFetcher that makes a search for the entire hierarchy.!
!CoClassImplementedMessagesFetcher commentStamp: '' prior: 0!
I am a fetcher looking for the messages implemented in a class.!
!CoClassVariableFetcher commentStamp: '' prior: 0!
I am a fetcher looking for the class variables implemented in a class.!
!CoInstanceVariableFetcher commentStamp: '' prior: 0!
I am a fetcher looking for the instance variables implemented in a class.!
!CoCollectionFetcher commentStamp: '' prior: 0!
I'm a fetcher simply enumerating a collection of items defined using the collection: message.
Mainly used for testing.!
!CoEmptyFetcher commentStamp: '' prior: 0!
By default I do not nothing. I'm the NullObject of the fetcher hierarchy.!
!CoFetcherDecorator commentStamp: '' prior: 0!
I am an abstract decorator superclass encapsulating common tasks that should be done with my decoree.
I am a complishon fetcher exposing the same API, and redirecting it to my decoree by default.
My decoree is also a complishon fetcher.!
!CoAvoidRepeatedFetcher commentStamp: '' prior: 0!
GenericComplishonFetcher I ensure that I will not return twice the same entity.
I am mainly used in the context of code completion of messages, although I can be used in other context.

For example, when looking to autocomplete messages for ==self==, an heuristic may choose to show the selectors in the class, then the selectors in the superclass, and so on, following the inheritance chain. However, in the class hierarchy we may observe redefined methods, so a naive fetcher will first show #redefined from the subclass and then #redefined again from the superclass.

I can be easily created by sending the #withoutRepetition message to another fetcher.

(GenericComplishonFetcher onCollection: aCollection) withoutRepetition.!
!CoFilterFetcher commentStamp: '' prior: 0!
I am a filtering complishon fetcher. I decorate a complishon fetcher and filter its results to those ones that satisfy a given condition block.
I can be created by sending the #select: message to an existing fetcher.

(GenericComplishonFetcher onCollection: aCollection) select: [ :each | each even ]

As a convenience method to get rid of the upmost filter in the decorator chain, all fetchers understand #withoutFilter.
#withoutFilter will return self for all fetchers except for a filter one.
A filter will return its decoree.

Finally, as a convenience for code completion, the method #narrowFilterBlock: is a convenience allowing to replace the filter block on the fly.
It should be used only if the block actually narrows the selection, or at least filters the same elements.!
!CoHierarchyFetcher commentStamp: '' prior: 0!
I am a complishon fetcher decorator for ClassBasedComplishonFetcher that will iterate from my child up to the end of the class hierarchy.
I'll yield all results found in one, then move to the superclass, and so on.!
!CoMappingFetcher commentStamp: '' prior: 0!
I am a mapping complishon fetcher. I decorate a complishon fetcher and transform its results to those ones using the collectBlock block.
I can be created by sending the #collect: message to an existing fetcher.

(GenericComplishonFetcher onCollection: aCollection) collect [ :each | each * 2 ]!
!CoFetcherSequence commentStamp: '' prior: 0!
I'm a fetcher composed of a sequence of subfetchers. 
When executed, I execute my subfetchers one by one.

Sequences are created by sending the message #, between two fetchers.!
!CoGlobalVariableFetcher commentStamp: '' prior: 0!
I am a fetcher looking for globals in an environment.!
!CoMethodVariableFetcher commentStamp: '' prior: 0!
I am a complishon fetcher that autocompletes variable names accessible in the lexical context of a method.
That is, block temporaries, block arguments, method temporaries and method arguments.

From a given ast node, I walk up the tree looking for scopes and yield the variables I find.!
!CoPackageImplementedMessagesFetcher commentStamp: '' prior: 0!
I am a fetcher that yields the messages implemented in the given package.!
!CoHeuristicBuilder commentStamp: '' prior: 0!
I am an heuristic builder.
I am composed with several small heuristics and generate a chain of responsibility from them in the right order.

For example, given a list of heuristics:

CoHeuristicBuilder new
	add: CoSelfMessageHeuristic new;
	add: CoSuperMessageHeuristic new;
	add: CoInitializeInferencedMessageHeuristic new;
	yourself.

I create the following chain:

CoSelfMessageHeuristic -next-> CoSuperMessageHeuristic -next-> CoInitializeInferencedMessageHeuristic
	
I am used also as a hook, that can be redefined in subclasses and build heuristics differently.!
!CoStatisticsHeuristicBuilder commentStamp: '' prior: 0!
I am an heuristic builder that builds statistic-enabled fetchers.
I wrap each of my heuristics with a CoStatisticsHeuristicWrapper, and then compose these wrappers into a chain of responsibility.
For example, given a list of heuristics:

CoHeuristicBuilder new
	add: CoSelfMessageHeuristic new;
	add: CoSuperMessageHeuristic new;
	yourself.

I create the following chain:

CoStatisticsHeuristicWrapper -next-> CoStatisticsHeuristicWrapper
           |                                     |
        decoree                               decoree
           |                                     |
           v                                     v
   CoSelfMessageHeuristic             CoSuperMessageHeuristic
	
I am used also as a hook, that can be redefined in subclasses and build heuristics differently.!
!CoNullFetcherHeuristic commentStamp: '' prior: 0!
I am a null fetcher heuristic, returning an empty fetcher!
!CoResultSet commentStamp: '' prior: 0!
I am the main entry point of the completion system.
I am built from a (potentially composed) fetcher and a filter-string.

When asked for results, I fetch them from the fetcher.
Internally, I keep also a list of already fetched results to avoid fetching many times the same.
This is particularly useful when the filter is being narrowed (e.g., we go from a filter 'ab' to a filter 'abc').
In such a case, some of the results already fetched are still valid, and the fetcher state is valid too.
  => we then filter the subresults and change the fetcher filter
In case the filter is being broadened (e.g., we go from 'abc' to 'ab'), all results we already have are valid, but probably lots of other results were filtered already. So we reset both the results and the fetcher and restart the search.!
!CoResultSetBuilder commentStamp: '' prior: 0!
I am the an AST based heuristics builder.
The completion engine calls configures me with a completion context and eventually sends me the #buildCompletion message.
I then return a Complishon object configured with a correct fetcher and initial filter.

My subclasses define how to create the complishon given the context.!
!CoASTResultSetBuilder commentStamp: '' prior: 0!
I'm an abstract superclass for defining AST Based Complishons!
!CoASTHeuristicsResultSetBuilder commentStamp: '' prior: 0!
I am the an AST based heuristics builder.

When building the complishon, I build the AST from the source in the context, and get the current node from the context position.
Then I do a double dispatch on the current node and from it
1) I decide what fetchers to create
2) I extract the currently typed text and set is as initial filter!
!CoStatisticsASTHeuristicsResultSetBuilder commentStamp: '' prior: 0!
I am a result set builder that builds heuristics using statistic support!
!CoGlobalSorterResultSetBuilder commentStamp: '' prior: 0!
I build a resultset with all possible candidates for an AST node, pre-sorted with a sorter.!
!CoSession commentStamp: '' prior: 0!
I implement a session that collects execution information.
I collect the last words in modified methods.!
!CoStaticBenchmarks commentStamp: '' prior: 0!
I run a series of completion benchmarks over a static scope.
I take all existing callsites in a scope (a class, a package) and run the completion with different prefixes (2 to 8), asking for 10 results.
Then I check if the selector at that callsite is in those elements, and in what position.
I accumulate the results in a table per index in the results and prefix size.

I have an inspector extension to show the results in a table.

Examples:

global := CoStaticBenchmarks new
	scope: (CoBenchmarkPackage on: SpAbstractAdapter package);
	builder: (CoGlobalSorterResultSetBuilder new
		sorterClass: AlphabeticSorter;
		yourself);
	run.

staticHeuristics := CoStaticBenchmarks new
	scope: (CoBenchmarkPackage on: SpAbstractAdapter package);
	builder: CoASTHeuristicsResultSetBuilder new;
	run.!
!CoStatistics commentStamp: '' prior: 0!
I am an object keeping code completion statistics.
I store two collection of events: accepted events and cancelled events.
Both events contain information about the completion context (class, is workspace...).
Accepted events contain also the text accepted, the index, and the heuristic.

I provide methods to access and query the statistics.

I have a singleton instance for convenience.!
!CoStatisticsCompletionEntry commentStamp: '' prior: 0!
I am an entry to put in the list of candidates in the code completion list.
I wrap a normal entry (necEntry) and logs acceptance when I'm sent the #activateOn: message.

I'm meant to be created by a CoStatisticsHeuristicWrapper for each completion entry.
See CoStatisticsHeuristicWrapper for more details!
!CoSystemEnvironment commentStamp: '' prior: 0!
I represent an environment for the completion.
I know a system dictionary, and can be initialized with for example, Smalltalk globals.!
!CoTypeInferencer commentStamp: '' prior: 0!
I am a simple type inferencer that is depth-bound.
That is, I infer a method up to a certain level of the callgraph.!
!CoUnknownType commentStamp: '' prior: 0!
I represent an unknown type for CoTypeInferencer.!
!CoUsageEvent commentStamp: '' prior: 0!
I am an abstract class for events happening during code completion.
I'm used to take statistics about code completion usage.!
!CoCompletionCancelledEvent commentStamp: '' prior: 0!
I represent the event of having quit the code completion without having accepted any entry.!
!CoEntryAcceptedEvent commentStamp: '' prior: 0!
I represent the event of having accepted an entry in the candidate list of the code completion.
I have the index of the entry and the source that produced it (typically the heuristic)!
!ManifestHeuristicCompletionModel commentStamp: '' prior: 0!
HeuristicCompletion is a code completion engine using generators and herustics. Instead of query the entire system and generate lots of potentially intermediate collections that we need to concatenate, copy, grow, iterate all those sub-collections in order. Generators provide a stream-like access to those collections (and sequences of collections) without scanning the full system eagerly.

# Architecture
This completion engine is done out of three main components:

- lazy fetchers implemented using generators (cf. CoFetcher),
- a completion object that works as a result-set (cf. CoResultSet),
- and several completion heuristics that are decided depending on the code being completed by looking at the AST (cf. CoASTNodeFetcherHeuristic).

# Plugging different heuristics

This completion engine is meant to be pluggable. New heuristics can be introduced, or the ones in the system can be completely replaced. If you want to implement your own completion you need to subclass CoASTResultSetBuilder or CoResultSetBuilder. CoASTResultSetBuilder provides already common behavior when basic the code completion algorithm on the AST. Then the completion engine can be configured with the required result set builder.

CoCompletionEngine new
    complishonBuilder: MyResultSetBuilder new;
    yourself

## Subclassing CoResultSetBuilder
The system will provide your builder with a completion context, and will then call buildComplishon. You need to redefine buildComplishon and return a CoResultSet.

## Subclassing CoASTResultSetBuilder
The system will provide your builder with a completion context, and will then call a default version of buildComplishon. By default it will parse the source code to get an AST, get the AST node corresponding to the caret position, and make a double dispatch on the node. As a result, the ASTResultSetBuilder will be sent a corresponding visit* with the corresponding node. You need to redefine visit* and return a CoResultSet configured depending on the AST node.

## Subclassing CoASTHeuristicsResultSetBuilder
CoASTHeuristicsResultSetBuilder is an CoASTResultSetBuilder based on heuristics. It has three sets of heuristics: one for messages, one for variables, and one for methods. You can redefine messageHeuristic, methodHeuristic or variablesHeuristic to change one of them.!
!SystemNavigation methodsFor: '*HeuristicCompletion-Model'!
allSentMessagesInClass: aClass
	"Answer the set of selectors which are sent somewhere in the system."
	| sent |
	sent := IdentitySet new.
	self allSentMessagesInClass: aClass do: [ :e | sent add: e ].
	^ sent! !
!SystemNavigation methodsFor: '*HeuristicCompletion-Model'!
allSentMessagesInClass: aClass do: aBlock
	"Answer the set of selectors which are sent somewhere in the system."
	aClass methodsDo: [:method | "Include all sels, but not if sent by self"
		method literalsDo: [:literal | 
			(literal isSymbol) ifTrue: ["might be sent"
				literal == method selector ifFalse: [ aBlock value: literal ]].
			(literal isMemberOf: Array) ifTrue: ["might be performed"
				literal do: [:x | (x isSymbol) ifTrue: [ x == method selector ifFalse: [ aBlock value: x ]]]]]].
	"The following may be sent without being in any literal frame"
	1
		to: Smalltalk specialSelectorSize
		do: [:index | aBlock value: (Smalltalk specialSelectorAt: index)].! !
!SystemNavigation methodsFor: '*HeuristicCompletion-Model'!
allSentMessagesInPackage: aPackage
	| sent |
	sent := IdentitySet new.
	self allSentMessagesInPackage: aPackage do: [ :e | sent add: e ].
	^ sent! !
!SystemNavigation methodsFor: '*HeuristicCompletion-Model'!
allSentMessagesInPackage: aPackage do: aBlock
	"Answer the set of selectors which are sent somewhere in the system."
	aPackage definedClassesDo: [ :className | | class |
		class := Smalltalk globals at: className.
		self allSentMessagesInClass: class do: aBlock ]! !
!CoASTNodeFetcherHeuristic methodsFor: 'requests'!
appliesForNode: aRBMessageNode inContext: aContext
	
	^ false! !
!CoASTNodeFetcherHeuristic methodsFor: 'requests'!
buildFetcherFor: aRBMessageNode inContext: aContext

	^ CoEmptyFetcher new! !
!CoASTNodeFetcherHeuristic methodsFor: 'requests'!
fetcherFor: aRBMessageNode inContext: aContext

	| nextFetcher |
	nextFetcher := self next fetcherFor: aRBMessageNode inContext: aContext.
	^ (self appliesForNode: aRBMessageNode inContext: aContext)
		ifTrue: [
			(self buildFetcherFor: aRBMessageNode inContext: aContext),
				nextFetcher ]
		ifFalse: [ nextFetcher ]! !
!CoASTNodeFetcherHeuristic methodsFor: 'initialization'!
initialize
	super initialize.
	next := CoNullFetcherHeuristic new! !
!CoASTNodeFetcherHeuristic methodsFor: 'testing'!
isStatisticsHeuristicWrapper
	
	^ false! !
!CoASTNodeFetcherHeuristic methodsFor: 'fetcher-creation'!
newMessageInHierarchyFetcherForClass: aClass inASTNode: astNode
	
	^ CoClassImplementedMessagesFetcher new
		astNode: astNode;
		completionClass: aClass;
		forHierarchy! !
!CoASTNodeFetcherHeuristic methodsFor: 'accessing'!
next
	^ next! !
!CoASTNodeFetcherHeuristic methodsFor: 'accessing'!
next: nextHeuristic 
	next := nextHeuristic! !
!CoGlobalVariablesHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aNode isVariable and: [ aNode name first isUppercase ]! !
!CoGlobalVariablesHeuristic methodsFor: 'requests'!
buildFetcherFor: aNode inContext: completionContext

	^ CoGlobalVariableFetcher new
			astNode: aNode;
			completionEnvironment: completionContext completionEnvironment;
			yourself! !
!CoInitializeInferencedMessageHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aContext completionClass notNil
		and: [ aNode receiver isVariable ]! !
!CoInitializeInferencedMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aNode inContext: aContext

	| variables fetcher |
	variables := self inferTypesIn: aContext completionClass.
	fetcher := CoEmptyFetcher new.
	variables
		at: aNode receiver name
		ifPresent: [ :types |
			types do: [ :each |
				fetcher := (self newMessageInHierarchyFetcherForClass: each inASTNode: aNode), fetcher ] ].
	^ fetcher! !
!CoInitializeInferencedMessageHeuristic methodsFor: 'requests'!
inferTypesIn: aClass

	^ CoTypeInferencer new
		inferFrom: aClass;
		variables! !
!CoInstanceAccessibleVariablesHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aContext isWorkspace not! !
!CoInstanceAccessibleVariablesHeuristic methodsFor: 'requests'!
buildFetcherFor: astNode inContext: completionContext
	
	| ivFetcher cvFetcher |
	
	"Then instance variables"
	ivFetcher := (CoInstanceVariableFetcher new
		astNode: astNode;
		completionClass: completionContext completionClass) forHierarchy.
	
	"Then class variables if not a workspace"
	cvFetcher :=  (CoClassVariableFetcher new
			astNode: astNode;
			completionClass: completionContext completionClass) forHierarchy.
	
	^ ivFetcher, cvFetcher! !
!CoLiteralMessageHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aNode receiver isLiteralNode! !
!CoLiteralMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aRBMessageNode inContext: aContext

	^ self newMessageInHierarchyFetcherForClass: aRBMessageNode receiver value class inASTNode: aRBMessageNode! !
!CoLocalScopeVariablesHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ true! !
!CoLocalScopeVariablesHeuristic methodsFor: 'requests'!
buildFetcherFor: aNode inContext: aContext

	^ CoMethodVariableFetcher new completionASTNode: aNode! !
!CoSelfMessageHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aNode receiver isSelf! !
!CoSelfMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aNode inContext: completionContext
	| completionClass |
	
	"When in the playground, the completion class is not available.
	But self is bound to nil"
	completionClass := completionContext completionClass ifNil: [ nil class ].
	^ self newMessageInHierarchyFetcherForClass: completionClass inASTNode: aNode! !
!CoSessionMessagesHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aNode isMethod or: [ aNode isMessage ]! !
!CoSessionMessagesHeuristic methodsFor: 'requests'!
buildFetcherFor: aRBMessageNode inContext: aContext

	^ CoCollectionFetcher onCollection: session words! !
!CoSessionMessagesHeuristic methodsFor: 'accessing'!
session
	^ session! !
!CoSessionMessagesHeuristic methodsFor: 'accessing'!
session: anObject
	session := anObject! !
!CoStatisticsHeuristicWrapper methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ wrapped appliesForNode: aNode inContext: aContext! !
!CoStatisticsHeuristicWrapper methodsFor: 'requests'!
buildFetcherFor: aNode inContext: aContext

	| fetcher wrappedFetcher |
	fetcher := wrapped buildFetcherFor: aNode inContext: aContext.
	wrappedFetcher := fetcher collect: [ :e |
		(CoStatisticsCompletionEntry on: e)
			heuristic: self next;
			statistics: statistics;
			yourself ].
	^ wrappedFetcher! !
!CoStatisticsHeuristicWrapper methodsFor: 'testing'!
isStatisticsHeuristicWrapper
	
	^ true! !
!CoStatisticsHeuristicWrapper methodsFor: 'accessing'!
statistics
	^ statistics! !
!CoStatisticsHeuristicWrapper methodsFor: 'accessing'!
statistics: anObject
	statistics := anObject! !
!CoStatisticsHeuristicWrapper methodsFor: 'accessing'!
wrapped
	^ wrapped! !
!CoStatisticsHeuristicWrapper methodsFor: 'accessing'!
wrapped: anObject
	wrapped := anObject! !
!CoSuperMessageHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ (aNode isMessage
		and: [ aNode receiver isSuper ])
			or: [ aNode isMethod
				and: [ 
					"This heuristic is not valid for traits and nil subclasses"
					aContext completionClass superclass notNil ] ]! !
!CoSuperMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aNode inContext: completionContext
	| completionClass |
	
	"When in the playground, the completion class is not available.
	But self is bound to nil"
	completionClass := completionContext completionClass ifNil: [ nil class ].
	^ self newMessageInHierarchyFetcherForClass: completionClass superclass inASTNode: aNode! !
!CoUnknownMessageHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aNode isMethod or: [ aNode isMessage ]! !
!CoUnknownMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aNode inContext: completionContext
	"This is the main heuristic used for those messages where we cannot guess the type.
	I can be used also after more fine heuristics, to complete guessed heuristics that cannot be trusted too much, like variable names"

	"If the context allows it, autocomplete first messages in the current package, then the rest in the system"
	| fetcher |
	fetcher := (CoCollectionFetcher onCollection: Symbol selectorTable)
		collect: [ :e | NECSelectorEntry contents: e node: aNode ].
	completionContext completionClass ifNotNil: [
		fetcher := (CoPackageImplementedMessagesFetcher new
			astNode: aNode;
			completionPackage: completionContext completionClass package;
			yourself), fetcher
	].
	^ fetcher! !
!CoGlobalVariableMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aRBMessageNode inContext: completionContext

	completionContext
		environmentAt: aRBMessageNode receiver name
		ifPresent: [ :global | ^ self newFetcherForGlobal: global inASTNode: aRBMessageNode ].

	^ CoEmptyFetcher new! !
!CoGlobalVariableMessageHeuristic methodsFor: 'requests'!
newFetcherForGlobal: aGlobal inASTNode: ast

	"This is a class or trait. Autocomplete class-side messages" 
	aGlobal isClassOrTrait ifTrue: [
		^ CoClassImplementedMessagesFetcher new
			astNode: ast;
			completionClass: aGlobal classSide;
			forHierarchy ].

	"This is not a class binding but a global object. Autocomplete based on its class"
	^ CoClassImplementedMessagesFetcher new
		astNode: ast;
		completionClass: aGlobal class;
		forHierarchy! !
!CoVariableMessageHeuristic class methodsFor: 'testing'!
isAbstract

	^ self == CoVariableMessageHeuristic! !
!CoVariableMessageHeuristic methodsFor: 'requests'!
appliesForNode: aRBMessageNode inContext: aContext

	^ aRBMessageNode receiver isVariable! !
!CoVariableValueMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aRBMessageNode inContext: aContext

	"Try to fetch the real value of the variable from the context"
	self
		valueOfVariable: aRBMessageNode receiver name
		inContext: aContext
		ifPresent: [ :value | 
			^ self
				newMessageInHierarchyFetcherForClass: value class
				inASTNode: aRBMessageNode ].
	
	^ CoEmptyFetcher new! !
!CoVariableValueMessageHeuristic methodsFor: 'requests'!
valueOfVariable: aName inContext: completionContext ifPresent: aBlock

	| binding |
	"In the debugger, the binding values comes in the doItContext.
	If we find in the doItContext has a variable with the given name, use it, otherwise ignore it."
	(completionContext doItContext ifNotNil: [ :c | 
		(c astScope lookupVar: aName)
			ifNotNil: [ c lookupSymbol: aName ] ])
		ifNotNil: [ :value | ^ aBlock value: value ].

	"In the playground, the binding values comes in the bindings of the requestor.
	If we find in the requestor a binding with the given name, use it, otherwise ignore it."
	binding := (completionContext doItRequestor bindingOf: aName)
		ifNil: [ ^ self ].
	
	^ aBlock value: binding value! !
!CoVariableWithTypeNameMessageHeuristic methodsFor: 'requests'!
buildFetcherFor: aRBMessageNode inContext: completionContext

	"Heuristic: variables with type information.
	This is maybe an instance of this class, autocomplete for that class first, then continue with normal completion.
	E.g., aCollection => use completion for Collection class first, then normal collection.
	There are two cases: aPoint and anASTCache"
	aRBMessageNode receiver name size > 1
		and: [ completionContext
				environmentAt: aRBMessageNode receiver name allButFirst asSymbol
				ifPresent: [ :global | 
					^ self newFetcherForMaybeGlobalInstance: global inASTNode: aRBMessageNode ] ].
	
	aRBMessageNode receiver name size > 2
		and: [ completionContext
				environmentAt: (aRBMessageNode receiver name allButFirst: 2) asSymbol
				ifPresent: [ :global | 
					^ self newFetcherForMaybeGlobalInstance: global inASTNode: aRBMessageNode ] ].
				
	^ CoEmptyFetcher new! !
!CoVariableWithTypeNameMessageHeuristic methodsFor: 'requests'!
newFetcherForMaybeGlobalInstance: aGlobal inASTNode: astNode
	"Fetcher for messages to instance variables containing type information.
	For example: aCollection could autocomplete collection messages."

	"This is a class or trait. Autocomplete instance-side messages" 
	aGlobal isClassOrTrait ifTrue: [
		^ CoClassImplementedMessagesFetcher new
			astNode: astNode;
			completionClass: aGlobal instanceSide;
			forHierarchy ].

	"This is not a class binding but a global object.
	E.g., aSmalltalk
	Autocomplete based on its class"
	^ CoClassImplementedMessagesFetcher new
		astNode: astNode;
		completionClass: aGlobal class;
		forHierarchy! !
!CoWorkspaceVariablesHeuristic methodsFor: 'requests'!
appliesForNode: aNode inContext: aContext

	^ aContext isWorkspace! !
!CoWorkspaceVariablesHeuristic methodsFor: 'requests'!
buildFetcherFor: aNode inContext: aContext

	^ (CoCollectionFetcher onCollection: aContext variableBindingNames)
		collect: [ :e | NECLocalEntry contents: e node: aNode ]! !
!CoBenchmarkContext methodsFor: 'accessing'!
callsite
	^ callsite! !
!CoBenchmarkContext methodsFor: 'accessing'!
callsite: anObject
	callsite := anObject! !
!CoBenchmarkContext methodsFor: 'accessing'!
completionClass
	
	^ callsite methodNode methodClass! !
!CoBenchmarkContext methodsFor: 'accessing'!
doItContext
	
	^ nil! !
!CoBenchmarkContext methodsFor: 'accessing'!
doItRequestor

	^ nil! !
!CoBenchmarkContext methodsFor: 'accessing'!
environmentAt: aString ifPresent: aBlockClosure 
	
	self class environment at: aString ifPresent: aBlockClosure! !
!CoBenchmarkContext methodsFor: 'testing'!
isWorkspace
	
	^ false! !
!CoBenchmarkContext methodsFor: 'accessing'!
position
	
	^ position first + 1! !
!CoBenchmarkContext methodsFor: 'accessing'!
position: aPosition
	
	position := aPosition! !
!CoBenchmarkContext methodsFor: 'accessing'!
source
	
	^ callsite methodNode method sourceCode! !
!CoBenchmarkPackage class methodsFor: 'instance creation'!
on: aRPackage 
	
	^ self new
		package: aRPackage;
		yourself! !
!CoBenchmarkPackage methodsFor: 'enumerating'!
methodsDo: aBlockClosure 
	
	package definedClassesDo: [ :each | | class |
		class := self class environment at: each.
		class isTrait ifFalse: [
			(package definedMethodsForClass: class) do: aBlockClosure] ]! !
!CoBenchmarkPackage methodsFor: 'accessing'!
package: aRPackage 
	
	package := aRPackage! !
!CoBenchmarkPackage methodsFor: 'printing'!
printOn: aStream

	aStream print: package name! !
!CoCompletionContext class methodsFor: 'initialize-release'!
engine: aCompletionEngine class: aClass source: aString position: anInteger

	^ self new
		completionClass: aClass;
		engine: aCompletionEngine;
		source: aString;
		position: anInteger;
		yourself! !
!CoCompletionContext methodsFor: 'activating'!
activateEntryAt: anIndex

	(self entries at: anIndex) activateOn: self! !
!CoCompletionContext methodsFor: 'testing'!
completion

	completion ifNotNil: [ ^ completion ].
	^ completion := self completionBuilder
		completionContext: self;
		buildCompletion! !
!CoCompletionContext methodsFor: 'accessing'!
completion: anObject
	completion := anObject! !
!CoCompletionContext methodsFor: 'accessing'!
completionAt: aNumber
	| entry |
	
	entry := (self entries at: aNumber) contents asSymbol separateKeywords.
	^ NECPreferences spaceAfterCompletion 
		ifTrue: [ entry, ' ' ]
		ifFalse: [ entry ]! !
!CoCompletionContext methodsFor: 'accessing'!
completionBuilder
	^ completionBuilder! !
!CoCompletionContext methodsFor: 'accessing'!
completionBuilder: anUndefinedObject 
	completionBuilder := anUndefinedObject! !
!CoCompletionContext methodsFor: 'accessing'!
completionClass
	
	^ completionClass! !
!CoCompletionContext methodsFor: 'accessing'!
completionClass: aClass
	
	^ completionClass := aClass! !
!CoCompletionContext methodsFor: 'accessing'!
completionEnvironment
	
	^ CoSystemEnvironment new! !
!CoCompletionContext methodsFor: 'accessing'!
completionToken

	^ self completion completionToken! !
!CoCompletionContext methodsFor: 'accessing'!
doItContext

	^ engine doItContext! !
!CoCompletionContext methodsFor: 'accessing'!
doItRequestor

	^ engine doItRequestor! !
!CoCompletionContext methodsFor: 'accessing'!
engine
	^ engine! !
!CoCompletionContext methodsFor: 'accessing'!
engine: anObject
	engine := anObject! !
!CoCompletionContext methodsFor: 'accessing'!
entries

	^ self completion first: 20! !
!CoCompletionContext methodsFor: 'accessing'!
entryCount
	^ self entries size! !
!CoCompletionContext methodsFor: 'accessing'!
environmentAt: aString ifPresent: aBlockClosure 
	
	^ self completionEnvironment environmentAt: aString ifPresent: aBlockClosure! !
!CoCompletionContext methodsFor: 'testing'!
hasEntries

	^ self completion notEmpty! !
!CoCompletionContext methodsFor: 'menu'!
hasMessage
	
	^ false! !
!CoCompletionContext methodsFor: 'initialization'!
initialize

	super initialize.
	completionBuilder := CoASTHeuristicsResultSetBuilder initializeOnContext: self! !
!CoCompletionContext methodsFor: 'testing'!
isWorkspace
	
	^ engine notNil and: [ engine isScripting ]! !
!CoCompletionContext methodsFor: 'narrowing'!
narrowWith: aString 

	self completion filterWithString: aString! !
!CoCompletionContext methodsFor: 'accessing'!
position
	^ position! !
!CoCompletionContext methodsFor: 'accessing'!
position: anObject
	position := anObject! !
!CoCompletionContext methodsFor: 'replacing'!
replaceTokenInEditorWith: aString
	
	engine replaceTokenInEditorWith: aString! !
!CoCompletionContext methodsFor: 'accessing'!
source
	^ source! !
!CoCompletionContext methodsFor: 'accessing'!
source: anObject
	source := anObject! !
!CoCompletionContext methodsFor: 'accessing'!
title

	^ ''! !
!CoCompletionContext methodsFor: 'accessing'!
variableBindingNames

	^ self engine variableBindingNames! !
!CoStatisticsCompletionContext methodsFor: 'activating'!
activateEntryAt: anIndex

	^ (self entries at: anIndex)
		index: anIndex;
		activateOn: self! !
!CoClassBasedFetcher class methodsFor: 'testing'!
isAbstract

	^ self == CoClassBasedFetcher! !
!CoClassBasedFetcher methodsFor: 'accessing'!
astNode
	^ astNode! !
!CoClassBasedFetcher methodsFor: 'accessing'!
astNode: anObject
	astNode := anObject! !
!CoClassBasedFetcher methodsFor: 'accessing'!
completionClass
	^ completionClass! !
!CoClassBasedFetcher methodsFor: 'accessing'!
completionClass: anObject
	completionClass := anObject! !
!CoClassBasedFetcher methodsFor: 'hierarchy-fetching'!
forHierarchy
	
	^ CoHierarchyFetcher new
		decoree: self;
		yourself! !
!CoClassBasedFetcher methodsFor: 'hierarchy-fetching'!
onSuperclass
	
	completionClass superclass
		ifNil: [ ^ CoEmptyFetcher new ].

	^ self copy
		completionClass: completionClass superclass;
		yourself! !
!CoClassImplementedMessagesFetcher methodsFor: 'enumerating'!
entriesDo: aBlock
	
	self completionClass selectorsDo: [ :e | 
		aBlock value: (NECSelectorEntry contents: e node: astNode)]! !
!CoClassVariableFetcher methodsFor: 'enumerating'!
entriesDo: aBlock
	
	self completionClass instanceSide classVarNames do: [ :e |
		aBlock value: (NECClassVarEntry contents: e node: astNode)]! !
!CoInstanceVariableFetcher methodsFor: 'enumerating'!
entriesDo: aBlock
	
	self completionClass instVarNames do: [ :e |
		aBlock value: (NECInstVarEntry contents: e node: astNode)]! !
!CoCollectionFetcher class methodsFor: 'instance creation'!
onCollection: aCollection 
	
	^ self new
		collection: aCollection;
		yourself! !
!CoCollectionFetcher methodsFor: 'accessing'!
collection: aCollection 
	collection := aCollection! !
!CoCollectionFetcher methodsFor: 'enumerating'!
entriesDo: aBlock

	collection do: aBlock! !
!CoEmptyFetcher methodsFor: 'enumerating'!
entriesDo: aBlock

	"Nothing"! !
!CoEmptyFetcher methodsFor: 'testing'!
isEmptyCompletionFetcher
	
	^ true! !
!CoFetcher methodsFor: 'composing'!
, anotherFetcher 

	^ CoFetcherSequence new
		add: self;
		add: anotherFetcher;
		yourself! !
!CoFetcher methodsFor: 'testing'!
atEnd
	
	^ self generator atEnd! !
!CoFetcher methodsFor: 'composing'!
collect: aBlockClosure 
	
	^ CoMappingFetcher new
		decoree: self;
		collectBlock: aBlockClosure;
		yourself! !
!CoFetcher methodsFor: 'enumerating'!
entriesDo: aBlock
	"Key method for subclasses to define their semantics."
	
	^ self subclassResponsibility! !
!CoFetcher methodsFor: 'private'!
generator
	^ generator ifNil: [ 
		generator := Generator on: [ :g | 
			self entriesDo: [ :entry | g yield: entry ] ] ]! !
!CoFetcher methodsFor: 'testing'!
isEmptyCompletionFetcher
	
	^ false! !
!CoFetcher methodsFor: 'composing'!
narrowFilterBlock: aBlockClosure 
	
	^ self select: aBlockClosure! !
!CoFetcher methodsFor: 'fetching'!
next
	
	^ self generator next! !
!CoFetcher methodsFor: 'fetching'!
next: anInteger 
	
	^ Array new: anInteger streamContents: [ :stream | | total last |
		total := 0.
		[ (last := self next) ifNotNil: [ :each | 
			stream nextPut: each.
			total := total + 1 ] ]
			doWhileTrue: [ total < anInteger and: [ last notNil ] ] ]! !
!CoFetcher methodsFor: 'resetting'!
reset
	
	generator := nil! !
!CoFetcher methodsFor: 'composing'!
select: aBlockClosure 
	
	^ CoFilterFetcher new
		decoree: self;
		filterBlock: aBlockClosure;
		yourself! !
!CoFetcher methodsFor: 'enumerating'!
upToEnd
	
	^ self generator upToEnd! !
!CoFetcher methodsFor: 'composing'!
withoutFilter
	
	^ self! !
!CoFetcher methodsFor: 'composing'!
withoutRepetition

	^ CoAvoidRepeatedFetcher new
		decoree: self;
		yourself! !
!CoAvoidRepeatedFetcher methodsFor: 'enumerating'!
entriesDo: aBlock
	decoree
		entriesDo: [ :elem | 
			(self hasAlreadyReturned: elem)
				ifFalse: [ 
					"As the NECEntry does not know how to compare I will enter the content as symbol"
					elements add: elem contents asSymbol.
					aBlock value: elem ] ]! !
!CoAvoidRepeatedFetcher methodsFor: 'accessing'!
hasAlreadyReturned: anEntry

	^ elements includes: anEntry contents asSymbol! !
!CoAvoidRepeatedFetcher methodsFor: 'initialization'!
initialize

	super initialize.
	elements := Set new.! !
!CoAvoidRepeatedFetcher methodsFor: 'resetting'!
reset

	super reset.
	elements := Set new.! !
!CoFetcherDecorator class methodsFor: 'testing'!
isAbstract

	^ self == CoFetcherDecorator! !
!CoFetcherDecorator methodsFor: 'accessing'!
decoree: anotherFetcher
	
	decoree := anotherFetcher! !
!CoFetcherDecorator methodsFor: 'resetting'!
reset

	super reset.
	decoree reset.! !
!CoFilterFetcher methodsFor: 'enumerating'!
entriesDo: aBlockClosure
	decoree
		entriesDo: [ :each | 
			(filterBlock value: each)
				ifTrue: [ aBlockClosure value: each ] ]! !
!CoFilterFetcher methodsFor: 'accessing'!
filterBlock: aBlockClosure 
	
	filterBlock := aBlockClosure! !
!CoFilterFetcher methodsFor: 'composing'!
narrowFilterBlock: aBlock

	self filterBlock: aBlock! !
!CoFilterFetcher methodsFor: 'composing'!
select: aBlockClosure

	"Do not filter over a filter.
	Instead, create a new filter over the original fetcher"
	^ self withoutFilter select: aBlockClosure! !
!CoFilterFetcher methodsFor: 'composing'!
withoutFilter
	
	^ decoree! !
!CoHierarchyFetcher methodsFor: 'enumerating'!
entriesDo: aBlock
	| currentCompletionFetcher |
	currentCompletionFetcher := decoree.
	[ currentCompletionFetcher isEmptyCompletionFetcher ]
		whileFalse: [ currentCompletionFetcher entriesDo: aBlock.
			currentCompletionFetcher := currentCompletionFetcher onSuperclass ]! !
!CoMappingFetcher methodsFor: 'accessing'!
collectBlock: aBlockClosure 
	
	collectBlock := aBlockClosure! !
!CoMappingFetcher methodsFor: 'enumerating'!
entriesDo: aBlockClosure

	decoree entriesDo: [ :each | aBlockClosure value: (collectBlock value: each) ]! !
!CoFetcherSequence methodsFor: 'adding'!
add: aCompletion
	
	subcompletions add: aCompletion! !
!CoFetcherSequence methodsFor: 'resetting'!
context: anObject
	
	super context: anObject.
	subcompletions do: [ :each | each context: anObject ]! !
!CoFetcherSequence methodsFor: 'enumerating'!
entriesDo: aBlock
	subcompletions do: [ :completion | completion entriesDo: aBlock ]! !
!CoFetcherSequence methodsFor: 'initialization'!
initialize

	super initialize.
	subcompletions := OrderedCollection new! !
!CoFetcherSequence methodsFor: 'resetting'!
reset
	
	super reset.
	subcompletions do: [ :each | each reset ].! !
!CoGlobalVariableFetcher methodsFor: 'accessing'!
astNode
	^ astNode! !
!CoGlobalVariableFetcher methodsFor: 'accessing'!
astNode: anObject
	astNode := anObject! !
!CoGlobalVariableFetcher methodsFor: 'accessing'!
completionEnvironment
	^ completionEnvironment! !
!CoGlobalVariableFetcher methodsFor: 'accessing'!
completionEnvironment: anObject
	completionEnvironment := anObject! !
!CoGlobalVariableFetcher methodsFor: 'enumerating'!
entriesDo: aBlock

	completionEnvironment globals do: [ :e |
		aBlock value: (NECGlobalEntry contents: e node: astNode)]! !
!CoMethodVariableFetcher methodsFor: 'accessing'!
completionASTNode
	^ completionASTNode! !
!CoMethodVariableFetcher methodsFor: 'accessing'!
completionASTNode: anObject
	completionASTNode := anObject! !
!CoMethodVariableFetcher methodsFor: 'enumerating'!
entriesDo: aBlock

	self methodVariableNamesDo: [ :each |
		aBlock value: (NECLocalEntry contents: each node: completionASTNode) ]! !
!CoMethodVariableFetcher methodsFor: 'accessing'!
methodVariableNamesDo: aBlock

	| currentNode |
	currentNode := completionASTNode.
	[ currentNode notNil ] whileTrue: [ 
		"ASTs are strange.
		There is no way to ask the variables defined in the scope in an ordered way.
		Hack our way through"
		self flag: #notNice.
		currentNode isSequence ifTrue: [ 
			currentNode temporaryNames do: aBlock.
			currentNode parent argumentNames do: aBlock ].
		currentNode := currentNode parent ]! !
!CoPackageImplementedMessagesFetcher methodsFor: 'accessing'!
astNode
	^ astNode! !
!CoPackageImplementedMessagesFetcher methodsFor: 'accessing'!
astNode: anObject
	astNode := anObject! !
!CoPackageImplementedMessagesFetcher methodsFor: 'accessing'!
completionPackage
	^ completionPackage! !
!CoPackageImplementedMessagesFetcher methodsFor: 'accessing'!
completionPackage: anObject
	completionPackage := anObject! !
!CoPackageImplementedMessagesFetcher methodsFor: 'enumerating'!
entriesDo: aBlock
	
	SystemNavigation new allSentMessagesInPackage: completionPackage do: [ :e |
		aBlock value: (NECSelectorEntry contents: e node: astNode)]! !
!CoHeuristicBuilder methodsFor: 'adding'!
add: anHeuristic
	
	heuristics add: anHeuristic! !
!CoHeuristicBuilder methodsFor: 'building'!
build

	^ heuristics reduceRight: [ :left :right | left next: right. left ]! !
!CoHeuristicBuilder methodsFor: 'initialization'!
initialize
	super initialize.
	heuristics := OrderedCollection new! !
!CoStatisticsHeuristicBuilder methodsFor: 'adding'!
add: anHeuristic

	super add: (CoStatisticsHeuristicWrapper new
		statistics: statistics;
		wrapped: anHeuristic;
		yourself)! !
!CoStatisticsHeuristicBuilder methodsFor: 'accessing'!
statistics
	^ statistics! !
!CoStatisticsHeuristicBuilder methodsFor: 'accessing'!
statistics: anObject
	statistics := anObject! !
!CoNullFetcherHeuristic methodsFor: 'requests'!
fetcherFor: aNode inContext: anObject

	^ CoEmptyFetcher new! !
!CoNullFetcherHeuristic methodsFor: 'testing'!
isNullHeuristic
	
	^ true! !
!CoResultSet class methodsFor: 'instance creation'!
fetcher: aFetcher
	
	^ self new
		fetcher: aFetcher;
		yourself! !
!CoResultSet class methodsFor: 'instance creation'!
onContext: aCompletionContext fetcher: aFetcher
	
	^ self new
		fetcher: aFetcher;
		yourself! !
!CoResultSet methodsFor: 'accessing'!
completionToken
	
	^ completionString! !
!CoResultSet methodsFor: 'enumerating'!
ensureResults: aSize
	
	results size >= aSize ifTrue: [ ^ self ].
	self fetch: aSize - results size.! !
!CoResultSet methodsFor: 'fetching'!
fetch: anInteger 
	
	| newResults |
	newResults := fetcher next: anInteger.
	results addAll: newResults! !
!CoResultSet methodsFor: 'fetching'!
fetchAll
	
	results addAll: fetcher upToEnd! !
!CoResultSet methodsFor: 'accessing'!
fetcher
	^ fetcher! !
!CoResultSet methodsFor: 'accessing'!
fetcher: anObject

	fetcher := anObject! !
!CoResultSet methodsFor: 'api-filtering'!
filterWithString: aString 
	
	"Narrow results"
	aString size >= completionString size
		ifTrue: [ 
			"Filter existing results".
			fetcher := fetcher narrowFilterBlock: [ :e | aString isEmpty or: [ e contents beginsWith: aString ] ].
			results := results select: [ :e | aString isEmpty or: [ e contents beginsWith: aString ] ] ]
		ifFalse: [
			"Smaller filter, reset results and filter"
			results := OrderedCollection new.
			fetcher reset.
			fetcher := fetcher select: [ :e | aString isEmpty or: [ e contents beginsWith: aString ] ].
		].
	completionString := aString! !
!CoResultSet methodsFor: 'enumerating'!
first
	
	self ensureResults: 1.
	^ results first! !
!CoResultSet methodsFor: 'accessing'!
first: anInteger 

	self ensureResults: anInteger.	
	
	results size > anInteger
		ifTrue: [ ^ results first: anInteger ].
	^ results! !
!CoResultSet methodsFor: 'testing'!
hasMoreElements
	
	^ fetcher atEnd not! !
!CoResultSet methodsFor: 'initialization'!
initialize

	super initialize.
	results := OrderedCollection new.
	completionString := ''.! !
!CoResultSet methodsFor: 'testing'!
notEmpty
	
	^ results notEmpty or: [ fetcher atEnd not ]! !
!CoResultSet methodsFor: 'api-filtering'!
resetFilter
	
	results removeAll.
	fetcher := fetcher withoutFilter.! !
!CoResultSet methodsFor: 'accessing'!
results
	^ results! !
!CoResultSet methodsFor: 'accessing'!
results: anObject
	results := anObject! !
!CoASTHeuristicsResultSetBuilder methodsFor: 'heuristics'!
messageHeuristic

	^ messageHeuristic ifNil: [ messageHeuristic := self newHeuristicBuilder
		add: CoSelfMessageHeuristic new;
		add: CoSuperMessageHeuristic new;
		add: CoInitializeInferencedMessageHeuristic new;
		add: CoLiteralMessageHeuristic new;
		add: CoGlobalVariableMessageHeuristic new;
		add: CoVariableWithTypeNameMessageHeuristic new;
		add: CoVariableValueMessageHeuristic new;
		add: CoUnknownMessageHeuristic new;
		build ]! !
!CoASTHeuristicsResultSetBuilder methodsFor: 'heuristics'!
methodNodeHeuristic
	^ methodNodeHeuristic ifNil: [
		methodNodeHeuristic := self newHeuristicBuilder
		add: CoSuperMessageHeuristic new;
		add: CoUnknownMessageHeuristic new;
		build ]! !
!CoASTHeuristicsResultSetBuilder methodsFor: 'heuristics'!
newHeuristicBuilder
	^ CoHeuristicBuilder new! !
!CoASTHeuristicsResultSetBuilder methodsFor: 'heuristics'!
variablesHeuristic
	^ variablesHeuristic ifNil: [ variablesHeuristic := self newHeuristicBuilder
		add: CoLocalScopeVariablesHeuristic new;
		add: CoWorkspaceVariablesHeuristic new;
		add: CoInstanceAccessibleVariablesHeuristic new;
		add: CoGlobalVariablesHeuristic new;
		build ]! !
!CoASTHeuristicsResultSetBuilder methodsFor: 'visiting'!
visitMessageNode: aRBMessageNode 
	
	^ self
		configureFetcherForNode: aRBMessageNode
		usingHeuristicAvoidingRepetitions: self messageHeuristic
		narrowingWith: aRBMessageNode selector! !
!CoASTHeuristicsResultSetBuilder methodsFor: 'visiting'!
visitMethodNode: aRBMethodNode 

	^ self
		configureFetcherForNode: aRBMethodNode
		usingHeuristicAvoidingRepetitions: self methodNodeHeuristic
		narrowingWith: aRBMethodNode selector! !
!CoASTHeuristicsResultSetBuilder methodsFor: 'visiting'!
visitVariableNode: aRBVariableNode 

	^ self
		configureFetcherForNode: aRBVariableNode
		usingHeuristicAvoidingRepetitions: self variablesHeuristic
		narrowingWith: aRBVariableNode name! !
!CoASTSessionResultSetBuilder methodsFor: 'heuristics'!
messageHeuristic
	^ messageHeuristic ifNil: [ messageHeuristic := self newHeuristicBuilder
		add: (CoSessionMessagesHeuristic new
			session: session;
			yourself);
		add: CoUnknownMessageHeuristic new;
		build ]! !
!CoASTSessionResultSetBuilder methodsFor: 'accessing'!
session
	^ session! !
!CoASTSessionResultSetBuilder methodsFor: 'accessing'!
session: anObject
	session := anObject! !
!CoStatisticsASTHeuristicsResultSetBuilder methodsFor: 'heuristics'!
newHeuristicBuilder

	^ CoStatisticsHeuristicBuilder new
		statistics: statistics;
		yourself! !
!CoStatisticsASTHeuristicsResultSetBuilder methodsFor: 'accessing'!
statistics
	^ statistics! !
!CoStatisticsASTHeuristicsResultSetBuilder methodsFor: 'accessing'!
statistics: anObject
	statistics := anObject! !
!CoASTResultSetBuilder class methodsFor: 'testing'!
isAbstract

	^ self == CoASTResultSetBuilder! !
!CoASTResultSetBuilder methodsFor: 'accessing'!
astNode
	
	^ astNode! !
!CoASTResultSetBuilder methodsFor: 'API - building'!
buildCompletion

	"Visiting the node configures the completion for that node"
	astNode := self parseNode.
	^ astNode acceptVisitor: self! !
!CoASTResultSetBuilder methodsFor: 'API - building'!
configureEmptyFetcherForNode: aNode
	
	^ self
		configureFetcher: CoEmptyFetcher new
		forNode: aNode
		narrowingWith: ''! !
!CoASTResultSetBuilder methodsFor: 'private-building'!
configureFetcher: aFetcher forNode: aNode narrowingWith: aString
	
	| completion |
	completion := CoResultSet fetcher: aFetcher.
	completion filterWithString: aString.
	^ completion! !
!CoASTResultSetBuilder methodsFor: 'private-building'!
configureFetcherForNode: aNode usingHeuristic: heuristic narrowingWith: aString
	
	| fetcher |
	fetcher := heuristic fetcherFor: aNode inContext: completionContext.
	^ self
		configureFetcher: fetcher
		forNode: aNode
		narrowingWith: aString! !
!CoASTResultSetBuilder methodsFor: 'private-building'!
configureFetcherForNode: aNode usingHeuristicAvoidingRepetitions: heuristic narrowingWith: aString
	
	| fetcher |
	fetcher := heuristic fetcherFor: aNode inContext: completionContext.
	^ self
		configureFetcher: fetcher withoutRepetition
		forNode: aNode
		narrowingWith: aString! !
!CoASTResultSetBuilder methodsFor: 'accessing'!
node: aNode

	node := aNode! !
!CoASTResultSetBuilder methodsFor: 'API - building'!
parseNode

	^ node ifNil: [ node := (completionContext isWorkspace
		ifTrue: [ RBParser parseFaultyExpression: completionContext source ]
		ifFalse: [ RBParser parseFaultyMethod: completionContext source ])
			nodeForOffset: completionContext position ]! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitArrayNode: aRBArrayNode 
	
	^ self visitNode: aRBArrayNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitAssignmentNode: aRBAssignmentNode 
	
	^ self visitNode: aRBAssignmentNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitBlockNode: aRBBlockNode 

	^ self visitNode: aRBBlockNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitCascadeNode: aRBCascadeNode 

	^ self visitNode: aRBCascadeNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitLiteralArrayNode: aRBLiteralArrayNode 

	^ self visitNode: aRBLiteralArrayNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitLiteralValueNode: aRBLiteralValueNode 
	
	^ self visitNode: aRBLiteralValueNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitMessageNode: aRBMessageNode
	
	^ self visitNode: aRBMessageNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitMethodNode: aRBMethodNode
	
	^ self visitNode: aRBMethodNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitNode: aNode
	
	^ self configureEmptyFetcherForNode: aNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitParseErrorNode: aRBParseErrorNode 
	
	^ self visitNode: aRBParseErrorNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitPragmaNode: aRBPragmaNode

	^ self visitNode: aRBPragmaNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitReturnNode: aRBReturnNode 
	
	^ self visitNode: aRBReturnNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitSelfNode: aRBSelfNode 
	
	^ self visitNode: aRBSelfNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitSequenceNode: aRBSequenceNode 
	
	^ self visitNode: aRBSequenceNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitSuperNode: aRBSuperNode 
	
	^ self visitNode: aRBSuperNode! !
!CoASTResultSetBuilder methodsFor: 'visiting'!
visitVariableNode: aRBVariableNode
	
	^ self visitNode: aRBVariableNode! !
!CoGlobalSorterResultSetBuilder methodsFor: 'API - building'!
parseNode

	| aNewNode |
	aNewNode := super parseNode.
	aNewNode methodNode doSemanticAnalysis.
	TypingVisitor new visitNode: aNewNode methodNode.
	^ aNewNode! !
!CoGlobalSorterResultSetBuilder methodsFor: 'accessing'!
sorterClass
	
	^ sorterClass ifNil: [ completionContext class sorterClass ]! !
!CoGlobalSorterResultSetBuilder methodsFor: 'accessing'!
sorterClass: anObject
	sorterClass := anObject! !
!CoGlobalSorterResultSetBuilder methodsFor: 'visiting'!
visitNode: aNode

	| fetcher entries sorter |
	entries := aNode completionEntries: completionContext position.
	sorter := self sorterClass new context: completionContext.
	entries := sorter sortCompletionList: entries asOrderedCollection.

	fetcher := (CoCollectionFetcher onCollection: entries).

	^ self
		configureFetcher: fetcher
		forNode: aNode
		narrowingWith: (aNode completionToken: completionContext position)! !
!CoResultSetBuilder class methodsFor: 'instance creation'!
initializeOnContext: aSystemCompletionContext
	
	^ self new
		initializeOnContext: aSystemCompletionContext;
		yourself! !
!CoResultSetBuilder methodsFor: 'API - building'!
buildCompletion

	self subclassResponsibility! !
!CoResultSetBuilder methodsFor: 'accessing'!
completionContext
	^ completionContext! !
!CoResultSetBuilder methodsFor: 'accessing'!
completionContext: anObject
	completionContext := anObject! !
!CoResultSetBuilder methodsFor: 'initialization'!
initializeOnContext: aCompletionContext 
	
	completionContext := aCompletionContext! !
!CoSession methodsFor: 'vocabulary'!
addVocabulary: aString at: aDateAndTime 
	
	vocabularyCache at: aString put: aDateAndTime! !
!CoSession methodsFor: 'initialization'!
initialize

	super initialize.
	vocabularyCache := LRUCache new maximumWeight: 1000! !
!CoSession methodsFor: 'accessing'!
size
	^ vocabularyCache size! !
!CoSession methodsFor: 'accessing'!
words
	
	^ vocabularyCache keys! !
!CoStaticBenchmarks class methodsFor: 'running'!
runFor: aClass 
	
	^ self new
		scope: aClass;
		run! !
!CoStaticBenchmarks methodsFor: 'inspector'!
accuracyForCompletionIndex: completionIndexRange withPrefixSize: prefixSize
	
	| totalEntries |
	totalEntries := self totalEntriesPerPrefixSize: prefixSize.
	totalEntries = 0 ifTrue: [ ^ 0 ].
	
	^ (completionIndexRange sum: [ :index |
		(completionBenchs at: index at: prefixSize ifAbsent: [ {0} ]) first
	]) / totalEntries! !
!CoStaticBenchmarks methodsFor: 'benchmarks'!
benchCallsite: aRBMessageNode atPosition: aPosition
	
	| originalSelector |
	originalSelector := aRBMessageNode selector.
	2 to: (aRBMessageNode selector size min: 8) do: [ :index | | prefix completion candidates completionIndex previousResultsPerIndexPerPrefixSize |
	
		"The CoGlobalSorterResultSetBuilder uses the selector to pre-narrow the results"	
		prefix := originalSelector copyFrom: 1 to: index.
		aRBMessageNode selector: prefix.

		completion := builder
			node: aRBMessageNode;
			completionContext: (CoBenchmarkContext new
				callsite: aRBMessageNode;
				position: aPosition;
				yourself);
			buildCompletion.
		
		completion filterWithString: prefix.
		candidates := completion first: 10.

		completionIndex := (candidates collect: #contents) indexOf: originalSelector.
		
		previousResultsPerIndexPerPrefixSize := completionBenchs
			at: completionIndex
			at: prefix size
			ifAbsent: [ {0 . Set new } ].
		previousResultsPerIndexPerPrefixSize second add: originalSelector.
		completionBenchs
			at: completionIndex
			at: prefix size
			put: {previousResultsPerIndexPerPrefixSize first + 1 . previousResultsPerIndexPerPrefixSize second }
	].
	aRBMessageNode selector: originalSelector.! !
!CoStaticBenchmarks methodsFor: 'accessing'!
builder: aCompletionBuilder
	
	builder := aCompletionBuilder! !
!CoStaticBenchmarks methodsFor: 'inspector'!
completionIndexes
	
	^ { 1 to: 1.
	  2 to: 2.
	  3 to: 3.
	  4 to: 10.
	  0 to: 0.
	}! !
!CoStaticBenchmarks methodsFor: 'scoring'!
gradeForPrefixSize: prefixSize

	^ self accuracyForCompletionIndex: (2 to: 8) withPrefixSize: prefixSize! !
!CoStaticBenchmarks methodsFor: 'inspector'!
gtResultsTableIn: composite
	<gtInspectorPresentationOrder: 1>
	| table |
	table := composite table title: 'Results'.
	"columns"
	table
		column: 'Prefix'
		evaluated: [ :completionIndexRange | | label |
			label := '% '.
			label := label, (completionIndexRange size = 1
				ifTrue: [ 
					{ 'fail' . '1st' . '2nd' . '3rd' } at: completionIndexRange first + 1 ]
				ifFalse: [ completionIndexRange first asString , '-', completionIndexRange last asString ]).
			label ]
		width: 70.
	self prefixSizes do: [ :prefixSize |
		table
			column: prefixSize asString
			evaluated: [ :completionIndexRange | | float | 
				float := self accuracyForCompletionIndex: completionIndexRange withPrefixSize: prefixSize.
				(float * 100) printShowingDecimalPlaces: 2 ]
			width: 70 ].
	"rows"
	table display: [ 
		self completionIndexes
	].
	^ table! !
!CoStaticBenchmarks methodsFor: 'initialization'!
initialize

	super initialize.
	completionBenchs := Dictionary new! !
!CoStaticBenchmarks methodsFor: 'inspector'!
prefixSizes

	^ 2 to: 8! !
!CoStaticBenchmarks methodsFor: 'printing'!
printOn: aStream

	aStream
		print: builder;
		nextPutAll: '(';
		print: scope;
		nextPutAll: ')'! !
!CoStaticBenchmarks methodsFor: 'running'!
run
	
	scope methodsDo: [ :method |
		method parseTree nodesDo: [ :node |
			node isMessage ifTrue: [ 
				self benchCallsite: node atPosition: node keywordsIntervals first ]
		]
	]! !
!CoStaticBenchmarks methodsFor: 'accessing'!
scope: aClass 
	scope := aClass! !
!CoStaticBenchmarks methodsFor: 'scoring'!
score
	
	^ ((1 to: 7) sum: [ :i | (self gradeForPrefixSize: i + 1) / i ]) * 100 / ((1 to: 7) sum: [ :index | 1/index ])! !
!CoStaticBenchmarks methodsFor: 'inspector'!
totalEntriesPerPrefixSize: aPrefixSize

	^ completionBenchs sum: [ :benchsPerPrefix | (benchsPerPrefix at: aPrefixSize ifAbsent: [ {0} ]) first ]! !
!CoStatistics class methodsFor: 'singleton'!
reset
	
	UniqueInstance := nil! !
!CoStatistics class methodsFor: 'singleton'!
uniqueInstance
	
	^ UniqueInstance ifNil: [ 
		UniqueInstance := self new ]! !
!CoStatistics methodsFor: 'accessing'!
acceptedEntries
	
	^ acceptedEntries! !
!CoStatistics methodsFor: 'accessing'!
averageTypedCharacters
	
	| count total |
	count := 0.
	total := 0.
	acceptedEntries do: [ :entries |
		count := count + entries size.
		total := total + (entries sum: [ :entry | entry numberOfTypedCharacter ]).
	].
	
	^ count = 0
		ifTrue: [ 0 ]
		ifFalse: [ total / count ]! !
!CoStatistics methodsFor: 'accessing'!
averageTypedCharactersAt: anIndex
	
	| count total entries |
	count := total := 0.
	entries := acceptedEntries at: anIndex ifAbsent: [ ^ 0 ].
	count := count + entries size.
	total := entries sum: [ :entry | entry numberOfTypedCharacter ].
	^ count = 0
		ifTrue: [ 0 ]
		ifFalse: [ total / count ]! !
!CoStatistics methodsFor: 'accessing'!
entriesAtIndex: anInteger 
	
	^ acceptedEntries at: anInteger ifAbsentPut: [ CoEntryAcceptedEvent new ]! !
!CoStatistics methodsFor: 'accessing'!
entriesGeneratedBy: aSource

	^ acceptedEntries sum: [ :entries | 
		entries count: [ :entry | entry source = aSource ] ]! !
!CoStatistics methodsFor: 'querying'!
groupBy: aBlockClosure 
	
	^ acceptedEntries gather: [ :entriesByIndex |
		entriesByIndex select: aBlockClosure ]! !
!CoStatistics methodsFor: 'initialization'!
initialize

	super initialize.
	acceptedEntries := Dictionary new.
	cancelledCompletions := OrderedCollection new! !
!CoStatistics methodsFor: 'events'!
logAcceptEvent: anEntry
	
	| entries |
	entries := acceptedEntries at: anEntry index ifAbsentPut: [ OrderedCollection new ].
	entries add: anEntry! !
!CoStatistics methodsFor: 'events'!
logCancelCompletionFromTypedToken: typedToken inClass: aClassName withDynamicExtent: isDynamicExtent

	self logCancelEvent: (CoCompletionCancelledEvent new
		typedToken: typedToken;
		contextClassName: aClassName;
		isDynamicContext: isDynamicExtent;
		yourself)! !
!CoStatistics methodsFor: 'events'!
logCancelEvent: aCancelEntry
	
	cancelledCompletions add: aCancelEntry.
! !
!CoStatistics methodsFor: 'accessing'!
numberOfCancels
	
	^ cancelledCompletions size! !
!CoStatistics methodsFor: 'accessing'!
numberOfCancelsByClass: aClassName 
	
	^ cancelledCompletions count: [ :e | e contextClassName = aClassName ]! !
!CoStatistics methodsFor: 'accessing'!
numberOfCancelsByClassCompletions: cancelledCompletionsInClass
	
	^ cancelledCompletionsInClass sum: [ :e |
		e ifNil: [ 0 ] ifNotNil: [ e size ] ]! !
!CoStatisticsCompletionEntry class methodsFor: 'instance creation'!
on: aNECEntry
	
	^ self new
		necEntry: aNECEntry;
		yourself! !
!CoStatisticsCompletionEntry methodsFor: 'comparing'!
= anEntry
 
	^ self contents = anEntry contents! !
!CoStatisticsCompletionEntry methodsFor: 'activating'!
activateOn: aCoCompletionContext 
	
	| entry |
	entry := CoEntryAcceptedEvent new
		index: index;
		source: heuristic;
		typedToken: aCoCompletionContext completionToken;
		completedEntry: self contents.
	statistics logAcceptEvent: entry.
	necEntry activateOn: aCoCompletionContext! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
contents
	
	^ necEntry contents! !
!CoStatisticsCompletionEntry methodsFor: 'comparing'!
hash
 
	^ self contents hash! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
heuristic
	^ heuristic! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
heuristic: anObject
	heuristic := anObject! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
hightlightSymbol

	^ necEntry hightlightSymbol! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
index
	^ index! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
index: anInteger 
	
	index := anInteger! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
necEntry
	^ necEntry! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
necEntry: aNECEntry 
	"self haltIf: [ aNECEntry isKindOf: self class ]."
	necEntry := aNECEntry! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
statistics
	^ statistics! !
!CoStatisticsCompletionEntry methodsFor: 'accessing'!
statistics: anObject
	statistics := anObject! !
!CoSystemEnvironment class methodsFor: 'instance creation'!
forSmalltalkGlobals

	^ super new
		systemDictionary: Smalltalk globals;
		yourself! !
!CoSystemEnvironment class methodsFor: 'instance creation'!
new

	^ self forSmalltalkGlobals! !
!CoSystemEnvironment methodsFor: 'accessing'!
at: aString ifPresent: aBlockClosure
	
	systemDictionary at: aString ifPresent: aBlockClosure! !
!CoSystemEnvironment methodsFor: 'accessing'!
environmentAt: aKey ifPresent: aBlock
	
	^ systemDictionary at: aKey ifPresent: aBlock! !
!CoSystemEnvironment methodsFor: 'accessing'!
globals
	
	^ systemDictionary keys sorted! !
!CoSystemEnvironment methodsFor: 'accessing'!
systemDictionary: aDictionary

	systemDictionary := aDictionary! !
!CoTypeInferencer methodsFor: 'accessing'!
arguments: aCollection
	
	arguments := aCollection! !
!CoTypeInferencer methodsFor: 'inference'!
cleanupTypes

	| unknownType |
	unknownType := CoUnknownType new.
	variables valuesDo: [ :e |
		e remove: unknownType ifAbsent: [ "nothing" ] ]! !
!CoTypeInferencer methodsFor: 'visiting'!
ensureTypeOfArgumentVariable: aVariableName 
	
	^ argumentVariables
		at: aVariableName
		ifAbsentPut: [ Set new ]! !
!CoTypeInferencer methodsFor: 'visiting'!
ensureTypeOfTemporaryVariable: aVariableName 
	
	^ temporaryVariables
		at: aVariableName
		ifAbsentPut: [ Set new ]! !
!CoTypeInferencer methodsFor: 'visiting'!
ensureTypeOfVariable: aVariableName 

	^ variables
		at: aVariableName
		ifAbsentPut: [ Set new ]! !
!CoTypeInferencer methodsFor: 'inference'!
inferFrom: aClass

	self inferFrom: aClass typeGetters: true! !
!CoTypeInferencer methodsFor: 'inference'!
inferFrom: aClass typeGetters: aBoolean

	receiverClass := aClass.
	aClass allInstVarNames do: [ :each |
		self ensureTypeOfVariable: each ].
	self tryInferSelector: #initialize.
	aClass isTestCase ifTrue: [
		self tryInferSelector: #setUp ].
	
	aBoolean ifTrue: [ 
		aClass allInstVarNames do: [ :each |
			self tryInferSelector: each ] ].
	self cleanupTypes! !
!CoTypeInferencer methodsFor: 'visiting'!
inferMessageReturn: aRBMessageNode receiverType: type argumentTypes: argumentTypes

	| lookupClass inferer |
	lookupClass := aRBMessageNode receiver isSuper
		ifTrue: [ method methodClass superclass ]
		ifFalse: [ type ].
	method := lookupClass lookupSelector: aRBMessageNode selector.
	method ifNil: [ ^ { CoUnknownType new } ].
	
	"We only explore n levels and we arrived at the last one.
	But we only stop if this is not a conditional.
	"
	(level <= 0 and: [
		(#( ifTrue: ifFalse: ifTrue:ifFalse: ifNil: ifNotNil: ifNil:ifNotNil:) 
			includes: aRBMessageNode selector) not ]) ifTrue: [
				"When we stop, check fast if the looked-up method has no return, and guess self"
				aRBMessageNode selector traceCr.
				^ method ast body lastIsReturn
					ifTrue: [ { CoUnknownType new } ]
					ifFalse: [ { type } ] ].
	
	inferer := self class new
		level: level;
		arguments: argumentTypes;
		receiverClass: type.
	(receiverClass includesBehavior: type)
		ifTrue: [ inferer variables: variables ].
	^ inferer
		inferMethod: method;
		returnType! !
!CoTypeInferencer methodsFor: 'inference'!
inferMethod: aMethod

	method := aMethod.
	aMethod methodClass allInstVarNames do: [ :each |
		self ensureTypeOfVariable: each ].
	method ast acceptVisitor: self! !
!CoTypeInferencer methodsFor: 'initialization'!
initialize

	super initialize.
	level := 3.
	arguments := #().
	argumentVariables := Dictionary new.
	temporaryVariables := Dictionary new.
	variables := Dictionary new.
	returnType := OrderedCollection new.
	returnType add: CoUnknownType new! !
!CoTypeInferencer methodsFor: 'accessing'!
level
	^ level! !
!CoTypeInferencer methodsFor: 'accessing'!
level: anObject
	level := anObject! !
!CoTypeInferencer methodsFor: 'visiting'!
lookupVariableType: aVariableName 
	
	^ variables
		at: aVariableName
		ifAbsent: [ 
			argumentVariables
				at: aVariableName
				ifAbsent: [ self ensureTypeOfTemporaryVariable: aVariableName ] ]! !
!CoTypeInferencer methodsFor: 'accessing'!
receiverClass: aClass 
	receiverClass := aClass! !
!CoTypeInferencer methodsFor: 'accessing'!
returnType
	^ returnType! !
!CoTypeInferencer methodsFor: 'visiting'!
stackMessage: aBlock level: aNewLevel

	| previousLevel previousMethod previousTemporaries previousArguments |
	previousMethod := method.
	previousLevel := level.
	previousTemporaries := temporaryVariables.
	previousArguments := argumentVariables.
	level := aNewLevel.
	^ aBlock ensure: [ 
		level := previousLevel.
		method := previousMethod.
		temporaryVariables := previousTemporaries.
		argumentVariables := previousArguments ]! !
!CoTypeInferencer methodsFor: 'inference'!
tryInferSelector: aSelector

	"Try to infer types from a selector in the current class.
	If the class has no such selector, do nothing."
	
	| foundMethod |
	foundMethod := (receiverClass lookupSelector: #initialize).
	foundMethod ifNil: [ ^ self ].
	self inferMethod: foundMethod! !
!CoTypeInferencer methodsFor: 'accessing'!
variables
	^ variables! !
!CoTypeInferencer methodsFor: 'accessing'!
variables: aCollection 
	variables := aCollection! !
!CoTypeInferencer methodsFor: 'visiting'!
visitArgumentNode: aRBArgumentNode 
	
	^ self ensureTypeOfArgumentVariable: aRBArgumentNode name! !
!CoTypeInferencer methodsFor: 'visiting'!
visitArrayNode: aRBArrayNode 
	
	^ { Array }! !
!CoTypeInferencer methodsFor: 'visiting'!
visitAssignmentNode: aRBAssignmentNode 
	
	| types |
	types := self lookupVariableType: aRBAssignmentNode variable name.
	^ types addAll: (aRBAssignmentNode value acceptVisitor: self);
		yourself! !
!CoTypeInferencer methodsFor: 'visiting'!
visitBlockNode: aRBBlockNode 
	
	"Just visit the contents"
	| last |
	last := { CoUnknownType new }.
	aRBBlockNode statements do: [ :each |
		last := each acceptVisitor: self ].
	^ last! !
!CoTypeInferencer methodsFor: 'visiting'!
visitCascadeNode: aRBCascadeNode 
	
	| receiverType last |
	receiverType := aRBCascadeNode receiver acceptVisitor: self.
	aRBCascadeNode messages do: [ :each |
		last := self
			visitMessageNode: each
			receiverType: receiverType ].
	^ last! !
!CoTypeInferencer methodsFor: 'visiting'!
visitGlobalNode: aRBGlobalNode 
	
	| binding |
	binding := aRBGlobalNode binding value.
	^ { binding class }! !
!CoTypeInferencer methodsFor: 'visiting'!
visitInstanceVariableNode: aRBInstanceVariableNode 
	
	^ self ensureTypeOfVariable: aRBInstanceVariableNode name! !
!CoTypeInferencer methodsFor: 'visiting'!
visitLiteralArrayNode: aRBLiteralArrayNode 
	
	^ self visitArrayNode: aRBLiteralArrayNode! !
!CoTypeInferencer methodsFor: 'visiting'!
visitLiteralValueNode: aRBLiteralValueNode 
	
	^ { aRBLiteralValueNode value class }! !
!CoTypeInferencer methodsFor: 'visiting'!
visitMessageNode: aRBMessageNode 
	
	| receiverType |
	receiverType := aRBMessageNode receiver acceptVisitor: self.
	^ self
		visitMessageNode: aRBMessageNode
		receiverType: receiverType! !
!CoTypeInferencer methodsFor: 'visiting'!
visitMessageNode: aRBMessageNode receiverType: receiverType
	
	| argumentTypes |
	(#(new basicNew new: basicNew:) includes: aRBMessageNode selector)
		ifTrue: [ ^ receiverType collect: [ :each | each instanceSide ] ].
	
	((#( = == > < >= <= and: or:) includes: aRBMessageNode selector)
		or: [ aRBMessageNode selector beginsWith: 'is' ])
			ifTrue: [ ^ { True . False } ].
	
	(#(yourself copy) includes: aRBMessageNode selector)
		ifTrue: [ ^ receiverType ].
	
	(#(+ - / *) includes: aRBMessageNode selector)
		ifTrue: [ ^ { Number } ].
	
	"(aRBMessageNode selector = #asValueHolder)
		ifTrue: [ ^ { NewValueHolder } ]."
	
	aRBMessageNode selector = #class
		ifTrue: [ ^ receiverType collect: [ :each | each class ] ].

	argumentTypes := aRBMessageNode arguments
		collect: [ :each | each acceptVisitor: self ].
		
	^ receiverType gather: [ :type |
		self
			stackMessage: [
				self
					inferMessageReturn: aRBMessageNode
					receiverType: type
					argumentTypes: argumentTypes ]
			level: ((#( initialize setUp ) includes: aRBMessageNode selector)
				ifTrue: [level]
				ifFalse: [level - 1]) ]! !
!CoTypeInferencer methodsFor: 'visiting'!
visitMethodNode: aRBMethodNode 
	
	aRBMethodNode arguments withIndexDo: [ :each :index |
		(self ensureTypeOfArgumentVariable: each name)
			addAll: (arguments at: index)
	].
	aRBMethodNode statements do: [ :each |
		each acceptVisitor: self ].
	aRBMethodNode statements ifNotEmpty: [ :statements |
		statements last isReturn
			ifFalse: [ returnType add: method methodClass ] ]! !
!CoTypeInferencer methodsFor: 'visiting'!
visitReturnNode: aRBReturnNode 
	
	^ returnType 
		addAll: (aRBReturnNode value acceptVisitor: self);
		yourself! !
!CoTypeInferencer methodsFor: 'visiting'!
visitSelfNode: aRBSelfNode 
	
	^ { receiverClass }! !
!CoTypeInferencer methodsFor: 'visiting'!
visitSuperNode: aRBSuperNode 
	
	^ self visitSelfNode: aRBSuperNode! !
!CoTypeInferencer methodsFor: 'visiting'!
visitTemporaryNode: aRBTemporaryNode 
	
	^ self ensureTypeOfTemporaryVariable: aRBTemporaryNode name! !
!CoTypeInferencer methodsFor: 'visiting'!
visitThisContextNode: aRBThisContextNode 
	
	^ { Context }! !
!CoUnknownType methodsFor: 'comparing'!
= aType

	^ aType isKindOf: CoUnknownType! !
!CoUnknownType methodsFor: 'comparing'!
hash

	^ self class hash! !
!CoUnknownType methodsFor: 'accessing'!
instanceSide
	
	^ self! !
!CoUnknownType methodsFor: 'lookup'!
lookupSelector: aString 
	
	^ nil! !
!CoEntryAcceptedEvent methodsFor: 'accessing'!
completedEntry
	^ completedEntry! !
!CoEntryAcceptedEvent methodsFor: 'accessing'!
completedEntry: anObject
	completedEntry := anObject! !
!CoEntryAcceptedEvent methodsFor: 'accessing'!
index
	^ index! !
!CoEntryAcceptedEvent methodsFor: 'accessing'!
index: anObject
	index := anObject! !
!CoEntryAcceptedEvent methodsFor: 'accessing'!
source
	^ source! !
!CoEntryAcceptedEvent methodsFor: 'accessing'!
source: anObject
	source := anObject! !
!CoUsageEvent class methodsFor: 'testing'!
isAbstract

	^ self == CoUsageEvent! !
!CoUsageEvent methodsFor: 'accessing'!
contextClassName
	^ contextClassName! !
!CoUsageEvent methodsFor: 'accessing'!
contextClassName: anObject
	contextClassName := anObject! !
!CoUsageEvent methodsFor: 'accessing'!
isDynamicContext
	^ isDynamicContext! !
!CoUsageEvent methodsFor: 'accessing'!
isDynamicContext: anObject
	isDynamicContext := anObject! !
!CoUsageEvent methodsFor: 'accessing'!
numberOfTypedCharacter
	
	^ typedToken size! !
!CoUsageEvent methodsFor: 'accessing'!
typedToken
	^ typedToken! !
!CoUsageEvent methodsFor: 'accessing'!
typedToken: anObject
	typedToken := anObject! !
!ManifestHeuristicCompletionModel class methodsFor: 'code-critics'!
ruleReInspectorPresentationsNonlazyCodeV1FalsePositive
	^ #(#(#(#RGMethodDefinition #(#CoStaticBenchmarks #gtResultsTableIn: #false)) #'2020-03-26T14:49:28.1129+01:00') )! !
!ManifestHeuristicCompletionModel class methodsFor: 'code-critics'!
ruleReSendsDifferentSuperRuleV1FalsePositive
	^ #(#(#(#RGMethodDefinition #(#'CoSystemEnvironment class' #forSmalltalkGlobals #true)) #'2020-03-26T14:29:31.095031+01:00') )! !
!ManifestHeuristicCompletionModel class methodsFor: 'code-critics'!
ruleReTempsReadBeforeWrittenRuleV1FalsePositive
	^ #(#(#(#RGMethodDefinition #(#CoFetcher #next: #false)) #'2020-03-26T14:50:53.739628+01:00') #(#(#RGMethodDefinition #(#CoTypeInferencer #visitCascadeNode: #false)) #'2020-03-26T14:50:59.173856+01:00') )! !
!ManifestHeuristicCompletionModel class methodsFor: 'code-critics'!
ruleReUsesTrueRuleV1FalsePositive
	^ #(#(#(#RGMethodDefinition #(#CoTypeInferencer #visitMessageNode:receiverType: #false)) #'2020-03-26T14:21:20.676631+01:00') )! !

"HeuristicCompletion-Model"!
!CoCompletionEngine commentStamp: '' prior: 0!
I am an adaptor between the Morphic text morphs supporting completion and Complishon.
I contain a complishonBuilder that is used to create a complishon.

See my superclass for details!
!CoStatisticsCompletionEngine commentStamp: '' prior: 0!
I am a completion engine that logs when the menu is closed without activating an entry.!
!Workspace methodsFor: '*HeuristicCompletion-Morphic'!
bindings
	^ bindings! !
!CoCompletionEngine methodsFor: 'accessing'!
completionBuilder

	^ completionBuilder ifNil: [ CoASTHeuristicsResultSetBuilder new ]! !
!CoCompletionEngine methodsFor: 'accessing'!
completionBuilder: anObject
	completionBuilder := anObject! !
!CoCompletionEngine methodsFor: 'menu morph'!
createContext

	^ super createContext
		completionBuilder: self completionBuilder;
		yourself! !
!CoCompletionEngine methodsFor: 'accessing'!
doItContext
	"Rubric sends the morph as requestor to the compiler.
	We need to use it to keep the same semantics..."

	^ self editor model doItContext! !
!CoCompletionEngine methodsFor: 'accessing'!
doItRequestor

	^ self editor morph! !
!CoCompletionEngine methodsFor: 'initialization'!
initialize

	super initialize.
	contextClass := CoCompletionContext.! !
!CoCompletionEngine methodsFor: 'accessing'!
variableBindingNames

	self doItRequestor ifNil: [ ^ #() ].
	^ self doItRequestor model variableBindings keys! !
!CoStatisticsCompletionEngine methodsFor: 'menu morph'!
closeMenu

	context ifNotNil: [
		statistics logCancelEvent: (CoCompletionCancelledEvent new
			typedToken: context completionToken;
			contextClassName: (self contextClass 
					ifNotNil: [ :aClass | aClass name ]);
			isDynamicContext: self isScripting;
			yourself) ].
	super closeMenu! !
!CoStatisticsCompletionEngine methodsFor: 'initialization'!
initialize

	super initialize.
	statistics := CoStatistics uniqueInstance.
	completionBuilder := CoStatisticsASTHeuristicsResultSetBuilder new
		statistics: statistics;
		yourself.
	contextClass := CoStatisticsCompletionContext.! !
!RubScrolledTextModel methodsFor: '*HeuristicCompletion-Morphic'!
variableBindings
	"Required for polymorphism with the Playground"
	^ interactionModel
		ifNil: [ #() asDictionary ]
		ifNotNil: [ interactionModel bindings ]! !

"HeuristicCompletion-Morphic"!
!CoMockClass commentStamp: '' prior: 0!
I am a mock class used in the tests to get the information.!
!CoMockEnvironment commentStamp: '' prior: 0!
I am a mock environment. The tests use me to scope the environment to a known one.!
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildArrayHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBArrayNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #array! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildAssignmentHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBAssignmentNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #assignment! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildBlockHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBBlockNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #block! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildCascadeHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBCascadeNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #cascade! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildLiteralArrayHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBLiteralArrayNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #literalArray! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildLiteralHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBLiteralValueNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #literal! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildMessageHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBMessageNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #message! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildMethodHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBMethodNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #method! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildParseErrorHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBParseErrorNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #error! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildPragmaHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBPragmaNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #pragma! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildReturnHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBReturnNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #return! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildSequenceHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBSequenceNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #sequence! !
!CoASTResultSetBuilderTest methodsFor: 'tests'!
testBuildVariableHeuristic

	| builder |
	builder := CoMockASTResultSetBuilder new.
	builder
		completionContext: CoCompletionContext new;
		node: RBVariableNode new;
		buildCompletion.
		
	self assert: builder heuristic equals: #variable! !
!CoBasicCompletionTest class methodsFor: 'testing'!
isAbstract

	^ self == CoBasicCompletionTest! !
!CoBasicCompletionTest methodsFor: 'tests'!
assertCollectionOfEntry: aCollection equals: anotherCollection

	self assert: aCollection size equals: anotherCollection size.

	aCollection with: anotherCollection do: [ :a :b |
		self assertEntry: a equals: b ].! !
!CoBasicCompletionTest methodsFor: 'tests'!
assertEntry: anEntry equals: expectedEntry

	"Entries do not define equality :("
	self assert: anEntry class equals: expectedEntry class.
	self assert: anEntry contents equals: expectedEntry contents.! !
!CoBasicCompletionTest methodsFor: 'tests'!
completionClass

	^ completionClass! !
!CoBasicCompletionTest methodsFor: 'tests'!
completionEnvironment

	^ completionEnvironment! !
!CoBasicCompletionTest methodsFor: 'tests'!
innerASTNode
	| nodeInsideABlock |
	RBMethodNode
		selector: #foo
		arguments: (#(methodArgument) collect: [ :e | RBVariableNode named: e ])
		body:
			(RBSequenceNode
				temporaries: (#(methodTemporary) collect: [ :e | RBVariableNode named: e ])
				statements:
					{(RBBlockNode
						arguments: (#(blockArgument) collect: [ :e | RBVariableNode named: e ])
						body:
							(RBSequenceNode
								temporaries: (#(blockTemporary) collect: [ :e | RBVariableNode named: e ])
								statements: {(nodeInsideABlock := RBVariableNode named: '')}))}).
	^ nodeInsideABlock! !
!CoBasicCompletionTest methodsFor: 'running'!
setUp

	super setUp.
	completionClass := CoMockClass new
		instanceVariables: #(a b c);
		selectors: #(ma mb mc);
		classVariables: #(Ca Cb Cc);
		superclass: (CoMockClass new
			instanceVariables: #( supera superb superc );
			selectors: #(superma supermb supermc);
			classVariables: #(SuperCa SuperCb SuperCc);
			yourself)
		yourself.
	
	completionEnvironment := CoMockEnvironment new
		globals: {'A' . 'B' . 'C'};
		yourself! !
!CoBasicFetcherTest class methodsFor: 'testing'!
isAbstract

	^ self == CoBasicFetcherTest! !
!CoBasicFetcherTest methodsFor: 'accessing'!
fetcher
	^ fetcher! !
!CoBasicFetcherTest methodsFor: 'tests'!
testConsumedFetcherShouldBeAtEnd
	
	self fetcher upToEnd.
	self assert: self fetcher atEnd! !
!CoBasicFetcherTest methodsFor: 'tests'!
testNextShouldReturnNilAfterEnd

	self fetcher upToEnd.
	self assert: self fetcher next equals: nil! !
!CoAvoidRepeatedFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoAvoidRepeatedFetcher new
		decoree: (CoCollectionFetcher onCollection: #( a b b a c )).
	expectedElements := #(a b c).! !
!CoBasicFetcherWithElementsTest class methodsFor: 'testing'!
isAbstract

	^ self == CoBasicFetcherWithElementsTest! !
!CoBasicFetcherWithElementsTest methodsFor: 'helpers'!
firstExpectedElement

	^ expectedElements first! !
!CoBasicFetcherWithElementsTest methodsFor: 'helpers'!
secondExpectedElement

	^ expectedElements second! !
!CoBasicFetcherWithElementsTest methodsFor: 'tests'!
testNewFetcherWithElementsShouldNotBeAtEnd

	self deny: self fetcher atEnd! !
!CoBasicFetcherWithElementsTest methodsFor: 'tests'!
testNextManyAfterLimitShouldStopAfterLimit

	| fetchedElements |
	fetchedElements := self fetcher next: expectedElements size + 1.
	fetchedElements withIndexDo: [ :each :index |
		self assertEntry: each equals: (expectedElements at: index) ].
	self assert: fetchedElements size equals: expectedElements size! !
!CoBasicFetcherWithElementsTest methodsFor: 'tests'!
testNextManyShouldReturnCollection

	| fetchedElements expected |
	fetchedElements := self fetcher next: 2.
	expected := { self firstExpectedElement . self secondExpectedElement }.
	fetchedElements withIndexDo: [ :each :index |
		self assertEntry: each equals: (expected at: index) ].
	self assert: fetchedElements size equals: expected size! !
!CoBasicFetcherWithElementsTest methodsFor: 'tests'!
testNextNextShouldReturnSecondExpectedElement

	self fetcher next.
	self assertEntry: self fetcher next equals: self secondExpectedElement! !
!CoBasicFetcherWithElementsTest methodsFor: 'tests'!
testNextShouldReturnFirstElement

	self assertEntry: self fetcher next equals: self firstExpectedElement! !
!CoBasicFetcherWithElementsTest methodsFor: 'tests'!
testResetShouldRestartGenerator

	| fetchedElements |
	self fetcher upToEnd; reset.
	fetchedElements := self fetcher next: expectedElements size + 1.
	fetchedElements withIndexDo: [ :each :index |
		self assertEntry: each equals: (expectedElements at: index) ].
	self assert: fetchedElements size equals: expectedElements size! !
!CoClassVariableFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoClassVariableFetcher new.
	fetcher completionClass: self completionClass.
	expectedElements := { 
		NECClassVarEntry contents: 'Ca' node: nil. 
		NECClassVarEntry contents: 'Cb' node: nil.
		NECClassVarEntry contents: 'Cc' node: nil.}! !
!CoHierarchyClassVariableFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoClassVariableFetcher new
		completionClass: self completionClass;
		forHierarchy.
	expectedElements := { 
		NECClassVarEntry contents: 'Ca' node: nil. 
		NECClassVarEntry contents: 'Cb' node: nil.
		NECClassVarEntry contents: 'Cc' node: nil.
		NECClassVarEntry contents: 'SuperCa' node: nil. 
		NECClassVarEntry contents: 'SuperCb' node: nil.
		NECClassVarEntry contents: 'SuperCc' node: nil.}! !
!CoFilterFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoInstanceVariableFetcher new.
	fetcher completionClass: self completionClass.
	fetcher := fetcher select: [ :e | (e contents beginsWith: 'a') not ].
	expectedElements := { 
		NECInstVarEntry contents: 'b' node: nil. 
		NECInstVarEntry contents: 'c' node: nil. }! !
!CoGlobalVariableFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoGlobalVariableFetcher new.
	fetcher completionEnvironment: self completionEnvironment.
	expectedElements := { 
		NECGlobalEntry contents: 'A' node: nil.
		NECGlobalEntry contents: 'B' node: nil. 
		NECGlobalEntry contents: 'C' node: nil. }! !
!CoHierarchyImplementedSelectorsFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoClassImplementedMessagesFetcher new
		completionClass: self completionClass;
		forHierarchy.
	expectedElements := { 
		NECSelectorEntry contents: 'ma' node: nil.
		NECSelectorEntry contents: 'mb' node: nil.
		NECSelectorEntry contents: 'mc' node: nil.
		NECSelectorEntry contents: 'superma' node: nil.
		NECSelectorEntry contents: 'supermb' node: nil.
		NECSelectorEntry contents: 'supermc' node: nil.}! !
!CoImplementedSelectorsFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoClassImplementedMessagesFetcher new.
	fetcher completionClass: self completionClass.
	expectedElements := { 
		NECSelectorEntry contents: 'ma' node: nil.
		NECSelectorEntry contents: 'mb' node: nil.
		NECSelectorEntry contents: 'mc' node: nil.}! !
!CoRepeatedHierarchyImplementedSelectorsFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := (CoClassImplementedMessagesFetcher new
		completionClass: self completionClass;
		forHierarchy)
		withoutRepetition.
	self completionClass superclass
		selectors: (self completionClass superclass selectors copyWith: 'ma').
	expectedElements := { 
		NECSelectorEntry contents: 'ma' node: nil.
		NECSelectorEntry contents: 'mb' node: nil.
		NECSelectorEntry contents: 'mc' node: nil.
		NECSelectorEntry contents: 'superma' node: nil.
		NECSelectorEntry contents: 'supermb' node: nil.
		NECSelectorEntry contents: 'supermc' node: nil.}! !
!CoHierarchyInstanceVariableFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoInstanceVariableFetcher new
		completionClass: self completionClass;
		forHierarchy.
	expectedElements := { 
		NECInstVarEntry contents: 'a' node: nil. 
		NECInstVarEntry contents: 'b' node: nil.
		NECInstVarEntry contents: 'c' node: nil.
		NECInstVarEntry contents: 'supera' node: nil. 
		NECInstVarEntry contents: 'superb' node: nil.
		NECInstVarEntry contents: 'superc' node: nil. }! !
!CoInstanceVariableFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoInstanceVariableFetcher new.
	fetcher completionClass: self completionClass.
	expectedElements := { 
		NECInstVarEntry contents: 'a' node: nil. 
		NECInstVarEntry contents: 'b' node: nil.
		NECInstVarEntry contents: 'c' node: nil. }! !
!CoMethodVariablesFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoMethodVariableFetcher new.
	fetcher completionASTNode: self innerASTNode.
	expectedElements := #(blockTemporary blockArgument methodTemporary methodArgument)
		collect: [:e | NECLocalEntry contents: e node: nil ].! !
!CoSequenceFetcherTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := (CoInstanceVariableFetcher new
			completionClass: self completionClass)
				, (CoGlobalVariableFetcher new
					completionEnvironment: self completionEnvironment).
	expectedElements := { 
		NECInstVarEntry contents: 'a' node: nil. 
		NECInstVarEntry contents: 'b' node: nil.
		NECInstVarEntry contents: 'c' node: nil.
		NECGlobalEntry contents: 'A' node: nil. 
		NECGlobalEntry contents: 'B' node: nil.
		NECGlobalEntry contents: 'C' node: nil. }! !
!CoSequenceFetcherTest methodsFor: 'tests'!
testCompletionCompositionNextManyShouldStopAfterEndOfElements

	self assertCollectionOfEntry: (self fetcher next: 10) equals: expectedElements! !
!CoSequenceFetcherTest methodsFor: 'tests'!
testCompletionCompositionNextShouldReturnValuesOfSecondCompletionAfterFirst

	"Consume instance variables"
	self fetcher next: 3.
	self assertEntry: self fetcher next equals: (NECGlobalEntry contents: 'A' node: nil)! !
!CoSequenceFetcherTest methodsFor: 'tests'!
testNextManyAfterFirstSubfetcherShouldReturnCollectionWithSecondSubfetcherElements

	self
		assertCollectionOfEntry: (self fetcher next: 5)
		equals: expectedElements allButLast! !
!CoFetcherWithNoResultsTest methodsFor: 'running'!
setUp

	super setUp.
	fetcher := CoInstanceVariableFetcher new.
	fetcher completionClass: self completionClass.
	fetcher := fetcher select: [ :e | false ].! !
!CoFetcherWithNoResultsTest methodsFor: 'tests'!
testCompletionWithNoResultsShouldBeAtEnd

	self assert: self fetcher atEnd! !
!CoResultSetTest methodsFor: 'running'!
setUp

	super setUp.
	self completionClass addInstanceVariable: 'ba'.
	completion := CoResultSet
		fetcher: (CoInstanceVariableFetcher new
			completionClass: self completionClass)! !
!CoResultSetTest methodsFor: 'tests'!
testBroadenFilterAfterFetchCompletionShouldBroadenResults

	completion filterWithString: 'ba'.
	completion fetch: 1.
	completion filterWithString: 'b'.
	
	self assertEntry: completion first equals: (NECInstVarEntry contents: 'b' node: nil)! !
!CoResultSetTest methodsFor: 'tests'!
testBroaderFilterCompletionShouldBroadenResults

	completion filterWithString: 'ba'.
	completion filterWithString: 'b'.
	
	self assertEntry: completion first equals: (NECInstVarEntry contents: 'b' node: nil)! !
!CoResultSetTest methodsFor: 'tests'!
testCompletionWithElementsToFetchShouldHaveMore

	self assert: completion hasMoreElements! !
!CoResultSetTest methodsFor: 'tests'!
testCompletionWithNoElementsToFetchShouldNotHaveMore

	| c |
	c := CoResultSet fetcher: (CoInstanceVariableFetcher new
			completionClass: self completionClass).
	c fetchAll.	
	self deny: c hasMoreElements! !
!CoResultSetTest methodsFor: 'tests'!
testEnumerateShouldFetch

	self assertEntry: completion first equals: (NECInstVarEntry contents: 'a' node: nil)! !
!CoResultSetTest methodsFor: 'tests'!
testFilterCompletionAfterFetchingShouldNarrowResults

	completion fetch: 1.
	completion filterWithString: 'b'.

	self assertEntry: completion first equals: (NECInstVarEntry contents: 'b' node: nil)! !
!CoResultSetTest methodsFor: 'tests'!
testFilterTwiceWithSameCompletionShouldReturnSameResults
	
	completion filterWithString: 'ba'.
	completion fetch: 2.
	completion filterWithString: 'ba'.

	self assertCollectionOfEntry: (completion first: 2) equals: { NECInstVarEntry contents: 'ba' node: nil }! !
!CoResultSetTest methodsFor: 'tests'!
testNarrowFilterAfterFetchCompletionShouldNarrowResults

	completion filterWithString: 'b'.
	completion fetch: 1.
	completion filterWithString: 'ba'.

	self assertEntry: completion first equals: (NECInstVarEntry contents: 'ba' node: nil)! !
!CoResultSetTest methodsFor: 'tests'!
testNarrowerFilterCompletionShouldNarrowResults

	completion filterWithString: 'b'.
	completion filterWithString: 'ba'.

	self assertEntry: completion first equals: (NECInstVarEntry contents: 'ba' node: nil)! !
!CoResultSetTest methodsFor: 'tests'!
testResetFilterShouldRetrievePreviousResults

	completion filterWithString: 'b'.
	completion fetch: 5.
	completion resetFilter.

	self assertEntry: completion first equals: (NECInstVarEntry contents: 'a' node: nil)! !
!CoResultSetTest methodsFor: 'tests'!
testResetFilterWithNoFilterSetShouldNotAlterResults

	completion resetFilter.

	self assertEntry: completion first equals: (NECInstVarEntry contents: 'a' node: nil)! !
!CoStatisticsTest methodsFor: 'test-average'!
logAcceptedEvent: anIndex

	self logAcceptedEvent: anIndex typedToken: 'to'! !
!CoStatisticsTest methodsFor: 'test-average'!
logAcceptedEvent: anIndex typedToken: aToken

	| entry |
	entry := CoEntryAcceptedEvent new
		index: anIndex;
		source: 'heuristic';
		typedToken: aToken;
		completedEntry: 'toto'.
	
	statistics logAcceptEvent: entry! !
!CoStatisticsTest methodsFor: 'test-average'!
testAcceptEntryIncrementsAverage
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self logAcceptedEvent: 1 typedToken: 'tototo'.
	self assert: statistics averageTypedCharacters equals: 4! !
!CoStatisticsTest methodsFor: 'test-average'!
testAcceptEntryIncrementsAverageEvenIfAtDifferentIndexes
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self logAcceptedEvent: 2 typedToken: 'tototo'.
	self assert: statistics averageTypedCharacters equals: 4! !
!CoStatisticsTest methodsFor: 'test-entries'!
testAcceptEntryLogsAllSources

	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self logAcceptedEvent: 2.
	self assert: (statistics entriesGeneratedBy: 'heuristic') equals: 2! !
!CoStatisticsTest methodsFor: 'test-average'!
testAcceptEntryLogsAverageTypedCharacters
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self assert: statistics averageTypedCharacters equals: 2! !
!CoStatisticsTest methodsFor: 'test-average'!
testAcceptEntryLogsAverageTypedCharactersAtPosition
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self assert: (statistics averageTypedCharactersAt: 1) equals: 2! !
!CoStatisticsTest methodsFor: 'test-average'!
testAcceptEntryLogsAverageTypedCharactersDoesNotAffectOtherIndexes
	statistics := CoStatistics new.
	self logAcceptedEvent: 2.
	self assert: (statistics averageTypedCharactersAt: 1) equals: 0! !
!CoStatisticsTest methodsFor: 'test-entries'!
testAcceptEntryLogsIt
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self assert: statistics acceptedEntries notEmpty! !
!CoStatisticsTest methodsFor: 'test-entries'!
testAcceptEntryLogsItsSize
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self assert: (statistics entriesAtIndex: 1) size equals: 1! !
!CoStatisticsTest methodsFor: 'test-entries'!
testAcceptEntryLogsItsSource

	| entries |
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	
	entries := statistics groupBy: [ :e | e index = 1 and: [ e source = 'heuristic' ] ].
	
	self assert: entries size equals: 1! !
!CoStatisticsTest methodsFor: 'test-entries'!
testAcceptEntryLogsItsSourceInSeparateEntries

	| entries |
	statistics := CoStatistics new.
	self logAcceptedEvent: 2.
	entries := statistics groupBy: [ :e | e index = 1 and: [ e source = 'heuristic' ] ].
	self assert: entries size equals: 0! !
!CoStatisticsTest methodsFor: 'test-entries'!
testAcceptTwoEntriesAtDifferentIndexLogsSeparateCounts
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self logAcceptedEvent: 2.
	self assert: (statistics entriesAtIndex: 1) size equals: 1.
	self assert: (statistics entriesAtIndex: 2) size equals: 1! !
!CoStatisticsTest methodsFor: 'test-entries'!
testAcceptTwoEntriesAtSameIndexLogsCount
	statistics := CoStatistics new.
	self logAcceptedEvent: 1.
	self logAcceptedEvent: 1.
	self assert: (statistics entriesAtIndex: 1) size equals: 2! !
!CoStatisticsTest methodsFor: 'test-closing'!
testCancelCompletionInClassWithDynamicExtentDoesNotLogOtherClass

	statistics := CoStatistics new.
	statistics logCancelCompletionFromTypedToken: 'to' inClass: #Object withDynamicExtent: false.
	self assert: (statistics numberOfCancelsByClass: #Point) equals: 0! !
!CoStatisticsTest methodsFor: 'test-closing'!
testCancelCompletionInClassWithDynamicExtentLogsIt

	statistics := CoStatistics new.
	statistics logCancelCompletionFromTypedToken: 'to' inClass: #Object withDynamicExtent: false.
	self assert: statistics numberOfCancels equals: 1! !
!CoStatisticsTest methodsFor: 'test-closing'!
testCancelCompletionInClassWithDynamicExtentLogsPerClass

	statistics := CoStatistics new.
	statistics logCancelCompletionFromTypedToken: 'to' inClass: #Object withDynamicExtent: false.
	self assert: (statistics numberOfCancelsByClass: #Object) equals: 1! !
!CoStatisticsTest methodsFor: 'tests-heuristicbuilder'!
testHeuristicBuilderForSingleHeuristicBuildsWrapper

	| builder heuristic singleHeuristic |
	builder := CoStatisticsHeuristicBuilder new.
	singleHeuristic := CoGlobalVariablesHeuristic new.
	builder add: singleHeuristic.

	heuristic := builder build.
	self assert: heuristic isStatisticsHeuristicWrapper! !
!CoStatisticsTest methodsFor: 'tests-heuristicbuilder'!
testHeuristicBuilderForSingleHeuristicLastIsNullHeuristic

	| builder heuristic singleHeuristic |
	builder := CoStatisticsHeuristicBuilder new.
	singleHeuristic := CoGlobalVariablesHeuristic new.
	builder add: singleHeuristic.

	heuristic := builder build.
	self assert: heuristic next isNullHeuristic! !
!CoStatisticsTest methodsFor: 'tests-heuristicbuilder'!
testHeuristicBuilderForSingleHeuristicWrapsNonWrapper

	| builder heuristic singleHeuristic |
	builder := CoStatisticsHeuristicBuilder new.
	singleHeuristic := CoGlobalVariablesHeuristic new.
	builder add: singleHeuristic.

	heuristic := builder build.
	self assert: heuristic wrapped equals: singleHeuristic! !
!CoStatisticsTest methodsFor: 'tests-heuristicbuilder'!
testHeuristicBuilderForTwoHeuristicBuildsWrapper

	| builder heuristic heuristic1 heuristic2 |
	builder := CoStatisticsHeuristicBuilder new.
	builder add: (heuristic1 := CoGlobalVariablesHeuristic new).
	builder add: (heuristic2 := CoGlobalVariablesHeuristic new).
	heuristic := builder build.
	
	self assert: heuristic isStatisticsHeuristicWrapper! !
!CoStatisticsTest methodsFor: 'tests-heuristicbuilder'!
testHeuristicBuilderForTwoHeuristicNextIsWrapper

	| builder heuristic heuristic1 heuristic2 |
	builder := CoStatisticsHeuristicBuilder new.
	builder add: (heuristic1 := CoGlobalVariablesHeuristic new).
	builder add: (heuristic2 := CoGlobalVariablesHeuristic new).
	heuristic := builder build.
	
	self assert: heuristic next isStatisticsHeuristicWrapper! !
!CoStatisticsTest methodsFor: 'tests-heuristicbuilder'!
testHeuristicBuilderForTwoHeuristicSecondWrapperWrapsNonWrapper

	| builder heuristic heuristic1 heuristic2 |
	builder := CoStatisticsHeuristicBuilder new.
	builder add: (heuristic1 := CoGlobalVariablesHeuristic new).
	builder add: (heuristic2 := CoGlobalVariablesHeuristic new).
	heuristic := builder build.
	
	self assert: heuristic next wrapped equals: heuristic2! !
!CoStatisticsTest methodsFor: 'tests-heuristicbuilder'!
testHeuristicBuilderForTwoHeuristicWrapsNonWrapper

	| builder heuristic heuristic1 heuristic2 |
	builder := CoStatisticsHeuristicBuilder new.
	builder add: (heuristic1 := CoGlobalVariablesHeuristic new).
	builder add: (heuristic2 := CoGlobalVariablesHeuristic new).
	heuristic := builder build.
	
	self assert: heuristic wrapped equals: heuristic1! !
!CoStatisticsTest methodsFor: 'test-entries'!
testNewStatisticsHaveNoAcceptedEntries

	statistics := CoStatistics new.
	self assert: statistics acceptedEntries isEmpty! !
!CoInitializeTypeInferenceTest methodsFor: 'tests'!
testInferInstanceVariableNotUsedInInitializeHasNoType

	| types |
	types := CoTypeInferencer new
		inferFrom: (CoMockClass new
			methodAt: #initialize put: (CoMockMethod new
				source: 'initialize
					a := 1'
				yourself);
			instanceVariables: #(a b c);
			yourself);
		variables.
		
	self assert: (types at: #b) isEmpty! !
!CoInitializeTypeInferenceTest methodsFor: 'tests'!
testInferInstanceVariableUsedInInitialize

	| types |
	types := CoTypeInferencer new
		inferFrom: (CoMockClass new
			methodAt: #initialize put: (CoMockMethod new
				source: 'initialize
					a := 1'
				yourself);
			instanceVariables: #(a b c);
			yourself);
		variables.
		
	self assertCollection: (types at: #a) hasSameElements: { SmallInteger }! !
!CoInitializeTypeInferenceTest methodsFor: 'tests'!
testInferVariablesWithNoInitializeFindsNoTypes

	| types |
	types := CoTypeInferencer new
		inferFrom: (CoMockClass new
			instanceVariables: #(a b c);
			yourself);
		variables.
		
	self assert: (types values allSatisfy: [ :e | e isEmpty ]).! !
!CoSuperMessageHeuristicTest methodsFor: 'test'!
testDoesApplyForMethodNodeInContextWithSuperclass

	self assert: (CoSuperMessageHeuristic new
		appliesForNode: RBMethodNode new
		inContext: (CoCompletionContext new
			completionClass: (CoMockClass new superclass: CoMockClass new);
			yourself))! !
!CoSuperMessageHeuristicTest methodsFor: 'test'!
testDoesApplyForSuperMessageSendNodes

	self assert: (CoSuperMessageHeuristic new
		appliesForNode: (RBMessageNode receiver: RBSuperNode new selector: #foo)
		inContext: nil)! !
!CoSuperMessageHeuristicTest methodsFor: 'test'!
testDoesNotApplyForMethodNodeInContextWithNoSuperclass

	self deny: (CoSuperMessageHeuristic new
		appliesForNode: RBMethodNode new
		inContext: (CoCompletionContext new
			completionClass: (CoMockClass new superclass: nil);
			yourself))! !
!CoSuperMessageHeuristicTest methodsFor: 'test'!
testDoesNotApplyForNonSuperMessageSendNodes

	self deny: (CoSuperMessageHeuristic new
		appliesForNode: (RBMessageNode receiver: RBVariableNode new selector: #foo)
		inContext: nil)! !
!CoMockClass methodsFor: 'configuration'!
addInstanceVariable: aString 
	
	instanceVariables := instanceVariables copyWith: aString! !
!CoMockClass methodsFor: 'accessing'!
allInstVarNames
	
	| superclassVarNames |
	superclassVarNames := superclass
		ifNil: [ #() ]
		ifNotNil: [ superclass allInstVarNames ].
	^ superclassVarNames , instanceVariables ! !
!CoMockClass methodsFor: 'accessing'!
classVarNames
	
	^ classVariables! !
!CoMockClass methodsFor: 'accessing'!
classVariables: aCollection

	classVariables := aCollection! !
!CoMockClass methodsFor: 'initialization'!
initialize

	super initialize.
	methodDictionary := OrderedDictionary new! !
!CoMockClass methodsFor: 'accessing'!
instVarNames
	
	^ self instanceVariables! !
!CoMockClass methodsFor: 'accessing'!
instanceSide
	
	^ self! !
!CoMockClass methodsFor: 'accessing'!
instanceVariables
	^ instanceVariables! !
!CoMockClass methodsFor: 'accessing'!
instanceVariables: anObject
	instanceVariables := anObject! !
!CoMockClass methodsFor: 'testing'!
isTestCase
	
	^ false! !
!CoMockClass methodsFor: 'methods'!
lookupSelector: aString 
	
	^ methodDictionary
		at: aString
		ifAbsent: [ 
			superclass ifNil: [ ^ nil ].
			superclass lookupSelector: aString ]! !
!CoMockClass methodsFor: 'methods'!
methodAt: aString put: aCoMockMethod 
	
	methodDictionary at: aString asSymbol put: aCoMockMethod.
	aCoMockMethod methodClass: self! !
!CoMockClass methodsFor: 'accessing'!
selectors
	^ methodDictionary keys! !
!CoMockClass methodsFor: 'accessing'!
selectors: aCollection 

	"Install nil methods just for compatibility"
	aCollection do: [ :k |
		methodDictionary at: k put: nil
	]! !
!CoMockClass methodsFor: 'enumerating'!
selectorsDo: aBlockClosure 
	
	self selectors do: aBlockClosure! !
!CoMockClass methodsFor: 'accessing'!
superclass
	
	^ superclass! !
!CoMockClass methodsFor: 'accessing'!
superclass: aCompletionMockClass 
	
	superclass := aCompletionMockClass! !
!CoMockEnvironment methodsFor: 'accessing'!
globals
	^ globals! !
!CoMockEnvironment methodsFor: 'accessing'!
globals: anObject
	globals := anObject! !
!CoMockMethod methodsFor: 'accessing'!
ast
	^ ast! !
!CoMockMethod methodsFor: 'accessing'!
methodClass
	
	^ methodClass! !
!CoMockMethod methodsFor: 'accessing'!
methodClass: aCoMockClass 
	methodClass := aCoMockClass! !
!CoMockMethod methodsFor: 'accessing'!
source: aString 
	
	ast := RBParser parseMethod: aString ! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
heuristic

	^ heuristic! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitArrayNode: aRBArrayNode

	heuristic := #array.
	^ super visitArrayNode: aRBArrayNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitAssignmentNode: aRBAssignmentNode

	heuristic := #assignment.
	^ super visitAssignmentNode: aRBAssignmentNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitBlockNode: aNode

	heuristic := #block.
	^ super visitBlockNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitCascadeNode: aRBCascadeNode 

	heuristic := #cascade.
	^ super visitCascadeNode: aRBCascadeNode ! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitLiteralArrayNode: aNode

	heuristic := #literalArray.
	^ super visitLiteralArrayNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitLiteralValueNode: aNode

	heuristic := #literal.
	^ super visitLiteralValueNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitMessageNode: aNode

	heuristic := #message.
	^ super visitMessageNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitMethodNode: aNode

	heuristic := #method.
	^ super visitMethodNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitParseErrorNode: aNode

	heuristic := #error.
	^ super visitParseErrorNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'visiting'!
visitPragmaNode: aRBPragmaNode 

	heuristic := #pragma.
	^ super visitPragmaNode: aRBPragmaNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitReturnNode: aNode

	heuristic := #return.
	^ super visitReturnNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitSequenceNode: aNode

	heuristic := #sequence.
	^ super visitSequenceNode: aNode! !
!CoMockASTResultSetBuilder methodsFor: 'accessing'!
visitVariableNode: aNode

	heuristic := #variable.
	^ super visitVariableNode: aNode! !

"HeuristicCompletion-Tests"!
!SpLabelPresenter commentStamp: '' prior: 64476921!
I'm a LabelPresenter, made to add labels to spec components.

!! SpLabelPresenter 
A label presenter displays smalls (or medium) amounts of text.

Examples:
> self example

NOTE: In the future, it should be possible to attach another widget to a label, but for now it is not implementes.!
!SpPopoverPresenter methodsFor: 'initialization' stamp: 'Generated 7/20/2020 13:55'!
initialize
	super initialize.! !
!SpPopoverPresenter commentStamp: '' prior: 0!
I'm a popover popover. 
I will be relative to my owner, but I can be shown pointing to a particular place (see popup, and popupPointingTo:)
Also, I can be show at the top, left, bottom or right of the owner or rectangle to point.

self example

The presenter placed on a popover needs to extent SpPopoverContentPresenter (or implement its api) to gain all properties.!
!SpPopoverContentPresenter commentStamp: '' prior: 0!
I am a popover content presenter. 
All popovers contents need to extent me (to get some functionalies)!
!SpCodePopoverPrintPresenter commentStamp: '' prior: 0!
I show the result of a printing as part of a popover !
!SpPopoverContentExample commentStamp: '' prior: 0!
I am an example of a popover content.
I will show a simple text.!
!SpPopoverExample commentStamp: '' prior: 0!
I am a simple example of a popover. 
I will show a button pad to allow an user to display a popup in different places.

[[[
self new openWithSpec
]]]!
!SpTestPresenterWithToolbar commentStamp: '' prior: 0!
A presenter with a tollbar and a button to use in Window / World tests.!
!SpVerticalAlignment commentStamp: '' prior: 0!
I represent the vertical scrolling of a presenter.
You can ask the first and last index of the visible rows.
I can move the scrolling to make an element visible with the #desiredVisibleRow: method.!
!SpStyleSTONReader commentStamp: '' prior: 0!
I am a STON reader specialised on reading an SpStyle.

Contrary to my parent, I accept .class [ ... ] constructions.!
!SpMorphicOverlayAdapter commentStamp: '' prior: 0!
I'm a morphic adapter for an overlay layout. I contain a main widget and an overlay that superposes it.

Internally, I create a normal panel morph with a SpMorphicOverlayLayout.
The SpMorphicOverlayLayout collaborates with the layout's constraints to decide wether a child is the main widget or an overlay widget.!
!SpMorphicScrollableAdapter commentStamp: '' prior: 0!
I'm a morphic adapter for a scrollable layout. I contain a main widget that takes as much space as he wants and I add scrolling to it.

Internally, I create a GeneralScrollPane.
When I'm empty, I set the GeneralScrollPane's to an empty panel morph which I keep around to know if I'm empty or not.!
!SpCodeCompletionEngine commentStamp: '' prior: 0!
I'm a code completion engine.
I can have several configurations: 

- I have a completionClass, and I am not for scripting -> I will be used in a browser.
- I have a completionClass, and I am for scripting -> I will be used in an inspector.
- I do not have a completionClass, and I am not for scripting -> I am in a method without class
- I do not have a completionClass, and I am for scription -> I will be used in a workspace (playground)
!
!SpWindowResizing commentStamp: '' prior: 0!
I am emitted when a window is resized.
Collapsing and expanding a window changes the size and therefore it may 
trigger this announcement.

I provide the old and new window size.!
!SpButtonPresenter commentStamp: '' prior: 64148345!
I am a ButtonPresenter is an applicative presenter which handle a basic button.

!! SpButtonPresenter
A button who executes an =action= when pressed.

A button provides 
- action is the action performed when I am clicked.
- icon is the icon displayed on me.
- label is the text displayed on me.

Examples:
> self example

!
!SpToolCommand commentStamp: '' prior: 0!
I'm a base command to be used on spec 2 presenters. 
My children will define actions that can be executed as part of the Pharo System. 
!
!SpCodeEditionCommand commentStamp: '' prior: 0!
I'm a base command for edition in code presenters. 
Operations like "copy", "paste" will be implemented by extending me. !
!SpCodeSelectionCommand commentStamp: '' prior: 64211248!
I'm a code presenter command who's actions depends on the selected text.
In case no text is selected, the commands will take the text from cursor position to begining of line as an "ad hoc" selection.

"context" needs to conform a certain api to be used here: 

- selectedText
- selectedTextOrLine
- doItReceiver
- doItContext!
!SpSystemNavigationCommand commentStamp: '' prior: 0!
My subclasses implement commands related to system navigation.
I give a selector from a context that must:
- be a block
- evaluate to a string or symbol!
!SpBrowseClassCommand commentStamp: '' prior: 0!
I browse a class that is returned from the evaluation of my context.
My context must be a block that returns a class.!
!SpBrowseClassHierarchyCommand commentStamp: '' prior: 0!
My context must evaluate to a Behavior. I then browse the hierarchy of that behavior.!
!SpBrowseClassReferencesCommand commentStamp: '' prior: 0!
Browse all references to the class returned by the evaluation of the context.!
!SpBrowseClassVarRefsCommand commentStamp: '' prior: 0!
My context is a class, I browse the class var refs of that class.
The system navigation is in charge of executing, and will ask the user to select a variable.!
!SpBrowseClassVariablesCommand commentStamp: '' prior: 0!
My context is a class, I browse the class variables of that class.!
!SpBrowseImplementorsCommand commentStamp: '' prior: 0!
I browse all implementors of the computed context that is transformed to a selector.!
!SpBrowseInstVarRefsCommand commentStamp: '' prior: 0!
My context is a class, I browse the inst var refs of that class.
The system navigation is in charge of executing, and will ask the user to select a variable.!
!SpBrowseMethodInheritanceCommand commentStamp: '' prior: 0!
I browse the inheritance of a method - my context must evaluate to a method.!
!SpBrowseMethodReferencesCommand commentStamp: '' prior: 0!
I browse all references to the computed context that is transformed to a symbol.!
!SpBrowseMethodVersionsCommand commentStamp: '' prior: 0!
Create and schedule a message set browser on all versions of the method returned by the evaluation of the context.!
!SpBrowseMethodsContainingStringCommand commentStamp: '' prior: 0!
I browse all methods containing a string returned by the computed context.!
!SpBrowseSendersCommand commentStamp: '' prior: 0!
I browse all senders of the computed context that is transformed to a selector.!
!SpSystemDiscoveryCommand commentStamp: '' prior: 0!
My subclasses implement commands related to the live system discovery and exploration.!
!SpBrowseInstancesCommand commentStamp: '' prior: 0!
I browse all instances of the class returned by the evaluation of my context!
!SpBrowsePointersToCommand commentStamp: '' prior: 0!
I inspect all pointers to the object returned by the evaluation of my context!
!SpBrowseSubInstancesCommand commentStamp: '' prior: 0!
I browse all instances of the class (and all its subclasses) returned by the evaluation of my context !
!SpToolBarToggleButtonPresenterTest commentStamp: '' prior: 0!
A SpToolBarToggleButtonTest is a test class for testing the behavior of SpToolBarToggleButton!
!SpBoxConstraints commentStamp: '' prior: 0!
I am the constraints that can be applied to a presenter placed into a box layout.
I can define: 

- expand: the widget will expand to take all the space the layout wants to give it.
- fill: the widget will fill the space taken (this property just has sense if expand=false)
- padding: the padding let before the next presenter.
- width/height: fixed width and height to take. !
!SpMorphicToolBarMenuButtonAdapter commentStamp: '' prior: 0!
I'm the adapter used to bridge a ToolBarMenuButton and its morphic representation.!
!SpMorphicToolBarToggleButtonAdapter commentStamp: '' prior: 0!
I'm the adapter used to bridge a ToolBarToggleButton and its morphic representation.!
!SpNotebookMorph commentStamp: '' prior: 0!
I'm a tab morph used to build spec notebooks.
I extend my parent by adding special ways to add pages (allowing any widget to be a page).
I also add a toolbar to add actions.!
!SpAbstractWidgetLayout commentStamp: '' prior: 64089547!
I am a layout used for AbstractWidgetPresenters. I will manage all presenter that need to be adapted via a spec adapter for a specific binding.

Examples
--------------------

	SpAbstractWidgetLayout for: #ListAdapter
 
Internal Representation and Key Implementation Points.
--------------------

    Instance Variables
	adapterName:		<aSymbol>		Key to use in order to find the real adapter of a presenter for a specific binding.
!
!SpApplication commentStamp: '' prior: 64109721!
I'm a Spec application entry point. 
In Spec, each application needs to have a definition that concentrates its flow and resources.

!! SpApplication
A SpApplication is a class that handles many aspectes of a Spec Application (hence it's name) in a convenient fashion. 
SpApplication handles your application initialisation, configuration and resources. It also keeps the windows you have currently opened. 

!!!! Initialisation
Initialisation of an application includes (non mandatory): configure the backend you want to use, add useful resources and define a start method that will call your initial window.

!!!!!! Configure backend
Spec2 includes several backens (for the moment, Morphic and Gtk). A SpApplication configures a Morphic backend by default, but you can change it using ==#useBackend:== or ==#useBackend:with:== and sending the backend identifier and optionally a configuration (you may want to do specific backend things to configure your application behavior).

@NOTE: Is very important that after you initiate your application, you ==run== it.

Examples:
> self example1.
> self example2.

see also: *SpApplicationConfiguration*

!!!!!! Add resources
During initialisation, you may want to add special resources (like icons, themes, etc.).
While you can add your own way to access resources, SpApplication provides a property registration mechanism (a simple Dictionary and accessors), you may find useful to search at ==accessing properties== protocol.

!!!!!! Defining a start method.
This is useful to give your application a starting window (in general, this is what you want).

Example: 
[[[lang=Smalltalk
MyApplication>>start

   (self new: MyMainPresenter) openWithSpec
]]]!
!SpBoxLayout commentStamp: '' prior: 64133787!
I am a layout that will arrange presenters in a box, vertically or horizontally.
My elements can be added at the begining or at the end of the box (see add: and addLast: method families).
This layout can be created with certain properties: 

- borderWidth: the border to let empty before placing the presenters. 
- spacing: the space to let between presenters.
- homogeneous: if homogeneous, the layout will try to give same space to each presenter included.
- hAlign/vAlign: how the presenters will be aligned in the layout.!
!SpLayoutWidgetAlignment commentStamp: '' prior: 0!
I indicate the alignment of the presenter in relation with the layout.!
!SpLayoutWidgetAlignmentCenter commentStamp: '' prior: 0!
I will place the widget centered in relation to the layout.!
!SpLayoutWidgetAlignmentEnd commentStamp: '' prior: 0!
I will place the widget at the end in relation to the layout.!
!SpLayoutWidgetAlignmentStart commentStamp: '' prior: 0!
I will place the widget at the start in relation to the layout.!
!SpPopoverPosition commentStamp: '' prior: 0!
I represent the position of a popover in relation to its owner.
I am an abstract class and my children will define: top, left, bottom or right position.!
!SpPopoverPositionBottom commentStamp: '' prior: 0!
I define a popover needs to be shown at the bottom of its owner.!
!SpPopoverPositionLeft commentStamp: '' prior: 0!
I define a popover needs to be shown at the left of its owner.!
!SpPopoverPositionRight commentStamp: '' prior: 0!
I define a popover needs to be shown at the right of its owner.!
!SpPopoverPositionTop commentStamp: '' prior: 0!
I define a popover needs to be shown at the top of its owner.!
!SpValueSubscription commentStamp: '' prior: 0!
I'm a value holder subscription. 
I keep an action and I can be able to execute it.

My purpose is to give entity to the change action, so users can operate over the actions (for example unsubscribing them)!
!ManifestSpec2CodePresenter commentStamp: '' prior: 0!
I am a package part of the Spec 2 project.

Spec is a framework in Pharo for describing user interfaces. It allows for the construction of a wide variety of UIs; from small windows with a few but- tons up to complex tools like a debugger. Indeed, multiple tools in Pharo are written in Spec, e.g., Iceberg, Change Sorter, Critics Browser, and the Pharo debugger.

I contain Presenters for code editing!
!ManifestSpec2CodePresenterTests commentStamp: '' prior: 0!
I am a package part of the Spec 2 project.

Spec is a framework in Pharo for describing user interfaces. It allows for the construction of a wide variety of UIs; from small windows with a few but- tons up to complex tools like a debugger. Indeed, multiple tools in Pharo are written in Spec, e.g., Iceberg, Change Sorter, Critics Browser, and the Pharo debugger.

I contain tests for Presenters for code editing!
!ManifestSpec2MorphicPresenters commentStamp: '' prior: 0!
I am a package part of the Spec 2 project.

Spec is a framework in Pharo for describing user interfaces. It allows for the construction of a wide variety of UIs; from small windows with a few but- tons up to complex tools like a debugger. Indeed, multiple tools in Pharo are written in Spec, e.g., Iceberg, Change Sorter, Critics Browser, and the Pharo debugger.

I contain Presenters that require Morphic infrastructure!
!ManifestSpec2MorphicPresentersTests commentStamp: '' prior: 0!
I am a package part of the Spec 2 project.

Spec is a framework in Pharo for describing user interfaces. It allows for the construction of a wide variety of UIs; from small windows with a few but- tons up to complex tools like a debugger. Indeed, multiple tools in Pharo are written in Spec, e.g., Iceberg, Change Sorter, Critics Browser, and the Pharo debugger.

I contain tests for Presenters that require Morphic infrastructure!
!SpTestWorldPresenter commentStamp: '' prior: 0!
I specialized SpWorldPresenter fo test purporses.
I hold an instance of World that you can access using #currentWorld.
I allows to test a WorldPresenter in a World that is not the current world.!
!SpToolBarButtonPresenter methodsFor: 'initialization' stamp: 'Generated 7/20/2020 13:55'!
initialize
	super initialize.! !
!SpToolBarButtonPresenter commentStamp: '' prior: 0!
A button with an icon and label associated with an action and a badge !
!SpToolBarToggleButtonPresenter methodsFor: 'initialization' stamp: 'Generated 7/20/2020 13:55'!
initialize
	super initialize.! !
!SpToolBarToggleButtonPresenter commentStamp: '' prior: 0!
A toggle button which is either selected or unselected!
!SpToolBarOptionButtonPresenter commentStamp: '' prior: 0!
An option button!
!SpMorphicOverlayLayout commentStamp: '' prior: 0!
I'm a morphic layout that superposes morphs.
I have a main submorph and an overlay that is drawn on top.
To decide how to lay out each of these submorphs, they need a property named #constraints with a constraint object.
If the constraints object indicates it is an overlay object, it will be rendered on top.
Otherwise, it will be rendered first in the bottom.

Example

p := PanelMorph new
	hResizing: #spaceFill;
	vResizing: #spaceFill;
	layoutPolicy: SpMorphicOverlayLayout new.

mainMorph := Morph new
	hResizing: #spaceFill;
	vResizing: #spaceFill;
	setProperty: #constraints
	toValue: SpOverlayConstraints new.

overlay := Morph new
	hResizing: #spaceFill;
	vResizing: #spaceFill;
	color: Color green;
	setProperty: #constraints
	toValue: (SpOverlayConstraints new beOverlay; yourself);
	yourself.

p
	addMorphBack: overlay;
	addMorphBack: mainMorph.
p openInWindow!
!SpMorphicWorldAdapter commentStamp: '' prior: 0!
I am the adapter used to bridge a WorldPresenter and a WorldMorph!
!SpTHaveWrappingScrollBars methodsFor: 'accessing'!
addScrollBarStyle: aStyle

	scrollBarStyles := scrollBarStyles copyWith: aStyle! !
!SpTHaveWrappingScrollBars methodsFor: 'initialization'!
initializeTHaveWrappingScrollBars

	scrollBarStyles := #().
	self propagateNaturalWidth: false.
	self propagateNaturalHeight: false! !
!SpTHaveWrappingScrollBars methodsFor: 'testing'!
isPropagateNaturalHeight

	^ propagateNaturalHeight ifNil: [ false ]! !
!SpTHaveWrappingScrollBars methodsFor: 'testing'!
isPropagateNaturalWidth

	^ propagateNaturalWidth ifNil: [ false ]! !
!SpTHaveWrappingScrollBars methodsFor: 'accessing'!
propagateNaturalHeight: aBoolean
	"Natural height propagation means that the height of the text presenter will follow the 
	 height of the text contained"

	propagateNaturalHeight := aBoolean! !
!SpTHaveWrappingScrollBars methodsFor: 'accessing'!
propagateNaturalWidth: aBoolean
	"Natural width propagation means that the width of the text presenter will follow the 
	 width of the text contained"

	propagateNaturalWidth := aBoolean! !
!SpTHaveWrappingScrollBars methodsFor: 'accessing'!
removeScrollBarStyle: aStyle

	scrollBarStyles := scrollBarStyles copyWithout: aStyle! !
!SpTHaveWrappingScrollBars methodsFor: 'accessing'!
scrollBarStyles

	^ scrollBarStyles! !
!String methodsFor: '*Spec2-Core'!
localizedForPresenter: aPresenter

	"This message serves for the string modification for the purpose of a given Spec presenter. It may, for example, convert it to a presenter's locale. The implementation here (in the String) serves as fallback for regular strings."

	^ self! !
!String methodsFor: '*Spec2-Core'!
withAccentuatedCharacter: aCharacter

	| text index | 
	text := self asText.
	aCharacter ifNil: [ ^ text ].
	index := self asLowercase indexOf: aCharacter asLowercase.
	index isZero
		ifTrue: [ ^ text ].

	^ text
		addAttribute: TextEmphasis underlined from: index to: index;
		yourself! !
!SpMorphicTreeTableAdapter methodsFor: 'factory' prior: 64864111!
buildWidget
	| tableMorph |

	tableMorph := FTTableMorph new
		hResizing: #spaceFill;
		vResizing: #spaceFill;
		intercellSpacing: self class intercellSpacing;
		yourself.

	self addModelTo: tableMorph.
	widget := tableMorph.
	self configureScrolling.

	^ tableMorph! !
!SpMorphicTreeTableAdapter methodsFor: 'scrolling'!
configureScrolling
	self presenter verticalAlignment
		whenChangedDo: [ widget
				scrollToIndex: self presenter verticalAlignment desiredVisibleRow ].
			
	self presenter
		whenDisplayDo: [ widget
				scrollToIndex: self presenter verticalAlignment desiredVisibleRow.
			self scrollingChanged ].
		
	widget
		onAnnouncement: FTScrollingChanged
		send: #scrollingChanged
		to: self.! !
!SpMorphicTreeTableAdapter methodsFor: '*Spec2-Morphic-Backend-Tests'!
expandRowAt: anInteger
	"Click on the iconic button of a row at an index in the tree."

	| evt expandIcon |
	expandIcon := self iconOfRowMorphAt: anInteger.

	evt := MouseButtonEvent new
		setType: nil
		position: expandIcon center
		which: MouseButtonEvent redButton
		buttons: MouseButtonEvent redButton
		hand: nil
		stamp: nil.

	expandIcon mouseDown: evt.
	expandIcon mouseUp: evt! !
!SpMorphicTreeTableAdapter methodsFor: '*Spec2-Morphic-Backend-Tests'!
iconOfRowMorphAt: anInteger
	"Return the first icon of a row morph at a certain index in the tree. 
	If it is expandable, it will be an IconicButton, else it will be an empty image morph."

	| row indentCell |
	row := self rowMorphAt: anInteger.
	indentCell := row submorphs anyOne.
	"The expand icon should be an IconicButton"

	^ indentCell submorphs first! !
!SpMorphicTreeTableAdapter methodsFor: '*Spec2-Morphic-Backend-Tests'!
isRowMorphExpandableAt: anInteger
	"Return true if the row at the index has an expandable icon. This is specific to FastTable."

	^ (self iconOfRowMorphAt: anInteger) isKindOf: IconicButton! !
!SpMorphicTreeTableAdapter methodsFor: '*Spec2-Morphic-Backend-Tests'!
rowMorphAt: anInteger
	"Return the row morph at an index. Used for tests."

	^ self widget container visibleRowMorphAtIndex: anInteger! !
!SpMorphicTreeTableAdapter methodsFor: 'as yet unclassified'!
scrollToSelection
	widget ensureVisibleFirstSelection.! !
!SpMorphicTreeTableAdapter methodsFor: 'scrolling'!
scrollingChanged
	widget container updateAllRows.
	self presenter verticalAlignment
		firstVisibleRowIndex: widget firstVisibleRowIndex;
		lastVisibleRowIndex: widget lastVisibleRowIndex! !
!SpMorphicTreeTableAdapter methodsFor: 'selecting' prior: 64866240!
selectInto: aFTTableMorph paths: aCollectionOfPaths 
	
	| indexes items |
	
	items := aCollectionOfPaths collect: [ :aPath | | item |
		item := aFTTableMorph dataSource itemAtPath: aPath expanding: true.
		item 
			ifNil: [ aFTTableMorph selectIndex: 0. ^ self ].
		item ].

	aFTTableMorph refresh.
	indexes := items collect: [:item | aFTTableMorph dataSource indexOfItem: item].

	aFTTableMorph selectIndexes: indexes andMakeVisibleIf: false.! !
!SpMorphicTreeTableAdapter methodsFor: 'update' prior: 64863256!
updateSelectionOf: tableMorph
	
	self 
		selectInto: tableMorph 
		paths: self model selection selectedPaths! !
!SpTableWithFilter methodsFor: 'initialization' prior: 65285918!
initializePresenters
	<script: 'self new openWithSpec'>

	table := self newTable
		addColumn: (SpCompositeTableColumn new
			title: 'Classes';
			addColumn: ((SpImageTableColumn evaluated: #systemIcon) beNotExpandable);
			addColumn: (SpStringTableColumn evaluated: #name);
			yourself);
		items: Smalltalk allClassesAndTraits;
		itemFilter: [ :each :pattern |
			each asLowercase includesSubstring: pattern asLowercase ];
		yourself! !
!SpCheckBoxPresenter class methodsFor: 'example'!
example 

	self new 
		label: 'Example';
		state: false;
		whenActivatedDo: [ UIManager default defer: [ self inform: 'Activated' ] ];
		whenDeactivatedDo: [ UIManager default defer: [ self inform: 'Deactivated' ] ];
		openWithSpec! !
!SpToolBarPresenter class methodsFor: 'example'!
example
	| loremIpsumWords menuButton |
	
	loremIpsumWords := String loremIpsum substrings.
	^ SpToolBarPresenter new 
		beBoth;
		addItem: (SpToolBarButtonPresenter new 
			icon: (self iconNamed: #smallOk);
			label: 'Simple';
			action: [ UIManager default defer: [ self inform: 'Pressed' ] ];
			yourself);
		addItem: (SpToolBarToggleButtonPresenter new
			icon: (self iconNamed: #smallOk);
			label: 'Toggle';
			action: [ :value | UIManager default defer: [ self inform: value asString ] ];
			yourself);
		addItem: ((menuButton := SpToolBarMenuButtonPresenter new)
			label: 'Menu';
			icon: (self iconNamed: #smallOk);
			action: [ UIManager default defer: [ self inform: menuButton label ] ];
			menu: [ 
				SpMenuPresenter new
					addGroup: [ :group | group
						addItem: [ :item | item 
							name: '1: ', loremIpsumWords atRandom;
							action: [ menuButton label: item name ] ];
						addItem: [ :item | item 
							name: '2: ', loremIpsumWords atRandom;
							action: [ menuButton label: item name ] ];
						addItem: [ :item | item 
							name: '3: ', loremIpsumWords atRandom;
							action: [ menuButton label: item name ] ] ];
					yourself ];
			yourself);
		openWithSpec! !
!SpToolBarPresenter methodsFor: 'convenience' prior: 65352594!
addButtonLabel: aLabel iconNamed: anIconName help: aHelpString action: aBlock

	self addItem: (SpToolBarButtonPresenter new
		label: aLabel;
		icon: (self application iconNamed: anIconName);
		help: aHelpString;
		action: aBlock;
		yourself)! !
!SpBoxLayoutTest class methodsFor: 'testing'!
isAbstract

	^ self == SpBoxLayoutTest! !
!SpBoxLayoutTest methodsFor: 'private'!
extentOf: aPresenter

	^ aPresenter adapter widget bounds extent! !
!SpBoxLayoutTest methodsFor: 'private'!
heightOf: aPresenter

	^ (self extentOf: aPresenter) y! !
!SpBoxLayoutTest methodsFor: 'running'!
testElementsAreAddedInOrder

	| second |
	layout add: SpButtonPresenter new.
	layout add: (second := SpButtonPresenter new).
	self assert: layout children last equals: second! !
!SpBoxLayoutTest methodsFor: 'running'!
testLayoutWithOneElementIsNotEmpty

	layout add: SpButtonPresenter new.
	self deny: layout isEmpty! !
!SpBoxLayoutTest methodsFor: 'running'!
testRemoveElementFromLayoutTakesItOut

	| element |
	layout add: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: layout isEmpty! !
!SpBoxLayoutTest methodsFor: 'private'!
widthOf: aPresenter

	^ (self extentOf: aPresenter) x! !
!SpHorizontalBoxLayoutTest methodsFor: 'running'!
initializeTestedInstance

	layout := SpBoxLayout newHorizontal.
	presenter layout: layout! !
!SpHorizontalBoxLayoutTest methodsFor: 'tests'!
testPresenterExtentFollowsChildrenExtent
	| label button |

	layout 
		add: ((label := presenter newLabel) label: 'Label1');
		add: ((button := presenter newButton) label: 'Button1').
		
	self openInstance.
	
	self assert: (self widthOf: presenter) >= ((self widthOf: label) + (self widthOf: button)).
	self assert: (self heightOf: presenter) >= ((self heightOf: label) max: (self heightOf: button))! !
!SpVerticalBoxLayoutTest methodsFor: 'running'!
initializeTestedInstance

	layout := SpBoxLayout newVertical.
	presenter layout: layout! !
!SpVerticalBoxLayoutTest methodsFor: 'tests'!
testPresenterExtentFollowsChildrenExtent
	| label button |

	layout 
		add: ((label := presenter newLabel) label: 'Label1');
		add: ((button := presenter newButton) label: 'Button1').
		
	self openInstance.
	
	self assert: (self widthOf: presenter) >= ((self widthOf: label) max: (self widthOf: button)).
	self assert: (self heightOf: presenter) >= ((self heightOf: label) + (self heightOf: button))! !
!SpLayoutTest class methodsFor: 'testing'!
isAbstract

	^ self == SpLayoutTest! !
!SpLayoutTest methodsFor: 'running'!
classToTest

	^ SpEmptyPresenter! !
!SpLayoutTest methodsFor: 'running'!
testInitialLayoutIsEmpty

	self assert: layout isEmpty! !
!SpOverlayLayoutTest methodsFor: 'running'!
initializeTestedInstance

	layout := SpOverlayLayout new.
	presenter layout: layout! !
!SpOverlayLayoutTest methodsFor: 'running'!
testLayoutWithOneElementIsNotEmpty

	layout child: SpButtonPresenter new.
	self deny: layout isEmpty! !
!SpOverlayLayoutTest methodsFor: 'running'!
testLayoutWithOverlayWidgetIsNotEmpty

	layout addOverlay: SpButtonPresenter new.
	self deny: layout isEmpty! !
!SpOverlayLayoutTest methodsFor: 'running'!
testRemoveElementFromLayoutTakesItOut

	| element |
	layout child: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: layout isEmpty! !
!SpOverlayLayoutTest methodsFor: 'running'!
testRemoveOverlayFromLayoutTakesItOut

	| element |
	layout addOverlay: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: layout isEmpty! !
!SpOverlayLayoutTest methodsFor: 'running'!
testReplaceElementKeepsSingleElement

	| replacement |
	layout child: SpButtonPresenter new.
	layout child: (replacement := SpButtonPresenter new).
	self assert: layout children size equals: 1! !
!SpHorizontalPanedLayoutTest methodsFor: 'running'!
initializeTestedInstance

	layout := SpPanedLayout newHorizontal.
	presenter layout: layout! !
!SpPanedLayoutTest class methodsFor: 'testing'!
isAbstract

	^ self == SpPanedLayoutTest! !
!SpPanedLayoutTest methodsFor: 'running'!
testElementsAreAddedInOrder

	| second |
	layout addFirst: SpButtonPresenter new.
	layout addSecond: (second := SpButtonPresenter new).
	self assert: layout children last equals: second! !
!SpPanedLayoutTest methodsFor: 'running'!
testElementsAreAddedInOrderIndependentlyOfTheConfigurationOrder

	| second |
	layout addSecond: (second := SpButtonPresenter new).
	layout addFirst: SpButtonPresenter new.
	self assert: layout children last equals: second! !
!SpPanedLayoutTest methodsFor: 'running'!
testLayoutWithOneFirstElementIsNotEmpty

	layout addFirst: SpButtonPresenter new.
	self deny: layout isEmpty! !
!SpPanedLayoutTest methodsFor: 'running'!
testLayoutWithOneSecondElementIsNotEmpty

	layout addSecond: SpButtonPresenter new.
	self deny: layout isEmpty! !
!SpPanedLayoutTest methodsFor: 'running'!
testRemoveFirstElementFromLayoutTakesItOut

	| element |
	layout addFirst: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: layout isEmpty! !
!SpPanedLayoutTest methodsFor: 'running'!
testRemoveSecondElementFromLayoutTakesItOut

	| element |
	layout addSecond: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: layout isEmpty! !
!SpPanedLayoutTest methodsFor: 'running'!
testReplaceFirstElementKeepsSingleElement

	| replacement |
	layout addFirst: SpButtonPresenter new.
	layout addFirst: (replacement := SpButtonPresenter new).
	self assert: layout children size equals: 1! !
!SpPanedLayoutTest methodsFor: 'running'!
testReplaceFirstElementReplacesIt

	| replacement |
	layout addFirst: SpButtonPresenter new.
	layout addFirst: (replacement := SpButtonPresenter new).
	self assert: layout children first equals: replacement! !
!SpPanedLayoutTest methodsFor: 'running'!
testReplaceSecondElementKeepsSingleElement

	| replacement |
	layout addSecond: SpButtonPresenter new.
	layout addSecond: (replacement := SpButtonPresenter new).
	self assert: layout children size equals: 1! !
!SpPanedLayoutTest methodsFor: 'running'!
testReplaceSecondElementReplacesIt

	| replacement |
	layout addSecond: SpButtonPresenter new.
	layout addSecond: (replacement := SpButtonPresenter new).
	self assert: layout children first equals: replacement! !
!SpVerticalPanedLayoutTest methodsFor: 'running'!
initializeTestedInstance

	layout := SpPanedLayout newVertical.
	presenter layout: layout! !
!SpTest methodsFor: 'accessing'!
adapter

	^ self subclassResponsibility! !
!SpLayoutDirectionVertical methodsFor: 'testing'!
isVertical

	^ true! !
!SpLayoutDirectionVertical methodsFor: '*Spec2-Adapters-Morphic' prior: 64526076!
setRigidityOfNonExpandedMorph: aMorph

	aMorph 
		hResizing: #spaceFill; 
		vResizing: #rigid! !
!SpStyle class methodsFor: 'private' prior: 65180485!
createDefaultStyleSheet

	^ SpStyleSTONReader fromString: '
.application [
	Font { #name: "Source Sans Pro", #size: 10 },
	Geometry { #height: 25 },
	.label [
		Geometry { #hResizing: true },
		.headerError [Draw { #color:  Color{ #red: 1, #green: 0, #blue: 0, #alpha: 1}}  ],
		.headerSuccess [Draw { #color: Color{ #red: 0, #green: 1, #blue: 0, #alpha: 1}}  ],
		.header [ 
			Draw { #color: Color{ #rgb: 622413393 }},
			Font { #name: "Lucida Grande", #size: 10, #bold: true } ],
		.shortcut [ 
			Draw { #color: Color{ #rgb: 622413393 } },
			Font { #name: "Lucida Grande", #size: 10 }
		],
		.fixed [ 
			Geometry { #hResizing: false, #width: 100 }
		],
		.dim [
			Draw { #color : Color{ #rgb: 708480675 } }
		]
	],
	.link [  
		Geometry { #hResizing: true }		
	],
	.button [  
		Geometry { #width: 100 },
		.small [
		   Geometry { #width: 26 }
		]
	],
	.checkBox [  
		Geometry { #hResizing: true }
	],
	.radioButton [ 
		Geometry { #hResizing: true }
	],
	.dropList [ 
		Geometry { #width: 150, #hResizing: true }
	],
	.list [ 
		Geometry { #width: 150, #hResizing: true, #vResizing: true }
	],
	.slider [
		Geometry { #width: 150, #hResizing: true }
	],
	.actionBar [  
		Container { 
			#borderColor: Color { #rgb: 0, #alpha: 0 }, 
			#borderWidth: 2, 
			#padding: 5 },
		Geometry { #width: 150, #height: 29, #hResizing: true, #vResizing: false }
	],
	.menuBar [
		Geometry { #width: 150, #hResizing: true }
	],
	.actionButton [  
		Geometry { #width: 60, #hResizing: false },
		.showIcon [ Geometry { #width: 25 } ]
	],
	.toolBar [ 
		Geometry { #hResizing: true },
		.icons [ 
			Geometry { #height: 30 }
		],
		.iconsAndLabel [  
			Geometry { #height: 45 }
		]
	],
	.code [
		Font { #name : "Source Code Pro", #size : 10 }
	]
]
'! !
!SpAbstractTextPresenter methodsFor: 'undo-redo' prior: 64058331!
clearUndoManager

	self withAdapterDo: [ :anAdapter | anAdapter clearUndoManager ]! !
!SpAbstractTextPresenter methodsFor: 'api'!
cursorPositionIndex
	
	^self withAdapterDo: [ :anAdapter |
		anAdapter cursorPositionIndex ]! !
!SpAbstractTextPresenter methodsFor: '*Spec2-Transmission'!
defaultInputPort

	^ self inputTextPort! !
!SpAbstractTextPresenter methodsFor: '*Spec2-Transmission'!
defaultOutputPort

	^ self outputTextChangedPort! !
!SpAbstractTextPresenter methodsFor: 'TOREMOVE' prior: 64061191!
eventKeyStrokesForNextFocus
	"String describing the keystroke to perform to jump to the next widget"
	^ { Character arrowRight command ctrl asKeyCombination }! !
!SpAbstractTextPresenter methodsFor: 'TOREMOVE' prior: 64064466!
eventKeyStrokesForPreviousFocus
	"String describing the keystroke to perform to jump to the previous widget"

	^ { Character arrowLeft command ctrl asKeyCombination }! !
!SpAbstractTextPresenter methodsFor: 'initialization' prior: 64055437!
initialize
	super initialize.

	text := ''.
	placeholder := ''.
	actionToPerform := [ :txt |  ].
	readSelection := [ selection ].
	hasUnacceptedEdits := false.
	selection := 1 to: 0.
	wantsVisualFeedback := true.
	askBeforeDiscardingEdits := true.

	self registerEvents! !
!SpAbstractTextPresenter methodsFor: '*Spec2-Transmission'!
inputTextPort 

	^ SpTextPort newPresenter: self! !
!SpAbstractTextPresenter methodsFor: 'api'!
insertAndSelectAfterCurrentSelection: aString
	| selectionInterval |

	self flag: #TODO. "Does this really has to be part of the text api?"
	selectionInterval := self selectionInterval.
	self insert: aString at: selectionInterval last.
	self selectionInterval: (selectionInterval last + 1 to: selectionInterval last + aString size)! !
!SpAbstractTextPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #placeholder
	! !
!SpAbstractTextPresenter methodsFor: '*Spec2-Transmission'!
outputTextChangedPort

	^ SpTextChangedPort newPresenter: self! !
!SpAbstractTextPresenter methodsFor: '*Spec2-Adapters-Morphic' prior: 64052089!
pendingText
	"Return the current pending text"

	self withAdapterDo: [ :anAdapter | 
		anAdapter isMorphicAdapter ifTrue: [ 
			^ anAdapter pendingText ] ].
	^ self getText! !
!SpAbstractTextPresenter methodsFor: '*Spec2-Adapters-Morphic' prior: 64049543!
pendingText: aText
	"Set the pending text. Do no accept it"

	self withAdapterDo: [ :anAdapter | 
		anAdapter isMorphicAdapter 
			ifTrue: [ ^ anAdapter pendingText: aText ] ].
	self text: aText! !
!SpAbstractTextPresenter methodsFor: 'private' prior: 64058194!
rawSelection: anInterval

	self property: #selection rawValue: anInterval! !
!SpAbstractTextPresenter methodsFor: 'initialization' prior: 64063734!
registerEvents

	self whenTextChangedDo: [ self changed: #getText ].
	self whenReadSelectionIsChangedDo: [ self changed: #readSelection ].
	self property: #hasUnacceptedEdits whenChangedDo: [ :bool | self changed: #setHasUnacceptedEdits: with: {bool} ].
	self property: #selection whenChangedDo: [ :block | self changed: #setSelectionFromModel: with: {block value} ].
	self property: #wantsVisualFeedback whenChangedDo: [ :bool | self changed: #changed with: #() ].
	self property: #askBeforeDiscardingEdits whenChangedDo: [ :bool | self changed: #askBeforeDiscardingEdits: with: {bool} ]! !
!SpAbstractTextPresenter methodsFor: 'api'!
selectedText 
	| selectionInterval |
	
	selectionInterval := self selectionInterval.
	selectionInterval ifEmpty: [ ^ '' ].
	
	^ self text asString
		copyFrom: selectionInterval first 
		to: selectionInterval last! !
!SpAbstractTextPresenter methodsFor: 'api-events'!
whenResetDo: aBlock
	"This method will add a 'reset' event to the widget. It will react when user presses meta+l 
	key (this is for historical reasons)."

	self 
		bindKeyCombination: $l meta 
		toAction: aBlock! !
!SpAbstractTextPresenter methodsFor: 'api-events'!
whenSubmitDo: aBlock
	"This method will add a 'submit' event to the widget. It will react when user presses meta+s 
	key (this is for historical reasons) and (in case of text fields) with enter."

	self subclassResponsibility! !
!SpTextInputFieldPresenter methodsFor: 'initialization' prior: 65304571!
initialize
	super initialize.

	maxLength := 0.
	isPassword := false! !
!SpTextInputFieldPresenter methodsFor: 'accessing' prior: 65299150!
text: aText
	| truncatedText |

	truncatedText := self maxLength = 0
		ifTrue: [ aText ]
		ifFalse: [ aText first: (self maxLength min: aText size) ].
	super text: truncatedText! !
!SpTextInputFieldPresenter methodsFor: 'api-events'!
whenSubmitDo: aBlock
	"This method will add a 'submit' event to the widget. It will react when user presses meta+s 
	 key (this is for historical reasons) and with enter."

	self 
		bindKeyCombination: Character cr asKeyCombination | $s meta 
		toAction: aBlock! !
!SpCodePresenter class methodsFor: 'specs' prior: 64207269!
adapterName

	^ #CodeAdapter! !
!SpCodePresenter class methodsFor: 'commands'!
buildCommandsGroupWith: presenter forRoot: aCmCommandsGroup

	aCmCommandsGroup beDisplayedAsGroup.
	aCmCommandsGroup register: (self codeSelectionActionCommandsGroupWith: presenter).
	aCmCommandsGroup register: (self codeNavigationCommandsGroupWith: presenter)! !
!SpCodePresenter class methodsFor: 'commands'!
codeNavigationCommandsGroupWith: aPresenter
	| group |
	
	group := (CmCommandGroup named: 'Selection search commands') asSpecGroup.
	group
		description: 'Search the system from code selection.';
		beDisplayedAsGroup.
	group register: (SpBrowseClassCommand new 
		transform: [ :aContext | aContext findClassFromSelection ];
		asSpecCommand).	

	self flag: #TODO. "This looks like a very bad way to do this :P"	
	{ 
		SpBrowseImplementorsCommand.
		SpBrowseSendersCommand.
		SpBrowseMethodReferencesCommand.	
		SpBrowseMethodsContainingStringCommand.
	 } 
	do:[ :commandClass | 
		group register: (commandClass new 
			transform: [ :aContext | aContext selectedTextOrLine ];
			asSpecCommand) ].
	
	^ group! !
!SpCodePresenter class methodsFor: 'commands'!
codeSelectionActionCommandsGroupWith: presenter
	| group |
	
	group := (CmCommandGroup named: 'Selection action commands') asSpecGroup.
	group
		description: 'Actions on code selection.';
		beDisplayedAsGroup.
	
	SpCodeSelectionCommand allSubclassesDo: [ :cmdClass | 
		group register: (cmdClass forSpecContext: presenter) ].
	
	^ group! !
!SpCodePresenter class methodsFor: 'examples' prior: 64207434!
example
	<sampleInstance>

	^ self new
	 openWithSpec;
		text:
			'some method: 42'
! !
!SpCodePresenter class methodsFor: 'specs' prior: 64207356!
title

	^ 'Code'! !
!SpCodePresenter methodsFor: 'api-shout' prior: 64203948!
behavior
	"Return the class corresponding to the method class of the source code you are editing"
	
	^ behavior! !
!SpCodePresenter methodsFor: 'api-shout' prior: 64204116!
behavior: aClass
	"Set the class corresponding to the method class of the source code you are editing"

	behavior := aClass! !
!SpCodePresenter methodsFor: 'binding'!
bindingOf: aString

	interactionModel ifNotNil:  [ :im | ^ im bindingOf: aString  ].
	self behavior ifNotNil: [ :aBehavior | ^ aBehavior bindingOf: aString ].
	^ nil! !
!SpCodePresenter methodsFor: 'accessing'!
completionEngine

	^ completionEngine! !
!SpCodePresenter methodsFor: 'accessing'!
completionEngine: aCompletionEngine

	completionEngine := aCompletionEngine! !
!SpCodePresenter methodsFor: 'binding' prior: 64205307!
doItContext

	doItContext ifNotNil: [ ^ doItContext ].
	^ interactionModel ifNotNil: [ :im | im doItContext ]! !
!SpCodePresenter methodsFor: 'binding' prior: 64206030!
doItContext: anObject

	doItContext := anObject! !
!SpCodePresenter methodsFor: 'binding' prior: 64205836!
doItReceiver
	
	doItReceiver ifNotNil: [ 
		| receiver |
		receiver := doItReceiver.
		receiver isBehavior ifTrue: [ 
			receiver := receiver instanceSide ].
		^ receiver ].
	
	^ interactionModel ifNotNil: [ :im | im doItReceiver ]! !
!SpCodePresenter methodsFor: 'binding' prior: 64206954!
doItReceiver: anObject

	doItReceiver := anObject! !
!SpCodePresenter methodsFor: 'accessing' prior: 64204410!
findClassFrom: aString
	| ast |
	
	self flag: #TODO. "Does this really has to be part of the code api?"

	ast := RBParser parseExpression: aString onError: [ ^ nil ].
	ast nodesDo: [ :node | 
		(node isVariable and: [ node name first isUppercase ])
			ifTrue: [ 
				(self class environment classNamed: node name)
					ifNotNil: [ :aClass | ^ aClass ] ] ].

	^ nil! !
!SpCodePresenter methodsFor: 'accessing' prior: 64206525!
findClassFromSelection
	self flag: #TODO. "Does this really has to be part of the text api?"

	^ self findClassFrom: self selectedTextOrLine trimmed! !
!SpCodePresenter methodsFor: 'binding'!
hasBindingOf: aString

	interactionModel ifNotNil: [ :im | ^ im hasBindingOf: aString ].
	self behavior ifNotNil: [ :aBehavior | (aBehavior bindingOf: aString) notNil ].
	^ false! !
!SpCodePresenter methodsFor: 'binding'!
hasBindingThatBeginsWith: aString 
	
	^ interactionModel
		ifNotNil: [ :im | im hasBindingThatBeginsWith: aString ] 
		ifNil: [ false ]! !
!SpCodePresenter methodsFor: 'testing' prior: 64203325!
hasSyntaxHighlight

	^ syntaxHighlight! !
!SpCodePresenter methodsFor: 'initialization' prior: 64206139!
initialize 

	super initialize.
	
	self withSyntaxHighlight.
	
	self registerEventsForStyling.
	
	self contextMenu: [ self rootCommandsGroup asMenuPresenter ].
	self contextKeyBindings: self rootCommandsGroup asKMCategory! !
!SpCodePresenter methodsFor: 'api'!
insertPopoverAfterCurrentSelection: aPresenter

	self withAdapterDo: [ :anAdapter |
		anAdapter insertPopoverAfterCurrentSelection: aPresenter ]! !
!SpCodePresenter methodsFor: 'api'!
interactionModel

	^ interactionModel! !
!SpCodePresenter methodsFor: 'api'!
interactionModel: anObject 	

	interactionModel := anObject! !
!SpCodePresenter methodsFor: 'initialization' prior: 64207065!
registerEventsForStyling

	self whenBehaviorChangedDo: [ :class | 
		self changed: #classOrMetaClass: with: { class }.
		self changed: #getText ]! !
!SpCodePresenter methodsFor: 'api' prior: 64205385!
selectedBehavior

	self flag: #TODO. "What this is need for?"
	^ self behavior! !
!SpCodePresenter methodsFor: 'binding'!
selectedClassOrMetaClass

	behavior ifNotNil: [ ^ behavior ].
	^ interactionModel ifNotNil: [ :im | im selectedClassOrMetaClass ]! !
!SpCodePresenter methodsFor: 'api'!
selectedTextOrLine

	self selectedText ifNotEmpty: [ :aString | ^ aString ].
	
	^ self
		selectLine;
		selectedText! !
!SpCodePresenter methodsFor: 'accessing' prior: 64204859!
syntaxHighlight: aBoolean
	syntaxHighlight := aBoolean ! !
!SpCodePresenter methodsFor: 'api-events' prior: 64206657!
whenBehaviorChangedDo: aBlock
	"Set a block to perform when the behavior class changed"
	
	self 
		property: #behavior 
		whenChangedDo: aBlock! !
!SpCodePresenter methodsFor: 'api-events'!
whenCompletionEngineChangedDo: aBlock
	"Set a block to perform when the syntax highlight is enabled/disabled"
	
	self property: #completionEngine whenChangedDo: aBlock! !
!SpCodePresenter methodsFor: 'api-events' prior: 64205087!
whenSyntaxHighlightChangedDo: aBlock
	"Set a block to perform when the syntax highlight is enabled/disabled"

	self property: #syntaxHighlight whenChangedDo: aBlock! !
!SpCodePresenter methodsFor: 'api' prior: 64206851!
withSyntaxHighlight
	self syntaxHighlight: true! !
!SpCodePresenter methodsFor: 'api' prior: 64204751!
withoutSyntaxHighlight
	self syntaxHighlight: false! !
!SpTextPresenter class methodsFor: 'commands'!
buildEditionCommandsGroupFor: presenterInstance
	| rootCommandGroup |

	rootCommandGroup := CmCommandGroup forSpec beRoot.
	self 
		buildEditionCommandsGroupWith: presenterInstance 
		forRoot: rootCommandGroup.
	
	^ rootCommandGroup! !
!SpTextPresenter class methodsFor: 'commands'!
buildEditionCommandsGroupWith: presenter forRoot: aCmCommandsGroup

	aCmCommandsGroup beDisplayedAsGroup.
	aCmCommandsGroup register: (self codeEditionCommandsGroupWith: presenter).
	aCmCommandsGroup register: (self codeAcceptCommandsGroupWith: presenter)! !
!SpTextPresenter class methodsFor: 'commands'!
codeAcceptCommandsGroupWith: aPresenter

	^ (CmCommandGroup named: 'Accept commands') asSpecGroup
		description: 'Accept or cancel changes.';
		beDisplayedAsGroup;
		register: (SpAcceptChangesCommand forSpecContext: aPresenter);
		register: (SpCancelChangesCommand forSpecContext: aPresenter);
		yourself! !
!SpTextPresenter class methodsFor: 'commands'!
codeEditionCommandsGroupWith: aPresenter
	| group |

	group := (CmCommandGroup named: 'Selection edition commands') asSpecGroup.
	group
		description: 'Edit code selection.';
		beDisplayedAsGroup.
	
	SpCodeEditionCommand allSubclassesDo: [ :commandClass | 
		group register: (commandClass forSpecContext: aPresenter) ].
	
	^ group! !
!SpTextPresenter methodsFor: 'api'!
beEditable

	self editable: true! !
!SpTextPresenter methodsFor: 'api'!
beNotEditable

	self editable: false! !
!SpTextPresenter methodsFor: 'accessing'!
editable: aBoolean

	editable := aBoolean! !
!SpTextPresenter methodsFor: 'private'!
editionCommandsGroup

	^ SpRecursiveContextSetter 
		visit: (self class buildEditionCommandsGroupFor: self defaultCommandsContext) 
		toSetContext: self defaultCommandsContext! !
!SpTextPresenter methodsFor: 'accessing'!
editionContextKeyBindings

	^ self editionCommandsGroup asKMCategory! !
!SpTextPresenter methodsFor: 'accessing'!
editionContextMenu

	^ self editionCommandsGroup asMenuPresenter! !
!SpTextPresenter methodsFor: 'testing'!
hasEditionContextMenu

	^ editionContextMenu! !
!SpTextPresenter methodsFor: 'initialization' prior: 65311352!
initialize 

	super initialize.
	self initializeTHaveWrappingScrollBars.
	self flag: #REVIEW. "We really need scrollValue?"
	scrollValue := 0@0.
	self beEditable.
	self withScrollBars.
	self withEditionContextMenu.! !
!SpTextPresenter methodsFor: 'testing'!
isEditable

	^ editable! !
!SpTextPresenter methodsFor: 'api-events'!
whenEditableChangedDo: aBlock

	self property: #editable whenChangedDo: aBlock! !
!SpTextPresenter methodsFor: 'api-events'!
whenSubmitDo: aBlock
	"This method will add a 'submit' event to the widget. It will react when user presses meta+s 
	 key (this is for historical reasons) and with enter."

	self 
		bindKeyCombination: $s meta 
		toAction: [ aBlock value: self text ]! !
!SpTextPresenter methodsFor: 'accessing'!
withEditionContextMenu

	editionContextMenu := true! !
!SpTextPresenter methodsFor: 'accessing'!
withoutEditionContextMenu

	editionContextMenu := true! !
!SpAbstractWidgetPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #help
	! !
!SpAbstractWidgetPresenter methodsFor: 'private'!
replaceLayoutWith: aLayout
	"do nothing, widgets do not have updatable layouts"! !
!SpImagePresenter class methodsFor: 'specs' prior: 64455403!
adapterName

	^ #ImageAdapter! !
!SpImagePresenter methodsFor: 'api' prior: 64454829!
action

	^ action! !
!SpImagePresenter methodsFor: 'api' prior: 64455198!
action: aBlock
	"Set the action of the image"
	action := aBlock! !
!SpImagePresenter methodsFor: 'api' prior: 64455124!
autoScale
	^ autoScale! !
!SpImagePresenter methodsFor: 'api' prior: 64454378!
autoScale: aBoolean
	autoScale := aBoolean! !
!SpImagePresenter methodsFor: 'api' prior: 64454762!
image

	^ image! !
!SpImagePresenter methodsFor: 'api' prior: 64455313!
image: aForm
	
	image := aForm! !
!SpImagePresenter methodsFor: 'initialization' prior: 64455006!
initialize
	super initialize.
	action := [  ].
	autoScale := false! !
!SpImagePresenter methodsFor: 'api' prior: 64454898!
switchAutoscale
	autoScale := autoScale not.
! !
!SpImagePresenter methodsFor: 'events' prior: 64454475!
whenAutoScaleChangeDo: aBlockClosure
	self property: #autoScale whenChangedDo: aBlockClosure! !
!SpImagePresenter methodsFor: 'events' prior: 64454622!
whenImageChangeDo: aBlockClosure 
	
	self property: #image whenChangedDo: aBlockClosure ! !
!SpLabelPresenter class methodsFor: 'example'!
example
	"This example opens a spec window with a label."

	^ SpLabelPresenter new
		label: 'Label example';
		openWithSpec.! !
!SpLabelPresenter methodsFor: 'initialization' prior: 64478008!
defaultColor

	self flag: #TOREMOVE. "This needs to be removed"
	^ self theme textColor! !
!SpLabelPresenter methodsFor: 'transmission'!
defaultInputPort

	^ self inputLabelPort! !
!SpLabelPresenter methodsFor: 'initialization' prior: 64478107!
initialize
	super initialize.

	label := ''.
	self whenLabelChangedDo: [ self changed: #getText ]! !
!SpLabelPresenter methodsFor: 'transmission'!
inputLabelPort

	^ SpLabelPort newPresenter: self! !
!SpLabelPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #label
		! !
!SpLinkPresenter class methodsFor: 'specs' prior: 64537583!
adapterName
	^ #LinkAdapter! !
!SpLinkPresenter methodsFor: 'api' prior: 64536182!
action
	^ action! !
!SpLinkPresenter methodsFor: 'api' prior: 64537360!
action: aBlock
	action := aBlock! !
!SpLinkPresenter methodsFor: 'initialization' prior: 64536863!
defaultColor
	^ nil! !
!SpLinkPresenter methodsFor: 'initialization' prior: 64536944!
initialize
	super initialize.

	self whenLabelChangedDo: [ self changed: #getText ]! !
!SpLinkPresenter methodsFor: 'api' prior: 64536117!
label
	^ label! !
!SpLinkPresenter methodsFor: 'api' prior: 64537275!
label: aString
	^ label := aString! !
!SpLinkPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #label
		! !
!SpLinkPresenter methodsFor: 'api' prior: 64536375!
url: aString
	self action: [ WebBrowser openOn: aString ].
	self label ifNil: [ self label: aString ]! !
!SpLinkPresenter methodsFor: 'enumerating' prior: 64537451!
whenActionChangedDo: aBlock
	self property: #action whenChangedDo: aBlock! !
!SpLinkPresenter methodsFor: 'enumerating' prior: 64536535!
whenLabelChangedDo: aBlock
	self property: #label whenChangedDo: aBlock! !
!SpLinkPresenter methodsFor: 'enumerating' prior: 64536257!
whenUrlChangedDo: aBlock
	self property: #url whenChangedDo: aBlock! !
!SpMenuPresenter methodsFor: 'api-building' prior: 64595563!
buildWithSpecAsPopup

	^ self buildWithSpec! !
!SpMenuPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #title
	! !
!SpMenuPresenter methodsFor: 'TOREMOVE' prior: 64597175!
neglect: aModel

	aModel neglectMenuModel: self! !
!SpMorphPresenter class methodsFor: 'specs' prior: 64651846!
adapterName

	^ #MorphAdapter! !
!SpMorphPresenter methodsFor: 'handling transmission'!
defaultInputPort

	^ self inputMorphPort! !
!SpMorphPresenter methodsFor: 'initialization' prior: 64651685!
initialize
	super initialize.! !
!SpMorphPresenter methodsFor: 'handling transmission'!
inputMorphPort 

	^ SpMorphPort newPresenter: self! !
!SpMorphPresenter methodsFor: 'accessing' prior: 64651772!
morph
	^ morph! !
!SpMorphPresenter methodsFor: 'accessing' prior: 64651459!
morph: aMorph

	morph := aMorph! !
!SpMorphPresenter methodsFor: 'api-events' prior: 64651549!
whenMorphChangedDo: aBlock 

	self property: #morph whenChangedDo: aBlock! !
!SpPopoverPresenter class methodsFor: 'specs'!
adapterName

	^ #PopoverAdapter! !
!SpPopoverPresenter class methodsFor: '*Spec2-Examples'!
example

	^ SpPopoverExample new openWithSpec! !
!SpPopoverPresenter methodsFor: 'api'!
bePositionBottom

	self position: SpPopoverPosition bottom! !
!SpPopoverPresenter methodsFor: 'api'!
bePositionLeft

	self position: SpPopoverPosition left! !
!SpPopoverPresenter methodsFor: 'api'!
bePositionRight

	self position: SpPopoverPosition right! !
!SpPopoverPresenter methodsFor: 'api'!
bePositionTop

	self position: SpPopoverPosition top! !
!SpPopoverPresenter methodsFor: 'api'!
dismiss 

	^ self withAdapterDo: [ :anAdapter | anAdapter dismiss ]! !
!SpPopoverPresenter methodsFor: 'initialization' prior: 33726160!
initialize

	super initialize.
	self bePositionBottom! !
!SpPopoverPresenter methodsFor: 'api'!
popup
	"shows the popup, relative to #relativeTo"

	self adapter ifNil: [ self buildWithSpec ].
	self withAdapterDo: [ :anAdapter |
		anAdapter popup ]! !
!SpPopoverPresenter methodsFor: 'api'!
popupPointingTo: aRectangle
	"shows the popup, relative to #relativeTo, and pointing to aRectangle"

	self adapter ifNil: [ self buildWithSpec ].
	self withAdapterDo: [ :anAdapter |
		anAdapter popupPointingTo: aRectangle ]! !
!SpPopoverPresenter methodsFor: 'api'!
position

	^ position! !
!SpPopoverPresenter methodsFor: 'api'!
position: aPosition

	position := aPosition! !
!SpPopoverPresenter methodsFor: 'api'!
presenter
	^ presenter! !
!SpPopoverPresenter methodsFor: 'api'!
presenter: aPresenter

	aPresenter owner: self.
	presenter := aPresenter! !
!SpPopoverPresenter methodsFor: 'api'!
relativeTo

	^ relativeTo ifNil: [ self owner ]! !
!SpPopoverPresenter methodsFor: 'api'!
relativeTo: aPresenter

	relativeTo := aPresenter! !
!SpPopoverPresenter methodsFor: 'api-events'!
whenPresenterChangedDo: aBlock

	self property: #presenter whenChangedDo: aBlock! !
!SpTreeTablePresenter methodsFor: 'transmission'!
defaultInputPort

	^ self inputRootsPort! !
!SpTreeTablePresenter methodsFor: 'transmission'!
defaultOutputPort

	^ self outputSelectionPort! !
!SpTreeTablePresenter methodsFor: 'initialization' prior: 65419670!
initialize
	super initialize.
	self initializeTSearchable.

	self withScrollBars.
	
	activationBlock := [ ].
	
	showColumnHeaders := true.
	columns := #().
	isResizable := false.
	childrenBlock := [ :item | #() ].
	roots := #().
	lazilyComputeChildren := false.
	verticalAlignment := SpVerticalAlignment new.


	self beSingleSelection.
	self activateOnDoubleClick.
	self registerEvents! !
!SpTreeTablePresenter methodsFor: 'transmission'!
inputRootsPort

	^ SpRootsPort newPresenter: self! !
!SpTreeTablePresenter methodsFor: 'api'!
lazilyComputeChildren
	"When we compute lazily the children, we will show in all cases the expand arrow even if there is no children until we open this children."

	lazilyComputeChildren := true! !
!SpTreeTablePresenter methodsFor: 'accessing'!
lazilyComputeChildren: aBoolean
	lazilyComputeChildren := aBoolean! !
!SpTreeTablePresenter methodsFor: 'transmission'!
outputActivationPort
	
	^ SpActivationPort newPresenter: self! !
!SpTreeTablePresenter methodsFor: 'transmission'!
outputSelectionPort
	
	^ SpSelectionPort newPresenter: self! !
!SpTreeTablePresenter methodsFor: 'api'!
selectPath: aPath scrollToSelection: shouldScrollToSelection

	self selectPath: aPath.
	shouldScrollToSelection ifTrue: [ adapter scrollToSelection ]! !
!SpTreeTablePresenter methodsFor: 'testing'!
shouldLazilyComputeChildren
	^ lazilyComputeChildren! !
!SpTreeTablePresenter methodsFor: 'accessing'!
verticalAlignment
	^ verticalAlignment! !
!SpAbstractSelectionModeTest methodsFor: 'running'!
tearDown 
	presenter delete! !
!SpDemo class methodsFor: 'specs' prior: 64276479!
defaultSpec

	^ SpBoxLayout newVertical
		add: #menu withConstraints: [ :constraints | constraints height: self toolbarHeight ];
		add:
			(SpPanedLayout newHorizontal
				position: 200;
				add: #list;
				add: #page;
				yourself);
		yourself! !
!SpAbstractListAdapterSingleSelectionTest methodsFor: 'running'!
tearDown 
	presenter delete.! !
!SpAbstractListAdapterSingleSelectionTest methodsFor: 'tests-model-to-widget'!
testSelectPresenterWithScrollingMakeSelectedItemVisible
	| visibleItems |

	"TreeTable presenter does not have the same API, do not run the test"
	presenter class adapterName = #TreeTableAdapter ifTrue: [ ^ self ].
	
	self flag: 'TODO: remove the following guard clause once scrolling is implemented on SpComponentListPresenter'.
	presenter class adapterName = #ComponentListAdapter ifTrue: [ ^ self ].
	
	presenter
		items: (1 to: 200);
		selectIndex: 150 scrollToSelection: true;
		openWithSpec.
		
	visibleItems := presenter verticalAlignment firstVisibleRowIndex to: presenter verticalAlignment lastVisibleRowIndex.
		
	self assert: (visibleItems includes: presenter selection selectedIndex)! !
!SpAbstractListAdapterSingleSelectionTest methodsFor: 'tests-model-to-widget'!
testSelectPresenterWithoutScrollingDoesNotScroll
	| visibleItems verticalAlignment |
	
	"TreeTable presenter does not have the same API, do not run the test"
	presenter class adapterName = #TreeTableAdapter ifTrue: [ ^ self ].
	
	self flag: 'TODO: remove the following guard clause once scrolling is implemented on SpComponentListPresenter'.
	presenter class adapterName = #ComponentListAdapter ifTrue: [ ^ self ].
	
	presenter 
		items: (1 to: 200);
		openWithSpec.
	verticalAlignment := presenter verticalAlignment.		
	visibleItems := verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex.
	
	presenter selectIndex: 150 scrollToSelection: false.
			
	self 
		assert: (verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex) 
		equals: visibleItems! !
!Text methodsFor: '*Spec2-Core'!
localizedForPresenter: aPresenter

	^ self asString! !
!Text methodsFor: '*Spec2-Core'!
withAccentuatedCharacter: aCharacter

	| text index | 
	text := self copy.
	aCharacter ifNil: [ ^ text ].
	index := self asString asLowercase indexOf: aCharacter asLowercase.
	index isZero
		ifTrue: [ ^ text ].

	^ text
		addAttribute: TextEmphasis underlined from: index to: index;
		yourself! !
!FTUnsortedSortingState methodsFor: '*Spec2-Adapters-Morphic'!
isSorted 
	^ false! !
!SpLayoutDirectionHorizontal methodsFor: 'testing'!
isHorizontal

	^ true! !
!SpBoxLayoutAdapterTest class methodsFor: 'testing'!
isAbstract

	^ self == SpBoxLayoutAdapterTest! !
!SpBoxLayoutAdapterTest methodsFor: 'tests'!
testAdapterElementsAreInSameOrderThanLayout

	| first second |
	layout add: (first := SpButtonPresenter new).
	layout add: (second := SpButtonPresenter new).
	self assert: self adapter children first equals: first adapter widget.
	self assert: self adapter children second equals: second adapter widget.! !
!SpBoxLayoutAdapterTest methodsFor: 'tests'!
testAddElementAddsToAdapter

	layout add: SpButtonPresenter new.
	self deny: self adapter isEmpty! !
!SpBoxLayoutAdapterTest methodsFor: 'tests'!
testAddElementAfterOpenAddsToAdapter

	layout add: SpButtonPresenter new.
	self openInstance.
	
	layout add: SpButtonPresenter new.
	self assert: self adapter children size equals: 2! !
!SpBoxLayoutAdapterTest methodsFor: 'tests'!
testLayoutCanHaveMoreThanTwoChildren

	layout add: SpButtonPresenter new.
	layout add: SpButtonPresenter new.
	layout add: SpButtonPresenter new.
	
	self assert: layout children size equals: 3! !
!SpBoxLayoutAdapterTest methodsFor: 'tests'!
testRemoveElementAddedAfterOpenRemovesFromAdapter

	| element |
	layout add: (element := SpButtonPresenter new).
	self openInstance.
	
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpBoxLayoutAdapterTest methodsFor: 'tests'!
testRemoveElementRemovesFromAdapter

	| element |
	layout add: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpHorizontalBoxLayoutAdapterTest methodsFor: 'running'!
newLayout

	^ SpBoxLayout newHorizontal! !
!SpVerticalBoxLayoutAdapterTest methodsFor: 'running'!
newLayout

	^ SpBoxLayout newVertical! !
!SpGridLayoutAdapterTest methodsFor: 'accessing'!
newLayout

	^ SpGridLayout new! !
!SpGridLayoutAdapterTest methodsFor: 'tests'!
testAddAtSamePositionTwiceReplacesChild

	| first second |
	layout add: (first := SpButtonPresenter new) at: 1@1.
	layout add: (second := SpButtonPresenter new) at: 1@1.
	self assert: self adapter children first equals: second adapter widget! !
!SpGridLayoutAdapterTest methodsFor: 'tests'!
testAddAtSamePositionTwiceSetsChildrenSingleTime

	layout add: (SpButtonPresenter new) at: 1@1.
	layout add: (SpButtonPresenter new) at: 1@1.
	self assert: self adapter children size equals: 1! !
!SpGridLayoutAdapterTest methodsFor: 'tests'!
testAddElementAddsToAdapter

	layout add: SpButtonPresenter new at: 1@1.
	self deny: self adapter isEmpty! !
!SpGridLayoutAdapterTest methodsFor: 'tests'!
testAddElementAfterOpenAddsToAdapter

	layout add: SpButtonPresenter new at: 1@1.
	self openInstance.
	
	layout add: SpButtonPresenter new at: 1@2.
	self assert: self adapter children size equals: 2! !
!SpGridLayoutAdapterTest methodsFor: 'tests'!
testRemoveElementAddedAfterOpenRemovesFromAdapter

	| element |
	layout add: (element := SpButtonPresenter new) at: 1@1.
	self openInstance.
	
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpGridLayoutAdapterTest methodsFor: 'tests'!
testRemoveElementRemovesFromAdapter

	| element |
	layout add: (element := SpButtonPresenter new) at: 1@1.
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpLayoutAdapterTest class methodsFor: 'testing'!
isAbstract

	^ self == SpLayoutAdapterTest! !
!SpLayoutAdapterTest methodsFor: 'accessing'!
classToTest

	^ SpEmptyPresenter! !
!SpLayoutAdapterTest methodsFor: 'accessing'!
initializeTestedInstance

	layout := self newLayout.
	presenter layout: layout! !
!SpLayoutAdapterTest methodsFor: 'accessing'!
newLayout
	
	self subclassResponsibility! !
!SpLayoutAdapterTest methodsFor: 'tests'!
testEmptyLayoutHasEmptyAdapter

	self assert: self adapter isEmpty! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
newLayout

	^ SpOverlayLayout new! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testAddTwiceReplacesChild

	| first second |
	layout child: (first := SpButtonPresenter new).
	layout child: (second := SpButtonPresenter new).
	self assert: self adapter children first equals: second adapter widget! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testAddTwiceSetsChildrenSingleTime

	| first second |
	layout child: (first := SpButtonPresenter new).
	layout child: (second := SpButtonPresenter new).
	self assert: self adapter children size equals: 1! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testLayoutWithChildAndOverlayHasBothElements

	| overlay |
	layout child: SpButtonPresenter new.
	layout addOverlay: (overlay := SpButtonPresenter new).
	self assert: self adapter children size equals: 2! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testLayoutWithChildIsNotEmpty

	layout child: SpButtonPresenter new.
	self deny: self adapter isEmpty! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testLayoutWithOverlayIsNotEmpty

	layout addOverlay: SpButtonPresenter new.
	self deny: self adapter isEmpty! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testOverlaysAreAddedInOrder

	| second |
	layout addOverlay: SpButtonPresenter new.
	layout addOverlay: (second := SpButtonPresenter new).
	self assert: self adapter children last equals: second adapter widget! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testOverlaysAreAfterMainChild

	| overlay |
	layout child: SpButtonPresenter new.
	layout addOverlay: (overlay := SpButtonPresenter new).
	self assert: self adapter children last equals: overlay adapter widget! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testRemoveChildAddedAfterOpenRemovesFromAdapter

	| element |
	layout child: (element := SpButtonPresenter new).
	self openInstance.
	
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpOverlayLayoutAdapterTest methodsFor: 'tests'!
testRemoveChildElementRemovesFromAdapter

	| element |
	layout child: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpHorizontalPanedLayoutAdapterTest methodsFor: 'accessing'!
newLayout
	
	^ SpPanedLayout newHorizontal! !
!SpPanedLayoutAdapterTest class methodsFor: 'testing'!
isAbstract

	^ self == SpPanedLayoutAdapterTest! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testAdapterElementsAreInExplicitOrder

	| first second |
	layout addFirst: (first := SpButtonPresenter new).
	layout addSecond: (second := SpButtonPresenter new).
	self assert: self adapter children first equals: first adapter widget.
	self assert: self adapter children second equals: second adapter widget.! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testAddFirstElementAfterOpenAddsToAdapter

	layout addSecond: SpButtonPresenter new.
	self openInstance.
	
	layout addFirst: SpButtonPresenter new.
	self assert: self adapter children size equals: 2! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testAddFirstTwiceReplacesChild

	| first second |
	layout addFirst: (first := SpButtonPresenter new).
	layout addFirst: (second := SpButtonPresenter new).
	self assert: self adapter children first equals: second adapter widget! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testAddFirstTwiceSetsChildrenSingleTime

	| first second |
	layout addFirst: (first := SpButtonPresenter new).
	layout addFirst: (second := SpButtonPresenter new).
	self assert: self adapter children size equals: 1! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testAddSecondElementAfterOpenAddsToAdapter

	layout addFirst: SpButtonPresenter new.
	self openInstance.
	
	layout addSecond: SpButtonPresenter new.
	self assert: self adapter children size equals: 2! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testAddSecondTwiceReplacesChild

	| first second |
	layout addSecond: (first := SpButtonPresenter new).
	layout addSecond: (second := SpButtonPresenter new).
	self assert: self adapter children first equals: second adapter widget! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testAddSecondTwiceSetsChildrenSingleTime

	| first second |
	layout addSecond: (first := SpButtonPresenter new).
	layout addSecond: (second := SpButtonPresenter new).
	self assert: self adapter children size equals: 1! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testLayoutWithFirstElementIsNotEmpty

	layout addFirst: SpButtonPresenter new.
	self deny: self adapter isEmpty! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testLayoutWithSecondElementIsNotEmpty

	layout addSecond: SpButtonPresenter new.
	self deny: self adapter isEmpty! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testRemoveFirstElementAddedAfterOpenRemovesFromAdapter

	| element |
	layout addFirst: (element := SpButtonPresenter new).
	self openInstance.
	
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testRemoveFirstElementRemovesFromAdapter

	| element |
	layout addFirst: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testRemoveSecondElementAddedAfterOpenRemovesFromAdapter

	| element |
	layout addSecond: (element := SpButtonPresenter new).
	self openInstance.
	
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpPanedLayoutAdapterTest methodsFor: 'tests'!
testRemoveSecondElementRemovesFromAdapter

	| element |
	layout addSecond: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpVerticalPanedLayoutAdapterTest methodsFor: 'accessing'!
newLayout
	
	^ SpPanedLayout newVertical! !
!SpScrollableLayoutAdapterTest methodsFor: 'tests'!
newLayout

	^ SpScrollableLayout new! !
!SpScrollableLayoutAdapterTest methodsFor: 'tests'!
testAddTwiceReplacesChild

	| first second |
	layout child: (first := SpButtonPresenter new).
	layout child: (second := SpButtonPresenter new).
	self assert: self adapter children first equals: second adapter widget! !
!SpScrollableLayoutAdapterTest methodsFor: 'tests'!
testAddTwiceSetsChildrenSingleTime

	| first second |
	layout child: (first := SpButtonPresenter new).
	layout child: (second := SpButtonPresenter new).
	self assert: self adapter children size equals: 1! !
!SpScrollableLayoutAdapterTest methodsFor: 'tests'!
testLayoutWithChildIsNotEmpty

	layout child: SpButtonPresenter new.
	self deny: self adapter isEmpty! !
!SpScrollableLayoutAdapterTest methodsFor: 'tests'!
testRemoveChildAddedAfterOpenRemovesFromAdapter

	| element |
	layout child: (element := SpButtonPresenter new).
	self openInstance.
	
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpScrollableLayoutAdapterTest methodsFor: 'tests'!
testRemoveChildElementRemovesFromAdapter

	| element |
	layout child: (element := SpButtonPresenter new).
	layout remove: element.
	self assert: self adapter isEmpty! !
!SpCommandGroup methodsFor: 'converting' prior: 64231891!
asMenuPresenter

	^ SpMenuPresenterBuilder new
		visit: self;
		menuPresenter! !
!SpCodeProfileItCommand methodsFor: 'execution' prior: 64210681!
execute

	self flag: 'TODO'! !
!SpDatePresenterTest methodsFor: 'running' prior: 64270722!
classToTest
	^ SpDatePresenter! !
!SpDatePresenterTest methodsFor: 'tests' prior: 64270809!
testOnDateChosen
	| mookChoseDate |
	mookChoseDate := ChoseDate new.
	mookChoseDate
		calendar: StandardWindow new;
		date: Date tomorrow.
	presenter onDateChosen: mookChoseDate.
	self assert: presenter date equals: Date tomorrow! !
!SpImagePresenterTest methodsFor: 'running' prior: 64455978!
classToTest
	^ SpImagePresenter! !
!SpImagePresenterTest methodsFor: 'tests' prior: 64455701!
testAutoScale
	| count result |
	count := 0.
	presenter
		whenAutoScaleChangeDo: [ :value | 
			result := value.
			count := count + 1 ].
	presenter autoScale: true.
	self assert: count equals: 1.
	self assert: result! !
!SpImagePresenterTest methodsFor: 'tests' prior: 64455490!
testSwitchAutoScale
	| autoState |
	autoState := presenter autoScale.
	presenter switchAutoscale.
	self assert: presenter autoScale equals: autoState not! !
!SpLinkPresenterTest methodsFor: 'running' prior: 64538263!
classToTest
	^ SpLinkPresenter! !
!SpLinkPresenterTest methodsFor: 'tests' prior: 64538350!
testLabelIsUrlByDefault
	self assert: presenter label isNil.
	presenter url: 'Test'.
	self assert: presenter label equals: 'Test'.
	presenter label: 'Label'.
	self assert: presenter label equals: 'Label'! !
!SpLinkPresenterTest methodsFor: 'tests' prior: 64538610!
testWhenActionChangedDo
	| count result |
	count := 0.
	presenter
		whenActionChangedDo: [ :block | 
			count := count + 1.
			result := block ].
	presenter action: [ 'Test' ].
	self assert: result isBlock.
	self assert: result value equals: 'Test'.
	self assert: count equals: 1! !
!SpLinkPresenterTest methodsFor: 'tests' prior: 64537968!
testWhenLabelChangedDo
	| count result |
	count := 0.
	presenter
		whenLabelChangedDo: [ :label | 
			count := count + 1.
			result := label ].
	presenter label: 'Test'.
	self assert: result equals: 'Test'.
	self assert: count equals: 1! !
!SpMethodToolbarTest methodsFor: 'running' prior: 64613597!
classToTest
	^ SpMethodToolbar! !
!SpPopoverPresenterTest methodsFor: 'running'!
classToTest
	
	
	^ SpPopoverPresenter! !
!SpPopoverPresenterTest methodsFor: 'running'!
initializeTestedInstance

	presenter presenter: (SpPresenter new 
		layout: (SpBoxLayout newVertical
			add: 'Test Popover';
			add: (presenter newButton label: 'Button');
			yourself);
		yourself)! !
!SpPopoverPresenterTest methodsFor: 'tests'!
testPopoverTakesExtentFromPresenter

	self openInstance.
	
	self 
		assert: presenter adapter widget width >= presenter presenter adapter widget width;
		assert: presenter adapter widget height >= presenter presenter adapter widget height.! !
!SpRGBSlidersTest methodsFor: 'running' prior: 65080796!
classToTest
	^ SpRGBSliders! !
!SpRGBSlidersTest methodsFor: 'tests' prior: 65081202!
testColor
	| random red green blue |
	random := Random new.
	red := random nextInt: 255.
	green := random nextInt: 255.
	blue := random nextInt: 255.
	
	presenter redSlider value: red.
	presenter greenSlider value: green.
	presenter blueSlider value: blue.
	self
		assert: presenter color
		equals:
			(Color
				r: red
				g: green
				b: blue
				range: 255)! !
!SpRGBSlidersTest methodsFor: 'tests' prior: 65080877!
testwhenChangedDo
	| numberOfChanges |
	numberOfChanges := 0.
	presenter whenChangedDo: [ numberOfChanges := numberOfChanges + 1 ].
	presenter redSlider value: 66.
	presenter greenSlider value: 17.
	presenter blueSlider value: 200.
	self assert: numberOfChanges equals: 3! !
!SpRGBWidgetTest methodsFor: 'running' prior: 65083386!
classToTest
	^ SpRGBWidget! !
!SpVersatileDialogPresenterTest methodsFor: 'running' prior: 65471912!
classToTest
	^ SpVersatileDialogPresenter! !
!SpVersatileDialogPresenterTest methodsFor: 'tests' prior: 65470420!
testListBox
	| dialog app listPresenter |
	app := SpMockApplication new.

	dialog := SpVersatileDialogPresenter newApplication: app.
	listPresenter := dialog newList.
	listPresenter items: #(one two three).
	dialog contentArea: listPresenter.
	dialog
		addButton: #ok
		text: 'OK'
		value: #ok
		condition: [ listPresenter selection isEmpty not ].
	dialog addButton: #cancel text: 'Cancel' value: nil.
	dialog mainIcon: (self iconNamed: #question).

	dialog openModalWithSpec.
	dialog withWindowDo: [ :w | w title: 'Confirmation' ].

	dialog contentArea selection selectIndex: 2.

	(dialog buttons at: #ok) click.

	self assert: dialog result equals: #ok.
	self assert: dialog contentArea selection selectedItem equals: #two! !
!SpVersatileDialogPresenterTest methodsFor: 'tests' prior: 65471212!
testResult 

	| dialog app |
	
	app := SpMockApplication new.
	
	dialog := SpVersatileDialogPresenter newApplication: app.
	dialog mainMessage: 'Save content' asText allBold.
	dialog addButton: #save text: 'Save' value: true.
	dialog addButton: #cancel text: 'Cancel' value: false.
	dialog mainIcon: (self iconNamed: #question).
	dialog moreOptionsArea: (dialog newCheckBox label: 'Save header').

	dialog openModalWithSpec. 
	dialog withWindowDo: [ :w | w title: 'Confirmation' ].
	(dialog buttons at: #save) performAction.
	dialog moreOptionsArea click.

	self assert: dialog result.	
	self assert: dialog moreOptionsArea state.! !
!SpChooseMethodUITest methodsFor: 'tests' prior: 64185629!
testClickOnClassSideRadioButtonShouldFillTheMethodList
	biChooseMethod packageList selectItem: SpMethodChooserMockClass package.
	biChooseMethod classList selectItem: SpMethodChooserMockClass.
	biChooseMethod radioButtonClassSide click.
	biChooseMethod protocolList selectIndex: 1.
	self
		assertCollection: biChooseMethod methodList items
		hasSameElements: SpMethodChooserMockClass class methods! !
!SpAbstractMorphicListAdapter methodsFor: 'scrolling' prior: 64006512!
configureScrolling
	self presenter verticalAlignment
		whenChangedDo: [ widget
				scrollToIndex: self presenter verticalAlignment desiredVisibleRow ].
			
	self presenter
		whenDisplayDo: [ widget
				scrollToIndex: self presenter verticalAlignment desiredVisibleRow.
			self scrollingChanged ].
		
	widget
		onAnnouncement: FTScrollingChanged
		send: #scrollingChanged
		to: self.! !
!SpAbstractMorphicListAdapter methodsFor: 'widget API'!
elementAt: index

	^ self widget dataSource elementAt: index! !
!SpAbstractListAdapterMultipleSelectionTest methodsFor: 'tests'!
tearDown 
	presenter delete.
	super tearDown.! !
!SpAbstractListAdapterMultipleSelectionTest methodsFor: 'tests'!
testSelectPresenterWithScrollingMakeSelectedItemVisible
	| visibleItems |

	"TreeTable presenter does not have the same API, do not run the test"
	presenter class adapterName = #TreeTableAdapter ifTrue: [ ^ self ].
	
	self flag: 'TODO: remove the following guard clause once scrolling is implemented on SpComponentListPresenter'.
	presenter class adapterName = #ComponentListAdapter ifTrue: [ ^ self ].
	
	presenter
		items: (1 to: 200);
		selectIndex: 150 scrollToSelection: true;
		openWithSpec.
		
	visibleItems := presenter verticalAlignment firstVisibleRowIndex to: presenter verticalAlignment lastVisibleRowIndex.
		
	self assert: (visibleItems includes: presenter selection selectedIndexes first)! !
!SpAbstractListAdapterMultipleSelectionTest methodsFor: 'tests'!
testSelectPresenterWithoutScrollingDoesNotScroll
	| visibleItems verticalAlignment |
	
	"TreeTable presenter does not have the same API, do not run the test"
	presenter class adapterName = #TreeTableAdapter ifTrue: [ ^ self ].
	
	self flag: 'TODO: remove the following guard clause once scrolling is implemented on SpComponentListPresenter'.
	presenter class adapterName = #ComponentListAdapter ifTrue: [ ^ self ].
	
	presenter 
		items: (1 to: 200);
		selectIndex: 150 scrollToSelection: true;
		openWithSpec.

	verticalAlignment := presenter verticalAlignment.		
	visibleItems := verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex.
		
	self 
		assert: (verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex) 
		equals: visibleItems! !
!SpMenuItemPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #name
	! !
!SpComponentListPresenterTest methodsFor: 'tests'!
testSelectedItemsSortedByIndex

	presenter beMultipleSelection.
	presenter 
		selectIndex: 3;
		selectIndex: 1.
	self 
		assert: (presenter selection selectedItems collect: #label as: Array)
		equals: #('30' '10'). 
	self 
		assert: (presenter selection selectedItemsSortedByIndex collect: #label as: Array)
		equals: #('10' '30')! !
!SpLabelledTextInput methodsFor: 'api-events'!
whenSubmitDo: aBlock

	self input whenSubmitDo: aBlock! !
!SpLabelledTextInput methodsFor: 'api-events' prior: 64501951!
whenTextChanged: aBlock

	self input whenTextChanged: aBlock! !
!SpLabelledTextInput methodsFor: 'api-events' prior: 64503338!
whenTextIsAccepted: aBlock

	self input whenTextIsAccepted: aBlock! !
!SpAbstractListPresenterTest methodsFor: 'tests'!
testSelectedItemsSortedByIndex

	presenter beMultipleSelection.
	presenter 
		selectIndex: 3;
		selectIndex: 1.
	self 
		assert: presenter selection selectedItems asArray
		equals: #(30 10). 
	self 
		assert: presenter selection selectedItemsSortedByIndex asArray
		equals: #(10 30)! !
!SpWindowPresenterTest methodsFor: 'tests'!
testIsTopWindow

	self deny: presenter isTopWindow.
	self openInstance.
	presenter takeKeyboardFocus.
	self assert: presenter isTopWindow.
	presenter close.
	self deny: presenter isTopWindow! !
!SpMorphicCodeAdapter methodsFor: 'initialization'!
addKeyBindingsTo: aMorph

	super addKeyBindingsTo: aMorph.
	self presenter contextKeyBindings ifNotNil: [ :kmCategory |
	 	kmCategory allEntries keymaps do: [ :each |
			self
				bindKeyCombination: each shortcut 
				toAction: each action ] ]! !
!SpMorphicCodeAdapter methodsFor: 'widget API' prior: 64709404!
behavior

	^ self model behavior! !
!SpMorphicCodeAdapter methodsFor: 'factory' prior: 64709892!
buildWidget
	| newWidget |
	
	newWidget := super buildWidget.
	
	self presenter whenSyntaxHighlightChangedDo: [ :hasSyntaxHighlight | 
		self setEditingModeFor: newWidget ].
	
	self presenter completionEngine ifNotNil: [ :engine | newWidget completionEngine: engine ].
	self presenter whenCompletionEngineChangedDo: [ :engine | newWidget completionEngine: engine ].
	
	^ newWidget! !
!SpMorphicCodeAdapter methodsFor: 'private-shout' prior: 64710452!
classOrMetaClass: aClass

	self 
		setEditingModeFor: self widget 
		withBehavior: aClass! !
!SpMorphicCodeAdapter methodsFor: 'private'!
computeOriginFor: aMorph
	| desiredTop desiredLeft |

	aMorph textArea scrollSelectionIntoView: nil.
	desiredTop := (self originMorphFor: aMorph) positionInWorld y - 6.
						"unclear why 6 is the magic number"
	desiredLeft := (self originMorphFor: aMorph) right + aMorph positionInWorld x + 6.
	
	^ desiredLeft @ desiredTop! !
!SpMorphicCodeAdapter methodsFor: 'widget API' prior: 64710237!
doItContext

	^ self model doItContext! !
!SpMorphicCodeAdapter methodsFor: 'widget API' prior: 64710604!
doItReceiver

	^ self model doItReceiver! !
!SpMorphicCodeAdapter methodsFor: 'NOCompletion' prior: 64710816!
guessTypeForName: aString

	^nil! !
!SpMorphicCodeAdapter methodsFor: 'private' prior: 64709290!
hasSyntaxHighlight

	^ self presenter hasSyntaxHighlight! !
!SpMorphicCodeAdapter methodsFor: 'private' prior: 64711376!
hasSyntaxHighlightEnabled
	"this is used just for testing"
	
	^ self presenter hasSyntaxHighlight! !
!SpMorphicCodeAdapter methodsFor: 'widget API'!
insertPopoverAfterCurrentSelection: aPresenter
	| popover pos |

	self widgetDo: [ :w |

		popover := self presenter newPopover
			bePositionRight;
			presenter: aPresenter;
			buildWithSpec;
			yourself.
	
		pos := self computeOriginFor: w.
		popover popupPointingTo: (pos corner: (pos + (1@15))).
		popover takeKeyboardFocus ]! !
!SpMorphicCodeAdapter methodsFor: 'private'!
originMorphFor: aMorph

	(aMorph textArea hasSelection not and: [ 
		aMorph textArea hasHighlightSegment ]) ifTrue: [ 
			^ aMorph textArea getHighlightSegment ].
	^ aMorph textArea cursor! !
!SpMorphicCodeAdapter methodsFor: 'NOCompletion' prior: 64710143!
receiverClass

	^ self behavior! !
!SpMorphicCodeAdapter methodsFor: 'widget API' prior: 64710338!
selectedBehavior

	^ self model selectedBehavior! !
!SpMorphicCodeAdapter methodsFor: 'NOCompletion' prior: 64710709!
selectedClassOrMetaClass

	^ self behavior! !
!SpMorphicCodeAdapter methodsFor: 'private' prior: 64709496!
setEditingModeFor: textArea

	self hasSyntaxHighlight
		ifTrue: [ self setEditingModeFor: textArea withBehavior: self behavior ]
		ifFalse: [ super setEditingModeFor: textArea ]! !
!SpMorphicCodeAdapter methodsFor: 'private' prior: 64711122!
setEditingModeFor: textArea withBehavior: aBehavior

	aBehavior
		ifNotNil: [ textArea beForSmalltalkCodeInClass: aBehavior ]		
		ifNil: [ 
			textArea 
				model: self;
				beForSmalltalkScripting ]! !
!SpMorphicCodeAdapter methodsFor: 'private' prior: 64709733!
textWithStyle
	"This method is to be used for testing. 
	 DO NOT USE IT!!"
	
	^ self widget getText! !
!SpMorphicTextAdapter methodsFor: 'initialization'!
addKeyBindingsTo: aMorph

	super addKeyBindingsTo: aMorph.
	self presenter hasEditionContextMenu ifFalse: [ ^ self ].
	self presenter editionContextKeyBindings allEntries keymaps do: [ :each |
		self
			bindKeyCombination: each shortcut 
			toAction: each action ]! !
!SpMorphicTextAdapter methodsFor: 'protocol-shortcuts'!
bindKeyCombination: aShortcut toAction: aBlock 

	self widgetDo: [ :w | 
		w textArea
			bindKeyCombination: aShortcut 
			toAction: aBlock ]! !
!SpMorphicTextAdapter methodsFor: 'factory' prior: 64839659!
buildWidget
	| newWidget |
	
	newWidget := (RubScrolledTextMorph on: self)
		getTextSelector: #getText;
		setTextSelector: #accept:notifying:;
		getSelectionSelector: #readSelection;
		menuProvider: self selector: #codePaneMenu:shifted:;
		setSelectionSelector: #setSelection:;
		ghostText: self placeholder;
		beWrapped;
		enabled: self enabled;
		askBeforeDiscardingEdits: self askBeforeDiscardingEdits;
		autoAccept: true;
		vResizing: #spaceFill;
		hResizing: #spaceFill;
		setBalloonText: self help;
		dragEnabled: self dragEnabled;
		dropEnabled: self dropEnabled;
		registerScrollChanges: #scrollValueChanged:;
		yourself.
	
	self setEditable: self presenter isEditable to: newWidget.
	self setEditingModeFor: newWidget.
	self setText: self presenter text to: newWidget.
	
	self presenter whenTextChangedDo: [ :text | self setText: text to: newWidget ].
	self presenter whenPlaceholderChangedDo: [ :text | self setGhostText: text to: newWidget ].
	self presenter whenEditableChangedDo: [ :value | self setEditable: value to: newWidget ].
	
	^ newWidget! !
!SpMorphicTextAdapter methodsFor: 'widget API'!
codePaneMenu: aMenu shifted: shifted
	| menuPresenter |

	menuPresenter := self model contextMenu value
		ifNotNil: [ :contextMenu | contextMenu ]
		ifNil: [ SpMenuPresenter new ].
	self presenter hasEditionContextMenu ifTrue: [ 
		self presenter editionContextMenu menuGroups do: [ :each |
			menuPresenter addMenuGroup: each ] ].
	^ SpBindings
		value: self model application adapterBindings
		during: [ menuPresenter buildWithSpec ]! !
!SpMorphicTextAdapter methodsFor: 'private'!
setEditable: aBoolean to: aWidget

	aWidget textArea readOnly: aBoolean not! !
!SpMorphicTextAdapter methodsFor: 'private' prior: 64841071!
setText: text to: aWidget

	aWidget setText: text.
	self updateExtentPropagationOf: text on: aWidget
! !
!SpMorphicTextAdapter methodsFor: 'private'!
updateExtentPropagationOf: string on: aWidget
	| stringMorph width height |

	(self presenter isPropagateNaturalWidth 
		or: [ self presenter isPropagateNaturalHeight ])
		ifFalse: [ ^ self ].

	stringMorph := RubEditingArea new 
		font: aWidget font;
		updateTextWith: string.

	width := stringMorph width + 12 min: self currentWorld width / 3.
	self presenter isPropagateNaturalWidth 
		ifTrue: [ aWidget width: width ].

	self presenter isPropagateNaturalHeight 
		ifTrue: [ 
			height := (stringMorph
				beWrapped;
				width: width;
				yourself) height + 2 min: self currentWorld height / 3. 
			aWidget height: height ]! !
!SpMorphicTextAdapter methodsFor: 'emulating'!
widgetEventReceiver
	
	^ widget textArea! !
!SpNotebookPageMorph methodsFor: 'theme'!
themeChanged

	super themeChanged.
	labelMorph themeChanged.
	actualPageMorph ifNotNil: [ 
		actualPageMorph themeChanged ]! !
!SpAbstractAdapter methodsFor: 'as yet unclassified'!
replaceLayoutWith: aLayout
	
	! !
!SpLabelledTextInputTest methodsFor: 'private'!
textInputAdapter

	^ presenter input adapter! !
!SpAbstractPresenter class methodsFor: 'TOREMOVE' prior: 64028125!
defaultFont 

	self flag: #TODO. "This is so wrong. All this needs to be in the theme and in the 
	application"
		
	self class environment at: #StandardFonts ifPresent: [ :standardFonts | 
		^ standardFonts defaultFont ].
	
	^ LogicalFont
		familyName: 'Source Sans Pro'
		pointSize: 10
		stretchValue: 5
		weightValue: 400
		slantValue: 0
! !
!SpAbstractPresenter methodsFor: 'transmission'!
defaultInputPort

	^ nil! !
!SpAbstractPresenter methodsFor: 'transmission'!
defaultOutputPort

	^ nil! !
!SpAbstractPresenter methodsFor: 'private utils'!
forceUpdateSlot: aSymbol

	^ (self rawValueHolderNamed: aSymbol) valueChanged! !
!SpAbstractPresenter methodsFor: 'private utils'!
rawValueHolderNamed: aSymbol

	^ (self class slotNamed: aSymbol) rawRead: self.! !
!SpAbstractPresenter methodsFor: 'transmission' prior: 64014182!
transmitDo: aBlock

	^ self defaultOutputPort transmitDo: aBlock! !
!SpAbstractPresenter methodsFor: 'transmission' prior: 64016546!
transmitDo: aBlock transform: transformBlock
	
	^ self defaultOutputPort
		transmitDo: aBlock 
		transform: transformBlock! !
!SpAbstractPresenter methodsFor: 'abstract' prior: 64012859!
transmitTo: aPresenter
	
	^ self defaultOutputPort transmitTo: aPresenter defaultInputPort! !
!SpAbstractPresenter methodsFor: 'transmission' prior: 64017748!
transmitTo: aPresenter transform: aValuable
	
	^ self defaultOutputPort
		transmitTo: aPresenter defaultInputPort
		transform: aValuable! !
!SpAbstractPresenter methodsFor: 'transmission' prior: 64015731!
transmitTo: aPresenter transform: aValuable postTransmission: postValuable
	
	^ self defaultOutputPort
		transmitTo: aPresenter defaultInputPort
		transform: aValuable 
		postTransmission: postValuable! !
!SpDatePresenter class methodsFor: 'specs' prior: 64270393!
defaultSpec

	^ SpBoxLayout newHorizontal
		add: #dateModel;
		add: #chooseDateButton expand: false;
		yourself
		! !
!SpDatePresenter class methodsFor: '*Spec2-Examples' prior: 64270607!
example
	<sampleInstance>
	
	^ self new openWithSpec! !
!SpDatePresenter class methodsFor: '*Spec2-Examples' prior: 64270274!
exampleModal
	<sampleInstance>
	
	^ self new openModalWithSpec! !
!SpDatePresenter methodsFor: 'private' prior: 64267381!
chooseDate

	| calendar defaultDate |
	defaultDate := self date ifNil: [ self defaultDate ].
	calendar := CalendarMorph openOn: defaultDate.
	calendar
		center: calendar cursorPoint;
		fitInWorld;
		onChoiceSend: #onDateChosen: to: self.! !
!SpDatePresenter methodsFor: 'accessing-widgets' prior: 64267288!
chooseDateButton

	^ chooseDateButton.! !
!SpDatePresenter methodsFor: 'accessing' prior: 64267210!
date

	^ date! !
!SpDatePresenter methodsFor: 'accessing' prior: 64268162!
date: aDate

	| dateString |
	date := aDate.
	dateString := self display value: date.
	self dateModel text: dateString.! !
!SpDatePresenter methodsFor: 'accessing-widgets' prior: 64268346!
dateModel

	^ dateModel.! !
!SpDatePresenter methodsFor: 'defaults' prior: 64268079!
defaultDate
	^ Date today ! !
!SpDatePresenter methodsFor: 'api' prior: 64267669!
display
	"Return the one argument block used to wrap your domain specific items.
	The block should return something that can be displayed in a list - like a String or a Text"

	^ displayBlock! !
!SpDatePresenter methodsFor: 'api' prior: 64267911!
display: aBlock
	"Set the one argument block used to transfrom your date into a string"

	displayBlock := aBlock! !
!SpDatePresenter methodsFor: 'private' prior: 64269108!
iconMorph

	^ ImageMorph new form: (self iconNamed: #calendarIcon)! !
!SpDatePresenter methodsFor: 'initialization' prior: 64269236!
initialize
	super initialize.
	displayBlock := [ :object | object ifNotNil: [ object asStringOrText ] ifNil: '' ].
	self property: #displayBlock whenChangedDo: [ self date: self date ].
	self date: self defaultDate! !
!SpDatePresenter methodsFor: 'initialization' prior: 64269512!
initializePresenters

	dateModel := self newTextInput.
	chooseDateButton := self newButton.
	
	chooseDateButton
		icon: self iconMorph;
		action: [ self chooseDate ];
		extent: self iconMorph extent.! !
!SpDatePresenter methodsFor: 'private' prior: 64269766!
onDateChosen: aChoseDate

	aChoseDate calendar delete.
	self date: aChoseDate date! !
!SpDatePresenter methodsFor: 'api-events' prior: 64269906!
whenDateChanged: aBlock

	dateModel whenTextChanged: [ :newText :oldText :announcement :anAnnouncer |
		| oldDate |
		oldDate := date.
		date := newText
			ifNotEmpty: [ Date readFrom: newText readStream ]
			ifEmpty: [ nil ].
		aBlock cull: date cull: oldDate cull: announcement cull: anAnnouncer ]! !
!SpEmptyPresenter methodsFor: 'initialization'!
initializeWidgets
	
	"Empty"
	"This is required only because we are obliged to redefine initializeWidgets in SpPresenter"! !
!SpEmptyPresenter methodsFor: 'accessing'!
layout: aSpLayout
	
	layout := aSpLayout! !
!SpMethodToolbar class methodsFor: 'specs' prior: 64613013!
defaultSpec
	<spec>
	^ SpBoxLayout newHorizontal
		add: #browseModel;
		add: #usersModel;
		add: #sendersModel;
		add: #implementorsModel;
		add: #versionModel;
		add: #dropListModel;
		yourself! !
!SpMethodToolbar class methodsFor: 'specs' prior: 64613266!
title

	^ 'Toolbar'! !
!SpMethodToolbar methodsFor: 'api' prior: 64612090!
addItemLabeled: aString do: aBlock

	dropListModel addItemLabeled: aString do: aBlock! !
!SpMethodToolbar methodsFor: 'private' prior: 64610866!
browseMethod
	self method ifNotNil: [ :aMethod | aMethod browse ]! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64611428!
browseModel

	^ browseModel! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64610988!
dropListModel

	^ dropListModel! !
!SpMethodToolbar methodsFor: 'api' prior: 64609356!
emptyDropList
	
	dropListModel emptyList! !
!SpMethodToolbar methodsFor: 'private' prior: 64609993!
implementorsMethod
	self method ifNotNil: [ :aMethod | self model browseMessagesFrom: aMethod selector ]! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64612915!
implementorsModel

	^ implementorsModel! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64612638!
initialize
	model := AbstractTool new.

	super initialize! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64610317!
initializePresenters
	browseModel := self newButton.
	usersModel := self newButton.
	sendersModel := self newButton.
	implementorsModel := self newButton.
	versionModel := self newButton.
	dropListModel := self newDropList.
	self
		setFocusOrder;
		setBrowseModel;
		setUsersModel;
		setVersionModel;
		setSendersModel;
		setImplementorsModel! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64612394!
method
	^ method! !
!SpMethodToolbar methodsFor: 'api' prior: 64611337!
method: aMethod
	method := aMethod! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64610154!
model

	^ model! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64609624!
registerForChanges
	self
		property: #method
		whenChangedDo: [ :contents | 
			| boolean |
			boolean := contents ifNil: [ false ] ifNotNil: [ true ].
			browseModel state: boolean.
			usersModel state: boolean.
			sendersModel state: boolean.
			versionModel state: boolean.
			implementorsModel state: boolean ]! !
!SpMethodToolbar methodsFor: 'private' prior: 64612750!
sendersMethod
	self method ifNotNil: [ :aMethod | self model browseSendersOfMessagesFrom: aMethod selector ]! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64612010!
sendersModel

	^ sendersModel! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64612237!
setBrowseModel
	
	browseModel
		state: false;
		label: 'Browse';
		action: [ self browseMethod ].
	
! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64611812!
setFocusOrder

	self focusOrder
		add: browseModel;
		add: usersModel;
		add: sendersModel;
		add: implementorsModel;
		add: versionModel.
		! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64611162!
setImplementorsModel
	
	implementorsModel
		state: false;
		label: 'Implementors';
		action: [ self implementorsMethod ].
	
! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64609458!
setSendersModel
	
	sendersModel
		state: false;
		label: 'Senders';
		action: [ self sendersMethod ].
	
! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64610721!
setUsersModel
	usersModel
		state: false;
		label: 'Users';
		action: [ self usersMethod ]! !
!SpMethodToolbar methodsFor: 'initialization' prior: 64612472!
setVersionModel
	
	versionModel
		state: false;
		label: 'Version';
		action: [ self versionMethod ].
	
! !
!SpMethodToolbar methodsFor: 'private' prior: 64611510!
usersMethod
	self method methodClass ifNotNil: [ :class | self model browseClassRefsOf: class ]! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64611076!
usersModel
	^ usersModel! !
!SpMethodToolbar methodsFor: 'private' prior: 64611660!
versionMethod
	self method ifNotNil: [ :aMethod | self model browseVersionsFrom: aMethod ]! !
!SpMethodToolbar methodsFor: 'accessing' prior: 64610226!
versionModel

	^ versionModel! !
!SpCodePopoverPrintPresenter class methodsFor: 'accessing'!
linesToShow

	^ 15! !
!SpCodePopoverPrintPresenter class methodsFor: 'accessing'!
maxLengthShownInPopover

	^ 80! !
!SpCodePopoverPrintPresenter class methodsFor: 'instance creation'!
newCode: aCodePresenter object: anObject 

	^ (self on: anObject)
		code: aCodePresenter;
		yourself ! !
!SpCodePopoverPrintPresenter methodsFor: 'private'!
basicObjectAsString
	
	^ [ object printString ]
		on: Error
		do: [ '<error in printString: try ''Inspect it'' to debug>' ]! !
!SpCodePopoverPrintPresenter methodsFor: 'accessing'!
code

	^ code! !
!SpCodePopoverPrintPresenter methodsFor: 'accessing'!
code: aCodePresenter

	code := aCodePresenter! !
!SpCodePopoverPrintPresenter methodsFor: 'api'!
dismiss

	super dismiss.
	self code takeKeyboardFocus! !
!SpCodePopoverPrintPresenter methodsFor: 'actions'!
dismissAndInspect

	self dismiss.
	object inspect! !
!SpCodePopoverPrintPresenter methodsFor: 'actions'!
dismissAndPrint

	self dismiss.
	self code insertAndSelectAfterCurrentSelection: self objectAsPrintString! !
!SpCodePopoverPrintPresenter methodsFor: 'initialization'!
initializePresenters

	self initializeText.

	layout := SpBoxLayout newHorizontal
		spacing: 5;
		borderWidth: 5;
		add: text;
		add: (SpBoxLayout newVertical
				add: (self newButton 
						icon: (self application iconNamed: #smallPrintIt);
						action: [ self dismissAndPrint ];
						yourself)
					expand: false;
				add: (self newButton 
						icon: (self application iconNamed: #smallInspectIt);
						action: [ self dismissAndInspect ];
						yourself)
					expand: false;
				yourself)
			expand: false;
		yourself.

	text
		bindKeyCombination: Character cr asKeyCombination | $p meta 
			toAction: [ self dismissAndPrint ];
		bindKeyCombination: $i meta 
			toAction: [ self dismissAndInspect ];
		bindKeyCombination: Character escape asKeyCombination | Character backspace asKeyCombination
			toAction: [ self dismiss ]! !
!SpCodePopoverPrintPresenter methodsFor: 'initialization'!
initializeText
	| string numLines |

	string := self objectAsString.
	numLines := string lines size.	
	text := self 
		newTextMultiLine: string 
		withScrollBars: numLines >= self class linesToShow" ]".
		
	text 
		addStyle: 'code';
		addStyle: 'codePopover'! !
!SpCodePopoverPrintPresenter methodsFor: 'initialization'!
newTextMultiLine: aString withScrollBars: withScrollBars
	| newText |		

	newText := self newText
		propagateNaturalWidth: true;
		editable: false;
		text: aString;
		yourself.

	withScrollBars ifTrue: [ 
		newText addScrollBarStyle: 'scrollbarPopoverLarge' ].
	
	^ newText! !
!SpCodePopoverPrintPresenter methodsFor: 'initialization'!
newTextSingleLine
		
	^ self newTextInput! !
!SpCodePopoverPrintPresenter methodsFor: 'initialization'!
newTextSingleLine: aString
		
	^ self newLabel label: aString! !
!SpCodePopoverPrintPresenter methodsFor: 'accessing'!
objectAsPrintString
	
	^ String streamContents: [ :stream |
		stream 
			<< ' "'
			<< self basicObjectAsString
			<< '"' ]! !
!SpCodePopoverPrintPresenter methodsFor: 'accessing'!
objectAsString
	| string |
	
	string := self basicObjectAsString.
	string size <= self class maxLengthShownInPopover 
		ifTrue: [ ^ string ].
	
	(string includesAny: Character separators) 
		ifTrue: [ ^ string withNoLineLongerThan: self class maxLengthShownInPopover ].
	
	^ String streamContents: [ :stream | 
			| lines |
			lines := self basicObjectAsString 
				groupsOf: self class maxLengthShownInPopover 
				atATimeCollect: [ :group | group ].
			lines
				do: [ :each | stream << each ]
				separatedBy: [ stream cr ] ]! !
!SpCodePopoverPrintPresenter methodsFor: 'accessing model'!
setModelBeforeInitialization: anObject

	object := anObject! !
!SpPopoverContentExample methodsFor: 'initialization'!
initializePresenters

	self layout: (SpBoxLayout newVertical
		borderWidth: 10; 
		add: (self newLabel label: 'A cool popup!!');
		yourself)! !
!SpPopoverContentPresenter methodsFor: 'api'!
dismiss

	^ self owner dismiss! !
!SpPopoverExample class methodsFor: 'initialization'!
defaultSpec

	^ SpBoxLayout newHorizontal
		hAlignCenter;
		vAlignCenter; 
		add: #top expand: false;
		add: #left  expand: false;
		add: #bottom expand: false;
		add: #right expand: false;
		yourself! !
!SpPopoverExample methodsFor: 'initialization'!
initializePresenters

		top := self newButton
			label: 'Top';
			action: [ self showPopover: SpPopoverPosition top relativeTo: top ].
		left := self newButton
			label: 'Left';
			action: [ self showPopover: SpPopoverPosition left relativeTo: left ].
		bottom := self newButton
			label: 'Bottom';
			action: [ self showPopover: SpPopoverPosition bottom relativeTo: bottom ].
		right := self newButton
			label: 'Right';
			action: [ self showPopover: SpPopoverPosition right relativeTo: right ].! !
!SpPopoverExample methodsFor: 'initialization'!
initializeWindow: aWindowPresenter

	aWindowPresenter 
		title: 'Popover example';
		initialExtent: 800@600! !
!SpPopoverExample methodsFor: 'initialization'!
showPopover: aPosition relativeTo: aPresenter

	popover ifNotNil: [ popover dismiss ].
	(popover := self newPopover)
		relativeTo: aPresenter;
		position: aPosition;
		presenter: (SpPresenter new 
			layout: (SpBoxLayout newVertical
				borderWidth: 10; 
				spacing: 5;
				add: (self newLabel label: 'A cool popup!!');
				add: (self newButton 
					label: 'Dismiss';
					action: [ popover dismiss ];
					yourself);
				yourself);
			yourself);
		popup! !
!SpPresenter class methodsFor: 'accessing'!
currentApplication 

	^ SpApplication defaultApplication! !
!SpPresenter class methodsFor: 'instance creation' prior: 65028329!
on: aDomainObject

	^ self 
		newApplication: self currentApplication
		model: aDomainObject ! !
!SpPresenter methodsFor: 'TOREMOVE' prior: 65022913!
addMenuItemsToWindowMenu: aMenu
	"Do nothing"! !
!SpPresenter methodsFor: 'TOREMOVE' prior: 65002923!
applyMenuModel: aMenuModel

	aMenuModel menuGroups do: [ :group |
		group menuItems do: [ :item |
			item shortcut ifNotNil: [ :shortcut | 
				self 
					bindKeyCombination: shortcut 
					toAction: [ item performMenuActionWith: #() ] ].
			item subMenu ifNotNil: [ :subMenu | subMenu applyTo: self	] ] ]! !
!SpPresenter methodsFor: 'private building' prior: 65011960!
basicBuildAdapterWithSpecLayout: aSpecLayout

	layout == aSpecLayout 
		ifFalse: [ layout := aSpecLayout ].
	^ super basicBuildAdapterWithSpecLayout: aSpecLayout! !
!SpPresenter methodsFor: 'api-focus'!
defaultKeyboardFocus
	"Override this to allow the presenter to re-define the one that will answer the 
	 takeKeyboardFocus call in composed presenters"

	^ self! !
!SpPresenter methodsFor: 'api-focus'!
hasKeyboardFocus

	self canTakeKeyboardFocus ifFalse: [ ^ false ].
	self withAdapterDo: [ :anAdapter | ^ anAdapter hasKeyboardFocus ].
	^ false! !
!SpPresenter methodsFor: 'initialization' prior: 65002641!
initializePresenter
	"Now, presenters should implement #connectPresenters instead."

	self 
		property: #extent 
		whenChangedDo: [ :ex | 
			self withAdapterDo: [ :widget | 
				(widget respondsTo: #extent:) 
					ifTrue: [ widget extent: ex ] ] ]! !
!SpPresenter methodsFor: 'initialization - private' prior: 65012329!
initializePrivateAnnouncements

	self property: #titleHolder whenChangedDo: [ self updateTitle ].
	self property: #layout whenChangedDo: [ :newLayout | self replaceLayoutWith: newLayout ]! !
!SpPresenter methodsFor: 'testing' prior: 65008795!
isBuilt
	^ self isDisplayed! !
!SpPresenter methodsFor: 'api'!
layout: aLayout

	layout := aLayout! !
!SpPresenter methodsFor: 'private' prior: 65020635!
layoutPresenters

	layout ifNil: [ ^ self presenters ].
	
	^ layout deepPresenters
		select: [ :each | each isSymbol or: [ each isPresenter ] ]
		thenCollect: [ :each | 
			each isPresenter 
				ifTrue: [ each ]
				ifFalse:[ self presenterAt: each ] ]! !
!SpPresenter methodsFor: 'accessing'!
locale 

	^ self application locale! !
!SpPresenter methodsFor: 'localization'!
localeChanged

	"do nothing here. Override me in subclasses to update strings presented to the users"
	! !
!SpPresenter methodsFor: 'TOREMOVE' prior: 65015712!
neglectMenuModel: aMenuModel

	aMenuModel menuGroups do: [ :group |
		group menuItems do: [ :item |
			item shortcut ifNotNil: [ :shortcut | self removeKeyCombination: shortcut ].
			item subMenu ifNotNil: [ :subMenu | subMenu neglect: self	] ] ]! !
!SpPresenter methodsFor: '*Spec2-Code' prior: 65003948!
newCode
	^ self instantiate: SpCodePresenter! !
!SpPresenter methodsFor: '*Spec2-Morphic' prior: 65010773!
newImage
	^ self instantiate: SpImagePresenter! !
!SpPresenter methodsFor: '*Spec2-Morphic' prior: 65010540!
newLink
	^ self instantiate: SpLinkPresenter! !
!SpPresenter methodsFor: '*Spec2-Morphic' prior: 65007635!
newMorph

	^ self instantiate: SpMorphPresenter! !
!SpPresenter methodsFor: 'widgets'!
newPopover

	^ self instantiate: SpPopoverPresenter! !
!SpPresenter methodsFor: 'private'!
replaceLayoutWith: aLayout

	self withAdapterDo: [ :anAdapter |
		anAdapter replaceLayoutWith: aLayout ]! !
!SpPresenter methodsFor: '*Spec2-Commander2' prior: 64998375!
rootCommandsGroup

	^ SpRecursiveContextSetter 
		visit: (self class buildRootCommandsGroupFor: self defaultCommandsContext) 
		toSetContext: self defaultCommandsContext! !
!SpPresenter methodsFor: 'api-focus' prior: 65009753!
takeKeyboardFocus
	| focus |

	focus := self defaultKeyboardFocus.
	focus == self ifFalse: [ ^ focus takeKeyboardFocus ].
	
	self withAdapterDo: [ :anAdapter | 
		anAdapter takeKeyboardFocus ]! !
!SpPresenter methodsFor: 'TOMOVE' prior: 65018365!
updateTitle

	self flag: #TODO. "To move to WindowPresenter"
	"Update the window title"
	self withWindowDo: #updateTitle! !
!SpRGBSliders class methodsFor: 'specs' prior: 65080367!
defaultSpec
	^ SpBoxLayout newVertical
		add: #redSlider;
		add: #greenSlider;
		add: #blueSlider;
		yourself! !
!SpRGBSliders class methodsFor: '*Spec2-Examples' prior: 65080542!
example
	<sampleInstance>
	| example |
	example := self new
		extent: 300 @ 200;
		openWithSpec;
		yourself.
	example withWindowDo: [ :window | window title: 'RGBSliders example' ].
	^ example! !
!SpRGBSliders methodsFor: 'accessing' prior: 65079536!
blueSlider
	^ blueSlider! !
!SpRGBSliders methodsFor: 'accessing' prior: 65079299!
color
	^ (Color
				r: redSlider value
				g: greenSlider value
				b: blueSlider value
				range: 255)! !
!SpRGBSliders methodsFor: 'accessing' prior: 65079456!
greenSlider
	^ greenSlider! !
!SpRGBSliders methodsFor: 'initialization' prior: 65079695!
initializePresenters
	redSlider := self instantiate: SpSliderInput.
	greenSlider := self instantiate: SpSliderInput.
	blueSlider := self instantiate: SpSliderInput.
	redSlider
		min: 0;
		max: 255; label: 'Red' translated.
	greenSlider
		min: 0;
		max: 255; label: 'Green' translated.
	blueSlider
		min: 0;
		max: 255; label: 'Blue' translated.
	self focusOrder
		add: redSlider;
		add: greenSlider;
		add: blueSlider! !
!SpRGBSliders methodsFor: 'accessing' prior: 65079614!
redSlider
	^ redSlider! !
!SpRGBSliders methodsFor: 'initialization' prior: 65080171!
whenChangedDo: aBlock
	redSlider whenValueChangedDo: aBlock.
	greenSlider whenValueChangedDo: aBlock.
	blueSlider whenValueChangedDo: aBlock! !
!SpRGBWidget class methodsFor: 'specs' prior: 65082986!
defaultSpec
	^ SpBoxLayout newVertical
		add: #preview;
		add: #sliders;
		yourself! !
!SpRGBWidget class methodsFor: '*Spec2-Examples' prior: 65083134!
example
	<sampleInstance>
	| example |
	example := self new
		extent: 300 @ 250;
		openWithSpec;
		yourself.
	example withWindowDo: [ :window | window title: 'RGBWidget example' ].
	^ example! !
!SpRGBWidget methodsFor: 'api' prior: 65082172!
color
 ^ sliders color! !
!SpRGBWidget methodsFor: 'initialization' prior: 65082853!
connectPresenters
	sliders whenChangedDo: [ preview image: self makeNewForm ].! !
!SpRGBWidget methodsFor: 'initialization' prior: 65082382!
initializePresenters
	preview := self instantiate: SpImagePresenter.
	sliders := self instantiate: SpRGBSliders.
	preview image: (Form extent: 30 @ 30 depth: 32).
	preview image: self makeNewForm.
	self focusOrder add: sliders! !
!SpRGBWidget methodsFor: 'api' prior: 65082726!
makeNewForm
	^ (Form extent: 30 @ 30 depth: 32) fillColor: self color! !
!SpRGBWidget methodsFor: 'accessing' prior: 65082107!
preview
	^ preview! !
!SpRGBWidget methodsFor: 'accessing' prior: 65082661!
sliders
	^ sliders! !
!SpRGBWidget methodsFor: 'api-events' prior: 65082248!
whenExtentForPreviewChanged: aBlock
 extentForPreview whenChangedDo: aBlock ! !
!SpSelectEntity class methodsFor: 'specs' prior: 65137657!
defaultSpec
	^ SpBoxLayout newVertical
		add:
			(SpBoxLayout newHorizontal
				add: #entityText;
				add: #selectEntity withConstraints: [ :constraints | constraints width: self toolbarHeight ];
				yourself)
			withConstraints: [ :constraints | constraints height: self toolbarHeight ];
		yourself! !
!SpSelectEntity methodsFor: 'initialization' prior: 65135582!
connectPresenters
	selectEntity 
		action: [  |select|
			select := self selectDialog value.
			select openDialogWithSpec
				okAction: [  
					self entity: select selectedItem ]]
! !
!SpSelectEntity methodsFor: 'api' prior: 65132949!
displaySymbol
	"return the method selector used to get the label of the entity that is for entry completion"

	^ displaySymbol ifNil: [ #printString ]! !
!SpSelectEntity methodsFor: 'api' prior: 65136836!
displaySymbol: anObject
	displaySymbol := anObject.
	entityText entryCompletion: self entitiesEntryCompletion! !
!SpSelectEntity methodsFor: 'entryCompletion' prior: 65136347!
entitiesEntryCompletion
	^ EntryCompletion new
				dataSourceBlock: [:currText | self possibleEntities collect: [:each | 
		each perform: self displaySymbol ]];
				chooseBlock: [ :selectedName | 
					self entity: (self possibleEntities detect: [ :each | 
						(each perform: self displaySymbol) = selectedName ])];
				filterBlock: [:currEntity :currText | 
					currEntity asUppercase includesSubstring: currText asString asUppercase].! !
!SpSelectEntity methodsFor: 'api' prior: 65133839!
entity
	^ entity! !
!SpSelectEntity methodsFor: 'api' prior: 65137301!
entity: anObject
	entity := anObject.
	anObject ifNotNil: [ self entityText text: (anObject perform: self displaySymbol) ] ifNil: [ self entityText text: '' ]! !
!SpSelectEntity methodsFor: 'accessing' prior: 65134101!
entityText
	^ entityText! !
!SpSelectEntity methodsFor: 'accessing' prior: 65134419!
entityText: anObject
	entityText := anObject! !
!SpSelectEntity methodsFor: 'initialization' prior: 65137006!
initialize
	super initialize.
	displaySymbol := #displayString.
	placeholder := 'Choose one'.
	possibleEntities := #().
	selectDialog := [  ]! !
!SpSelectEntity methodsFor: 'initialization' prior: 65135039!
initializePresenters

	entityText := self newTextInput
		placeholder: self placeholder;
		entryCompletion: self entitiesEntryCompletion;
		yourself.
	selectEntity := self newButton
		icon: (self iconNamed: #glamorousSearch);
		help: 'Open a selection dialog'.
	self focusOrder
		add: entityText;
		add: selectEntity! !
!SpSelectEntity methodsFor: 'api' prior: 65135941!
placeholder
	^ placeholder ifNil: [ '' ]! !
!SpSelectEntity methodsFor: 'api' prior: 65133487!
placeholder: aString
	placeholder := aString.
	entityText placeholder: aString! !
!SpSelectEntity methodsFor: 'api' prior: 65132811!
possibleEntities
	^ possibleEntities ifNil: [ #() ] ifNotNil: [ possibleEntities value ]! !
!SpSelectEntity methodsFor: 'api' prior: 65134175!
possibleEntities: aBlock
	"Set the block used to return a collection of all possible entity choices"

	possibleEntities := aBlock.
	entityText entryCompletion: self entitiesEntryCompletion! !
!SpSelectEntity methodsFor: 'api' prior: 65136115!
selectDialog
	^ selectDialog! !
!SpSelectEntity methodsFor: 'api' prior: 65133615!
selectDialog: anObject
	"Set a block that returns an object that will 
	first be sent #openDialogWithSpec
	and then as okAction sent #selectedItem"

	selectDialog := anObject! !
!SpSelectEntity methodsFor: 'accessing' prior: 65136037!
selectEntity
	^ selectEntity! !
!SpSelectEntity methodsFor: 'accessing' prior: 65137203!
selectEntity: anObject
	selectEntity := anObject! !
!SpSelectEntity methodsFor: 'api-events' prior: 65136200!
whenDisplaySymbolChanged: aBlock
	self property: #displaySymbol whenChangedDo: aBlock! !
!SpSelectEntity methodsFor: 'api-events' prior: 65135820!
whenEntityChanged: aBlock
	self property: #entity whenChangedDo: aBlock! !
!SpSelectEntity methodsFor: 'api-events' prior: 65133912!
whenPlaceholderChanged: aBlock
	"aBlock will be performed when ghostText changed"

	self property: #placeholder whenChangedDo: aBlock! !
!SpSelectEntity methodsFor: 'api-events' prior: 65135430!
whenPossibleEntitiesChanged: aBlock
	self property: #possibleEntities whenChangedDo: aBlock! !
!SpSelectEntity methodsFor: 'api-events' prior: 65137516!
whenSelectDialogChanged: aBlock
	self property: #selectDialog whenChangedDo: aBlock! !
!SpTestPresenterWithToolbar class methodsFor: 'specs'!
defaultSpec

	^ SpBoxLayout newVertical
		add: (SpPanedLayout newVertical
			add: #button;
			yourself);
		yourself! !
!SpTestPresenterWithToolbar methodsFor: 'initialization'!
initializePresenters
	button := self newButton
		label: 'test';
		yourself.! !
!SpTestPresenterWithToolbar methodsFor: 'initialization'!
initializeWindow: aWindowPresenter
	| toolbar |
	toolbar := SpToolBarPresenter new
		addItemLeft: (SpToolBarButtonPresenter new
			label: 'toolbar button';
			yourself);
		yourself.
	aWindowPresenter
		title: self class name;
		initialExtent: 700 @ 500;
		toolBar: toolbar! !
!SpTransmissionExample class methodsFor: 'specs' prior: 65363890!
defaultSpec

	^ SpBoxLayout newVertical
		add: (SpBoxLayout newHorizontal 
			add: #packages;
			add: #classes;
			add: #protocols;
			add: #methods);
		add: #code;
		yourself! !
!SpTransmissionExample class methodsFor: 'showing' prior: 65363783!
open 
	<script>
	
	^ self new openWithSpec! !
!SpTransmissionExample methodsFor: 'initialization' prior: 65362266!
classTemplateFor: aPackage
	
	^ 'Object subclass: #NameOfSubclass
	slots: {}
	classVariables: {}
	package: ''', aPackage name,''' ' 
	! !
!SpTransmissionExample methodsFor: 'initialization' prior: 65362468!
initializePresenters
	packages := self newList display: #name.
	classes := self newList display: #name.
	protocols := self newList display: [ :aPair | aPair value name ].
	methods := self newList display: #selector.
	code := self newCode.
	packages
		transmitTo: classes
		transform: [ :aPackage | aPackage definedClasses asArray ].
	packages
		transmitTo: code
		transform: [ :aPackage | self classTemplateFor: aPackage ].
	classes
		transmitTo: protocols
		transform: [ :aClass | 
			aClass organization allProtocols
				collect: [ :each | aClass -> each ]
				as: OrderedCollection ]
		postTransmission: [ :destination :origin | destination selectIndex: 1 ].
	classes transmitTo: code transform: #definitionWithSlots.
	protocols
		transmitTo: methods
		transform: [ :aPair | 
			aPair value methods
				collect: [ :each | aPair key >> each ]
				as: OrderedCollection ].
	protocols
		transmitTo: code
		transform: [ :aPair | aPair key sourceCodeTemplate ].
	methods transmitTo: code transform: #sourceCode.
	packages items: RPackageOrganizer default packages! !
!SpTransmissionExample methodsFor: 'initialization' prior: 65363597!
initializeWindow: aWindowPresenter

	aWindowPresenter
		title: 'Transmission example browser';
		initialExtent: 800@600! !
!SpStringTableColumn methodsFor: 'testing'!
isSortable
	
	^ true! !
!SpMultipleSelectionMode methodsFor: 'selecting' prior: 64894340!
selectIndexes: aCollection
	| indexes |
	indexes := aCollection 
		collect: [ :each | self withinRangeIndex: each ]
		thenReject: [ :each | each = 0 ]. "0 index means out of range"
	(aCollection isNotEmpty and: [ indexes isEmpty ]) "all indexes are out of range"
		ifTrue: [ ^ #() ].

	indexes := indexes asOrderedCollection removeDuplicates.
	indexes = self selectedIndexes ifTrue: [ ^ self ].

	^ selectedIndexes := indexes! !
!SpMultipleSelectionMode methodsFor: 'selecting' prior: 64893554!
selectedItems

	^ self widget itemsAt: self selectedIndexes! !
!SpMultipleSelectionMode methodsFor: 'selecting'!
selectedItemsSortedByIndex

	^ self widget itemsAt: self selectedIndexes sort! !
!SpMultipleSelectionMode methodsFor: 'transmission' prior: 64895316!
transmission 
	
	^ self selectedItems! !
!SpMorphicDropListAdapter methodsFor: 'as yet unclassified'!
elementAt: index
	
	^ self presenter getList at: index! !
!SpToolBarPresenterTest methodsFor: 'private' prior: 65354872!
newToolbarItem
	
	^ SpToolBarButtonPresenter new! !
!SpToolBarPresenterTest methodsFor: 'tests' prior: 65354470!
testAddItem

	presenter addItem: SpToolBarButtonPresenter new.
	self assert: presenter items size equals: 1! !
!SpToolBarPresenterTest methodsFor: 'tests' prior: 65355452!
testIsEmpty 

	self assert: presenter isEmpty.
	presenter addItem: SpToolBarButtonPresenter new.
	self deny: presenter isEmpty! !
!SpNullApplication class methodsFor: 'initialization' prior: 64928964!
reset
	<script>
	
	DefaultApplication ifNotNil: [ 
		DefaultApplication reset ].
	DefaultApplication := nil! !
!SpImageAdapterTest methodsFor: 'accessing' prior: 64453627!
classToTest

	^ SpImagePresenter! !
!SpImageAdapterTest methodsFor: 'building' prior: 64453937!
imageForm

	^ (PNGReadWriter on: 
			(ZnBase64Encoder new decode: PolymorphSystemSettings pharoLogoContents) readStream) 
			nextImage! !
!SpImageAdapterTest methodsFor: 'building' prior: 64452839!
testAutoscale

	self presenter image: self imageForm.

	self presenter autoScale: false.
	self deny: self adapter hasImageAutoscaled.

	self presenter autoScale: true.
	self assert: self adapter hasImageAutoscaled.
! !
!SpImageAdapterTest methodsFor: 'building' prior: 64453424!
testSettingAnImageSetsTheImage

	self presenter image: self imageForm.
	backendForTest assertImage: self adapter image equals: self imageForm.
! !
!SpImageAdapterTest methodsFor: 'building' prior: 64453113!
testSettingAnImageSetsTheImageAndThrowsEvent

	| happened |
	self presenter whenImageChangeDo: [ happened := true ].
	self presenter image: self imageForm.
	
	backendForTest assertImage: self adapter image equals: self imageForm.
	self assert: happened! !
!SpImageAdapterTest methodsFor: 'building' prior: 64453718!
testSettingNilClearsTheImage

	self presenter image: self imageForm.
	self presenter image: nil.
	
	backendForTest assertImage: self adapter image equals: nil.
! !
!SpMorphicBoxAdapter methodsFor: 'private'!
applyAlignmentTo: aWidget
	| alignmentWidget |
	
	aWidget 
		changeTableLayout;
		hResizing: #shrinkWrap; 
		vResizing: #shrinkWrap.
	
	alignmentWidget := Morph new
		changeTableLayout; 
		color: Color transparent;
		addMorphBack: widget.
		
	layout isVertical 
		ifTrue: [
			layout vAlign ifNotNil: [ :align |
				alignmentWidget wrapCentering: align asMorphicAlign ].
			layout hAlign ifNotNil: [ :align |
				alignmentWidget listCentering: align asMorphicAlign ] ]
		ifFalse: [ 
			layout vAlign ifNotNil: [ :align |
				alignmentWidget listCentering: align asMorphicAlign ].
			layout hAlign ifNotNil: [ :align |
				alignmentWidget wrapCentering: align asMorphicAlign ] ].
		
	^ alignmentWidget! !
!SpMorphicBoxAdapter methodsFor: 'private' prior: 64698470!
basicAdd: aPresenter constraints: constraints to: aPanel
	| childMorph |

	childMorph := self buildMorph: aPresenter constraints: constraints.	

	aPanel extent: (aPanel width max: childMorph width)@(aPanel height max: childMorph height).

	constraints isPlacedAtStart
		ifTrue: [ startPanel addMorphBack: childMorph ]
		ifFalse: [ endPanel addMorphBack: childMorph ].

	^ childMorph! !
!SpMorphicBoxAdapter methodsFor: 'accessing'!
children

	^ startPanel submorphs, endPanel submorphs! !
!SpMorphicBoxAdapter methodsFor: 'accessing' prior: 64696310!
childrenWidgets
	
	^ self children! !
!SpMorphicBoxAdapter methodsFor: 'factory' prior: 64698956!
layout: aLayout

	layout := aLayout.
	
	widget ifNil: [
		"build of widget was differed up to here (to know what is the direction)"
		widget := aLayout direction newWidgetOn: self.
		widget borderWidth: aLayout borderWidth.
		aLayout hasAlignment ifTrue: [ 
			widget := self applyAlignmentTo: widget ].
		"the spacing needs to be applied to the inner sub-panels"
		{ startPanel. endPanel } do: [ :each |
			each cellInset: aLayout spacing ].
		"widget homogeneous: aLayout isHomogeneous" ].

	aLayout whenChildrenAddedDo: [ :ann |
		self
			add: ann child
			constraints: (aLayout constraintsFor: ann child) ].
	
	aLayout whenChildrenRemovedDo: [ :ann |
		self remove: ann child ].
	
	super layout: aLayout! !
!SpMorphicBoxAdapter methodsFor: 'factory' prior: 64696457!
newHorizontal

	^ self newPanel 
		listDirection: #leftToRight;
		addMorphBack: ((startPanel := self newPanel)
			listDirection: #leftToRight;
			yourself);
		addMorphBack: ((endPanel := self newPanel)
			listDirection: #leftToRight;
			hResizing: #shrinkWrap;
			width: 0;
			yourself);
		yourself	! !
!SpMorphicBoxAdapter methodsFor: 'factory' prior: 64695327!
newVertical

	^ self newPanel 
		listDirection: #topToBottom;
		addMorphBack: ((startPanel := self newPanel)
			listDirection: #topToBottom;
			yourself);
		addMorphBack: ((endPanel := self newPanel)
			listDirection: #topToBottom;
			vResizing: #shrinkWrap;
			height: 0;
			yourself);
		yourself	! !
!SpMorphicBoxAdapter methodsFor: 'accessing' prior: 64697648!
remove: aPresenter

	| morph |
	morph := aPresenter adapter widget.	
	startPanel removeMorph: morph.
	endPanel removeMorph: morph.! !
!SpMorphicBoxAdapter methodsFor: 'accessing' prior: 64699445!
removeAll

	startPanel removeAllMorphs.
	endPanel removeAllMorphs! !
!SpMorphicBoxAdapter methodsFor: 'factory' prior: 64698312!
removeSubWidgets

	startPanel removeAllMorphs.
	endPanel removeAllMorphs! !
!SpMorphicLayoutAdapter methodsFor: 'accessing'!
children

	^ self subclassResponsibility! !
!SpMorphicLayoutAdapter methodsFor: 'testing'!
isEmpty

	^ self children isEmpty! !
!SpMorphicLayoutAdapter methodsFor: 'initialization'!
replaceLayoutWith: aLayout 
	| oldAdapter |

	self widget owner ifNil: [ ^ self ].

	oldAdapter := self.
	self model adapter: (aLayout
		buildAdapterFor: self model
		bindings: self model application adapterBindings).
		
	oldAdapter widget owner 
		replaceSubmorph: oldAdapter widget  
		by: self model adapter widget! !
!SpMorphicOverlayAdapter methodsFor: 'protocol' prior: 64798261!
basicAdd: aPresenter constraints: constraints to: aWidget
	| childMorph |

	childMorph := self buildMorph: aPresenter constraints: constraints.	
	aWidget addMorphBack: childMorph.
	^ childMorph! !
!SpMorphicOverlayAdapter methodsFor: 'accessing'!
children
	
	^ widget submorphs! !
!SpMorphicOverlayAdapter methodsFor: 'protocol' prior: 64798514!
layout: aLayout
	widget
		ifNil: [ widget := PanelMorph new
				layoutPolicy: SpMorphicOverlayLayout new;
				hResizing: #spaceFill;
				vResizing: #spaceFill;
				color: Color transparent;
				borderColor: Color transparent;
				yourself ].

	aLayout whenChildrenAddedDo: [ :ann |
		self 
			basicAdd: ann child
			constraints: (aLayout constraintsFor: ann child) 
			to: widget ].
		
	aLayout whenChildrenRemovedDo: [ :ann |
		self removeChild: ann child ].

	super layout: aLayout! !
!SpMorphicOverlayAdapter methodsFor: 'accessing'!
removeChild: aPresenter
	
	| morph |
	morph := aPresenter adapter widget.
	widget removeMorph: morph! !
!SpMorphicPanedAdapter methodsFor: 'adding/removing' prior: 64800665!
addConstraits: constraints toChild: childMorph
	"adds constraits by child"
	| theMorph |
	
	theMorph := childMorph.
	"keep constraints to layout usage"
	theMorph setProperty: #constraints toValue: constraints. 
	
	^ theMorph ! !
!SpMorphicPanedAdapter methodsFor: 'adding/removing' prior: 64800334!
addSplitterIn: aPanel for: childMorph

	aPanel submorphs size = 1 ifFalse: [ ^ self ].
	aPanel addMorphBack: self direction newSplitter! !
!SpMorphicPanedAdapter methodsFor: 'adding/removing' prior: 64801092!
basicAdd: aPresenter constraints: constraints to: aPanel
	| childMorph |

	childMorph := self buildMorph: aPresenter constraints: constraints.	
	children add: childMorph.
	aPanel addMorphBack: childMorph.
	self addSplitterIn: aPanel for: childMorph.
	
	^ childMorph! !
!SpMorphicPanedAdapter methodsFor: 'accessing'!
children

	^ children! !
!SpMorphicPanedAdapter methodsFor: 'initialization'!
initialize
	super initialize.
	children := OrderedCollection new.! !
!SpMorphicPanedAdapter methodsFor: 'factory' prior: 64801549!
layout: aLayout
	layout := aLayout.
	widget
		ifNil: [ widget := aLayout direction newWidgetOn: self.
			widget layoutPolicy position: aLayout position.
			self selector: self splitterNewSelector ].

	layout whenChildrenAddedDo: [ :ann |
		self 
			basicAdd: ann child
			constraints: (layout constraintsFor: ann child) 
			to: widget ].
		
	layout whenChildrenRemovedDo: [ :ann |
		self removeChild: ann child ].

	super layout: aLayout! !
!SpMorphicPanedAdapter methodsFor: 'adding/removing'!
removeChild: aPresenter
	
	| morph |
	morph := aPresenter adapter widget.
	children remove: morph.
	widget removeMorph: morph! !
!SpMorphicScrollableAdapter methodsFor: 'accessing'!
children

	widget scrollTarget == emptyLayoutMarker
		ifTrue: [ ^ #() ].
	^ { widget scrollTarget }! !
!SpMorphicScrollableAdapter methodsFor: 'protocol' prior: 64808133!
layout: aLayout

	emptyLayoutMarker := PanelMorph new 
		hResizing: #spaceFill;
		vResizing: #spaceFill;
		yourself.
	widget ifNil: [
		widget := GeneralScrollPane new
			changeScrollerTableLayout;
			hResizing: #spaceFill;
			vResizing: #spaceFill;
			color: Color transparent;
			borderColor: Color transparent;
			scrollTarget: emptyLayoutMarker;
			yourself ].

	aLayout child ifNotNil: [ 
		self 
			basicAdd: aLayout child
			constraints: (aLayout constraintsFor: aLayout child)
			to: widget ].

	aLayout whenChildrenAddedDo: [ :ann |
		self 
			basicAdd: ann child
			constraints: (aLayout constraintsFor: ann child) 
			to: widget ].
		
	aLayout whenChildrenRemovedDo: [ :ann |
		self removeChild: ann child ].

	super layout: aLayout! !
!SpMorphicScrollableAdapter methodsFor: 'removing'!
removeChild: aPresenter

	self assert: aPresenter adapter widget == widget scrollTarget.
	widget scrollTarget: emptyLayoutMarker! !
!SpMorphicToolBarMenuButtonMorph class methodsFor: 'instance creation'!
new

	self error: 'Use newButton:menuButton:'! !
!SpMorphicToolBarMenuButtonMorph class methodsFor: 'instance creation'!
newButton: aButtonMorph menuButton: aMenuButton

	^ self basicNew
		initializeButton: aButtonMorph menuButton: aMenuButton;
		yourself! !
!SpMorphicToolBarMenuButtonMorph methodsFor: 'accessing'!
button 

	^ self submorphs first! !
!SpMorphicToolBarMenuButtonMorph methodsFor: 'configuring'!
configureWith: aMode item: aButton

	"transmit to button"
	self button
		configureWith: aMode 
		item: aButton! !
!SpMorphicToolBarMenuButtonMorph methodsFor: 'accessing'!
font: aFont 
	
	self submorphs do: [ :each |
		(each respondsTo: #font:) ifTrue: [ 
			each font: aFont ] ]! !
!SpMorphicToolBarMenuButtonMorph methodsFor: 'initialization'!
initialize

	super initialize.
	self 
		changeTableLayout;
		listDirection: #leftToRight;
		hResizing: #shrinkWrap;
		vResizing: #spaceFill;
		color: Color transparent;
		borderColor: Color transparent;
		clipSubmorphs: true;
		borderWidth: 0;
		extent: 0@0! !
!SpMorphicToolBarMenuButtonMorph methodsFor: 'initialization'!
initializeButton: aButtonMorph menuButton: aMenuButton

	self initialize.
	self addMorphBack: (aButtonMorph 
		hResizing: #shrinkWrap;
		yourself).
	self addMorphBack: aMenuButton! !
!SpMorphicToolBarMenuButtonMorph methodsFor: 'accessing'!
menuButton 

	^ self submorphs second! !
!SpMorphicButtonAdapter methodsFor: 'private' prior: 64705393!
buildLabel: text withIcon: icon

	icon ifNil: [ ^ (text localizedForPresenter: self presenter)
			ifNil: [ '' ] ].
	
	^ IconicListItem 
		text: text 
		icon: icon
! !
!SpMorphicButtonAdapter methodsFor: 'factory' prior: 64703357!
buildWidget
	| button | 

	button := self newButton.	
	button 
		getEnabledSelector: #enabled ;
		getFontSelector: #font ;
		hResizing: #spaceFill ;
		vResizing: #spaceFill ;
		askBeforeChanging: self askBeforeChanging ;
		setBalloonText: self getHelpText ;
		dragEnabled: self dragEnabled;
		dropEnabled: self dropEnabled ;	
		eventHandler: (MorphicEventHandler new 
			on: #keyStroke 
			send: #keyStroke:fromMorph: 
			to: self).
	
	self color ifNotNil: [ self setWidgetColor: button ].
	
	button 
		bindKeyCombination: Character space 
		toAction: [ self action ].

	^ button! !
!SpMorphicButtonAdapter methodsFor: 'private'!
getHelpText

	^ self presenter help ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicButtonAdapter methodsFor: 'private'!
getLabelText

	^ self presenter label ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicButtonAdapter methodsFor: 'widget API' prior: 64702484!
label
	
	^ self buildLabel: self presenter label withIcon: self presenter icon! !
!SpMorphicButtonAdapter methodsFor: 'widget API' prior: 64704181!
showSubMenu: aMenu 

	aMenu menuGroups ifNil: [ ^ self ].
	 
	subMenuWidget ifNotNil: [ 
		subMenuWidget delete.
		subMenuWidget := nil ].
	subMenuWidget := (SpMorphicMenuAdapter adaptAsPopup: aMenu) widget.
	subMenuWidget
		popUpAdjacentTo: { 
			self widget bounds bottomLeft.
			self widget bounds bottomRight }
		forHand: self widget activeHand
		from: self widget.
	subMenuWidget popUpOwner: self! !
!SpStyleDraw methodsFor: 'accessing' prior: 65185877!
backgroundColor: aColorOrSymbol

	backgroundColor := self toColor: aColorOrSymbol! !
!SpStyleDraw methodsFor: 'accessing' prior: 65185703!
color: aColorOrSymbol

	color := self toColor: aColorOrSymbol! !
!SpStyleDraw methodsFor: 'private'!
toColor: aColorOrSymbol

	"Try if color"
	aColorOrSymbol isSymbol ifFalse: [ ^ aColorOrSymbol ].
	"Try by name"
	(Color named: aColorOrSymbol) ifNotNil: [ :aColor | ^ aColor ]. 
	"Try by HEX (CSS style)"				
	^ Color fromHexString: aColorOrSymbol! !
!SpOutputPort methodsFor: 'transmitting'!
transmitDo: aBlock
	
	^ SpTransmission new
		fromPort: self;
		do: aBlock;
		apply! !
!SpOutputPort methodsFor: 'transmitting'!
transmitDo: aBlock transform: transformBlock
	
	^ SpTransmission new
		fromPort: self;
		do: aBlock;
		transform: transformBlock;
		apply! !
!SpOutputPort methodsFor: 'transmitting'!
transmitTo: aPort

	^ SpTransmission new
		fromPort: self;
		toPort: aPort;
		apply! !
!SpOutputPort methodsFor: 'transmitting'!
transmitTo: aPort transform: aValuable

	^ SpTransmission new
		fromPort: self;
		toPort: aPort;
		transform: aValuable;
		apply! !
!SpOutputPort methodsFor: 'transmitting'!
transmitTo: aPort transform: aValuable postTransmission: postValuable

	^ SpTransmission new
		fromPort: self;
		toPort: aPort;
		transform: aValuable;
		postTransmission: postValuable;
		apply! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
completionClass
	^ completionClass! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
completionClass: anObject
	completionClass := anObject! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
doItContext

	^ doItContext! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
doItContext: aContext

	doItContext := aContext! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
doItRequestor

	^ doItRequestor! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
doItRequestor: aRequestor

	doItRequestor := aRequestor! !
!SpCodeCompletionEngine methodsFor: 'testing'!
isScripting

	^ scripting! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
scripting: aBoolean 

	scripting := aBoolean! !
!SpCodeCompletionEngine methodsFor: 'accessing'!
variableBindingNames

	^ self doItRequestor variableBindingNames! !
!SpChooseMethodUI methodsFor: 'initialization - actions' prior: 64180880!
packageListAction
	packageList
		transmitTo: classList
		transform: [ :selectedPackage | 
			selectedPackage
				ifNil: [ #() ]
				ifNotNil: [ selectedPackage classes asOrderedCollection ] ]
		postTransmission: [ classList selectIndex: 1 ]! !
!SpCommand methodsFor: 'converting' prior: 64230722!
asButtonPresenter
	self flag: #TODO. "Needs to use inform user display strategy when available, no other available strategy can be used in this context. See issue #705"
	self configureAsButton.
	^ self buildPresenter! !
!SpCommand methodsFor: 'presenter building'!
buildPresenter
	^ presenter := self buildPresenterBlock value: self! !
!SpCommand methodsFor: 'accessing'!
buildPresenterBlock
	^ buildPresenterBlock! !
!SpCommand methodsFor: 'accessing'!
buildPresenterBlock: anObject
	buildPresenterBlock := anObject! !
!SpCommand methodsFor: 'presenter building'!
configureAsButton
	self configureAsButtonOfClass: SpButtonPresenter! !
!SpCommand methodsFor: 'presenter building'!
configureAsButtonOfClass: aButtonClass
	self
		buildPresenterBlock: [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ]! !
!SpCommand methodsFor: 'presenter building'!
configureAsToolBarButton
	self configureAsButtonOfClass: SpToolBarButtonPresenter! !
!SpCommand methodsFor: 'presenter building'!
configureAsToolBarToggleButton
	self configureAsButtonOfClass: SpToolBarToggleButtonPresenter! !
!SpCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self configureAsToolBarButton! !
!SpCommand methodsFor: 'accessing'!
presenter
	^ presenter! !
!SpCommand methodsFor: 'updating'!
updateEnableStatus 
    self presenter enabled: self canBeExecuted! !
!Form methodsFor: '*Spec2-Morphic' prior: 26395010!
asPresenter

	^ SpImagePresenter new 
		image: self;
		yourself! !
!SpPort class methodsFor: 'instance creation'!
newPresenter: aPresenter

	^ self new 
		presenter: aPresenter;
		yourself! !
!SpAbstractTreeTableAdapterTest methodsFor: 'running'!
initializeTestedInstance
	presenter
		addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);
		hideColumnHeaders;
		roots: #(1 2 3);
		children: [ :aNumber | {(aNumber * 2) . (aNumber * 3) . (aNumber * 10)} ]! !
!SpAbstractTreeTableAdapterTest methodsFor: 'tests'!
testAfterOpeningEmptyLazyChildrenExpandIconVanish
	presenter
		children: [ :aNumber | aNumber odd ifTrue: [ {(aNumber * 2) . (aNumber * 3) . (aNumber * 10)} ] ifFalse: [ #() ] ];
		lazilyComputeChildren.

	self
		assert: (self adapter isRowMorphExpandableAt: 2)
		description: 'If we do not compute the children then we should show an expand icon even if there is no children'.

	self adapter expandRowAt: 2.	"This row has no child"

	self deny: (self adapter isRowMorphExpandableAt: 2)! !
!SpAbstractTreeTableAdapterTest methodsFor: 'tests'!
testItemsWithoutChildrenDoNotHaveExpandIcon
	presenter children: [ :aNumber | aNumber odd ifTrue: [ {(aNumber * 2) . (aNumber * 3) . (aNumber * 10)} ] ifFalse: [ #() ] ].

	self assert: (self adapter isRowMorphExpandableAt: 1).
	self deny: (self adapter isRowMorphExpandableAt: 2).
	self assert: (self adapter isRowMorphExpandableAt: 3)! !
!SpAbstractTreeTableAdapterTest methodsFor: 'tests'!
testLazilyComputeChildrenDoesNotComputeChildren
	presenter
		children: [ :aNumber | aNumber odd ifTrue: [ {(aNumber * 2) . (aNumber * 3) . (aNumber * 10)} ] ifFalse: [ #() ] ];
		lazilyComputeChildren.

	self assert: (self adapter isRowMorphExpandableAt: 1).
	self
		assert: (self adapter isRowMorphExpandableAt: 2)
		description: 'If we do not compute the children then we should show an expand icon even if there is no children'.
	self assert: (self adapter isRowMorphExpandableAt: 3)! !
!SpChildrenAdded methodsFor: 'accessing'!
child
	^ child! !
!SpChildrenAdded methodsFor: 'accessing'!
child: aPresenter 
	child := aPresenter! !
!SpChildrenAdded methodsFor: 'accessing'!
parent: aPresenter 
	parent := aPresenter! !
!SpChildrenRemoved methodsFor: 'accessing'!
child
	^ child! !
!SpChildrenRemoved methodsFor: 'accessing'!
child: aPresenter 
	child := aPresenter! !
!SpChildrenRemoved methodsFor: 'accessing'!
parent: aPresenter 
	parent := aPresenter! !
!SpWindowAnnouncement methodsFor: 'accessing'!
window
	^ window! !
!SpWindowAnnouncement methodsFor: 'accessing'!
window: anObject
	window := anObject! !
!SpWindowResizing methodsFor: 'testing'!
isResized
	^ true! !
!SpWindowResizing methodsFor: 'testing'!
newSize
	^ newSize! !
!SpWindowResizing methodsFor: 'testing'!
newSize: anObject
	newSize := anObject! !
!SpWindowResizing methodsFor: 'testing'!
oldSize
	^ oldSize! !
!SpWindowResizing methodsFor: 'testing'!
oldSize: anObject
	oldSize := anObject! !
!SpWindowWillClose methodsFor: 'accessing'!
window
	^ window! !
!SpWindowWillClose methodsFor: 'accessing'!
window: anObject
	window := anObject! !
!SpClassMethodBrowser methodsFor: 'initialization' prior: 64190757!
connectPresenters
	classListPresenter
		transmitTo: methodListPresenter
		transform: [ :class | class ifNil: [ #() ] ifNotNil: [ class methods sort: #selector descending ] ]
		postTransmission: [ :destination | destination selectIndex: 1 ].
		
	methodListPresenter
		transmitTo: textPresenter
		transform: [ :method | method ifNil: [ '' ] ifNotNil: #sourceCode ]
		postTransmission:
			[ :destination :origin :transmited | 
			transmited ifNotNil: [ destination behavior: transmited methodClass ] ]! !
!SpClassMethodBrowser methodsFor: 'initialization' prior: 64190348!
initializePresenters
	classListPresenter := self newList.
	methodListPresenter := self newList.
	textPresenter := self newCode.
	textPresenter whenSubmitDo: [ :t | methodListPresenter selectedItem inspect ].
	methodListPresenter display: #selector.
	self focusOrder
		add: classListPresenter;
		add: methodListPresenter;
		add: textPresenter! !
!SpLabelledPresenter methodsFor: 'accessing' prior: 64496919!
description: aString
	aString ifNil: [ ^ self ].
	
	descriptionPresenter := self newLabel
		addStyle: 'italic';
		label: aString;
		yourself! !
!SpToolBarPresenterBuilder methodsFor: 'visiting' prior: 65353960!
visitCommand: aCmCommandEntry
	aCmCommandEntry positionStrategy
		addButton: aCmCommandEntry buildPresenter
		toToolbar: self toolbarPresenter! !
!SpSingleSelectionModeTest methodsFor: 'tests'!
testDropListSelectionIsNotAffectedBySorting
	"To get the proper selection when a presenter is sorted, the selection asks the adapter to return the right element according to the sorting.
	DropList does not share the same hierarchy as other lists.
	We need to ensure that drop list is polymorphic with other lists and handle correctly the selection"
	presenter := SpDropListPresenter new.
	presenter 
		items: (1 to: 10) asArray;
		selectIndex: 3;
		openWithSpec.
		
	self assert: presenter selection selectedItem model equals: 3! !
!SpSingleSelectionModeTest methodsFor: 'tests'!
testDropListSelectionIsResetAfterItemsAssignment
	presenter := SpDropListPresenter new.
	presenter
		items: (1 to: 10) asArray;
		selectIndex: 1.

	presenter items: #(2 5).

	self 
		assert: presenter selection selectedItem
		equals: nil! !
!SpSingleSelectionModeTest methodsFor: 'tests'!
testGetRightElementAfterSortingOfElementsChanged
	presenter := SpTablePresenter new. "use a TablePresenter since ListPresenter cannot sort"
	presenter 
		items: (1 to: 10) asArray;
		beSingleSelection;
		openWithSpec.
	
	presenter 
		withAdapterDo: [ :adapter | adapter widget dataSource sortElements: [ :a :b | a > b ] ];
		selectIndex: 3.
	
	self assert: presenter selection selectedItem equals: 8! !
!SpSingleSelectionModeTest methodsFor: 'tests'!
testSelectionIsResetAfterItemsAssignment
	presenter
		beSingleSelection;
		openWithSpec;
		selectIndex: 1.

	presenter items: #(2 5).

	self 
		assert: presenter selection selectedItem 
		equals: nil! !
!SpSingleSelectionModeTest methodsFor: 'tests'!
testSelectionIsResetAfterSorting
	presenter := SpTablePresenter new.	"use a TablePresenter since ListPresenter cannot sort"
	presenter
		items: (1 to: 10) asArray;
		beSingleSelection;
		openWithSpec;
		selectIndex: 1.
		
	presenter
		withAdapterDo: [ :adapter | 
			adapter widget dataSource
				sortByColumn: presenter adapter columns first
				event: nil
				morph: nil ].
			
	self assert: presenter selection selectedItem equals: nil! !
!SpDemoNotebookPresenter methodsFor: 'pages' prior: 64312753!
objectInspectorPage
	^ SpNotebookPage
		title: 'Object inspector'
		icon: (self iconNamed: #nautilusIcon)
		provider: [ 
			self flag: #TODO. "Using reference to suspend a dependency, but is not cool since 
			it makes a hidden depenency. Instead, we better think another example" 
			(self class environment at: #EyeInspector) new
				inspect: Object;
				yourself ]
		layoutSpec: #inspectorSpec! !
!SpTMorphicTableDataSourceCommons methodsFor: 'accessing' prior: 65224524!
headerColumn: column
	| headerMorph |

	column id ifNil: [ ^ nil ].
	headerMorph := SpHeaderCellMorph new 
		addMorph: column id asMorph asReadOnlyMorph;
		yourself.
		
	column isSortable ifTrue: [ 
		headerMorph eventHandler: (MorphicEventHandler new 
			on: #click 
			send: #sortByColumn:event:morph:
			to: self
			withValue: column).
	column sortingIcon ifNotNil: [ :icon | headerMorph addMorph: icon ] ].

	^ headerMorph! !
!SpTMorphicTableDataSourceCommons methodsFor: 'sorting' prior: 65224369!
sortByColumn: aColumn event: anEvent morph: aMorph

	aColumn sortDataSource: self.
	self model selection unselectAll.! !
!SpAbstractFormButtonPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #label
	! !
!SpDropListMorph methodsFor: 'configuring' prior: 64362664!
configureWith: displayModel item: itemPresenter
	displayModel configureDropList: self item: itemPresenter! !
!SpTablePresenter methodsFor: 'emulating'!
clickOnColumnHeaderAt: anIndex
	self withAdapterDo: [ :tableAdapter | tableAdapter clickOnColumnHeaderAt: anIndex ]! !
!SpTreeTableAdapterSingleColumnMultiSelectionTest methodsFor: 'running' prior: 65409637!
initializeTestedInstance
	super initializeTestedInstance.
	presenter beMultipleSelection! !
!SpTablePresenterTest methodsFor: 'tests'!
testGivenSortingIsActiveWhenAffectingNewItemsThenNewItemsAreSorted
	[ presenter
		addColumn: (SpStringTableColumn title: ' i ' evaluated: #value);
		addColumn: (SpStringTableColumn title: ' 1 / i ' evaluated: [ :item | (1 / item) value ]);
		openWithSpec;
		selectIndex: 1.
		
	"sort by 1/i ascending"
	presenter clickOnColumnHeaderAt: 2.

	presenter
		items: #(40 50); 
		selectIndex: 1.
	
	self assert: presenter selection selectedItem equals: 50 "items are still sorted by 1/i ascending value" ]
		ensure: [ presenter delete ]! !
!SpTablePresenterTest methodsFor: 'tests'!
testSelectedItemsReturnsRightElementAfterSortingOfElementsChanged
	[ presenter
		addColumn: (SpStringTableColumn title: ' i ' evaluated: #value);
		addColumn: (SpStringTableColumn title: ' 1 / i ' evaluated: [ :item | (1 / item) value ]);
		openWithSpec;
		selectIndex: 1. "10"
		
	"sort by 1/i ascending"
	presenter clickOnColumnHeaderAt: 2.

	presenter selectIndex: 1.
	
	self assert: presenter selectedItems first equals: 30 "items are still sorted by 1/i ascending value" ]
		ensure: [ presenter delete ]! !
!SpAbstractButtonPresenter methodsFor: 'private' prior: 63950232!
addShortcutTipFor: aCharacter on: aString
	
	^ aString withAccentuatedCharacter: aCharacter! !
!SpAbstractButtonPresenter methodsFor: 'localization'!
localeChanged

	super localeChanged.
	self forceUpdateSlot: #label
	! !
!SpAbstractButtonPresenter methodsFor: 'api-events' prior: 63948998!
whenIconChangedDo: aBlock

	self property: #icon whenChangedDo: aBlock! !
!SpButtonPresenter methodsFor: 'initialization' prior: 64152591!
initialize
	super initialize.

	action := [  ].
	state := false.
	askBeforeChanging := false.

	self whenFontChangedDo: [ self changed: #font ].
	self whenStateChangedDo: [ self changed: #state ].
	self whenMenuChangedDo: [ 
		self withAdapterDo: [ :anAdapter | anAdapter updateMenu ] ].
	self 
		property: #askBeforeChanging 
		whenChangedDo: [ :newValue | self changed: {#askBeforeChanging: . newValue} ].
	self
		property: #shortcut
		whenChangedDo: [ :newShortcut :oldShortcut | 
			self unregisterShortcut: oldShortcut.
			self registerShortcut: newShortcut.
			self changed: #label ].

	self color: nil! !
!SpDemoToolBarPresenter methodsFor: 'initialization' prior: 64333501!
initializePresenters
	
	toolBar := self newToolBar
		addItem: (SpToolBarButtonPresenter new
			label: 'Ok';
			icon: (self iconNamed: #smallOk);
			help: 'Ok';
			action: [ self inform: 'Ok' ];
			yourself);
		addItem: (SpToolBarButtonPresenter new
			label: 'Cancel';
			icon: (self iconNamed: #smallCancel);
			help: 'Cancel';
			action: [ self inform: 'Cancel' ];
			yourself);
		yourself.
	text := self newText! !
!CmCommand class methodsFor: '*Spec2-Commander2' prior: 21073983!
forSpecContext: anObject

	^ self new 
	context: anObject;
	asSpecCommand! !
!SpCodeSelectionCommand methodsFor: 'private' prior: 64212125!
evaluate: aString andDo: aBlock
	"Treat the current selection as an expression; evaluate it and invoke 
	 aBlock with the result."
	| stream result receiver evaluationContext |
	
	stream := aString readStream.
	
	receiver := self context doItReceiver.
	evaluationContext := self context doItContext.
	result := receiver class compiler
		source: stream;
		context: evaluationContext;
		receiver: receiver;
		requestor: self context;
		failBlock:  [ ^ nil ];
		evaluate.		

	^ aBlock value: result! !
!SpCodeSelectionCommand methodsFor: 'private' prior: 64212678!
evaluateSelectionAndDo: aBlock
	"Treat the current selection as an expression; evaluate it and invoke aBlock with the result.
	If no selection is present select the current line."
	| selection |
	
	selection := self selectedTextOrLine.
	selection ifEmpty: [ ^ '' ].
	
	^ self 
		evaluate: selection 
		andDo: aBlock! !
!SpCodeSelectionCommand methodsFor: 'accessing'!
selectedText
	
	^ self context selectedText! !
!SpCodeSelectionCommand methodsFor: 'accessing'!
selectedTextOrLine
	
	^ self context selectedTextOrLine! !
!SpBrowseClassCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse the selected class'! !
!SpBrowseClassCommand class methodsFor: 'default'!
defaultShortcutKey

	^ $b command mac 
		| $b control win
		| $b control unix! !
!SpBrowseClassCommand class methodsFor: 'default'!
shortName

	^ 'class'! !
!SpBrowseClassCommand methodsFor: 'execution'!
execute

	self target ifNotNil: [ :aTarget | aTarget browse ]! !
!SpBrowseClassHierarchyCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse the class hierarchy of the selected class'! !
!SpBrowseClassHierarchyCommand class methodsFor: 'default'!
shortName

	^ 'class hierarchy'! !
!SpBrowseClassHierarchyCommand methodsFor: 'executing'!
execute

	self systemNavigation browseHierarchy: self target! !
!SpBrowseClassReferencesCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all references to the receiver''s class'! !
!SpBrowseClassReferencesCommand class methodsFor: 'default'!
shortName

	^ 'class references'! !
!SpBrowseClassReferencesCommand methodsFor: 'execution'!
execute
	| class |

	class := self target instanceSide.
	class isTrait
		ifTrue: [ self systemNavigation browseAllUsersOfTrait: class ]
		ifFalse: [ self systemNavigation browseAllCallsOnClass: class ]! !
!SpBrowseClassVarRefsCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse the references to class variables'! !
!SpBrowseClassVarRefsCommand class methodsFor: 'default'!
shortName

	^ 'class variables reference'! !
!SpBrowseClassVarRefsCommand methodsFor: 'executing'!
execute	
	
	self systemNavigation browseClassVarRefs: self target! !
!SpBrowseClassVariablesCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse the class variables'! !
!SpBrowseClassVariablesCommand class methodsFor: 'default'!
shortName

	^ 'class variables'! !
!SpBrowseClassVariablesCommand methodsFor: 'executing'!
execute

	self systemNavigation browseClassVariables: self target! !
!SpBrowseImplementorsCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all implementors of the selected method or message'! !
!SpBrowseImplementorsCommand class methodsFor: 'default'!
defaultShortcutKey

	^ $m command mac 
		| $m control win
		| $m control unix! !
!SpBrowseImplementorsCommand class methodsFor: 'default'!
shortName

	^ 'implementors'! !
!SpBrowseImplementorsCommand methodsFor: 'executing'!
execute

	self systemNavigation browseAllImplementorsOf: self selector! !
!SpBrowseInstVarRefsCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse the references to instance variables'! !
!SpBrowseInstVarRefsCommand class methodsFor: 'default'!
shortName

	^ 'instance variables reference'! !
!SpBrowseInstVarRefsCommand methodsFor: 'executing'!
execute	
	self systemNavigation browseInstVarRefs: self target! !
!SpBrowseMethodInheritanceCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse the hierarchy implementors of the selected method'! !
!SpBrowseMethodInheritanceCommand class methodsFor: 'default'!
shortName

	^ 'method inheritance'! !
!SpBrowseMethodInheritanceCommand methodsFor: 'executing'!
execute
	self systemNavigation
		methodHierarchyBrowserForClass: self target methodClass
		selector: self target selector! !
!SpBrowseMethodReferencesCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all references to the selected method or selector'! !
!SpBrowseMethodReferencesCommand class methodsFor: 'default'!
shortName

	^ 'references'! !
!SpBrowseMethodReferencesCommand methodsFor: 'executing'!
execute

	self systemNavigation browseAllReferencesTo: self selector! !
!SpBrowseMethodVersionsCommand class methodsFor: 'default'!
defaultDescription 
	'Browse history of the method'! !
!SpBrowseMethodVersionsCommand class methodsFor: 'default'!
shortName

	^ 'method versions'! !
!SpBrowseMethodVersionsCommand methodsFor: 'executing'!
execute
	| target |

	target := self target.
	Smalltalk tools versionBrowser
		browseVersionsForClass: target methodClass
		selector: target selector! !
!SpBrowseMethodsContainingStringCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all methods containing the selected string'! !
!SpBrowseMethodsContainingStringCommand class methodsFor: 'default'!
shortName

	^ 'methods containing string'! !
!SpBrowseMethodsContainingStringCommand methodsFor: 'executing'!
execute

	self systemNavigation 
		browseMethodsWithSourceString: self target 
		matchCase: false! !
!SpBrowseSendersCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all senders of the selected method or message'! !
!SpBrowseSendersCommand class methodsFor: 'default'!
defaultShortcutKey

	^ $n command mac 
		| $n control win
		| $n control unix! !
!SpBrowseSendersCommand class methodsFor: 'default'!
shortName

	^ 'senders'! !
!SpBrowseSendersCommand methodsFor: 'executing'!
execute

	self systemNavigation browseAllSendersOf: self selector! !
!SpBrowseInstancesCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all instances of the selected class'! !
!SpBrowseInstancesCommand class methodsFor: 'accessing'!
shortName

	^ 'all instances'! !
!SpBrowseInstancesCommand methodsFor: 'executing'!
execute

	self target instanceSide inspectAllInstances! !
!SpBrowsePointersToCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all objects referencing the selected object'! !
!SpBrowsePointersToCommand class methodsFor: 'accessing'!
shortName

	^ 'pointers to'! !
!SpBrowsePointersToCommand methodsFor: 'executing'!
execute

	self target pointersTo inspect! !
!SpBrowseSubInstancesCommand class methodsFor: 'default'!
defaultDescription
	^ 'Browse all instances of the selected class and all its subclasses'! !
!SpBrowseSubInstancesCommand class methodsFor: 'accessing'!
shortName

	^ 'all subinstances'! !
!SpBrowseSubInstancesCommand methodsFor: 'executing'!
execute

	self target instanceSide inspectSubInstances! !
!SpSystemDiscoveryCommand class methodsFor: 'defaults'!
defaultIconName
	^ #smallObjects! !
!SpSystemNavigationCommand class methodsFor: 'defaults'!
defaultIconName
	^#smallSystemBrowser ! !
!SpSystemNavigationCommand class methodsFor: 'default'!
defaultName
	^'Browse ', self shortName ! !
!SpSystemNavigationCommand class methodsFor: 'accessing'!
shortName
	^self subclassResponsibility ! !
!SpSystemNavigationCommand methodsFor: 'accessing'!
selector

	^ self target asSymbol! !
!SpToolCommand class methodsFor: 'defaults'!
defaultIconName
	^nil! !
!SpToolCommand class methodsFor: 'defaults'!
defaultShortcutKey

	^ nil! !
!SpToolCommand class methodsFor: 'default'!
shortName
	"For menus some commands can implement this helper to provide shorter names.
	Example: default name = 'Browse Command', short name = 'command'.
	It is intended to be accessed through a menu 'browse' then  'command' instead of directly 'browse command'"

	^ self defaultName! !
!SpToolCommand methodsFor: 'converting'!
asSpecCommand
	| command |
	command := super asSpecCommand.
	self shortcutKey ifNotNil: [ :key | command shortcutKey: key ].
	self defaultIconName
		ifNotNil: [ :iconName | command iconName: iconName ].
	^ command! !
!SpToolCommand methodsFor: 'accessing'!
defaultIconName
	^self class defaultIconName! !
!SpToolCommand methodsFor: 'initialization'!
initialize

	super initialize.
	transform := [ :aContext | aContext ]! !
!SpToolCommand methodsFor: 'accessing'!
shortcutKey

	^ self class defaultShortcutKey! !
!SpToolCommand methodsFor: 'accessing'!
target

	^ self transform value: self context! !
!SpToolCommand methodsFor: 'accessing'!
transform

	^ transform! !
!SpToolCommand methodsFor: 'accessing'!
transform: aBlock

	transform := aBlock! !
!SpPrepareWindowExample methodsFor: 'private building' prior: 64990689!
buildPopMessageToolBarItem
		
	^ SpToolBarButtonPresenter new
		label: 'Pop';
		icon: (self iconNamed: #glamorousDown);
		help: 'Pop last status bar message';
		action: [ self popMessage ];
		yourself! !
!SpPrepareWindowExample methodsFor: 'private building' prior: 64990951!
buildPushMessageToolBarItem
		
	^ SpToolBarButtonPresenter new
		label: 'Push';
		icon: (self iconNamed: #glamorousUp);
		help: 'Push a new status bar message';
		action: [ self pushMessage ];
		yourself! !
!SpTObservable methodsFor: 'events' prior: 65243958!
property: aName whenChangedDo: aBlock 
	
	"Obtain the raw value.
	We need to access the underlying value holder to subscribe to it"
	^ (self observablePropertyNamed: aName) whenChangedDo: aBlock! !
!SpCommandTest methodsFor: 'test'!
testCanUpdateEnableStatus
	| buttonPresenter shouldBeAvailable |
	shouldBeAvailable := true.
	command := CmBlockCommand new
		canBeExecutedBlock: [ :ctx | shouldBeAvailable ];
		context: #foo; "need a conext for #canBeExecuted to be performed"
		yourself.
	command := command asSpecCommand.
	buttonPresenter := command asButtonPresenter.
	self assert: buttonPresenter isEnabled.
	
	shouldBeAvailable := false.
	command updateEnableStatus.
	
	self deny: buttonPresenter isEnabled! !
!SpCommandTest methodsFor: 'test'!
testConfigureAsButton
	| button |
	command := (CmBlockCommand new
		name: 'foo';
		description: 'bar';
		block: [ 42 ];
		yourself) asSpecCommand.
		
	button := command
					configureAsButton;
					buildPresenter.
	
	self assert: button class equals: SpButtonPresenter.
	self assert: button label equals: command name.
	self assert: button help equals: command description.
	self assert: button icon isNil.
	self assert: button action value equals: command execute! !
!SpCommandTest methodsFor: 'test'!
testConfigureAsButtonWithIcon
	| button |
	command := CmCommand forSpec
					iconName: #arrowUp;
					yourself.
		
	button := command
					configureAsButton;
					buildPresenter.
					
	self assert: button icon equals: command icon! !
!SpCommandTest methodsFor: 'test'!
testConfigureAsToolBarButton
	| button |
	command := (CmBlockCommand new
		name: 'foo';
		description: 'bar';
		block: [ 42 ];
		yourself) asSpecCommand.
		
	button := command
					configureAsToolBarButton;
					buildPresenter.
	
	self assert: button class equals: SpToolBarButtonPresenter.
	self assert: button label equals: command name.
	self assert: button help equals: command description.
	self assert: button icon isNil.
	self assert: button action value equals: command execute! !
!SpCommandTest methodsFor: 'test'!
testConfigureAsToolBarToggleButton
	| button |
	command := (CmBlockCommand new
		name: 'foo';
		description: 'bar';
		block: [ 42 ];
		yourself) asSpecCommand.
		
	button := command
					configureAsToolBarToggleButton;
					buildPresenter.
	
	self assert: button class equals: SpToolBarToggleButtonPresenter.
	self assert: button label equals: command name.
	self assert: button help equals: command description.
	self assert: button icon isNil.
	self assert: button action value equals: command execute! !
!SpMorphicListDataSource methodsFor: 'testing'!
hasElementAt: index 
	
	^ self model model hasElementAt: index! !
!SpNotebookTabSelectorMorph methodsFor: 'operations'!
newLabelMorph: aStringOrMorph
	"Answer a new label morph with the given label text."

	^ TabLabelMorph new
		roundedCorners: #(1 4);
		cornerStyle: self cornerStyle;
		changeTableLayout;
		listDirection: #leftToRight;
		listCentering: #center;
		layoutInset: (self theme tabLabelInsetFor: self);
		hResizing: #shrinkWrap;
		vResizing: #spaceFill;
		label: aStringOrMorph;
		in: [ :this | self font ifNotNil: [ this font: self font ] ];
		on: #mouseDown send: #tabClicked:with: to: self;
		tabSelector: self! !
!SpNotebookTabSelectorMorph methodsFor: 'operations'!
newLabelMorph: aStringOrMorph selected: selectedStringOrMorph
	"Answer a new label morph with the given label text or morph and
	alternate when selected."

	^ TabLabelMorph new
		roundedCorners: #(1 4);
		cornerStyle: self cornerStyle;
		changeTableLayout;
		listDirection: #leftToRight;
		listCentering: #center;
		layoutInset: (self theme tabLabelInsetFor: self);
		hResizing: #shrinkWrap;
		vResizing: #spaceFill;
		label: aStringOrMorph selected: selectedStringOrMorph;
		in: [ :this | self font ifNotNil: [ this font: self font ] ];
		on: #mouseDown send: #tabClicked:with: to: self;
		tabSelector: self! !
!SpCodePopoverPrintPresenterTest methodsFor: 'running'!
setUp

	presenter := SpCodePopoverPrintPresenter new! !
!SpCodePopoverPrintPresenterTest methodsFor: 'tests'!
testObjectAsString
	| string |

	presenter setModelBeforeInitialization: 10 factorial. 
	self 
		assert: presenter objectAsString 
		equals: '3628800'.

	presenter setModelBeforeInitialization: 42 factorial. 
	self 
		assert: presenter objectAsString 
		equals: '1405006117752879898543142606244511569936384000000000'.

	presenter setModelBeforeInitialization: 150 factorial.
	self 
		assert: presenter objectAsString 
		equals: (String streamContents: [ :stream | 
			(150 factorial asString 
				groupsOf: presenter class maxLengthShownInPopover 
				atATimeCollect: [ :g | g ])
				do: [ :each | stream << each ]
				separatedBy: [ stream cr ] ]).	
		
	string := String loremIpsum withNoLineLongerThan: presenter class maxLengthShownInPopover.
	presenter setModelBeforeInitialization: string.
	self 
		assert: presenter objectAsString 
		equals: string printString.
		
	string := String loremIpsum withNoLineLongerThan: 10.
	presenter setModelBeforeInitialization: string.
	self 
		assert: presenter objectAsString 
		equals: string printString! !
!SpStyleDrawTest methodsFor: 'tests'!
testToColor
	| style |
	
	style := SpStyleDraw new.
	self assert: (style toColor: #FF0000) equals: Color red.
	self assert: (style toColor: #'00FF00FF') equals: Color green.
	self assert: (style toColor: #blue) equals: Color blue! !
!SpTestMockAdapters methodsFor: 'tests'!
testLabel
	| app label string |
	app := SpTestApplicationWithLocale new.
	app locale: (Locale isoLanguage: 'en' isoCountry: 'US').
	app useBackend: #Morphic.
	string := SpTestLocalizedString from: 'string'.
	label := app newPresenter: SpLabelPresenter.
	label label: string.	
	label openWithSpec.
	self assert: label adapter widget contents equals: 'string[en-US](1)'.

	app locale: (Locale isoLanguage: 'de' isoCountry: 'DE').
	label localeChanged.
	self assert: label adapter widget contents equals: 'string[de-DE](2)'.
	
	label window close.! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testBecomeSelectedWhenToggledAndUnselected
	| toggleButton |
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton beSelected.
	self assert: toggleButton isSelected.
	
	toggleButton toggle.
	
	self deny: toggleButton isSelected.! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testBecomeUnselectedWhenToggledAndSelected
	| toggleButton |
	toggleButton := SpToolBarToggleButtonPresenter new.
	self deny: toggleButton isSelected.
		
	toggleButton toggle.
	
	self assert: toggleButton isSelected.
! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testSelectedBlockExecutedWhenBecomeSelected
	| toggleButton selectedBlockExecuted |
	selectedBlockExecuted := false.
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton whenSelectedDo: [ selectedBlockExecuted := true ].
	
	toggleButton beSelected.
		
	self assert: selectedBlockExecuted! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testSelectedBlockNotExecutedWhenAlreadySelectedAndUnselectedTriggered
	| toggleButton selectedBlockExecuted |
	selectedBlockExecuted := false.
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton beSelected.
	toggleButton whenSelectedDo: [ selectedBlockExecuted := true ].
	
	toggleButton beSelected.
		
	self deny: selectedBlockExecuted! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testSelectedBlockNotExecutedWhenBecomeUnselected
	| toggleButton selectedBlockExecuted |
	selectedBlockExecuted := false.
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton beSelected.
	toggleButton whenSelectedDo: [ selectedBlockExecuted := true ].

	toggleButton beUnselected.	
		
	self deny: selectedBlockExecuted! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testToggleBlockExecutedWhenToggled
	| toggleButton toggled |
	toggled := false.
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton whenToggledDo: [ toggled := true ].
	
	toggleButton toggle.
	
	self assert: toggled! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testUnselectedBlockExecutedWhenBecomeUnselected
	| toggleButton unselectedBlockExecuted |
	unselectedBlockExecuted := false.
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton beSelected.
	toggleButton whenUnselectedDo: [ unselectedBlockExecuted := true ].
	
	toggleButton beUnselected.
		
	self assert: unselectedBlockExecuted! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testUnselectedBlockNotExecutedWhenAlreadyUnselectedAndUnselectedTriggered
	| toggleButton unselectedBlockExecuted |
	unselectedBlockExecuted := false.
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton beUnselected.
	toggleButton whenUnselectedDo: [ unselectedBlockExecuted := true ].
	
	toggleButton beUnselected.
		
	self deny: unselectedBlockExecuted! !
!SpToolBarToggleButtonPresenterTest methodsFor: 'tests'!
testUnselectedBlockNotExecutedWhenBecomeSelected
	| toggleButton unselectedBlockExecuted |
	unselectedBlockExecuted := false.
	toggleButton := SpToolBarToggleButtonPresenter new.
	toggleButton beUnselected.
	toggleButton whenUnselectedDo: [ unselectedBlockExecuted := true ].
	
	toggleButton beSelected.
		
	self deny: unselectedBlockExecuted! !
!SpWorldPresenterTest methodsFor: 'setup'!
setUp
	worldMorph := SpTestWorldPresenter
		reset;
		currentWorld.
	worldMorph
		extent: 300 @ 400;
		borderWidth: 0;
		color: Color veryLightGray.
	application := SpNullApplication new! !
!SpWorldPresenterTest methodsFor: 'setup'!
tearDown
	worldMorph delete! !
!SpWorldPresenterTest methodsFor: 'tests'!
testOpenPresenterInWorldDisplayInFullWorld
	| buttonPresenter |
	buttonPresenter := (application newPresenter: SpButtonPresenter)
		label: 'test'.
	application
		open: buttonPresenter
		withSpecLayout: buttonPresenter defaultSpec
		using: SpTestWorldPresenter.
	self currentWorld addMorph: worldMorph.
	
	self
		assert: worldMorph submorphs first submorphs first extent
		equals: worldMorph extent - 8 "border"! !
!SpWorldPresenterTest methodsFor: 'tests'!
testOpenPresenterInWorldDisplayToolbarDoesNotHidePresenter
	| windowPresenter worldPanel |
	windowPresenter := application
		newPresenter: SpTestPresenterWithToolbar.
		
	application
		open: windowPresenter
		withSpecLayout: windowPresenter defaultSpec
		using: SpTestWorldPresenter.
		
	worldPanel := worldMorph submorphs first.
	self
		assert:
			(worldPanel submorphs first bounds
				intersect: worldPanel submorphs second bounds)
				= (0 @ 0 extent: 0 @ 0)
		description: 'toolbar should not intersect with presenter when opening in world'! !
!SpWorldPresenterTest methodsFor: 'tests'!
testOpenPresenterInWorldRemoveExisitingMorphsInWorld
	| buttonPresenter |
	worldMorph addMorph: CircleMorph new.
	buttonPresenter := (application newPresenter: SpButtonPresenter)
		label: 'testOpenPresenterInWorldRemoveExisitingMorphsInWorld'. 
	application
		open: buttonPresenter
		withSpecLayout: buttonPresenter defaultSpec
		using: SpTestWorldPresenter.

	self deny: (worldMorph submorphs anySatisfy: [ :morph | morph class = CircleMorph ]).
	self assert: worldMorph submorphs size equals: 1.
	self assert: worldMorph submorphs first class equals: PanelMorph.! !
!SpTransferMorph methodsFor: 'initialization' prior: 65357216!
initialize

	super initialize.

	dragHand := self activeHand! !
!SpSliderInput class methodsFor: '*Spec2-Examples' prior: 65145053!
example
	<sampleInstance>
	| example |
	example := self new
		min: 0;
		max: 250;
		value: 120;
		extent: 400 @ 50;
		openWithSpec.
	example withWindowDo: [ :window | window title: 'SliderInput example' ].
	^ example! !
!SpMorphicTreeTableDataSource methodsFor: 'accessing'!
buttonFor: item
	^ (self shouldDisplayExpandableArrowFor: item) ifTrue: [ item generateButton ] ifFalse: [ self class emptyMorph ]! !
!SpMorphicTreeTableDataSource methodsFor: 'testing'!
shouldDisplayExpandableArrowFor: item
	^ (self canDisplayChildrenOf: item) and: [
			self model shouldLazilyComputeChildren
				ifTrue: [ item hasComputedChildren ]
				ifFalse: [ item hasChildren ] ]! !
!SpAbstractTextPresenterTest methodsFor: 'tests'!
testWhenSubmitDo
	| submitted |

	submitted := false.
	presenter whenSubmitDo: [ :aString | submitted := true ].
	
	self openInstance.
	
	self textInputAdapter
		keyPressed: $s asciiValue 
		shift: false
		meta: true 
		control: false 
		option: false.
		
	self assert: submitted! !
!SpAbstractTextPresenterTest methodsFor: 'private'!
textInputAdapter
	
	^ presenter adapter! !
!SpCollectionListModel methodsFor: 'testing'!
hasElementAt: index

	^ self size >= index! !
!SpGeneratorListModel class methodsFor: 'example'!
example
	| items generator |

	items := ($a to: $z) asArray.
	generator := Generator on: [ :g | items do: [ :each | 
		each crTrace.
		g yield: each ] ].

	SpListPresenter new 
		model: (self new 
			generator: generator;
			yourself);
		openWithSpec.
! !
!SpGeneratorListModel methodsFor: 'accessing'!
at: anIndex

	^ self 
		at: anIndex 
		ifAbsent: [ self error: 'Index not found' ]! !
!SpGeneratorListModel methodsFor: 'accessing'!
at: anIndex ifAbsent: aBlock

	[ collection size < anIndex ] 
	whileTrue: [ 
		self generator atEnd ifTrue: [ ^ aBlock value ].
		collection add: self generator next.
		self generator atEnd ifTrue: [ size := collection size ] ].
	^ collection at: anIndex! !
!SpGeneratorListModel methodsFor: 'accessing'!
generator
	^ generator! !
!SpGeneratorListModel methodsFor: 'accessing'!
generator: aGenerator

	generator := aGenerator.! !
!SpGeneratorListModel methodsFor: 'testing'!
hasElementAt: index

	self at: index ifAbsent: [ ^ false ].
	^ true! !
!SpGeneratorListModel methodsFor: 'initialization'!
initialize

	super initialize.
	self collection: OrderedCollection new.
	size := 10000! !
!SpGeneratorListModel methodsFor: 'accessing'!
size

	^ size! !
!SpLabelledContainer class methodsFor: '*Spec2-Examples' prior: 64481964!
example
	<sampleInstance>
	| example |
	example := self abstractExample.
	self setUpExample: example.
	example openWithSpec.
	example withWindowDo: [ :window | window title: self name asString , ' example' ].
	^ example! !
!FTBasicItem methodsFor: '*Spec2-Adapters-Morphic'!
hasComputedChildren
	"I return true if I have computed children or if I don't have computed children."

	^ children ifNil: [ true ] ifNotNil: [ super hasComputedChildren ]! !
!SpDemoActionBarPresenter methodsFor: 'initialization' prior: 64277849!
initializePresenters
	
	actionBar := self newActionBar
		add: (self newButton
			label: 'Add'; 
			icon: (self iconNamed: #smallOk);
			help: 'Add.';
			action: [ MorphicRenderLoop new defer: [ self inform: 'Add' ] ];
			yourself);
		add: (self newButton
			label: 'Remove'; 
			icon: (self iconNamed: #smallCancel);
			help: 'Remove.';
			action: [ MorphicRenderLoop new defer: [ self inform: 'Remove' ] ];
			yourself);
		addLast: (self newButton
			label: 'Other'; 
			help: 'Other.';
			action: [ MorphicRenderLoop new defer: [ self inform: 'Other' ] ];
			yourself);
		yourself.

	text := self newText! !
!SpLayoutDirection methodsFor: 'testing'!
isHorizontal

	^ false! !
!SpLayoutDirection methodsFor: 'testing'!
isVertical

	^ false! !
!SpMorphicGridLayoutComputation methodsFor: 'private' prior: 64734577!
styleOf: aMorph 

	^ aMorph 
		valueOfProperty: #style
		ifAbsent: [ SpMorphStyle newStyles: #() ]! !
!FTStaticBasicItem methodsFor: '*Spec2-Adapters-Morphic'!
hasComputedChildren
	^ self hasChildren! !
!SpAbstractSelectionMode methodsFor: 'transmission' prior: 64035574!
transmission 
	self subclassResponsibility! !
!SpAbstractSelectionMode methodsFor: 'accessing' prior: 64035122!
widget
	"Returns the presenter"
	^ widget! !
!SpMethodBrowser methodsFor: 'initialization' prior: 64607508!
connectPresenters

	listModel whenSelectionChangedDo: [ :selection | 
		selection isEmpty
			ifTrue: [ 
				textModel text: ''.
				textModel behavior: nil.
				toolbarModel method: nil ]
			ifFalse: [ | m |
				m := selection selectedItem. 
				textModel text: m sourceCode.
				textModel behavior: m methodClass.
				toolbarModel method: m ] ].
	self whenSubmitDo: [ :t | self listModel selectedItem inspect ].
	self wrapWith: [ :item | item methodClass name , '>>#' , item selector ]! !
!SpMethodBrowser methodsFor: 'accessing'!
whenSubmitDo: aBlock

	textModel whenSubmitDo: aBlock! !
!SpBoxConstraints methodsFor: 'accessing' prior: 64133046!
height: aNumber
	"height of component.
	 this just has sense in the case of expand=false"

	self expand: false.
	height := aNumber! !
!SpMorphicToolBarButtonAdapter methodsFor: 'factory' prior: 64848229!
buildWidget
	| button |
	
	button := self newButton.
	
	self presenter whenLabelChangedDo: [ self updateLabel ].
	self presenter whenIconChangedDo: [ self updateIcon ].

	^ button! !
!SpMorphicToolBarButtonAdapter methodsFor: 'updating'!
button

	^ widget! !
!SpMorphicToolBarButtonAdapter methodsFor: 'factory'!
morphClass

	^ SpToolBarButtonMorph! !
!SpMorphicToolBarButtonAdapter methodsFor: 'factory'!
newButton
	
	^ (self morphClass
			on: self presenter
			getState: nil 
			action: #execute)
		helpText: self model help;
		beIconTop;
		hResizing: #rigid;
		vResizing: #spaceFill;
		borderWidth: 0;
		borderColor: Color transparent;		
		cellPositioning: #center;
		yourself! !
!SpMorphicToolBarButtonAdapter methodsFor: 'updating'!
updateIcon

	self button update: self button getIconSelector! !
!SpMorphicToolBarButtonAdapter methodsFor: 'updating'!
updateLabel

	self button update: self button getLabelSelector! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'protocol'!
askBeforeChanging

	^ false! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'accessing'!
badge
	
	^ self presenter badge! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'factory'!
buildWidget
	
	^ SpMorphicToolBarMenuButtonMorph  
		newButton: super buildWidget
		menuButton: self newMenuButton! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'updating'!
button

	^ widget submorphs first! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'control'!
deleteIfPopUp: anEvent 
	! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'drag and drop'!
dragEnabled

	^ false! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'drag and drop'!
dropEnabled

	^ false! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'accessing'!
icon

	^ self presenter icon! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'testing'!
isSelected: aBooolean! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'accessing'!
label
	
	^ self presenter label! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'accessing'!
menuIcon

	^ self application iconNamed: #arrowDown! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'factory'!
newMenuButton

	^ IconicButton new
		target: self;
		actionSelector: #showMenu;
		arguments: {};
		labelGraphic: self menuIcon;
		color: Color transparent;
		borderWidth: 0! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'accessing'!
showMenu

	self presenter menu ifNotNil: [ :aValuable |
		aValuable value ifNotNil: [ :aMenu |
			aMenu owner: self presenter.
			self showSubMenu: aMenu ] ].
	self widget ifNotNil: [ :m | m takeKeyboardFocus ] ! !
!SpMorphicToolBarMenuButtonAdapter methodsFor: 'widget API'!
showSubMenu: aMenu 

	aMenu menuGroups ifNil: [ ^ self ].
	 
	subMenuWidget ifNotNil: [ 
		subMenuWidget delete.
		subMenuWidget := nil ].
	subMenuWidget := (SpMorphicMenuAdapter adaptAsPopup: aMenu) widget.
	subMenuWidget
		popUpAdjacentTo: { 
			self widget bounds bottomLeft.
			self widget bounds bottomRight }
		forHand: ActiveHand
		from: self widget.
	subMenuWidget popUpOwner: self! !
!SpMorphicToolBarToggleButtonAdapter methodsFor: 'factory'!
morphClass 

	^ SpToolBarToggleButtonMorph! !
!SpMorphicToolBarToggleButtonAdapter methodsFor: 'factory'!
newButton

	^ super newButton
		action: #execute:
		yourself! !
!SpMorphicBaseTextAdapter methodsFor: 'widget API' prior: 64683306!
accept: aString notifying: aNotifyier

	self presenter text: aString.
	"Raise an announcement"
	self presenter changed: #clearUserEdits.

	^ true! !
!SpMorphicBaseTextAdapter methodsFor: 'accessing' prior: 64681533!
acceptAllowed

	^ self widget editingMode acceptAllowed! !
!SpMorphicBaseTextAdapter methodsFor: 'spec protocol'!
cursorPositionIndex

	self widgetDo: [:w| ^w textArea editor pointIndex]
! !
!SpMorphicBaseTextAdapter methodsFor: 'spec protocol' prior: 64684440!
insert: aString at: positionIndex
	| text |

	text := self getText.
	text := String streamContents: [ :stream |
		stream << (text copyFrom: 1 to: positionIndex).
		stream << aString.
		text size > positionIndex ifTrue: [  
			stream << (text copyFrom: positionIndex + 1 to: text size) ] ].

	self presenter text: text! !
!SpMorphicBaseTextAdapter methodsFor: 'spec protocol' prior: 64685415!
selectionInterval

	^ self widget selectionInterval ! !
!SpVersatileDialogPresenter class methodsFor: 'specs' prior: 65467624!
example1
	<example>
	| dialog |
	(dialog := SpVersatileDialogPresenter new)
		mainMessage: 'Confirm your choice' asText allBold;
		mainIcon: (self iconNamed: #question);
		contentArea: 'Do you want to discard your content?';
		moreOptionsArea: (dialog newCheckBox label: 'Discard permanently');
		addButton: #yes text: 'yes' value: #yes;
		addButton: #no text: 'no' value: #no;
		addButton: #cancel text: 'cancel' value: #cancel;
		footnoteIcon: (self iconNamed: #error);
		footnoteArea: 'This operation can be very dangerous.';
		openModalWithSpec.
	dialog withWindowDo: [ :w | w title: 'Confirmation' ].
	dialog result traceCr.

	self inform: dialog moreOptionsArea state asString! !
!SpVersatileDialogPresenter class methodsFor: 'specs' prior: 65469399!
example2
	<example>
	| dialog |
	dialog := SpVersatileDialogPresenter new
		mainMessage: 'Save content' asText allBold;
		addButton: #save text: 'Save' value: true;
		addButton: #cancel text: 'Cancel' value: false;
		mainIcon: (self iconNamed: #question);
		openModalWithSpec;
		yourself.

	dialog withWindowDo: [ :w | w title: 'Confirmation' ].
	dialog result traceCr! !
!SpVersatileDialogPresenter class methodsFor: 'specs' prior: 65468798!
example3
	<example>
	| dialog |
	dialog := SpVersatileDialogPresenter new
		mainMessage: 'Save content' asText allBold;
		addButton: #save text: 'Save' value: true;
		addButton: #cancel text: 'Cancel' value: false;
		mainIcon: (self iconNamed: #question);
		footnoteIcon: (self iconNamed: #error);
		footnoteArea: 'Saving may take several minutes';
		yourself.

	(dialog buttonAt: #save) icon: (self iconNamed: #smallSave).

	dialog openModalWithSpec.

	dialog withWindowDo: [ :w | w title: 'Confirmation' ].
	dialog result traceCr! !
!SpVersatileDialogPresenter class methodsFor: 'specs' prior: 65468376!
example4
	<example>
	| dialog |
	dialog := SpVersatileDialogPresenter new.

	1 to: 5 do: [ :aNumber | dialog addButton: ('button' , aNumber asString) asSymbol text: aNumber printStringRoman value: aNumber ].

	dialog defaultButtonId: #button2.

	dialog openModalWithSpec.

	dialog withWindowDo: [ :w | w title: 'Select number' ].
	dialog result traceCr! !
!SpVersatileDialogPresenter class methodsFor: 'specs' prior: 65469837!
example5
	<example>
	| dialog listPresenter |
	dialog := SpVersatileDialogPresenter new.
	listPresenter := dialog newList.
	listPresenter items: #(one two three).
	dialog contentArea: listPresenter.
	dialog
		addButton: #ok
		text: 'OK'
		value: true
		condition: [ listPresenter selection isEmpty not ].
	dialog addButton: #cancel text: 'Cancel' value: false.
	dialog mainIcon: (self iconNamed: #question).

	dialog openModalWithSpec.

	dialog withWindowDo: [ :w | w title: 'Confirmation' ].
	dialog result traceCr! !
!SpVersatileDialogPresenter methodsFor: 'api' prior: 65466586!
addButton: id text: buttonText value: anObject

	^ self addButton: id text: buttonText value: anObject condition: true! !
!SpVersatileDialogPresenter methodsFor: 'api' prior: 65464609!
addButton: id text: buttonText value: anObject condition: aCondition
	| aButton |
	aButton := self newButton label: buttonText.
	aButton action: [ aCondition value ifTrue: [ self return: anObject ] ].

	buttons at: id put: aButton.

	self presenterAt: id put: aButton! !
!SpVersatileDialogPresenter methodsFor: 'api' prior: 65465669!
buttonAt: id

	^ buttons at: id! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65465196!
buttons

	^ buttons! !
!SpVersatileDialogPresenter methodsFor: 'initialization' prior: 65464949!
connectPresenters 

	super connectPresenters.
	
	moreOptionsButton action: [ 
		moreOptionsVisible := moreOptionsVisible not.
		self needRebuild: false.
		self buildWithSpec ].
	
! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65465368!
contentArea

	^ contentArea! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65463360!
contentArea: aTextOrPresenter

	contentArea := aTextOrPresenter.! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65463492!
contentAreaPresenter
	^ contentAreaPresenter! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65465463!
defaultButtonId
	^ defaultButtonId! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65465902!
defaultButtonId: anObject
	defaultButtonId := anObject! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65463145!
footnoteArea

	^ footnoteArea! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65465768!
footnoteArea: aTextOrPresenter

	footnoteArea := aTextOrPresenter.! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65467422!
footnoteIcon

	^ footnoteIcon! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65466480!
footnoteIcon: aForm

	footnoteIcon := aForm.! !
!SpVersatileDialogPresenter methodsFor: 'initialization' prior: 65467130!
initialize
	super initialize.

	moreOptionsVisible := false.
	buttons := OrderedDictionary new! !
!SpVersatileDialogPresenter methodsFor: 'initialization' prior: 65462982!
initializeDialogWindow: aDialogWindowPresenter
	aDialogWindowPresenter initialExtent: 400 @ 200! !
!SpVersatileDialogPresenter methodsFor: 'initialization' prior: 65464287!
initializePresenters 

	moreOptionsText := 'More options' asText.
	lessOptionsText := 'Less options' asText.
	moreOptionsButton := self newButton label: moreOptionsText.
	! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65460047!
layout
	| mainLayout row |
	mainLayout := SpBoxLayout newVertical.


	"if the content area is not defined, place main message next to the main icon"
	contentArea
		ifNotNil: [ mainMessage
				ifNotNil: [ mainMessagePresenter := (mainMessage isString or: [ mainMessage isText ]) ifTrue: [ self newLabel label: mainMessage ] ifFalse: [ mainMessage ].
					mainLayout add: #mainMessagePresenter ] ].

	row := SpBoxLayout newHorizontal.

	mainIcon
		ifNotNil: [ mainIconPresenter := self newImage image: self mainIcon.
			row add: #mainIconPresenter withConstraints: [ :constraints | constraints width: self mainIcon width * 2 ] ].

	contentArea
		ifNotNil: [ contentAreaPresenter := (contentArea isString or: [ contentArea isText ]) ifTrue: [ self newLabel label: contentArea ] ifFalse: [ contentArea ].
			row add: #contentAreaPresenter ]
		ifNil: [ mainMessage
				ifNotNil: [ mainMessagePresenter := (mainMessage isString or: [ mainMessage isText ]) ifTrue: [ self newLabel label: mainMessage ] ifFalse: [ mainMessage ].
					row add: #mainMessagePresenter ] ].

	mainLayout add: row.

	row := SpBoxLayout newHorizontal.


	moreOptionsArea
		ifNotNil: [ moreOptionsButton label: (moreOptionsVisible ifFalse: [ self moreOptionsText ] ifTrue: [ self lessOptionsText ]).
			moreOptionsButton icon: (self iconNamed: (moreOptionsVisible ifFalse: [ #arrowDown ] ifTrue: [ #arrowUp ])).

			row add: #moreOptionsButton.
			moreOptionsAreaPresenter := (moreOptionsArea isString or: [ moreOptionsArea isText ]) ifTrue: [ self newLabel label: moreOptionsArea ] ifFalse: [ moreOptionsArea ] ].
	buttons keysAndValuesDo: [ :buttonKey :aButton | row add: buttonKey ].

	mainLayout add: row.

	moreOptionsVisible ifTrue: [ mainLayout add: #moreOptionsAreaPresenter ].

	footnoteArea
		ifNotNil: [ row := SpBoxLayout newHorizontal.
			footnoteIcon
				ifNotNil: [ footnoteIconPresenter := self newImage image: footnoteIcon.
					row add: #footnoteIconPresenter withConstraints: [ :constraints | constraints width: self footnoteIcon width * 2 ] ].

			footnoteAreaPresenter := (footnoteArea isString or: [ footnoteArea isText ]) ifTrue: [ self newLabel label: footnoteArea ] ifFalse: [ footnoteArea ].
			row add: #footnoteAreaPresenter ].
	mainLayout add: row.

	defaultButtonId ifNotNil: [ (self buttonAt: defaultButtonId) takeKeyboardFocus ].

	^ mainLayout! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65467519!
lessOptionsText

	^ lessOptionsText! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65463242!
lessOptionsText: aText

	lessOptionsText := aText.! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65464526!
mainIcon

	^ mainIcon! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65462459!
mainIcon: aFrom

	mainIcon := aFrom! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65466024!
mainIconPresenter
	^ mainIconPresenter! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65464084!
mainMessage

	^ mainMessage! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65466772!
mainMessage: aTextOrPresenter

	mainMessage := aTextOrPresenter.! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65463710!
mainMessagePresenter
	^ mainMessagePresenter! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65463822!
moreOptionsArea

	^ moreOptionsArea! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65462562!
moreOptionsArea: aTextOrPresenter

	moreOptionsArea := aTextOrPresenter.! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65463604!
moreOptionsButton
	^ moreOptionsButton! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65464179!
moreOptionsText

	^ moreOptionsText! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65466130!
moreOptionsText: aText

	moreOptionsText := aText.! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65465283!
result

	^ result! !
!SpVersatileDialogPresenter methodsFor: 'accessing' prior: 65466248!
result: anObject

	result := anObject! !
!SpVersatileDialogPresenter methodsFor: 'private' prior: 65466351!
return: anObject

	self result: anObject.
	self window close.! !
!SpApplicationTest methodsFor: '*Spec2-Adapters-Morphic-Tests' prior: 64121752!
testAdapterBindings

	self assert: application adapterBindings class equals: SpStubAdapterBindings.
	application useBackend: #Morphic.
	self assert: application adapterBindings class equals: SpMorphicAdapterBindings
	! !
!SpMorphicToggleButtonAdapter methodsFor: 'factory' prior: 64845006!
buildWidget
	| checkButton |

	checkButton := PluggableToggleButtonMorph
		on: self 
		getState: #state
		action:  #toggleAction:
		label: #label 
		menu: nil. 	
	
	checkButton 
		icon: self icon;
		label:	 self getLabelText; 
		hResizing: #spaceFill; 
		vResizing: #shrinkWrap; 
		setBalloonText: self getHelpText;
		getEnabledSelector: #enabled;
		dragEnabled: self dragEnabled;
		dropEnabled: self dropEnabled.
			
	self presenter whenLabelChangedDo: [ :newLabel | checkButton label: (newLabel ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]) ].
	self presenter whenIconChangedDo: [ checkButton icon: self icon ].
	self presenter whenChangedDo: [ checkButton pressed: self model state ].

	^ checkButton! !
!SpMorphicToggleButtonAdapter methodsFor: 'private'!
getHelpText

	^ self presenter help ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicToggleButtonAdapter methodsFor: 'private'!
getLabelText

	^ self presenter label ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicToggleButtonAdapter methodsFor: 'widget API' prior: 64844785!
label
	
	^ self getLabelText! !
!SpToolBarAdapterTest methodsFor: 'tests' prior: 65334342!
testAddLabelledButtonAddTheButton
	presenter addItem: (SpToolBarButtonPresenter new
				label: 'a label';
				iconNamed: #abstract;
				action: [];
				yourself).
				
	self assert: (self adapter hasButtonWithLabel: 'a label').
	self assert: (self adapter numberOfItems) equals: 1! !
!SpWindow methodsFor: 'open/close'!
extent: aPoint 

	| announcement |

	super extent: aPoint.
	announcement := SpWindowResizing new
		window: self;
		yourself.
	self announce: announcement.
	self currentWorld announcer announce: announcement.	
! !
!SpLabelledSliderInput class methodsFor: '*Spec2-Examples' prior: 64500636!
setUpExample: example
	
	example
		min: 0;
		max: 250;
		value: 120;
		extent: 400 @ 50! !
!SpDropListPresenter methodsFor: 'transmission'!
defaultInputPort

	^ self inputItemsPort! !
!SpDropListPresenter methodsFor: 'transmission'!
defaultOutputPort

	^ self outputSelectionPort! !
!SpDropListPresenter methodsFor: 'transmission'!
inputItemsPort

	^ SpListItemsPort newPresenter: self! !
!SpDropListPresenter methodsFor: 'api'!
items 

	^ self listItems! !
!SpDropListPresenter methodsFor: 'api' prior: 64372168!
items: aList
	"Populate the drop list with a list of ui specific items"

	"aList is a list of domain specific objects. If you want to specify more precisely the item actions, see #addItemLabeled:do:"

	| dropListItems |
	dropListItems := aList collect: [ :each | SpDropListItem on: each do: [ ] ].
	model collection: dropListItems.
	(dropListItems isNotEmpty
		and: [ startsWithSelection 
		and: [ self selection isEmpty ] ])
		ifTrue: [ self selectIndex: 1 ]
		ifFalse: [ self resetSelection ]! !
!SpDropListPresenter methodsFor: 'transmission'!
outputSelectionPort

	^ SpDropListSelectionPort newPresenter: self! !
!SpEditableListPresenter methodsFor: 'initialization' prior: 64413345!
connectPresenters
	super connectPresenters.
	addButton action: [ 
		| newItem |
		newItem := addItemBlock value.
		newItem ifNotNil: [ 
			self items add: newItem.
			self 
				refresh;
				selectItem: newItem ] ].
	removeButton 
		action: [ removeItemBlock cull: self selectedItem ].
	topButton action: [ self moveElementAt: self selectedIndex to: 1 ].
	bottomButton action: [ 
		self moveElementAt: self selectedIndex to: self items size ].
	upButton action: [ 
		self moveElementAt: self selectedIndex to: self selectedIndex - 1 ].
	downButton action: [ 
		self moveElementAt: self selectedIndex to: self selectedIndex + 1 ]! !
!SpEditableListPresenter methodsFor: 'initialization' prior: 64415316!
initialize
	super initialize.
	title := 'Title'.
	okBlock := [  ].
	removeItemBlock := [ :item | 
								item
									ifNotNil: [ self items remove: item.
													self refresh. ] ]! !
!SpEditableListPresenter methodsFor: 'initialization'!
newList
	"Default list collection is an Array.
	As this presenter aims to add / remove items from the list, we need a growable collection"
	^ (self instantiate: SpListPresenter)
			items: OrderedCollection new;
			yourself! !
!SpEditableListPresenter methodsFor: 'api' prior: 64411798!
refresh
	self resetSelection.
	self items: self items! !
!SpEditableListPresenter methodsFor: 'api'!
resetSelection
	self selectIndex: 0! !
!SpEditableListPresenter methodsFor: 'api'!
selectIndex: anIndex
	list selectIndex: anIndex! !
!SpEditableListPresenter methodsFor: 'api' prior: 64415762!
selectItem: anObject
	list selectItem: anObject! !
!SpModalWindowPresenter methodsFor: 'initialization' prior: 64650172!
initialize

	super initialize.
	closeOnBackdropClick := false! !
!SpToggleButtonPresenter class methodsFor: 'example'!
example

	self new
		icon: (self iconNamed: #smallOk);
		whenActivatedDo: [ UIManager default defer: [ self inform: 'Activated' ] ];
		whenDeactivatedDo: [ UIManager default defer: [ self inform: 'Deactivated' ] ];
		openWithSpec! !
!SpNotification class methodsFor: 'private' prior: 64927167!
dispatchErrorTo: aNotificationCenter message: aString 

	^ self new 
		beError;
		message: aString;
		dispatchTo: aNotificationCenter! !
!SpNotification class methodsFor: 'private' prior: 64927370!
dispatchInfoTo: aNotificationCenter message: aString 

	^ self new 
		beInfo;
		message: aString;
		dispatchTo: aNotificationCenter! !
!SpNotification class methodsFor: 'instance creation'!
newError: aString

	^ self new 
		beError;
		message: aString;
		yourself! !
!SpNotification class methodsFor: 'instance creation'!
newInfo: aString

	^ self new 
		beInfo;
		message: aString;
		yourself! !
!SpListCommonPropertiestTest methodsFor: 'tests'!
testSelectingANotVisibleItemDoesNotScroll
	| verticalAlignment visibleItems |
	presenter items: (1 to: 500).
	verticalAlignment := presenter verticalAlignment.
	self openInstance.
	visibleItems := verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex.
	presenter selectItem: 400.

	self 
		assert: (verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex) 
		equals: visibleItems! !
!SpMorphicGridAdapter methodsFor: 'accessing'!
children
	
	^ widget submorphs! !
!SpMorphicGridAdapter methodsFor: 'factory' prior: 64724635!
layout: aLayout
	"build of widget was differed up to here (to know what is the direction)"

	widget ifNil: [ 
		widget := self newPanel.
		widget layoutPolicy layout: aLayout ].
	
	aLayout whenChildrenAddedDo: [ :ann |
		self
			add: ann child
			constraints: (aLayout constraintsFor: ann child) ].
	
	aLayout whenChildrenRemovedDo: [ :ann |
		self remove: ann child ].

	super layout: aLayout! !
!SpMorphicGridAdapter methodsFor: 'removing'!
remove: aPresenter

	| morph |
	morph := aPresenter adapter widget.
	widget removeMorph: morph! !
!SpTextFieldExample methodsFor: 'initialization' prior: 65296187!
connectPresenters
	
	textField whenTextChangedDo: [ :text | 
		self class environment
			at: text asSymbol
			ifPresent: [ :class | methodBrowser messages: class methods ]
			ifAbsent: [ methodBrowser messages: #() ] ]! !
!SpTextFieldExample methodsFor: 'initialization' prior: 65295779!
initializePresenters
	methodBrowser := self instantiate: MessageBrowser.

	textField := self newTextInput.
	textField
		placeholder: 'Enter a class name';
		removeEntryCompletion.

	methodBrowser sortingBlock: [ :a :b | a selector < b selector ]! !
!SpPopoverMorph methodsFor: 'accessing'!
bePositionBottom

	position := #bottom! !
!SpPopoverMorph methodsFor: 'accessing'!
bePositionLeft

	position := #left! !
!SpPopoverMorph methodsFor: 'accessing'!
bePositionRight

	position := #right! !
!SpPopoverMorph methodsFor: 'accessing'!
bePositionTop

	position := #top! !
!SpPopoverMorph methodsFor: 'accessing'!
beRelativeTo: aMorph

	relativeTo := aMorph! !
!SpPopoverMorph methodsFor: 'private'!
calculatePositionBottomFrom: aRect
	| x y |
	
	y := aRect corner y + 10.
	x := aRect corner x - ((aRect width + self width) // 2).

	^ x @ y
	! !
!SpPopoverMorph methodsFor: 'private'!
calculatePositionFrom: aRect

	position = #top ifTrue: [ ^ self calculatePositionTopFrom: aRect ].
	position = #left ifTrue: [ ^ self calculatePositionLeftFrom: aRect ].
	position = #bottom ifTrue: [ ^ self calculatePositionBottomFrom: aRect ].
	position = #right ifTrue: [ ^ self calculatePositionRightFrom: aRect ].
	
	self error: 'Should not arrive here'


	! !
!SpPopoverMorph methodsFor: 'private'!
calculatePositionLeftFrom: aRect
	| x y |
	
	x := aRect origin x - 10 - self width.
	y := aRect origin y.

	^ x @ y	! !
!SpPopoverMorph methodsFor: 'private'!
calculatePositionRightFrom: aRect
	| x y |
	
	x := aRect corner x + 10.
	y := aRect origin y.

	^ x @ y! !
!SpPopoverMorph methodsFor: 'private'!
calculatePositionTopFrom: aRect
	| x y |
	
	y := aRect origin y - 10 - self height.
	x := aRect corner x - ((aRect width + self width) // 2).

	^ x @ y	! !
!SpPopoverMorph methodsFor: 'accessing'!
contentMorph: aMorph 

	self removeAllMorphs.
	self extent: aMorph extent + (self borderWidth * 2) + (aMorph borderWidth * 2).
	self addMorphBack: aMorph.
	 "I need this to calculate properly the size (otherwise I cannot position 
	  the popover correctly"
	self computeFullBounds! !
!SpPopoverMorph methodsFor: 'initialization'!
defaultColor

	^ self theme lightBaseColor! !
!SpPopoverMorph methodsFor: 'initialization'!
initialize

	super initialize.
	self 
		changeTableLayout;
		listDirection: #leftToRight;
		hResizing: #shrinkWrap;
		vResizing: #shrinkWrap;
		onAnnouncement: MorphLostFocus do: [ :ann | ann morph popdown ];
		beSticky.
	self bePositionBottom! !
!SpPopoverMorph methodsFor: 'api'!
popdown
	
	self delete! !
!SpPopoverMorph methodsFor: 'api'!
popup

	self popupPointingTo: self relativeTo bounds! !
!SpPopoverMorph methodsFor: 'api'!
popupPointingTo: aRectangle

	self setPositionFrom: aRectangle.
	self openInWorld.
	self takeKeyboardFocus! !
!SpPopoverMorph methodsFor: 'accessing'!
relativeTo 

	^ relativeTo! !
!SpPopoverMorph methodsFor: 'private'!
setPositionFrom: aRect

	self position: (self calculatePositionFrom: aRect)

	! !
!SpToolBarMorph class methodsFor: 'accessing' prior: 65347512!
defaultHeight
	
	^ self defaultMode height! !
!SpToolBarMorph class methodsFor: 'accessing' prior: 65347317!
defaultItemSeparation

	^ 0! !
!SpToolBarMorph class methodsFor: 'accessing' prior: 65347616!
defaultItemSize

	^ 50! !
!SpToolBarMorph class methodsFor: 'accessing' prior: 65347406!
defaultMode

	^ SpToolBarDisplayMode default! !
!SpToolBarMorph class methodsFor: 'accessing' prior: 65347232!
statusBarHeight
	
	^ 25! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65345503!
addItem: aToolbarItem
	
	self addItem: aToolbarItem position: SpToolBarItemPosition left! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65344633!
addItem: aToolbarItem position: aPosition

	aPosition addItem: aToolbarItem into: self.
	self width: self width + aToolbarItem width.
	self refresh! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65346787!
addItemLeft: aMorph

	leftPanel addMorphBack: (aMorph
		vResizing: #spaceFill;
		yourself)! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65343913!
addItemRight: aMorph

	rightPanel addMorphBack: (aMorph
		vResizing: #spaceFill;
		yourself)! !
!SpToolBarMorph methodsFor: 'as yet unclassified' prior: 65344071!
addItemsFromContext: aContext
	
	self flag: #TODO.
	"| menu |
	
	menu := CmdMenu activatedBy: ITToolbarActivation.
	menu buildInContext: aContext.
	menu buildToolbarOn: self"
! !
!SpToolBarMorph methodsFor: 'updating' prior: 65344301!
clearItems
	
	leftPanel removeAllMorphs.
	rightPanel removeAllMorphs.! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65345206!
color
	^ color ifNil: [ Color transparent ]! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65346564!
color: aColor
	color := aColor! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65346650!
displayMode
	^ displayMode ifNil: [ displayMode := SpToolBarDisplayMode default ]! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65346058!
displayMode: anObject
	displayMode := anObject! !
!SpToolBarMorph methodsFor: 'initialization' prior: 65346309!
initialize
	super initialize.

	self
		changeTableLayout;
		listDirection: #leftToRight;
		hResizing: #spaceFill;
		vResizing: #spaceFill;
		color: self color;
		extent: 0@0.
	
	self initializePanels! !
!SpToolBarMorph methodsFor: 'initialization' prior: 65344947!
initializePanels

	leftPanel := self newPanelMorph.
	rightPanel := self newPanelMorph
		listDirection: #rightToLeft;
		hResizing: #spaceFill.

	self
		addMorphBack: leftPanel;
		addMorphBack: rightPanel
! !
!SpToolBarMorph methodsFor: 'private accessing' prior: 65345980!
leftPanel
	^ leftPanel! !
!SpToolBarMorph methodsFor: 'private accessing' prior: 65344844!
leftPanel: anObject
	leftPanel := anObject! !
!SpToolBarMorph methodsFor: 'private factory' prior: 65346939!
newPanelMorph

	^ PanelMorph new 
		changeTableLayout;
		listDirection: #leftToRight;
		hResizing: #spaceFill;
		vResizing: #spaceFill;
		cellInset: self class defaultItemSeparation@0;
		extent: 0@0;
		color: self color;
		yourself! !
!SpToolBarMorph methodsFor: 'private factory' prior: 65345653!
newToolbarItemFont
	| buttonFont |

	buttonFont := self theme buttonFont.
	^ LogicalFont 
		familyName: buttonFont familyName 
		pointSize: buttonFont pointSize - 3! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65345873!
refresh

	self flag: #TODO. "Maybe remove?"! !
!SpToolBarMorph methodsFor: 'private accessing' prior: 65345313!
rightPanel
	^ rightPanel! !
!SpToolBarMorph methodsFor: 'private accessing' prior: 65344434!
rightPanel: anObject
	rightPanel := anObject! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65346160!
toolbarItemFont
	^ toolbarItemFont ifNil: [ toolbarItemFont := self newToolbarItemFont ]! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65345393!
toolbarItemFont: anObject
	toolbarItemFont := anObject! !
!SpToolBarMorph methodsFor: 'accessing' prior: 65344534!
toolbarItemSize

	^ self displayMode height! !
!SpNotebookMorph methodsFor: 'adding'!
addPage: aMorph label: aStringOrMorph
	
	super addPage: aMorph label: aStringOrMorph.
	aMorph privateOwner: self! !
!SpNotebookMorph methodsFor: 'private' prior: 64900610!
pageAt: index

	^ (self pages at: index) actualPageMorph! !
!SpNotebookMorph methodsFor: 'private'!
postAddPage: aMorph 
	"a hook to format the page after creation"! !
!SpNotebookMorph methodsFor: 'private'!
updateContentMorph: aMorph with: newMorph
	| pageBounds |

	pageBounds := self pageMorph bounds.
	self contentMorph replaceSubmorph: aMorph by: newMorph.
	self flag: 'Without setting here the bounds the page moves a few pixels when 
	refreshing the inspector'.
	self pageMorph bounds: pageBounds.
	self pageMorph layoutChanged! !
!SpNotebookMorph methodsFor: 'private' prior: 64899197!
updatePageIndex: index
	"Change to the given page index, update the toolbar and send the announcement"
	| oldPage newPage |

	index = 0 ifTrue: [ ^ self ].

	oldPage := self pages at: self selectedPageIndex.
	self pageMorph
		ifNotNil: [ :aPage | self updateContentMorph: aPage with: (self pageAt: index) ]
		ifNil: [ self contentMorph addMorph: (self pageAt: index) ].

	newPage := self pages at: index.
	self postAddPage: newPage.

	self headerMorph layoutChanged.
	self pageMorph layoutChanged.
	self adoptPaneColor: (self owner ifNil: [ self ]) paneColor.
	self tabSelectorMorph font ifNotNil: [ :aFont |
		(self tabSelectorMorph tabs at: index) font: aFont ].

	self announcer announce: (SpNotebookPageChanged new
		page: newPage;
		oldPage: oldPage;
		pageIndex: index)! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
badge
	badgeSelector ifNil: [ ^ nil ].
	^ self model perform: badgeSelector! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
badgeColor
	^ self theme badgeColor! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
badgeFont
	^ badgeFont ifNil: [ badgeFont := self newBadgeFont ]! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
badgeSelector: aSymbol
	badgeSelector := aSymbol! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
badgeTextColor
	^ self theme badgeTextColor! !
!SpToolBarToggleButtonMorph methodsFor: 'configuring'!
configureWith: displayModel item: itemPresenter
	displayModel configureButton: self item: itemPresenter! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
drawBadgeOn: aCanvas
	| badgeString badgeBounds textBounds textWidth textHeight width |
	
	badgeString := self badge asString.
	textWidth := self badgeFont widthOfString: badgeString.
	textHeight := self badgeFont height.
	width := 14 max: textWidth + 2. 
	badgeBounds := ((bounds right - width - 2)@(bounds top + 2) extent: width@14).
	aCanvas 
		fillOval: badgeBounds
		fillStyle: self badgeColor.
		
	textBounds := 
		(badgeBounds center - ((textWidth@textHeight) / 2.0)) + (1@0) 
		extent: textWidth@textHeight. 
	aCanvas 
		drawString: badgeString
		in: textBounds
		font: self badgeFont 
		color: self badgeTextColor! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
drawOn: aCanvas
	super drawOn: aCanvas.
	self hasBadge ifTrue: [
		self drawBadgeOn: aCanvas ]! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
drawSubmorphsOn: aCanvas
	
	super drawSubmorphsOn: aCanvas! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
getIconSelector

	^ getIconSelector! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
getIconSelector: aSelector

	getIconSelector := aSelector.
	self update: getIconSelector! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
getLabelSelector

	^ getLabelSelector! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
getLabelSelector: aSelector

	getLabelSelector := aSelector.
	self update: getLabelSelector! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
hasBadge
	^ self badge notNil! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
newBadgeFont
	| baseBadgeFont |
	baseBadgeFont := StandardFonts codeFont.
 	^ (LogicalFont 
		familyName: baseBadgeFont familyName 
		pointSize: baseBadgeFont pointSize - 3)
			weightValue: 700! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
normalBorderStyle
	^ BorderStyle simple
		width: 0;
		baseColor: Color transparent! !
!SpToolBarToggleButtonMorph methodsFor: 'accessing'!
normalFillStyle
	^ Color transparent! !
!SpMorphicCheckBoxAdapter methodsFor: 'factory' prior: 64708112!
buildWidget

	| checkButton |
	checkButton := CheckboxMorph
						on: self 
						selected: #state
						changeSelected: #state:.
	checkButton 
			label: self getLabelText; 
			beCheckbox;
			hResizing: #spaceFill; 
			vResizing: #shrinkWrap; 
			setBalloonText: self getHelpText;
			getEnabledSelector: #enabled;
			dragEnabled: self dragEnabled;
			dropEnabled: self dropEnabled;	
			labelClickable: self labelClickable.
			
	self presenter whenLabelChangedDo: [ :newLabel | checkButton label: (newLabel ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]) ].
	self presenter whenChangedDo: [ checkButton updateSelection ].
	^ checkButton! !
!SpMorphicCheckBoxAdapter methodsFor: 'private'!
getHelpText

	^ self presenter help ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicCheckBoxAdapter methodsFor: 'private'!
getLabelText

	^ self presenter label ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicCheckBoxAdapter methodsFor: 'widget API' prior: 64707764!
label
	
	^ self getLabelText! !
!SpAbstractListPresenter methodsFor: 'transmission'!
defaultInputPort

	^ self inputItemsPort! !
!SpAbstractListPresenter methodsFor: 'transmission'!
defaultOutputPort

	^ self outputSelectionPort! !
!SpAbstractListPresenter methodsFor: 'transmission'!
inputItemsPort

	^ SpListItemsPort newPresenter: self! !
!SpAbstractListPresenter methodsFor: 'accessing' prior: 63973959!
itemAt: index 
	"If there is an adapter the widget items indexes can be different thant the model items indexes, 
	e.g. when the sort by a column is activated. In this case, ask the adapter to get the element displayed at index."

	^ self adapter 
			ifNotNil: [ :anAdapter | anAdapter elementAt: index ]
			ifNil: [ self model at: index ].
				
	"^ self model at: index"! !
!SpAbstractListPresenter methodsFor: 'private'!
itemAtPath: anArray
	"This is to provide polymorphism with SpTreeTablePresentrer"

	^ self itemAt: anArray first! !
!SpAbstractListPresenter methodsFor: 'api' prior: 63989338!
items: aCollection
	"Set the items of the list.
	aCollection is a collection of your domain specific items.
	This creates a collection model"
	
	model collection: aCollection.
	self unselectAll.! !
!SpAbstractListPresenter methodsFor: 'private'!
itemsAt: aCollectionOfIndex
	^ aCollectionOfIndex collect: [ :anIndex | self itemAt: anIndex ]! !
!SpAbstractListPresenter methodsFor: 'accessing' prior: 63983379!
model: aModel
	
	model := aModel.
	model whenChangedDo: [ 
		self withAdapterDo: [ :anAdapter | anAdapter refreshList ] ]! !
!SpAbstractListPresenter methodsFor: 'transmission'!
outputActivationPort
	
	^ SpActivationPort newPresenter: self! !
!SpAbstractListPresenter methodsFor: 'transmission'!
outputSelectionPort
	
	^ SpSelectionPort newPresenter: self! !
!SpAbstractListPresenter methodsFor: 'initialization' prior: 63987017!
registerEvents

	self whenSelectionModeChangedDo: [ :selection | 
		self withAdapterDo: [ :anAdapter | anAdapter refreshWidgetSelection ] ].
	self whenMenuChangedDo: [ 
		self withAdapterDo: [ :anAdapter | anAdapter updateMenu ] ]! !
!SpAbstractListPresenter methodsFor: 'api'!
selectIndex: anIndex scrollToSelection: shouldScrollToSelection
    self selectIndex: anIndex.
    shouldScrollToSelection ifTrue: [ 
        self verticalAlignment desiredVisibleRow: anIndex ].! !
!SpAbstractListPresenter methodsFor: 'api'!
selectIndexes: aListOfIndexes scrollToSelection: shouldScrollToSelection
    self selectIndexes: aListOfIndexes.
    shouldScrollToSelection ifTrue: [ 
        self verticalAlignment desiredVisibleRow: aListOfIndexes first ].! !
!SpAbstractListPresenter methodsFor: 'api' prior: 63983045!
selectedItems
	"Return all the selected items in the case of a multiple selection list"

	^ self selection selectedItems! !
!SpAbstractListPresenter methodsFor: 'api' prior: 63986804!
selectedItemsSorted
	"return all the selected items sorted by their index"

	^ self itemsAt: self selection selectedIndexes sort! !
!Object methodsFor: '*Spec2-Core'!
isPresenter

	^ false! !
!SpAbstractWidgetLayout methodsFor: 'building' prior: 64090868!
buildAdapterFor: aPresenter bindings: adapterBindings
	"In case we are building an adapter, we need to get the actual adapter class for a specific binding and make it adapt the presenter."

	^ aPresenter needRebuild
		ifTrue: [ self adapt: aPresenter bindings: adapterBindings ]
		ifFalse: [ 
			aPresenter needRebuild: true.
			aPresenter adapter
				ifNil: [ self adapt: aPresenter bindings: adapterBindings ]
				ifNotNil: [ :adapter | 
					adapter isRedrawable ifTrue: [ adapter removeSubWidgets ].
					adapter ] ]! !
!SpApplication class methodsFor: 'examples'!
example1
	"This example shows how to change the backend of an application" 
	| app |
	
	"You want to subclass SpApplication to create your app"
	app := SpApplication new.
	app useBackend: #Gtk.
	app run! !
!SpApplication class methodsFor: 'examples'!
example2
	"This example shows how to change the backend of an application" 
	| app |
	
	"You want to subclass SpApplication to create your app"
	app := SpApplication new.
	"You want to subclass SpGtkConfiguration to create your own cofiguration"
	app useBackend: #Gtk with: SpApplicationConfiguration new.
	app run! !
!SpApplication methodsFor: 'private' prior: 64112445!
adapterBindings
	
	^ self backend adapterBindings! !
!SpApplication methodsFor: 'accessing'!
closeAllWindows

	self windows do: [ :each | each close ]! !
!SpApplication methodsFor: 'ui' prior: 64111115!
defer: aBlock
	"doInUIThread: ?"
	self backend defer: aBlock! !
!SpApplication methodsFor: 'testing' prior: 64114911!
hasWindow: aWindow
	
	^ self windows includes: aWindow! !
!SpApplication methodsFor: 'accessing'!
locale

	^ Locale current! !
!SpApplication methodsFor: 'private showing' prior: 64113378!
open: aPresenter withSpecLayout: aSpecLayout using: aWindowClass
	| window |

	self validateApplicationOfPresenter: aPresenter.

	window := aWindowClass presenter: aPresenter.
	window application: aPresenter application.
	self windows add: window.
	window openWithSpecLayout: aSpecLayout.
	
	^ window! !
!SpApplication methodsFor: 'showing' prior: 64111345!
openDialog: aPresenter withSpecLayout: aSpecLayout

	^ self 
		open: aPresenter 
		withSpecLayout: aSpecLayout 
		using: SpModalWindowPresenter! !
!SpApplication methodsFor: 'accessing'!
reset 

	self closeAllWindows! !
!SpApplication methodsFor: 'accessing'!
topWindow

	^ self windows 
		detect: [ :each | each isTopWindow ]
		ifNone: [ nil ]! !
!SpTestApplicationWithLocale methodsFor: 'accessing'!
initialize 

	super initialize.
	
	locale := Locale isoLanguage: 'en' isoCountry: 'US'.! !
!SpTestApplicationWithLocale methodsFor: 'accessing'!
locale
	^ locale! !
!SpTestApplicationWithLocale methodsFor: 'accessing'!
locale: anObject
	locale := anObject! !
!SpDynamicPresentersListLayout methodsFor: 'accessing'!
sublayoutConstraints
	^ sublayoutConstraints ifNil: [ sublayoutConstraints := [ :c |  ] ]! !
!SpDynamicPresentersListLayout methodsFor: 'accessing'!
sublayoutConstraints: anObject
	sublayoutConstraints := anObject! !
!SpBoxLayout class methodsFor: 'instance creation' prior: 64139224!
new 

	self error: 'Use either #newHorizontal or #newVertical'! !
!SpBoxLayout methodsFor: 'adding' prior: 64138521!
add: aPresenter withConstraints: aBlock
	
	super add: aPresenter withConstraints: aBlock.
	self announceChildAdded: aPresenter.! !
!SpBoxLayout methodsFor: 'accessing'!
hAlign
	"I define the vertical alignment of the widgets in the layout.
	 aligns can be start, center and end. 
	 To set this value, you can use vAlignStart, vAlignCenter, vAlignEnd"

	^ hAlign! !
!SpBoxLayout methodsFor: 'accessing'!
hAlign: anAlignment
	"Sets the align property. See #hAlign to details"
	
	hAlign := anAlignment! !
!SpBoxLayout methodsFor: 'accessing'!
hAlignCenter

	self hAlign: SpLayoutWidgetAlignment center! !
!SpBoxLayout methodsFor: 'accessing'!
hAlignEnd

	self hAlign: SpLayoutWidgetAlignment end! !
!SpBoxLayout methodsFor: 'accessing'!
hAlignStart

	self hAlign: SpLayoutWidgetAlignment start! !
!SpBoxLayout methodsFor: 'testing'!
hasAlignment

	^ vAlign notNil or: [ hAlign notNil ]! !
!SpBoxLayout methodsFor: 'removing' prior: 64135485!
remove: aPresenter

	children removeKey: aPresenter.
	self announceChildRemoved: aPresenter! !
!SpBoxLayout methodsFor: 'accessing'!
vAlign
	"I define the vertical alignment of the widgets in the layout.
	 aligns can be start, center and end. 
	 To set this value, you can use vAlignStart, vAlignCenter, vAlignEnd"

	^ vAlign! !
!SpBoxLayout methodsFor: 'accessing'!
vAlign: anAlignment
	"Sets the align property. See #vAlign to details"

	vAlign := anAlignment! !
!SpBoxLayout methodsFor: 'accessing'!
vAlignCenter

	self vAlign: SpLayoutWidgetAlignment center! !
!SpBoxLayout methodsFor: 'accessing'!
vAlignEnd

	self vAlign: SpLayoutWidgetAlignment end! !
!SpBoxLayout methodsFor: 'accessing'!
vAlignStart

	self vAlign: SpLayoutWidgetAlignment start! !
!SpExecutableLayout methodsFor: 'accessing' prior: 64425725!
add: aName withConstraints: aBlock
	| constraints |
	constraints := self constraintsClass new.
	aBlock value: constraints.
	children at: aName put: constraints! !
!SpExecutableLayout methodsFor: 'accessing'!
announceChildAdded: aChildPresenter

	self presenter ifNotNil: [
		self announcer announce: (SpChildrenAdded new
			parent: self presenter;
			child: aChildPresenter;
			yourself)].! !
!SpExecutableLayout methodsFor: 'accessing'!
announceChildRemoved: aChildPresenter

	self presenter ifNotNil: [
		self announcer announce: (SpChildrenRemoved new
			parent: self presenter;
			child: aChildPresenter;
			yourself)].! !
!SpExecutableLayout methodsFor: 'adding'!
announcer

	^ announcer ifNil: [ announcer := Announcer new ]! !
!SpExecutableLayout methodsFor: 'accessing'!
basicAdd: aName withConstraints: aBlock
	| constraints |
	constraints := self constraintsClass new.
	aBlock value: constraints.
	children at: aName put: constraints! !
!SpExecutableLayout methodsFor: 'accessing' prior: 64426094!
children

	^ children keys! !
!SpExecutableLayout methodsFor: 'accessing'!
constraintsFor: aPresenter

	^ children at: aPresenter! !
!SpExecutableLayout methodsFor: 'testing'!
isEmpty

	^ children isEmpty! !
!SpExecutableLayout methodsFor: 'accessing'!
presenter

	^ adapter ifNotNil: [ adapter presenter ]! !
!SpExecutableLayout methodsFor: 'adding'!
whenChildrenAddedDo: aBlock

	self announcer
		when: SpChildrenAdded
		do: aBlock! !
!SpExecutableLayout methodsFor: 'adding'!
whenChildrenRemovedDo: aBlock

	self announcer
		when: SpChildrenRemoved
		do: aBlock! !
!SpGridLayout methodsFor: 'adding' prior: 64442551!
add: aName at: aPoint span: spanPoint

	childrenByPosition at: aPoint ifPresent: [ :e |
		"Remove element at the same position"
		self remove: e ].

	^ self 
		add: aName 
		withConstraints: [ :constraints |
			constraints 
				position: aPoint;
				span: spanPoint ]! !
!SpGridLayout methodsFor: 'adding'!
add: aChild withConstraints: aBlock

	super add: aChild withConstraints: aBlock.
	childrenByPosition at: (children at: aChild) position put: aChild.
	self announceChildAdded: aChild.! !
!SpGridLayout methodsFor: 'accessing'!
children

	^ children! !
!SpGridLayout methodsFor: 'initialization' prior: 64441893!
initialize 

	super initialize.
	self beColumnHomogeneous.
	self beRowHomogeneous.
	columnConstraints := Dictionary new.
	rowConstraints := Dictionary new.
	childrenByPosition := Dictionary new.! !
!SpGridLayout methodsFor: 'removing'!
remove: aPresenter

	children removeKey: aPresenter.
	self announceChildRemoved: aPresenter! !
!SpOverlayLayout methodsFor: 'accessing'!
addOverlay: aPresenter
	
	self
		add: aPresenter
		withConstraints: [ :constraints | constraints beOverlay ].
	overlays add: aPresenter.
	self announceChildAdded: aPresenter! !
!SpOverlayLayout methodsFor: 'accessing'!
child: aPresenter

	singleChild ifNotNil: [ self remove: singleChild ].
	self
		add: aPresenter
		withConstraints: [ :constraints | ].
	singleChild := aPresenter.
	self announceChildAdded: aPresenter! !
!SpOverlayLayout methodsFor: 'accessing'!
initialize
	super initialize.
	overlays := OrderedCollection new! !
!SpOverlayLayout methodsFor: 'accessing'!
presenter

	^ adapter ifNotNil: [ adapter presenter ]! !
!SpOverlayLayout methodsFor: 'accessing'!
remove: aPresenter
	
	children removeKey: aPresenter.
	singleChild := nil.
	self announceChildRemoved: aPresenter! !
!SpPanedLayout methodsFor: 'adding' prior: 64963073!
add: aName

	self 
		add: aName 
		withConstraints: [ :constraints | ]
		position: children size + 1! !
!SpPanedLayout methodsFor: 'adding'!
add: aChild withConstraints: aBlock position: aPosition
	"Add a child to the layout following the constraints in the block.
	The position is an integer index (1 or 2) indicating whether the child is first or last in the pane.
	For a horizontal layout, index 1 means left, index 2 means right.
	For a vertical layout, index 1 means top, index 2 means bottom."
	| constraints |

	aPosition > 2 ifTrue: [ 
		self error: 'You can not add more than two paned presenters.' ].

	(childrenByPosition at: aPosition) ifNotNil: [ :element |
		self remove: element ].

	constraints := self constraintsClass new.
	aBlock value: constraints.
	
	childrenByPosition at: aPosition put: aChild.
	
	children 
		at: aChild 
		put: constraints.
	
	self announceChildAdded: aChild.! !
!SpPanedLayout methodsFor: 'adding'!
addFirst: aName

	self 
		add: aName 
		withConstraints: [ :constraints | ]
		position: 1! !
!SpPanedLayout methodsFor: 'adding'!
addSecond: aName

	self 
		add: aName 
		withConstraints: [ :constraints | ]
		position: 2! !
!SpPanedLayout methodsFor: 'accessing'!
children

	^ childrenByPosition reject: #isNil! !
!SpPanedLayout methodsFor: 'initialization' prior: 64964323!
initialize 

	super initialize.
	self position: 50 percent.
	childrenByPosition := Array new: 2! !
!SpPanedLayout methodsFor: 'accessing'!
presenter

	^ adapter ifNotNil: [ adapter presenter ]! !
!SpPanedLayout methodsFor: 'adding'!
remove: aChild
	
	children removeKey: aChild.
	self announceChildRemoved: aChild! !
!SpScrollableLayout methodsFor: 'adding'!
child

	^ singleChild! !
!SpScrollableLayout methodsFor: 'adding'!
child: aPresenter

	singleChild ifNotNil: [ self remove: singleChild ].
	self
		add: aPresenter
		withConstraints: [ :constraints | ].
	singleChild := aPresenter.
	self announceChildAdded: aPresenter! !
!SpScrollableLayout methodsFor: 'adding'!
remove: aPresenter

	children removeKey: aPresenter.
	singleChild := nil.
	self announceChildRemoved: aPresenter! !
!SpLayoutWidgetAlignment class methodsFor: 'accessing'!
center

	^ SpLayoutWidgetAlignmentCenter uniqueInstance! !
!SpLayoutWidgetAlignment class methodsFor: 'accessing'!
end

	^ SpLayoutWidgetAlignmentEnd uniqueInstance! !
!SpLayoutWidgetAlignment class methodsFor: 'instance creation'!
new 

	self error: 'Use #uniqueInstance'! !
!SpLayoutWidgetAlignment class methodsFor: 'accessing'!
start

	^ SpLayoutWidgetAlignmentStart uniqueInstance! !
!SpLayoutWidgetAlignment class methodsFor: 'instance creation'!
uniqueInstance

	self = SpLayoutWidgetAlignment ifTrue: [ 
		self error: 'I''m an abstract class. Use one of my children instead.' ].
	^ uniqueInstance ifNil: [ uniqueInstance := self basicNew initialize ]! !
!SpLayoutWidgetAlignment methodsFor: '*Spec2-Morphic'!
asMorphicAlign

	^ self subclassResponsibility! !
!SpLayoutWidgetAlignmentCenter methodsFor: '*Spec2-Morphic'!
asMorphicAlign

	^ #center! !
!SpLayoutWidgetAlignmentEnd methodsFor: '*Spec2-Morphic'!
asMorphicAlign

	^ #bottomRight! !
!SpLayoutWidgetAlignmentStart methodsFor: '*Spec2-Morphic'!
asMorphicAlign

	^ #topLeft! !
!SpNotebookPage methodsFor: 'accessing'!
beCloseable

	closeable := true! !
!SpNotebookPage methodsFor: 'initialization' prior: 64905890!
initialize 

	self class initializeSlots: self.
	super initialize.
	
	closeable := false.
	
	self property: #title whenChangedDo: [ self pageTitleChanged ].
	self property: #icon whenChangedDo: [ self pageTitleChanged ]! !
!SpNotebookPage methodsFor: 'testing'!
isCloseable

	^ closeable! !
!SpPopoverPosition class methodsFor: 'accessing'!
bottom

	^ SpPopoverPositionBottom uniqueInstance! !
!SpPopoverPosition class methodsFor: 'accessing'!
left

	^ SpPopoverPositionLeft uniqueInstance! !
!SpPopoverPosition class methodsFor: 'instance creation'!
new

	self error: 'Use #uniqueInstance'! !
!SpPopoverPosition class methodsFor: 'accessing'!
right

	^ SpPopoverPositionRight uniqueInstance! !
!SpPopoverPosition class methodsFor: 'accessing'!
top

	^ SpPopoverPositionTop uniqueInstance! !
!SpPopoverPosition class methodsFor: 'instance creation'!
uniqueInstance

	self = SpPopoverPosition 
		ifTrue: [ self error: 'I''m abstract, use one of my children.' ].	
	^ uniqueInstance ifNil: [ uniqueInstance := self basicNew initialize ]! !
!SpPopoverPosition methodsFor: 'operations'!
applyTo: aWidget

	self subclassResponsibility! !
!SpPopoverPositionBottom methodsFor: 'operations'!
applyTo: aWidget

	aWidget bePositionBottom! !
!SpPopoverPositionLeft methodsFor: 'operations'!
applyTo: aWidget

	aWidget bePositionLeft! !
!SpPopoverPositionRight methodsFor: 'operations'!
applyTo: aWidget

	aWidget bePositionRight! !
!SpPopoverPositionTop methodsFor: 'operations'!
applyTo: aWidget

	aWidget bePositionTop! !
!SpTestLocalizedString class methodsFor: 'instance creation'!
from: aString

	^ self new string: aString! !
!SpTestLocalizedString methodsFor: 'accessing'!
asString 
	^ string asString! !
!SpTestLocalizedString methodsFor: 'accessing'!
initialize 

	super initialize.
	requestsCount := 0! !
!SpTestLocalizedString methodsFor: 'accessing'!
isEmptyOrNil

	^ self string isEmpty! !
!SpTestLocalizedString methodsFor: 'accessing'!
localizedForPresenter: aPresenter 

	requestsCount := requestsCount + 1.
	
	^ string, '[', aPresenter locale localeID isoString, '](', requestsCount asString, ')'! !
!SpTestLocalizedString methodsFor: 'accessing'!
string
	^ string! !
!SpTestLocalizedString methodsFor: 'accessing'!
string: anObject
	string := anObject! !
!SpTestLocalizedString methodsFor: 'accessing'!
withAccentuatedCharacter: aCharacter

! !
!SpValueSubscription class methodsFor: 'instance creation'!
with: aBlock

	^ self new 
		action: aBlock;
		yourself! !
!SpValueSubscription methodsFor: 'accessing'!
action

	^ action! !
!SpValueSubscription methodsFor: 'accessing'!
action: aBlock

	action := aBlock! !
!SpValueSubscription methodsFor: 'evaluating'!
cull: newValue cull: oldValue

	action 
		cull: newValue 
		cull: oldValue! !
!SpRootsPort methodsFor: 'handling transmission'!
incomingTransmission: anObject from: outPort

	self presenter roots: anObject! !
!SpMorphicLabelAdapter methodsFor: 'factory' prior: 64750305!
buildWidget
	| label |
	label := LabelMorph new model: self.
	label
		getEnabledSelector: #enabled;
		getTextSelector: #getText;
		vResizing: #shrinkWrap;
		hResizing: #spaceFill;
		dragEnabled: self dragEnabled;
		dropEnabled: self dropEnabled;
		setBalloonText: self getHelpText;
		setProperty: #minWidth toValue: 3. "3 is the default value of StringMorph. We do not want the default value of LabelMorph that is the min width of the content..."
		
	^ label! !
!SpMorphicLabelAdapter methodsFor: 'private'!
getHelpText

	^ self presenter help ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicLabelAdapter methodsFor: 'model access' prior: 64751631!
getText

	^self presenter label ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpDynamicLeftToRightColumnsLayout methodsFor: 'building' prior: 64375026!
buildLayoutFor: aDynamicPresentersListBuilder
	| layout |
	layout := SpBoxLayout newHorizontal.
	(self instVarNamesFrom: aDynamicPresentersListBuilder)
		groupsOf: self columnsCount
		atATimeDo: [ :group | 
			| subLayout |
			subLayout := SpBoxLayout newVertical.
			group do: [ :instVar | subLayout add: instVar ].
			layout add: subLayout withConstraints: self sublayoutConstraints ].
	^ layout! !
!SpEditableListPresenterTest methodsFor: 'tests'!
testWhenAddingNewItemThenNewItemIsSelected
	presenter 
		items: #(1 2 3) asOrderedCollection;
		addItemBlock: [ 4 ].
		
	presenter addButton click.
	
	self 
		assert: presenter selectedItem 
		equals: 4! !
!SpTransmission methodsFor: 'private' prior: 65360322!
from: aPresenter
	self fromPort: aPresenter defaultOutputPort! !
!SpTransmission methodsFor: 'private' prior: 65361518!
to: aPresenter

	self toPort: aPresenter defaultInputPort! !
!CmUILeftPositionStrategyExtensionsTest methodsFor: 'test' prior: 21167889!
testAddButtonToToolbar
	| toolbar button |
	toolbar := SpToolBarPresenter new.
	button := SpToolBarButtonPresenter new.
	
	self assertEmpty: toolbar items.
	
	CmUILeftPositionStrategy new
		addButton: button toToolbar: toolbar.
		
	self assert: toolbar leftItems size equals: 1.
	self assert: toolbar leftItems anyOne equals: button.
	self assertEmpty: toolbar rightItems! !
!SpCodePrintItCommand methodsFor: 'execution' prior: 64209297!
execute
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."

	self evaluateSelectionAndDo: [ :result | 
		self printObject: result ]! !
!SpCodePrintItCommand methodsFor: 'private' prior: 64209635!
printObject: anObject

	self context insertPopoverAfterCurrentSelection: (SpCodePopoverPrintPresenter 
		newCode: context 
		object: anObject)! !
!SpCodePrintItCommand methodsFor: 'private' prior: 64209928!
toPrintableString: printString

	self flag: #TODO. "This is maybe not the best? 
	I think I need to add a popover, but that then means I need to 
	have a special way to handle this special 'insertion' (to transmit the correct insertion 
	to the presenter's adapter)."
	^ String streamContents: [ :stream |
		stream << ' ' << printString  ]! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65337026!
badge
	badgeSelector ifNil: [ ^ nil ].
	^ self model perform: badgeSelector! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65337260!
badgeColor
	^ self theme badgeColor! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65336744!
badgeFont
	^ badgeFont ifNil: [ badgeFont := self newBadgeFont ]! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65337524!
badgeSelector: aSymbol
	badgeSelector := aSymbol! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65335955!
badgeTextColor
	^ self theme badgeTextColor! !
!SpToolBarButtonMorph methodsFor: 'configuring' prior: 65337359!
configureWith: displayModel item: itemPresenter
	displayModel configureButton: self item: itemPresenter! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65336060!
drawBadgeOn: aCanvas
	| badgeString badgeBounds textBounds textWidth textHeight width |
	
	badgeString := self badge asString.
	textWidth := self badgeFont widthOfString: badgeString.
	textHeight := self badgeFont height.
	width := 14 max: textWidth + 2. 
	badgeBounds := ((bounds right - width - 2)@(bounds top + 2) extent: width@14).
	aCanvas 
		fillOval: badgeBounds
		fillStyle: self badgeColor.
		
	textBounds := 
		(badgeBounds center - ((textWidth@textHeight) / 2.0)) + (1@0) 
		extent: textWidth@textHeight. 
	aCanvas 
		drawString: badgeString
		in: textBounds
		font: self badgeFont 
		color: self badgeTextColor! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65336870!
drawOn: aCanvas
	super drawOn: aCanvas.
	self hasBadge
		ifTrue: [ self drawBadgeOn: aCanvas ]! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65337163!
getIconSelector

	^ getIconSelector! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65335805!
getIconSelector: aSelector

	getIconSelector := aSelector.
	self update: getIconSelector! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65337634!
getLabelSelector

	^ getLabelSelector! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65337733!
getLabelSelector: aSelector

	getLabelSelector := aSelector.
	self update: getLabelSelector! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65338141!
hasBadge
	^ self badge notNil! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65337886!
newBadgeFont
	| baseBadgeFont |
	baseBadgeFont := StandardFonts codeFont.
 	^ (LogicalFont 
		familyName: baseBadgeFont familyName 
		pointSize: baseBadgeFont pointSize - 3)
			weightValue: 700! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65338232!
normalBorderStyle
	^ BorderStyle simple
		width: 0;
		baseColor: Color transparent! !
!SpToolBarButtonMorph methodsFor: 'accessing' prior: 65338376!
normalFillStyle
	^ Color transparent! !
!SpMockMenu methodsFor: 'owner'!
privateOwner: aRubEditingArea 
	
	"Nothing"! !
!SpMorphicTextInputFieldAdapter methodsFor: 'widget API' prior: 64841332!
accept: aText notifying: aNotifyier
	"We use #asString because rubric send Text instead of strings."

	super
		accept: aText asString 
		notifying: aNotifyier! !
!SpMorphicTextInputFieldAdapter methodsFor: 'factory' prior: 64841973!
buildWidget
	| newWidget |
	
	newWidget := (RubTextFieldMorph on: self)
		getTextSelector: #getText;
		setTextSelector: #accept:notifying:;
		getSelectionSelector: #readSelection;
		menuProvider: self selector: #codePaneMenu:shifted:;
		setSelectionSelector: #setSelection:;
		entryCompletion: self entryCompletion;
		ghostText: self getPlaceholderText;
		encrypted: self encrypted;
		enabled: self enabled;
		askBeforeDiscardingEdits: self askBeforeDiscardingEdits;
		autoAccept: true;
		vResizing: #spaceFill;
		hResizing: #spaceFill;
		setBalloonText: self help;
		dragEnabled: self dragEnabled;
		dropEnabled: self dropEnabled;
		maxLength: self presenter maxLength;
		yourself.

	self presenter whenTextChangedDo: [ :text | newWidget setText: text ].
	self presenter whenPlaceholderChangedDo: [ :text | 
		newWidget ghostText: (text ifNotNil: [ :aString | 
			aString localizedForPresenter: self presenter ]) ].
	self presenter whenPasswordChangedDo: [ :isPassword | newWidget encrypted: isPassword ].
	self presenter whenMaxLengthChangedDo: [ :length | newWidget maxLength: length ].

	^ newWidget! !
!SpMorphicTextInputFieldAdapter methodsFor: 'private'!
getPlaceholderText

	^ self presenter placeholder ifNotNil: [ :aString | 
		aString localizedForPresenter: self presenter ]! !
!SpListPresenter methodsFor: 'private' prior: 64552977!
registerEvents
	super registerEvents.
	"Do not use whenAutoDeselectChangedDo: to avoid the deprecation warning."
	self 
		property: #autoDeselect 
		whenChangedDo: [ :aBoolean | self changed: #autoDeselect: with: {aBoolean} ].
	self whenDisplayBlockChangedDo: [ 
		self withAdapterDo: [ :anAdapter | anAdapter refreshWidgetList ] ].
	self 
		property: #headerTitle 
		whenChangedDo: [ 
			self withAdapterDo: [ :anAdapter | anAdapter refreshWidgetHeaderTitle ] ]! !
!SpListPresenter methodsFor: 'api' prior: 64553799!
updateList

	self withAdapterDo: [ :anAdapter | anAdapter refreshWidgetList ].
	self unselectAll! !
!VersionBrowser methodsFor: 'instance creation' prior: 86848654!
showSourceWithConverter: aConverter
	sourcePresenter := self newCode.
	isShowingDiff := false.
	self needRebuild: false.
	self buildWithSpec.
	self textConverter: aConverter.
	sourcePresenter whenSubmitDo: [ :text :notifyer | (self accept: text notifying: notifyer) notNil ].
	sourcePresenter behavior: self selectedMessage methodClass.
	messageList selectIndex: (messageList selectedIndex)! !
!SpTMorphicUIRedrawer methodsFor: 'utilities' prior: 65234288!
waitUntilUIRedrawed
	"I wait until the UI has been redrawn. 
	I take care of selecting how to do it. 
	If I am in the CI I should defer a semaphore signal. 
	If I am running in the UI process I can directly execute a doOneCycle on the World.
	If I am in the CI the tests and the UI run in different process. So I should not do a #doOneCycle.
	If I do it, I am in a race condition!!"

	self isRunningInUIProcess
		ifTrue: [
			MorphicRenderLoop new doOneCycle.
			^ self ].

	self currentWorld defer: [ uiWaitingSemaphore ifNotNil: #signal ].
	uiWaitingSemaphore wait: self defaultWaitDuration! !
!SpMorphicNotebookAdapter methodsFor: 'factory' prior: 64782616!
addPage: aNotebookPage to: aNotebook

	aNotebook 
		addLazyPage: [ self buildContentForPage: aNotebookPage ] 
		label: (self buildLabelForPage: aNotebookPage)
		collapsable: aNotebookPage isCloseable.
	"Since I do not have the page added, I need to take it from the list. But I know 
	 this will be the last added :)"
	aNotebook pages last model: aNotebookPage! !
!SpTextPresenterTest methodsFor: 'tests'!
testEditable

	presenter beNotEditable.
	self openInstance.
	
	presenter adapter 
		keyPressed: $x asciiValue 
		shift: false 
		meta: false 
		control: false 
		option: false.
	
	self assert: presenter text equals: ''.
	
	presenter beEditable.
	
	presenter adapter 
		keyPressed: $x asciiValue 
		shift: false 
		meta: false 
		control: false 
		option: false.
	
	self assert: presenter text equals: 'x'.
! !
!SpTextPresenterTest methodsFor: 'tests'!
testPropagateNaturalHeight

	presenter text: String loremIpsum.
	presenter propagateNaturalHeight: true. 
	self openInstance.
	self assert: presenter adapter widget height >= String loremIpsum asMorph height.! !
!SpTextPresenterTest methodsFor: 'tests'!
testPropagateNaturalWidth
	| lipsum stringMorph expectedWidth |

	lipsum := String loremIpsum withNoLineLongerThan: 50.

	presenter text: lipsum.
	presenter propagateNaturalWidth: true. 
	self openInstance.
	
	stringMorph := RubEditingArea new 
		font: presenter adapter widget font;
		updateTextWith: lipsum.

	expectedWidth := stringMorph width + 12 min: self currentWorld width / 3.
	
	
	self assert: presenter adapter widget width >= expectedWidth.
	
	! !
!SpMorphicTableColumn methodsFor: 'private'!
defaultSortFunction

	^ [ :each | (self readObject: each) ] ascending! !
!SpMorphicTableColumn methodsFor: 'testing'!
isSorted

	^ self sortingStrategy isSortingEnabled and: [ self sortingStrategy state isSorted ]! !
!SpMorphicTableColumn methodsFor: 'sorting'!
sortableUsing: aSortFunction

	^ super sortableUsing: (aSortFunction ifNil: [ self defaultSortFunction ])! !
!SpTreeTableAdapterSingleSelectionTest methodsFor: 'tests-model-to-widget'!
testSelectPresenterWithScrollingMakeSelectedItemVisible
	| visibleItems |

	presenter
		roots: (1 to: 200);
		openWithSpec.
		
	presenter selectPath: { 150 } scrollToSelection: true.
	visibleItems := presenter verticalAlignment firstVisibleRowIndex to: presenter verticalAlignment lastVisibleRowIndex.
		
	self assert: (visibleItems includes: presenter selection selectedPath first)! !
!SpTreeTableAdapterSingleSelectionTest methodsFor: 'tests-model-to-widget'!
testSelectPresenterWithoutScrollingDoesNotScroll
	| visibleItems verticalAlignment |
	
	presenter 
		roots: (1 to: 200);
		openWithSpec.
	verticalAlignment := presenter verticalAlignment.		
	visibleItems := verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex.
	
	presenter selectPath: { 150 } scrollToSelection: false.
		
	self 
		assert: (verticalAlignment firstVisibleRowIndex to: verticalAlignment lastVisibleRowIndex) 
		equals: visibleItems! !
!SpWindowPresenter methodsFor: 'private building' prior: 65483832!
addPresenterIn: widget withSpecLayout: aSpec
	
	self presenter ifNil: [ ^ self ].
	self initializeWindow.
	self withAdapterDo: [ :anAdapter |
		anAdapter addPresenterIn: widget withSpecLayout: aSpec ]! !
!SpWindowPresenter methodsFor: 'api'!
centeredRelativeToTopWindow

	self centeredRelativeTo: self application topWindow! !
!SpWindowPresenter methodsFor: 'private' prior: 65484070!
delete
	"DO NOT USE. This will destroy the window and maybe you do not want that :/
	 I'm keeping this here because of testing."

	self withAdapterDo: [ :anAdapter | anAdapter delete ]! !
!SpWindowPresenter methodsFor: 'testing'!
isTopWindow
	"answers true if this si the active window (the one that has the focus)"
	
	self withAdapterDo: [ :anAdapter | 
		^ anAdapter isTopWindow ].

	^ false! !
!SpWindowPresenter methodsFor: 'api' prior: 65484362!
maximize

	self withAdapterDo: [ :anAdapter | anAdapter maximize ]! !
!SpWindowPresenter methodsFor: 'api' prior: 65478619!
minimize

	self withAdapterDo: [ :anAdapter | anAdapter minimize ]! !
!SpWindowPresenter methodsFor: 'api-events' prior: 65478908!
whenResizingDo: aBlock
	
	self announcer 
		when: SpWindowResizing
		do: aBlock! !
!SpTestWorldPresenter class methodsFor: 'ui requests'!
currentWorld
	^ TestWorld ifNil: [ TestWorld := self newWorld ]! !
!SpTestWorldPresenter class methodsFor: 'instance creation'!
newWorld
	| hand |
	hand := HandMorph new.
	^ WorldMorph new 
		addHand: hand;
		activeHand: hand;
		yourself! !
!SpTestWorldPresenter class methodsFor: 'ui requests'!
reset
	TestWorld := nil! !
!SpTestWorldPresenter methodsFor: 'accessing'!
currentWorld
	^ self class currentWorld! !
!SpTestWorldPresenter methodsFor: 'private showing'!
openWithSpecLayout: aLayout
	super openWithSpecLayout: aLayout.
	isClosed := false! !
!SpTestWorldPresenter methodsFor: 'accessing'!
widget
	^ self currentWorld! !
!SpWorldPresenter class methodsFor: 'specs' prior: 65495149!
defaultSpec
	self setUpWorld.
	^ SpAbstractWidgetLayout for: #WorldAdapter! !
!SpWorldPresenter class methodsFor: 'private' prior: 65494672!
setUpWorld

	self currentWorld changeProportionalLayout.
	self currentWorld submorphs do: [:e | e delete ].
 
 	(Smalltalk at: #PolymorphSystemSettings) 
		perform: #desktopColor: 
		with: self currentWorld theme backgroundColor.
 	"((Smalltalk at: #UITheme) perform: #currentSettings) perform: #windowColor: with: (Color r: 0.745 g: 0.745 b: 0.745)."
	(Smalltalk at: #TaskbarMorph) perform: #showTaskbar: with: false! !
!SpWorldPresenter methodsFor: 'private' prior: 65493522!
addPresenterIn: container withSpecLayout: aSpec

	self presenter ifNil: [ ^ self ].
	self presenter initializeWindow: self.
	self 
		changed: #addPresenterIn:withSpecLayout:
		with: { container. aSpec }! !
!SpWorldPresenter methodsFor: 'private' prior: 65494239!
defaultInitialExtent
	
	^ self currentWorld extent! !
!SpWorldPresenter methodsFor: 'api' prior: 65493296!
ensureExtentFor: aWidget

	self extent ifNotNil: [ :ext | DisplayScreen hostWindowSize: ext ].
	self initialExtent ifNotNil: [ :ext | DisplayScreen hostWindowSize: ext ].! !
!SpWorldPresenter methodsFor: 'api' prior: 65494163!
isDisplayed

	^ true! !
!SpWorldPresenter methodsFor: 'private' prior: 65493781!
openWithSpec: aSpec

	self buildWithSpec: aSpec.
	self updateTitle! !
!SpWorldPresenter methodsFor: 'private' prior: 65494033!
openWithSpecLayout: aSpec

	self buildWithSpecLayout: aSpec.
	self updateTitle! !
!SpWorldPresenter methodsFor: 'private' prior: 65494345!
title: aString

	self adapter ifNotNil: [ :worldAdapter | worldAdapter title: self title ]! !
!SpWorldPresenter methodsFor: 'private' prior: 65494528!
updateTitle
	"Update the window title"

	self title: self title! !
!SpWorldPresenter methodsFor: 'api' prior: 65494454!
widget

	^ widget ! !
!CmUIRightPositionStrategyExtensionsTest methodsFor: 'test' prior: 21169948!
testAddButtonToToolbar
	| toolbar button |
	toolbar := SpToolBarPresenter new.
	button := SpToolBarButtonPresenter new.
	
	self assertEmpty: toolbar items.
	
	CmUIRightPositionStrategy new
		addButton: button toToolbar: toolbar.
		
	self assert: toolbar rightItems size equals: 1.
	self assert: toolbar rightItems anyOne equals: button.
	self assertEmpty: toolbar leftItems! !
!SpMorphicAdapterTestCase methodsFor: 'running' prior: 64662802!
openInstance

	window ifNil: [ window := presenter openWithSpec ].
	MorphicRenderLoop new doOneCycle.! !
!SpMorphicAdapterTestCase methodsFor: 'running' prior: 64662512!
widget

	"Force opening the spec instance here.
	The action should have been correctly configured before
	depending on the spec initialization strategy"
	self openInstance.
	MorphicRenderLoop new doOneCycle.
	^ self adapter widget! !
!FTTableMorph methodsFor: '*Spec2-Adapters-Morphic'!
clickOnColumnHeaderAt: anIndex
	| header |
	header := self container headerRow submorphs at: anIndex.
	header click: (MouseButtonEvent basicNew 
							setType: #mouseDown;
							yourself).
		! !
!SpMorphicMenuItemAdapter methodsFor: 'widget API' prior: 64770333!
name
	| name | 
	
	name := self presenter name.
	
	^ (name isBlock or: [ name isMessageSend ])
		ifTrue: [ name cull: self model ]
		ifFalse: [ name ifNotNil: [ :aString | aString localizedForPresenter: self presenter ] ]
! !
!FTTreeItem methodsFor: '*Spec2-Adapters-Morphic'!
hasComputedChildren
	"I return true if I have computed children or if I don't have computed children."

	^ self hasChildren! !
!SpMorphicRadioButtonAdapter methodsFor: 'factory' prior: 64805635!
buildWidget
	| radioButton |

	self presenter isInitialStateSet ifFalse: [ 
		"initial state is false, set all associated buttons to false too"
		self presenter property: #state rawValue: false.
		self presenter associatedRadioButtons do: [ :each |
			each property: #state rawValue: false ] ].

	radioButton := CheckboxMorph new
		on: self 
			selected: #state 
			changeSelected: #state:;
		getEnabledSelector: #enabled;
		label: self getLabelText;
		labelClickable: self labelClickable;
		beRadioButton;
		hResizing: #shrinkWrap;
		vResizing: #shrinkWrap;
		setBalloonText: self getHelpText;
		dragEnabled: self dragEnabled;
		dropEnabled: self dropEnabled;
		yourself.
		
	self presenter whenLabelChangedDo: [ :newLabel | radioButton label: (newLabel ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]) ].
	self presenter whenChangedDo: [ radioButton updateSelection ].

	^ radioButton! !
!SpMorphicRadioButtonAdapter methodsFor: 'factory'!
getHelpText

	^ self presenter help ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicRadioButtonAdapter methodsFor: 'private'!
getLabelText

	^ self presenter label ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicRadioButtonAdapter methodsFor: 'widget API' prior: 64805418!
label

	^ self getLabelText! !
!SpToolBarButtonPresenter class methodsFor: 'specs'!
adapterName

	^ #ToolBarButtonAdapter! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
action
	^ action! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
action: anObject
	action := anObject! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
badge
	^ badge! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
badge: aString
	badge := aString! !
!SpToolBarButtonPresenter methodsFor: 'simulating'!
click
	
	self execute! !
!SpToolBarButtonPresenter methodsFor: 'execution'!
execute
	self action cull: self! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
icon
	^ icon! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
icon: anObject
	icon := anObject! !
!SpToolBarButtonPresenter methodsFor: 'initialization' prior: 33740490!
initialize
	super initialize.! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
label
	^ label! !
!SpToolBarButtonPresenter methodsFor: 'accessing'!
label: anObject
	label := anObject! !
!SpToolBarButtonPresenter methodsFor: 'api-events'!
whenIconChangedDo: aBlock 

	self property: #icon whenChangedDo: aBlock ! !
!SpToolBarButtonPresenter methodsFor: 'api-events'!
whenLabelChangedDo: aBlock 

	self property: #label whenChangedDo: aBlock ! !
!SpToolBarMenuButtonPresenter class methodsFor: 'specs'!
adapterName

	^ #ToolBarMenuButtonAdapter! !
!SpToolBarMenuButtonPresenter methodsFor: 'initialization'!
initialize

	super initialize.
	self addStyle: 'button'! !
!SpToolBarMenuButtonPresenter methodsFor: 'accessing'!
menu
	^ menu! !
!SpToolBarMenuButtonPresenter methodsFor: 'accessing'!
menu: anObject
	menu := anObject! !
!SpToolBarOptionButtonPresenter class methodsFor: 'specs'!
adapterName

	^ #ToolBarOptionAdapter! !
!SpToolBarOptionButtonPresenter methodsFor: 'accessing'!
buttonGroup: anITOptionButtonGroup 
	
	buttonGroup := anITOptionButtonGroup! !
!SpToolBarOptionButtonPresenter methodsFor: 'execution'!
execute: state

	buttonGroup unselectAll.
	self beSelected.
	self action cull: state cull: self! !
!SpToolBarToggleButtonPresenter class methodsFor: 'specs'!
adapterName

	^ #ToolBarToggleButtonAdapter! !
!SpToolBarToggleButtonPresenter methodsFor: 'selection'!
beSelected
	
	self setSelection: true! !
!SpToolBarToggleButtonPresenter methodsFor: 'selection'!
beUnselected
	
	self setSelection: false! !
!SpToolBarToggleButtonPresenter methodsFor: 'execution'!
execute: state

	self setSelection: state.
	self action 
		cull: state 
		cull: self! !
!SpToolBarToggleButtonPresenter methodsFor: 'initialization' prior: 33740745!
initialize

	super initialize.
	selected := false! !
!SpToolBarToggleButtonPresenter methodsFor: 'testing'!
isSelected

	^ selected! !
!SpToolBarToggleButtonPresenter methodsFor: 'selection'!
setSelection: aBoolean

	selected := aBoolean.
	self changed: #isSelected! !
!SpToolBarToggleButtonPresenter methodsFor: 'selection'!
toggle
	
	self setSelection: selected not! !
!SpToolBarToggleButtonPresenter methodsFor: 'private'!
whenChangedDo: aBlock
	"Only execute aBlock if old value is different from new value"

	self
		property: #selected
		whenChangedDo: [ :newSelectedValue :oldSelectedValue | 
			newSelectedValue = oldSelectedValue
				ifFalse: [ aBlock cull: newSelectedValue cull: oldSelectedValue ] ]! !
!SpToolBarToggleButtonPresenter methodsFor: 'api - events'!
whenSelectedDo: aBlock
	self whenChangedDo: [ :newSelectedValue | 
			newSelectedValue
				ifTrue: [ aBlock value ] ]! !
!SpToolBarToggleButtonPresenter methodsFor: 'api - events'!
whenToggledDo: aBlock 

	self property: #selected whenChangedDo: aBlock ! !
!SpToolBarToggleButtonPresenter methodsFor: 'api - events'!
whenUnselectedDo: aBlock
	self whenChangedDo: [ :newSelectedValue | 
			newSelectedValue
				ifFalse: [ aBlock value ] ]! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64192093!
assertText: text at: index isStyle: styleName
	| tag |

	tag := SpCodeStyleForTest new.
	text attributesAt: index do: [ :each | 
		self fillTag: tag withAttribute: each ].
	self assert: tag equals: (self style: styleName)! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64193374!
assertText: text atInterval: interval isStyle: styleName

	interval do: [ :index |
		self assertText: text at: index isStyle: styleName ]! !
!SpCodeAdapterTest methodsFor: 'accessing' prior: 64193787!
classToTest

	^ SpCodePresenter! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64194246!
fillTag: tag withAttribute: attr

	attr class = TextColor ifTrue: [ tag foreground: attr color ].
	self flag: #TODO. "Other attributes"! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64193873!
style: aSymbol 
	| tag |
	
	tag := SpCodeStyleForTest new.
	self styleTableAt: aSymbol do: [ :each |
		self fillTag: tag withAttribute: each ]. 
	
	^ tag
	! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64193566!
styleTableAt: styleName do: aBlock 
	| attributes |	

	attributes := (SHRBTextStyler initialTextAttributesForPixelHeight: 1) at: styleName.
	attributes do: aBlock! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64192369!
testTextWithStyle
	| text |

	presenter 
		behavior: nil;
		doItReceiver: Object;
		type: 'self asString.'.
	
	text := self adapter textWithStyle.
	self assertText: text atInterval: "self" (1 to: 4) isStyle: #self.
	self assertText: text atInterval: "asString" (6 to: 13) isStyle: #unary.

	presenter type: '10 + 42.0'.
	text := self adapter textWithStyle.
	self assertText: text atInterval: "10" (1 to: 2) isStyle: #integer.
	self assertText: text atInterval: "+" (4 to: 4) isStyle: #binary.
	self assertText: text atInterval: "42.0" (6 to: 9) isStyle: #number.

	presenter behavior: Object.
	presenter type: 'm1 ^ "test" 42'.
	text := self adapter textWithStyle.
	self assertText: text atInterval: "m1" (1 to: 2) isStyle: #patternKeyword.
	self assertText: text atInterval: "^" (4 to: 4) isStyle: #return.
	self assertText: text atInterval: "test" (6 to: 11) isStyle: #comment.	
	self assertText: text atInterval: "42" (13 to: 14) isStyle: #number.! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64194083!
testWithSyntaxHighlight
	presenter withSyntaxHighlight.
	self assert: self adapter hasSyntaxHighlightEnabled! !
!SpCodeAdapterTest methodsFor: 'tests' prior: 64191926!
testWithoutSyntaxHighlight
	presenter withoutSyntaxHighlight.
	self deny: self adapter hasSyntaxHighlightEnabled! !
!SpMorphicLinkAdapter methodsFor: 'factory' prior: 64754745!
buildWidget
	"Since Pharo does not yet have a real morph for URL, I create my own. Maybe later we will have real links in Morphic?"

	| aMorph |
	
	aMorph := StringMorph new
		contents: self getLabelText;
		dragEnabled: self dragEnabled;
		dropEnabled: self dropEnabled;
		vResizing: #shrinkWrap;
		hResizing: #spaceFill;
		setBalloonText: self getHelpText;
		color: self urlColor;
		on: #mouseEnter send: #mouseEnter:from: to: self;
		on: #mouseLeave send: #mouseLeave:from: to: self;
		on: #mouseDown send: #mouseDown:from: to: self;
		on: #mouseUp send: #mouseUp:from: to: self;
		yourself.	";
		emphasis: (self emphasisCodeFor: self model emphasis)"
		
	self presenter whenLabelChangedDo: [ :newLabel | aMorph contents: (newLabel ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]) ].
	
	^ aMorph! !
!SpMorphicLinkAdapter methodsFor: 'private'!
getHelpText

	^ self presenter help ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicLinkAdapter methodsFor: 'private'!
getLabelText

	^ self presenter label ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicLinkAdapter methodsFor: 'accessing' prior: 64754554!
label
	^ self getLabelText! !
!SpTreeTableAdapterMultiColumnTest methodsFor: 'running' prior: 65406516!
initializeTestedInstance
	super initializeTestedInstance.
	presenter addColumn: (SpImageTableColumn title: 'Icon' evaluated: [ :x | self iconNamed: #add ])! !
!SpMorphicTableAdapter methodsFor: 'factory' prior: 64818704!
addModelTo: tableMorph

	self model columns do: [ :each |
		tableMorph addColumn: (self newColumnFrom: each) ].
	self ensureAtLeastOneColumnIn: tableMorph.

	self isResizable 
		ifTrue: [ tableMorph beResizable ] 
		ifFalse: [ tableMorph beNotResizable ].
	
	tableMorph setMultipleSelection: self model isMultipleSelection.

	self refreshShowColumnHeaders.
	self refreshWidgetSelection.
	
	self presenter whenShowColumnHeadersChangedDo: [ :showColumns |
		self refreshShowColumnHeaders ].

	self presenter whenModelChangedDo: [ self refreshModel ].
	self presenter whenColumnsChangedDo: [ self refreshColumnsInWidget ].
	
	tableMorph setBalloonText: self help.

	self configureScrolling.

	tableMorph
		onAnnouncement: FTSelectionChanged
			send: #selectionChanged:
			to: self;
		onAnnouncement: FTStrongSelectionChanged
			send: #strongSelectionChanged:
			to: self.

	tableMorph dataSource: self newDataSource.
	
	self presenter whenItemFilterBlockChangedDo: [ :block | 
		self updateItemFilterBlockWith: block ].
	self presenter whenSearchChangedDo: [ 
		self updateSearch ].
	self updateItemFilterBlockWith: self itemFilter! !
!SpMorphicTableAdapter methodsFor: 'emulating'!
clickOnColumnHeaderAt: anIndex
	self widgetDo: [ :tableWidget | tableWidget clickOnColumnHeaderAt: anIndex ]! !
!SpMorphicTableAdapter methodsFor: 'private'!
ifSorted: sortedBlock ifNotSorted: notSortedBlock 
	widget columns 
		do: [ :column | | state | 
			column isSorted
				ifTrue: [ 
					state := column sortingStrategy state.
					state isSorted
						ifTrue: [ ^ sortedBlock cull: state ] ] ].
	^ notSortedBlock value! !
!SpMorphicTableAdapter methodsFor: 'refreshing' prior: 64818488!
refreshList

	^ self widget refresh! !
!SpMorphicTableAdapter methodsFor: 'refreshing'!
refreshModel

	widget dataSource resetElements.
	self
		ifSorted: [ :sortingStrategyState | sortingStrategyState executeSortingOn: widget dataSource ]
		ifNotSorted: [ self refreshList ]! !
!SpMorphicTableAdapter methodsFor: 'refreshing' prior: 64817093!
refreshWidgetSelection
	| rowIndexes |
	rowIndexes := self presenter selection selectedIndexes.
	rowIndexes = self widget selectedIndexes
		ifTrue: [ ^ self ].
	rowIndexes isEmpty
		ifTrue: [ self widget basicSelectIndexes: #() ]
		ifFalse: [ self widget basicSelectIndexes: rowIndexes ].
	^ self refreshList! !
!SpMultipleSelectionModeTest methodsFor: 'tests'!
testGetRightElementAfterSortingOfElementsChanged
	presenter := SpTablePresenter new. "use a TablePresenter since ListPresenter cannot sort"
	presenter 
		items: (1 to: 10) asArray;
		beMultipleSelection;
		openWithSpec.
	
	presenter 
		withAdapterDo: [ :adapter | adapter widget dataSource sortElements: [ :a :b | a > b ] ];
		selectIndexes: #(1 3).
	
	self 
		assert: presenter selection selectedItems asArray 
		equals: #(10 8)! !
!SpMultipleSelectionModeTest methodsFor: 'tests'!
testSelectionIsResetAfterItemsAssignment
	presenter
		beMultipleSelection;
		openWithSpec;
		selectIndexes: #(1 2 3).

	presenter items: #(2 5).

	self 
		assert: presenter selection selectedItems asArray
		equals: #()! !
!SpMultipleSelectionModeTest methodsFor: 'tests'!
testSelectionIsResetAfterSorting
	presenter := SpTablePresenter new.	"use a TablePresenter since ListPresenter cannot sort"
	presenter
		items: (1 to: 10) asArray;
		beMultipleSelection;
		openWithSpec;
		selectIndexes: #(1 3).
		
	presenter
		withAdapterDo: [ :adapter | 
			adapter widget dataSource
				sortByColumn: presenter adapter columns first
				event: nil
				morph: nil ].
			
	self assert: presenter selection selectedItems isEmpty! !
!FTAbstractSortingState methodsFor: '*Spec2-Adapters-Morphic'!
isSorted 
	^ true! !
!SpTreeMultipleSelectionMode methodsFor: 'transmission' prior: 65371929!
transmission
	
	^ self selectedItems! !
!SpDynamicTopToBottomRowsLayout methodsFor: 'building' prior: 64406615!
buildLayoutFor: aDynamicPresentersListBuilder
	| layout |
	layout := SpBoxLayout newVertical.
	(self instVarNamesFrom: aDynamicPresentersListBuilder)
		groupsOf: self rowsCount
		atATimeDo: [ :group | 
			| subLayout |
			subLayout := SpBoxLayout newHorizontal.
			group do: [ :instVar | subLayout add: instVar ].
			layout add: subLayout withConstraints: self sublayoutConstraints ].
	^ layout! !
!SpMorphicTableDataSource methodsFor: 'accessing' prior: 64828281!
elements 
	
	^ elements ifNil: [
		self model 
			ifNotNil: #items
			ifNil: [ #() ] ]! !
!SpMorphicTableDataSource methodsFor: 'accessing'!
resetElements

	elements := nil! !
!SpSpinnerMorph class methodsFor: 'accessing' prior: 65156803!
spinnerForm

	SpinnerForm ifNotNil: [ ^ SpinnerForm ].
	^ SpinnerForm := Form
		extent: 40 @ 40
		depth: 32
		fromArray: self spinnerFormContents
		offset: 0 @ 0! !
!SpSpinnerMorph class methodsFor: 'private'!
spinnerFormContents
		
	^ #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1280145589 2202892982 1565292724 71270335 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2773515703 4082664381 4268595409 4082927812 3461381560 90597068 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 911243955 4082401467 4287215086 4287346672 4287346672 4082993860 1615690420 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1582201525 4066479816 4287346672 4287346672 4287346672 4285504213 2370796726 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 743143859 4099047096 4287083756 4287346672 4287280879 4065953472 1431206836 0 0 0 0 0 0 0 156529065 90597068 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 693140660 1766685110 1078950835 0 0 0 0 0 0 0 2303753914 4082270393 4100231370 4065690044 3042016696 16777471 0 0 0 0 0 693140660 3461447096 4182670262 4182735798 2974973368 357071286 0 0 0 0 0 0 0 0 0 0 0 0 1229748917 4098981560 4133786059 4065690044 2370928312 0 0 0 0 0 0 0 810515124 1699641781 1045330868 0 0 0 0 0 0 290158772 3964763319 4252213209 4287280879 4287215086 4184380366 3427892663 16777471 0 0 0 0 0 0 0 0 0 0 0 3545398968 4286228191 4287346672 4287083500 4166024119 156529065 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1833793972 4133720266 4287346672 4287346672 4287346672 4287280880 4065690044 944601782 0 0 0 0 0 0 0 0 0 0 0 3629219513 4286359777 4287346672 4287149294 4166024119 189100985 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2454748341 4285504470 4287346672 4287346672 4287346672 4287346672 4049636551 1498250164 0 0 0 0 0 0 0 0 0 0 0 1464826805 4099047098 4251621328 4065953215 2639363769 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1565292724 4082993603 4287346672 4287346672 4287346672 4287215086 4099047354 709786038 0 0 0 0 0 0 0 0 0 0 0 0 944601782 2119072694 1397521077 16777471 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 71270335 3595664823 4133786059 4286622949 4286425570 4099639234 2790358456 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 206929855 2471722681 3729882808 3595730617 1951366582 41910143 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 390953393 2807070135 3947986359 4115626678 3276963256 944601782 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 324040878 3847257271 4150826190 4286820328 4287083500 4268924632 4098981047 1061976502 0 0 0 1162968501 3947986104 3998252215 1330674356 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2404547767 4133720266 4287346672 4287346672 4287346672 4287346672 4269188060 3662708151 0 0 0 3880811703 4286228449 4286491364 4048583607 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3528621753 4286360034 4287346672 4287346672 4287346672 4287346672 4287346671 4182735542 223245744 0 0 3880811703 4286228449 4286491364 4048583607 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3528621753 4286360034 4287346672 4287346672 4287346672 4287346672 4287346671 4182735542 223245744 0 0 1162968501 3947986103 3998252215 1347385781 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2370796726 4133785802 4287346672 4287346672 4287346672 4287346672 4269187803 3662708151 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 324040878 3847257271 4150826190 4286820328 4287083243 4268990424 4098981047 1061976502 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 390953393 2790358454 3947986359 4115626678 3260120760 944601782 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 156529065 1666021812 2773581495 2589031863 1347189173 41910143 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 357071286 3696196791 4099770563 4285767641 4285636054 4082533052 3058793655 55924138 0 0 0 0 0 0 0 0 0 0 0 0 0 357071286 307527608 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2891021495 4167471820 4287346672 4287346672 4287346672 4287280878 4082795968 1917746613 0 0 0 0 0 0 0 0 0 0 0 0 1028618675 4132404150 4098915254 843872946 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16777471 4132404151 4287083500 4287346672 4287346672 4287346672 4287346672 4286293984 3428023993 0 0 0 0 0 0 0 0 0 0 0 0 1984788917 4200697288 4166945476 1783397044 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 206929855 4199513013 4287346672 4287346672 4287346672 4287346672 4287346672 4286754534 3847323064 0 0 0 0 0 0 0 0 0 0 0 0 324040878 3125968569 3042148024 257259451 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3897589175 4286556900 4287346672 4287346672 4287346672 4287346672 4268924631 3042148024 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1800305589 4099244477 4286820328 4287346672 4287346672 4286425570 4132469943 961312946 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2119203766 4115692471 4015621568 4032266942 4048518069 1380809140 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41910143 2689564088 1901165753 0 0 0 0 0 0 0 0 0 223245744 1028618675 860911796 106266538 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 273645487 4216224436 3562044856 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 609056952 340557746 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)! !
!SpSpinnerMorph methodsFor: 'stepping and presenter'!
height: aHeight

	super height: aHeight.
	transformationMorph height: aHeight! !
!SpSpinnerMorph methodsFor: 'stepping and presenter' prior: 65156493!
initialize

	| wheelImageMorph |
	super initialize.
	self color: Color transparent.
	wheelImageMorph := self newSpinnerMorph.
	
	transformationMorph := TransformationMorph new asFlexOf: wheelImageMorph.
	transformationMorph 
		vResizing: #rigid;
		hResizing: #rigid.

	self addMorph: transformationMorph! !
!SpSpinnerMorph methodsFor: 'stepping and presenter'!
width: aWidth

	super width: aWidth.
	transformationMorph width: aWidth! !
!SpTreeSingleSelectionMode methodsFor: 'transmission' prior: 65405617!
transmission
	
	^ self selectedItem! !
!SpPresenterWithModel methodsFor: 'abstract'!
defaultInputPort

	^ self inputModelPort! !
!SpPresenterWithModel methodsFor: 'abstract'!
inputModelPort

	^ SpModelPort newPresenter: self! !
!SpPresenterWithModel methodsFor: 'transmission' prior: 65045855!
setModel: aDomainObject

	^	self model: aDomainObject! !
!SpAbstractTreeSelectionMode methodsFor: 'transmission' prior: 64073479!
transmission
	self subclassResponsibility! !
!SpSingleSelectionMode methodsFor: 'selecting' prior: 65139596!
selectedItem

	self selectedIndex = 0 ifTrue: [ ^ nil ].
	self widget withAdapterDo: [ :anAdapter |
		^ anAdapter elementAt: self selectedIndex ].
	^ self model at: self selectedIndex! !
!SpSingleSelectionMode methodsFor: 'transmission' prior: 65141538!
transmission 
	
	^ self selectedItem! !
!SpMorphicModalWindowAdapter methodsFor: 'protocol' prior: 64779654!
open
	self model windowIsOpening.

	backdropMorph := FullscreenMorph new
		color: self theme modalBackdropColor;
		on: #click send: #mouseClick:onBackdrop: to: self;
		openInWorld;
		yourself.

	self widget
		toggleStickiness;
		center: self currentWorld clearArea center;
		openModal! !
!SpDemoStandaloneFormPresenter class methodsFor: 'specs' prior: 64325815!
defaultSpec
	
	^ SpBoxLayout newVertical
		add:
			(SpGridLayout new
				add: 'Name:' at: 1 @ 1;
				add: #nameTextInput at: 2 @ 1;
				add: 'Surname:' at: 1 @ 2;
				add: #surnameTextInput at: 2 @ 2;
				add: 'Number 1:' at: 1 @ 3;
				add: #number1Input at: 2 @ 3;
				add: 'Number 2:' at: 1 @ 4;
				add: #number2Input at: 2 @ 4;
				add: 'Scale:' at: 1 @ 5;
				add: #scaleInput at: 2 @ 5;
				add: 'Password:' at: 1 @ 6;
				add: #passwordInput at: 2 @ 6;
				add: 'Remember me:' at: 1 @ 7;
				add: #checkboxInput at: 2 @ 7;
				add: 'Date:' at: 1 @ 8;
				add: #dateInput at: 2 @ 8;
				add: 'Gender:' at: 1 @ 9;
				add:
					(SpBoxLayout newHorizontal
						add: #maleButton;
						add: #femaleButton;
						yourself)
					at: 2 @ 9;
				add: 'Items:' at: 1 @ 10;
				add: #itemsInput at: 2 @ 10;
				yourself);
		add:
			(SpBoxLayout newHorizontal
				add: #submitButton;
				add: #restoreButton;
				yourself);
		yourself! !
!SpDemoStandaloneFormPresenter methodsFor: 'initialization' prior: 64321636!
initializePresenters
	nameLabel := self newLabel label: 'name:'.
	nameTextInput := self newTextInput.

	surnameLabel := self newLabel label: 'surname:'.
	surnameTextInput := self newTextInput.
	surnameTextInput placeholder: 'empty'.
	number1Label := self newLabel label: 'number 1:'.
	number1Input := self newNumberInput.

	number2Label := self newLabel label: 'number 2:'.
	number2Input := self newNumberInput
		beFloat;
		digits: 3;
		climbRate: 0.005;
		minimum: 10.005;
		maximum: 20.05.

	scaleLabel := self newLabel label: 'scale:'.
	scaleInput := self newSlider.

	passwordLabel := self newLabel label: 'password:'.
	passwordInput := self newTextInput
		bePassword.
	checkboxLabel := self newLabel label: 'remember me'.
	checkboxInput := self newCheckBox state: true.

	dateLabel := self newLabel label: 'date:'.
	dateInput := self instantiate: SpDatePresenter.
	dateInput display: [ :item | item yyyymmdd ].

	maleButton := self newRadioButton label: 'male'.
	femaleButton := self newRadioButton label: 'female'.
	maleButton associatedRadioButtons: {femaleButton}.
	genderButtons := Dictionary newFrom: {(#male -> maleButton) . (#female -> femaleButton)}.

	genderLabel := self newLabel label: 'gender:'.
	itemsLabel := self newLabel label: 'items:'.
	itemsInput := self newList.
	itemsInput beMultipleSelection.
	itemsInput items: self model items.

	submitButton := self newButton label: 'Submit'.
	restoreButton := self newButton label: 'Restore'.

	self focusOrder
		add: nameTextInput;
		add: surnameTextInput;
		add: number1Input;
		add: number2Input;
		add: scaleInput;
		add: passwordInput;
		add: checkboxInput! !
!SpMorphicBaseMenuAdapter methodsFor: 'private'!
getTitleText

	^ self presenter title ifNotNil: [ :aString | aString localizedForPresenter: self presenter ]! !
!SpMorphicBaseMenuAdapter methodsFor: 'protocol' prior: 64679620!
title

	^ self getTitleText! !
!SpAbstractMorphicAdapter methodsFor: 'initialization' prior: 63996761!
addSettingsTo: aMorph
	
	self widget ifNil: [ ^ self ].
	self applyVisibility! !
!SpAbstractMorphicAdapter methodsFor: 'emulating' prior: 64002327!
keyPressed: keyCode shift: shiftBoolean meta: metaBoolean control: controlBoolean option: optionBoolean
	| evt modifiers |
	
	modifiers := 0.
	shiftBoolean ifTrue: [ modifiers := modifiers | 8 ].
	metaBoolean ifTrue: [ modifiers := modifiers |
		(Smalltalk os isWin32 | Smalltalk os isUnix
			ifTrue: [ 2r00010000 ]
			ifFalse: [ 2r01000000 ]) ].
	controlBoolean ifTrue: [ modifiers := modifiers | 2r00010000 ].
	optionBoolean ifTrue: [ modifiers := modifiers |
		(Smalltalk os isWin32 | Smalltalk os isUnix
			ifTrue: [ 2r01000000 ]
			ifFalse: [ 2r00100000 ]) ].
	
	evt := KeyboardEvent new
		setType: #keystroke
		buttons: modifiers
		position: self widget position + (1 @ 1)
		keyValue: keyCode
		charCode: keyCode
		hand: self currentWorld activeHand
		stamp: Time millisecondClockValue.

	evt sentTo: self widgetEventReceiver.
	"Some time to allow things to happen?"
	10 milliSeconds wait! !
!SpAbstractMorphicAdapter methodsFor: 'protocol' prior: 63995325!
setBalloonText: aString

	self widget ifNotNil: [ :w | 
		w setBalloonText: (
			aString ifNotNil: [ :theString | theString localizedForPresenter: self presenter ] ) ]
	! !
!SpAbstractMorphicAdapter methodsFor: 'emulating'!
widgetEventReceiver
	
	^ widget! !
!SpAbstractMorphicWindowAdapter methodsFor: 'private'!
add: containerMorph toWindow: aSpecWindow

	aSpecWindow 
		addMorph: containerMorph 
		fullFrame: LayoutFrame identity! !
!SpAbstractMorphicWindowAdapter methodsFor: 'private'!
addContent: aMorph toWindow: aSpecWindow
	| containerMorph |
	
	containerMorph := self newContainerMorph.
	containerMorph layoutFrame: aMorph layoutFrame.

	"add all decorations (menu, toolbar and statusbar)"
	self model hasMenu ifTrue: [ self addMenuTo: containerMorph ].
	self model hasToolbar ifTrue: [ self addToolBarTo: containerMorph ].
	containerMorph addMorphBack: aMorph.
	aMorph
		hResizing: #spaceFill;
		vResizing: #spaceFill.
	self model hasStatusBar ifTrue: [ self addStatusBarTo: containerMorph ].
	
	self add: containerMorph toWindow: aSpecWindow! !
!SpAbstractMorphicWindowAdapter methodsFor: 'private'!
addMenuTo: aMorph
	| menuMorph |

	menuMorph := self model menu buildWithSpec.
	aMorph addMorphBack: menuMorph.	
	menuMorph
		hResizing: #spaceFill;
		vResizing: #rigid! !
!SpAbstractMorphicWindowAdapter methodsFor: 'private'!
addStatusBarTo: aMorph
	| statusBarMorph |

	statusBarMorph := self model statusBar buildWithSpec.
	aMorph addMorphBack: statusBarMorph.	
	statusBarMorph
		hResizing: #spaceFill;
		vResizing: #rigid! !
!SpAbstractMorphicWindowAdapter methodsFor: 'private'!
addToolBarTo: aMorph
	| toolbarMorph |

	toolbarMorph := self model toolBar buildWithSpec.
	aMorph addMorphBack: toolbarMorph.	
	toolbarMorph
		hResizing: #spaceFill;
		vResizing: #rigid! !
!SpAbstractMorphicWindowAdapter methodsFor: 'private'!
newContainerMorph
		
	^ PanelMorph new
		layoutPolicy: TableLayout new; 
		hResizing: #spaceFill;
		vResizing: #spaceFill;		
		listDirection: #topToBottom; 
		yourself! !
!SpMorphicWindowAdapter methodsFor: 'spec protocol'!
isTopWindow

	self widgetDo: [ :w | ^ w isTopWindow ].
	^ false! !
!SpMorphicWindowAdapter methodsFor: 'protocol' prior: 64886267!
open

	self model isCentered 
		ifTrue: [ self centered ].
	
	self widget openInWorld.
	self model initialPosition ifNotNil: [
		self widget position: self model initialPosition ].
	
	self windowIsOpening! !
!SpMorphicWindowAdapter methodsFor: 'factory' prior: 64889563!
subscribeToAnnouncements: aWindow

	aWindow announcer 
		when: SpWindowWillClose send: #announce: to: self presenter announcer;
		when: SpWindowResizing send: #announce: to: self presenter announcer! !
!SpMorphicWindowAdapter methodsFor: 'widget API' prior: 64889343!
title: aString

	self widgetDo: [ :w | w setLabel: (aString ifNotNil: [ :theString | theString localizedForPresenter: self presenter]) ]! !
!SpMorphicWorldAdapter methodsFor: 'adding'!
addPresenterIn: widgetToBuild withSpecLayout: aSpec

	self 
		addContent: (self model presenter buildWithSpecLayout: aSpec) 
		toWindow: widgetToBuild! !
!SpMorphicWorldAdapter methodsFor: 'factory'!
buildWidget

	^ self presenter currentWorld
		borderColor: self theme backgroundColor;
		borderWidth: 4;
		yourself! !
!SpMorphicWorldAdapter methodsFor: 'api'!
centered
	"Do nothing. I will fill the full world"! !
!SpMorphicWorldAdapter methodsFor: 'private'!
newContainerMorph
	^ super newContainerMorph 
		adoptPaneColor: self theme backgroundColor;
		yourself! !
!SpMorphicWorldAdapter methodsFor: 'private'!
title: aString
	"Update the host window title"

	DisplayScreen hostWindowTitle: aString! !
!SpMorphicPopoverAdapter class methodsFor: 'accessing'!
defaultHeight

	^ 30! !
!SpMorphicPopoverAdapter class methodsFor: 'accessing'!
defaultItemSeparation
	
	^ 3@0! !
!SpMorphicPopoverAdapter methodsFor: 'factory'!
addModelTo: aMorph

	aMorph contentMorph: self presenterWidget.	
	aMorph beRelativeTo: self presenter relativeTo adapter widget. 	
	self setPopoverPositionTo: aMorph.
	
	self presenter whenPresenterChangedDo: [
		aMorph contentMorph: self presenterWidget ]! !
!SpMorphicPopoverAdapter methodsFor: 'factory'!
buildWidget
	| panelMorph |
	
	panelMorph := SpPopoverMorph new.
	self addModelTo: panelMorph.
	
	^ panelMorph! !
!SpMorphicPopoverAdapter methodsFor: 'api'!
dismiss 

	self widgetDo: [ :w | w popdown ]! !
!SpMorphicPopoverAdapter methodsFor: 'api'!
popup

	self widgetDo: [ :w | w popup ]! !
!SpMorphicPopoverAdapter methodsFor: 'api'!
popupPointingTo: aRectangle

	self widgetDo: [ :w | 
		w popupPointingTo: aRectangle ]! !
!SpMorphicPopoverAdapter methodsFor: 'factory'!
presenterWidget

	^ self presenter presenter buildWithSpec! !
!SpMorphicPopoverAdapter methodsFor: 'factory'!
setPopoverPositionTo: gtkPopover
		
	^ self presenter position applyTo: gtkPopover! !
!SpCodeDebugItCommand methodsFor: 'private'!
compile: aStream for: anObject in: evalContext
	| methodClass |

	methodClass := evalContext
		ifNil: [ anObject class ]
		ifNotNil: [ evalContext methodClass ].

	^ context class compiler
		source: aStream;
		class: methodClass;
		context: evalContext;
		requestor: nil;
		noPattern: true;
		failBlock: [ ^ nil ];
		compile! !
!SpCodeDebugItCommand methodsFor: 'private'!
debug: aStream
	| method doItReceiver doItContext |

	(self context respondsTo: #doItReceiver)
		ifTrue: [ 
			doItReceiver := self context doItReceiver.
			doItContext := self context doItContext ]
		ifFalse: [ 
			doItReceiver := doItContext := nil ].
		
	method := self compile: aStream for: doItReceiver in: doItContext.
	method isReturnSpecial
		ifTrue: [ self inform: 'Nothing to debug, the expression is optimized'.
			^ self ].
	method notNil
		ifTrue: [ self debug: method receiver: doItReceiver in: doItContext ]! !
!SpCodeDebugItCommand methodsFor: 'private'!
debug: aCompiledMethod receiver: anObject in: evalContext
	| guineaPig suspendedContext debugSession |

	guineaPig := [ 
		aCompiledMethod
			valueWithReceiver: anObject
			arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ]) ]
			newProcess.
	suspendedContext := guineaPig suspendedContext.
	
	debugSession := guineaPig newDebugSessionNamed: 'debug it' startedAt: suspendedContext.
	debugSession stepIntoUntil: [ :currentContext | 
		currentContext method == aCompiledMethod ].
	
	Smalltalk tools debugger openOn: debugSession withFullView: true.! !
!SpCodeDebugItCommand methodsFor: 'execution' prior: 64200904!
execute
	| selection |
	
	selection := self selectedTextOrLine.
	selection ifEmpty: [ ^ '' ].
	
	self debug: selection readStream	! !
!MessageBrowser methodsFor: 'private' prior: 51383438!
accept: text notifying: notifyer

	^ self selectedMessage ifNotNil: [ :message | 
		message methodClass 
			compile: text 
			classified: message protocol
			notifying: notifyer ]! !
!MessageBrowser methodsFor: 'initialization' prior: 51393448!
connectPresenters
	messageList
		whenSelectionChangedDo: [ :selection | [ :item | self selectItem: item ] cull: selection selectedItem ];
		whenModelChangedDo: [ self updateTitle ].
	textModel whenSubmitDo: [ :text | (self accept: text notifying: nil) notNil ]! !
!SpScrollSyncExample methodsFor: 'layouts' prior: 65121411!
defaultSpecLayout
	<spec>
	
	^ SpBoxLayout newVertical
		add: #sideRuler;
		add: #text;
		yourself! !

SpMorphicWindowAdapter removeSelector: #newContainerMorph!

SpMorphicWindowAdapter removeSelector: #addToolBarTo:!

SpMorphicWindowAdapter removeSelector: #addStatusBarTo:!

SpMorphicWindowAdapter removeSelector: #addMenuTo:!

SpMorphicWindowAdapter removeSelector: #addContent:toWindow:!

SpMorphicWindowAdapter removeSelector: #add:toWindow:!

SpTreeTableAdapterSingleColumnTest removeSelector: #initializeTestedInstance!

SpMorphicLabelAdapter removeSelector: #emphasisOptions!

SpMorphicLabelAdapter removeSelector: #emphasisCodeFor:!

SpMorphicLabelAdapter removeSelector: #emphasis:!

SpCodeSelectionCommand removeSelector: #selectionOrLine!

SpCodeSelectionCommand removeSelector: #selection!

SpCodeSelectionCommand removeSelector: #selectLine!

SpCodeSelectionCommand removeSelector: #afterSelectionInsertAndSelect:!

SpCodeBrowsingCommand removeSelector: #selector!

SpCodeBrowsingCommand removeSelector: #browserClientProvider!

SpCodeBrowseSendersCommand removeSelector: #execute!

SpCodeBrowseSendersCommand class removeSelector: #defaultShortcutKey!

SpCodeBrowseSendersCommand class removeSelector: #defaultName!

SpCodeBrowseSendersCommand class removeSelector: #defaultIconName!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeBrowseSendersCommand!

SpCodeBrowseReferencesCommand removeSelector: #execute!

SpCodeBrowseReferencesCommand class removeSelector: #defaultName!

SpCodeBrowseReferencesCommand class removeSelector: #defaultIconName!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeBrowseReferencesCommand!

SpCodeBrowseMethodsContainingStringCommand removeSelector: #execute!

SpCodeBrowseMethodsContainingStringCommand class removeSelector: #defaultName!

SpCodeBrowseMethodsContainingStringCommand class removeSelector: #defaultIconName!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeBrowseMethodsContainingStringCommand!

SpCodeBrowseItCommand removeSelector: #findClassOn:!

SpCodeBrowseItCommand removeSelector: #execute!

SpCodeBrowseItCommand removeSelector: #browseClass:!

SpCodeBrowseItCommand class removeSelector: #defaultShortcutKey!

SpCodeBrowseItCommand class removeSelector: #defaultName!

SpCodeBrowseItCommand class removeSelector: #defaultIconName!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeBrowseItCommand!

SpCodeBrowseImplementorsCommand removeSelector: #execute!

SpCodeBrowseImplementorsCommand class removeSelector: #defaultShortcutKey!

SpCodeBrowseImplementorsCommand class removeSelector: #defaultName!

SpCodeBrowseImplementorsCommand class removeSelector: #defaultIconName!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeBrowseImplementorsCommand!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeBrowsingCommand!

SpAbstractTextPresenter removeSelector: #whenTextIsAcceptedDo:!

SpAbstractTextPresenter removeSelector: #whenAutoAcceptChangedDo:!

SpAbstractTextPresenter removeSelector: #textArea!

SpAbstractTextPresenter removeSelector: #setSelection:!

SpAbstractTextPresenter removeSelector: #selection:!

SpAbstractTextPresenter removeSelector: #selection!

SpAbstractTextPresenter removeSelector: #getSelection!

SpAbstractTextPresenter removeSelector: #getMenu!

SpAbstractTextPresenter removeSelector: #defineOutputPorts!

SpAbstractTextPresenter removeSelector: #defineInputPorts!

SpAbstractTextPresenter removeSelector: #autoAccept:!

SpAbstractTextPresenter removeSelector: #autoAccept!

SpAbstractTextPresenter removeSelector: #actionPerformed!

SpAbstractTextPresenter removeSelector: #acceptBlock:!

SpAbstractTextPresenter removeSelector: #acceptBlock!

SpAbstractTextPresenter removeSelector: #accept!

SpLabelledList removeSelector: #displayBlock:!

SpCodeBrowseItCommandTest removeSelector: #testFindClassOn!

SpCodeBrowseItCommandTest removeSelector: #commandClass!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeBrowseItCommandTest!

SpTransmission removeSelector: #to:port:!

SpTransmission removeSelector: #from:port:!

SpSliderInput removeSelector: #autoAccept:!

SpSliderInput removeSelector: #autoAccept!

SpMorphicNumberInputFieldAdapter removeSelector: #accept:!

SpPresenterWithModel removeSelector: #defineInputPorts!

SpMethodBrowser removeSelector: #acceptBlock:!

SpRootsPresenterPort removeSelector: #incomingTransmission:from:!

Smalltalk globals removeClassNamed: #AnObsoleteSpRootsPresenterPort!

SpNotebookPresenter removeSelector: #selectedPageIndex:!

SpNotebookPresenter removeSelector: #selectedPage:!

SpPanedLayout removeSelector: #add:withConstraints:!

SpTreeTablePresenter removeSelector: #defineOutputPorts!

SpTreeTablePresenter removeSelector: #defineInputPorts!

MessageBrowser class removeSelector: #example!

SpCodePresenter removeSelector: #selectionOrLine!

SpCodePresenter removeSelector: #codeCommandGroup!

SpCodePresenter removeSelector: #buildCodeMenu!

SpCodePresenter removeSelector: #buildCodeKeyBindings!

SpLabelPresenter removeSelector: #emphasis:!

SpLabelPresenter removeSelector: #emphasis!

SpLabelPresenter removeSelector: #defineInputPorts!

SpCodeCommand removeSelector: #shortcutKey!

SpCodeCommand removeSelector: #defaultIconName!

SpCodeCommand removeSelector: #asSpecCommand!

SpCodeCommand class removeSelector: #defaultShortcutKey!

SpCodeCommand class removeSelector: #defaultIconName!

Smalltalk globals removeClassNamed: #AnObsoleteSpCodeCommand!

SpLabelledDropList removeSelector: #displayBlock:!

SpDatePresenter removeSelector: #displayBlock:!

SpDatePresenter removeSelector: #displayBlock!

SpListPresenter removeSelector: #displayBlock:!

SpListPresenter removeSelector: #displayBlock!

SpNotebookMorph removeSelector: #newToolbarMorph!

SpSearchableTreeTest removeSelector: #classToTest!

Smalltalk globals removeClassNamed: #AnObsoleteSpSearchableTreeTest!

SpInterpreterTest removeSelector: #testInterpreterCanAccessPresenterVariablesWithoutAccessor!

SpInterpreterTest removeSelector: #testInterpretASpecModelMorphAssociation!

SpInterpreterTest removeSelector: #testDynamicBuild!

SpInterpreterTest removeSelector: #testConvertRandomSymbolOfClassToInstance!

SpInterpreterTest removeSelector: #tearDown!

SpInterpreterTest removeSelector: #setUp!

Smalltalk globals removeClassNamed: #AnObsoleteSpInterpreterTest!

SpButtonPresenter removeSelector: #menu:!

SpButtonPresenter removeSelector: #menu!

SpLabelledSliderInput removeSelector: #autoAccept:!

SpLabelledSliderInput removeSelector: #autoAccept!

SpToolBarToggleButton removeSelector: #setSelection:!

SpToolBarToggleButton removeSelector: #isSelected!

SpToolBarToggleButton removeSelector: #initialize!

SpToolBarToggleButton removeSelector: #execute:!

SpToolBarToggleButton removeSelector: #beUnselected!

SpToolBarToggleButton removeSelector: #beSelected!

SpToolBarToggleButton class removeSelector: #adapterName!

SpToolBarOptionButton removeSelector: #execute:!

SpToolBarOptionButton removeSelector: #buttonGroup:!

SpToolBarOptionButton class removeSelector: #adapterName!

Smalltalk globals removeClassNamed: #AnObsoleteSpToolBarOptionButton!

Smalltalk globals removeClassNamed: #AnObsoleteSpToolBarToggleButton!

SpToolBarButton removeSelector: #label:!

SpToolBarButton removeSelector: #label!

SpToolBarButton removeSelector: #icon:!

SpToolBarButton removeSelector: #icon!

SpToolBarButton removeSelector: #execute!

SpToolBarButton removeSelector: #click!

SpToolBarButton removeSelector: #badge:!

SpToolBarButton removeSelector: #badge!

SpToolBarButton removeSelector: #action:!

SpToolBarButton removeSelector: #action!

SpToolBarButton class removeSelector: #adapterName!

Smalltalk globals removeClassNamed: #AnObsoleteSpToolBarButton!

SpMorphPresenter removeSelector: #defineInputPorts!

SpLabelledTextInput removeSelector: #autoAccept:!

SpLabelledTextInput removeSelector: #acceptOnCR:!

SpLabelledTextInput removeSelector: #acceptBlock:!

SpWorldPresenter removeSelector: #buildWidget!

SpSearchableTree removeSelector: #whenSelectedItemsChanged:!

SpSearchableTree removeSelector: #whenSelectedItemChanged:!

SpSearchableTree removeSelector: #whenRootsChanged:!

SpSearchableTree removeSelector: #whenMenuChanged:!

SpSearchableTree removeSelector: #whenDisplayBlockChanged:!

SpSearchableTree removeSelector: #whenChildrenBlockChanged:!

SpSearchableTree removeSelector: #updateTree!

SpSearchableTree removeSelector: #updateRootFor:!

SpSearchableTree removeSelector: #tree!

SpSearchableTree removeSelector: #selectedItems:!

SpSearchableTree removeSelector: #selectedItems!

SpSearchableTree removeSelector: #selectedItem:!

SpSearchableTree removeSelector: #selectedItem!

SpSearchableTree removeSelector: #secondSelection:!

SpSearchableTree removeSelector: #rowInset:!

SpSearchableTree removeSelector: #roots:!

SpSearchableTree removeSelector: #roots!

SpSearchableTree removeSelector: #rootNodeHolder:!

SpSearchableTree removeSelector: #rootNodeHolder!

SpSearchableTree removeSelector: #resizerWidth:!

SpSearchableTree removeSelector: #resetSelection!

SpSearchableTree removeSelector: #preferedPaneColor:!

SpSearchableTree removeSelector: #multiSelection:!

SpSearchableTree removeSelector: #menu:!

SpSearchableTree removeSelector: #menu!

SpSearchableTree removeSelector: #keyStrokeAction:!

SpSearchableTree removeSelector: #isCheckList:!

SpSearchableTree removeSelector: #inputField!

SpSearchableTree removeSelector: #initializePresenters!

SpSearchableTree removeSelector: #initialize!

SpSearchableTree removeSelector: #iconBlock:!

SpSearchableTree removeSelector: #highlightedItem:!

SpSearchableTree removeSelector: #evenRowColor:!

SpSearchableTree removeSelector: #doubleClick:!

SpSearchableTree removeSelector: #displayBlock:!

SpSearchableTree removeSelector: #displayBlock!

SpSearchableTree removeSelector: #display:!

SpSearchableTree removeSelector: #display!

SpSearchableTree removeSelector: #connectPresenters!

SpSearchableTree removeSelector: #columns:!

SpSearchableTree removeSelector: #columns!

SpSearchableTree removeSelector: #columnInset:!

SpSearchableTree removeSelector: #childrenBlock:!

SpSearchableTree removeSelector: #childrenBlock!

SpSearchableTree removeSelector: #button!

SpSearchableTree removeSelector: #autoMultiSelection:!

SpSearchableTree removeSelector: #autoAccept:!

SpSearchableTree class removeSelector: #searchAtTop!

SpSearchableTree class removeSelector: #searchAtBottom!

SpSearchableTree class removeSelector: #example!

SpSearchableTree class removeSelector: #defaultSpec!

Smalltalk globals removeClassNamed: #AnObsoleteSpSearchableTree!

SpPresenter removeSelector: #whenShortcutsChanged:!

SpScrollableLayout removeSelector: #add:!

SpGridConstraints removeSelector: #verticalAlignment!

SpGridConstraints removeSelector: #vAlign:!

SpGridConstraints removeSelector: #vAlign!

SpGridConstraints removeSelector: #horizontalAlignment!

SpGridConstraints removeSelector: #hAlign:!

SpGridConstraints removeSelector: #hAlign!

SpGridConstraints removeSelector: #beVerticalAlignmentStart!

SpGridConstraints removeSelector: #beVerticalAlignmentEnd!

SpGridConstraints removeSelector: #beVerticalAlignmentCenter!

SpGridConstraints removeSelector: #beHorizontalAlignmentStart!

SpGridConstraints removeSelector: #beHorizontalAlignmentEnd!

SpGridConstraints removeSelector: #beHorizontalAlignmentCenter!

SpAbstractPresenter removeSelector: #transmitPort:do:transform:!

SpAbstractPresenter removeSelector: #transmitPort:do:!

SpAbstractPresenter removeSelector: #outputPorts!

SpAbstractPresenter removeSelector: #outputPortNamed:!

SpAbstractPresenter removeSelector: #outputPortDefault!

SpAbstractPresenter removeSelector: #newTransmission!

SpAbstractPresenter removeSelector: #inputPorts!

SpAbstractPresenter removeSelector: #inputPortNamed:!

SpAbstractPresenter removeSelector: #inputPortDefault!

SpAbstractPresenter removeSelector: #hasPortNamed:!

SpAbstractPresenter removeSelector: #defineOutputPorts!

SpAbstractPresenter removeSelector: #defineInputPorts!

SpDropListPresenter removeSelector: #selectedItem:!

SpDropListPresenter removeSelector: #selectedIndex:!

SpDropListPresenter removeSelector: #displayBlock:!

SpDropListPresenter removeSelector: #displayBlock!

SpDropListPresenter removeSelector: #defineOutputPorts!

SpDropListPresenter removeSelector: #defineInputPorts!

SpLegacyLayout removeSelector: #isSpLayout!

SpLegacyLayout removeSelector: #buildAdapterFor:bindings:!

SpLegacyLayout class removeSelector: #isDeprecated!

SpLegacyArrayLayout removeSelector: #selector!

SpLegacyArrayLayout removeSelector: #asArray!

SpLegacyArrayLayout removeSelector: #array:!

Smalltalk globals removeClassNamed: #AnObsoleteSpLegacyArrayLayout!

SpRowLayout removeSelector: #shiftLastWidgets!

SpRowLayout removeSelector: #setWidgetLayoutWithOffset:at:!

SpRowLayout removeSelector: #setWidgetLayoutWithNoOffset:at:delta:!

SpRowLayout removeSelector: #resetArrayComputation!

SpRowLayout removeSelector: #privateAsArray!

SpRowLayout removeSelector: #manualFractionComputation!

SpRowLayout removeSelector: #countNumberOfProportionals!

SpRowLayout removeSelector: #autoFractionComputation!

SpRowLayout removeSelector: #addSplitter!

SpRowLayout removeSelector: #add:width:!

Smalltalk globals removeClassNamed: #AnObsoleteSpRowLayout!

SpLayout removeSelector: #type:!

SpLayout removeSelector: #type!

SpLayout removeSelector: #splitterWidth!

SpLayout removeSelector: #setTopOffset:for:borderWidth:!

SpLayout removeSelector: #setRightOffset:for:borderWidth:!

SpLayout removeSelector: #setOffsetsFor:top:left:bottom:right:borderWidth:!

SpLayout removeSelector: #setLeftOffset:for:borderWidth:!

SpLayout removeSelector: #setBottomOffset:for:borderWidth:!

SpLayout removeSelector: #send:withArguments:!

SpLayout removeSelector: #send:!

SpLayout removeSelector: #selector:!

SpLayout removeSelector: #selector!

SpLayout removeSelector: #resetArrayComputation!

SpLayout removeSelector: #privateAsArray!

SpLayout removeSelector: #newRow:top:bottom:!

SpLayout removeSelector: #newRow:top:!

SpLayout removeSelector: #newRow:origin:corner:offsetOrigin:offsetCorner:!

SpLayout removeSelector: #newRow:origin:corner:!

SpLayout removeSelector: #newRow:height:!

SpLayout removeSelector: #newRow:bottom:!

SpLayout removeSelector: #newRow:!

SpLayout removeSelector: #newColumn:width:!

SpLayout removeSelector: #newColumn:right:!

SpLayout removeSelector: #newColumn:origin:corner:offsetOrigin:offsetCorner:!

SpLayout removeSelector: #newColumn:origin:corner:!

SpLayout removeSelector: #newColumn:left:right:!

SpLayout removeSelector: #newColumn:left:!

SpLayout removeSelector: #newColumn:!

SpLayout removeSelector: #isExecutable!

SpLayout removeSelector: #initialize!

SpLayout removeSelector: #computeSplittersIn:!

SpLayout removeSelector: #computeNonSplitterWidgetsIn:!

SpLayout removeSelector: #computeLayoutFromTop:bottom:left:right:!

SpLayout removeSelector: #commands:!

SpLayout removeSelector: #commands!

SpLayout removeSelector: #asSpLayout!

SpLayout removeSelector: #asArray!

SpLayout removeSelector: #addVSplitter!

SpLayout removeSelector: #addSpacer!

SpLayout removeSelector: #addHSplitter!

SpLayout removeSelector: #add:withSpec:top:bottom:left:right:!

SpLayout removeSelector: #add:withSpec:top:bottom:!

SpLayout removeSelector: #add:withSpec:top:!

SpLayout removeSelector: #add:withSpec:right:!

SpLayout removeSelector: #add:withSpec:origin:corner:offsetOrigin:offsetCorner:!

SpLayout removeSelector: #add:withSpec:origin:corner:!

SpLayout removeSelector: #add:withSpec:left:right:!

SpLayout removeSelector: #add:withSpec:left:!

SpLayout removeSelector: #add:withSpec:bottom:!

SpLayout removeSelector: #add:withSpec:!

SpLayout removeSelector: #add:top:bottom:left:right:!

SpLayout removeSelector: #add:top:bottom:!

SpLayout removeSelector: #add:top:!

SpLayout removeSelector: #add:right:!

SpLayout removeSelector: #add:origin:corner:offsetOrigin:offsetCorner:!

SpLayout removeSelector: #add:origin:corner:!

SpLayout removeSelector: #add:left:right:!

SpLayout removeSelector: #add:left:!

SpLayout removeSelector: #add:bottom:!

SpLayout removeSelector: #add:!

SpLayout class removeSelector: #windowBorderWidth!

SpLayout class removeSelector: #composed!

SpColumnLayout removeSelector: #shiftLastWidgets!

SpColumnLayout removeSelector: #setWidgetLayoutWithOffset:at:!

SpColumnLayout removeSelector: #setWidgetLayoutWithNoOffset:at:delta:!

SpColumnLayout removeSelector: #resetArrayComputation!

SpColumnLayout removeSelector: #privateAsArray!

SpColumnLayout removeSelector: #manualFractionComputation!

SpColumnLayout removeSelector: #countNumberOfProportionals!

SpColumnLayout removeSelector: #autoFractionComputation!

SpColumnLayout removeSelector: #addSplitter!

SpColumnLayout removeSelector: #add:height:!

Smalltalk globals removeClassNamed: #AnObsoleteSpColumnLayout!

Smalltalk globals removeClassNamed: #AnObsoleteSpLayout!

Smalltalk globals removeClassNamed: #AnObsoleteSpLegacyLayout!

SpInterpreter removeSelector: #subpresenterNamed:!

SpInterpreter removeSelector: #returnInterpretationOf:!

SpInterpreter removeSelector: #retrieveSpecFrom:!

SpInterpreter removeSelector: #presenter:!

SpInterpreter removeSelector: #presenter!

SpInterpreter removeSelector: #performNextSelectorAndIncrementIndex!

SpInterpreter removeSelector: #isPresenterSymbol:!

SpInterpreter removeSelector: #interpretASpec:presenter:!

SpInterpreter removeSelector: #interpretASpec:!

SpInterpreter removeSelector: #getAdaptorWithDefaultSpecOf:!

SpInterpreter removeSelector: #extractArrayToInterpretFrom:!

SpInterpreter removeSelector: #convertSymbolOfClassToInstance:!

SpInterpreter removeSelector: #computeSpecFrom:!

SpInterpreter removeSelector: #bindings!

SpInterpreter removeSelector: #actionToPerformWithSelector:arguments:!

SpInterpreter class removeSelector: #interpretASpec:presenter:!

SpInterpreter class removeSelector: #bindings!

Smalltalk globals removeClassNamed: #AnObsoleteSpInterpreter!

Smalltalk globals removeClassNamed: #AnObsoleteSpGridAlignmentStart!

Smalltalk globals removeClassNamed: #AnObsoleteSpGridAlignmentEnd!

Smalltalk globals removeClassNamed: #AnObsoleteSpGridAlignmentCenter!

SpGridAlignment class removeSelector: #uniqueInstance!

SpGridAlignment class removeSelector: #start!

SpGridAlignment class removeSelector: #new!

SpGridAlignment class removeSelector: #end!

SpGridAlignment class removeSelector: #center!

Smalltalk globals removeClassNamed: #AnObsoleteSpGridAlignment!

SpLayoutSend removeSelector: #topOffset:!

SpLayoutSend removeSelector: #topOffset!

SpLayoutSend removeSelector: #topFraction:!

SpLayoutSend removeSelector: #topFraction!

SpLayoutSend removeSelector: #rightOffset:!

SpLayoutSend removeSelector: #rightOffset!

SpLayoutSend removeSelector: #rightFraction:!

SpLayoutSend removeSelector: #rightFraction!

SpLayoutSend removeSelector: #leftOffset:!

SpLayoutSend removeSelector: #leftOffset!

SpLayoutSend removeSelector: #leftFraction:!

SpLayoutSend removeSelector: #leftFraction!

SpLayoutSend removeSelector: #isSplitter!

SpLayoutSend removeSelector: #bottomOffset:!

SpLayoutSend removeSelector: #bottomOffset!

SpLayoutSend removeSelector: #bottomFraction:!

SpLayoutSend removeSelector: #bottomFraction!

SpLayoutSend removeSelector: #arguments!

SpLayoutSend class removeSelector: #selector:!

SpSplitterVertical removeSelector: #isSplitter!

SpSplitterVertical removeSelector: #initialize!

SpSplitterVertical removeSelector: #commands:!

SpSplitterVertical removeSelector: #commands!

SpSplitterVertical removeSelector: #arguments!

SpSplitterVertical class removeSelector: #commands:!

Smalltalk globals removeClassNamed: #AnObsoleteSpSplitterVertical!

SpSplitterHorizontal removeSelector: #isSplitter!

SpSplitterHorizontal removeSelector: #initialize!

SpSplitterHorizontal removeSelector: #commands:!

SpSplitterHorizontal removeSelector: #commands!

SpSplitterHorizontal removeSelector: #arguments!

SpSplitterHorizontal class removeSelector: #commands:!

Smalltalk globals removeClassNamed: #AnObsoleteSpSplitterHorizontal!

SpLayoutAddWithSpec removeSelector: #subwidgetArguments!

SpLayoutAddWithSpec removeSelector: #subwidget:spec:layoutFrame:!

SpLayoutAddWithSpec removeSelector: #specSelector:!

SpLayoutAddWithSpec removeSelector: #specSelector!

SpLayoutAddWithSpec class removeSelector: #subwidget:spec:layoutFrame:!

Smalltalk globals removeClassNamed: #AnObsoleteSpLayoutAddWithSpec!

SpLayoutAddRow removeSelector: #block:layoutFrame:!

SpLayoutAddRow class removeSelector: #block:layoutFrame:!

Smalltalk globals removeClassNamed: #AnObsoleteSpLayoutAddRow!

SpLayoutAddColumn removeSelector: #block:layoutFrame:!

SpLayoutAddColumn class removeSelector: #block:layoutFrame:!

Smalltalk globals removeClassNamed: #AnObsoleteSpLayoutAddColumn!

SpLayoutAdd removeSelector: #topOffset:!

SpLayoutAdd removeSelector: #topOffset!

SpLayoutAdd removeSelector: #topFraction:!

SpLayoutAdd removeSelector: #topFraction!

SpLayoutAdd removeSelector: #subwidgetArguments!

SpLayoutAdd removeSelector: #subwidget:layoutFrame:!

SpLayoutAdd removeSelector: #subwidget:!

SpLayoutAdd removeSelector: #subwidget!

SpLayoutAdd removeSelector: #rightOffset:!

SpLayoutAdd removeSelector: #rightOffset!

SpLayoutAdd removeSelector: #rightFraction:!

SpLayoutAdd removeSelector: #rightFraction!

SpLayoutAdd removeSelector: #offsets!

SpLayoutAdd removeSelector: #leftOffset:!

SpLayoutAdd removeSelector: #leftOffset!

SpLayoutAdd removeSelector: #leftFraction:!

SpLayoutAdd removeSelector: #leftFraction!

SpLayoutAdd removeSelector: #layoutFrame:!

SpLayoutAdd removeSelector: #layoutFrame!

SpLayoutAdd removeSelector: #initialize!

SpLayoutAdd removeSelector: #generateSpec!

SpLayoutAdd removeSelector: #fractions!

SpLayoutAdd removeSelector: #bottomOffset:!

SpLayoutAdd removeSelector: #bottomOffset!

SpLayoutAdd removeSelector: #bottomFraction:!

SpLayoutAdd removeSelector: #bottomFraction!

SpLayoutAdd removeSelector: #arguments!

SpLayoutAdd class removeSelector: #subwidget:layoutFrame:!

Smalltalk globals removeClassNamed: #AnObsoleteSpLayoutAdd!

Smalltalk globals removeClassNamed: #AnObsoleteSpLayoutSend!

SpAbstractSpecLayoutAction removeSelector: #selector:!

SpAbstractSpecLayoutAction removeSelector: #selector!

SpAbstractSpecLayoutAction removeSelector: #asSpecElements!

SpAbstractSpecLayoutAction removeSelector: #arguments!

SpAbstractSpecLayoutAction class removeSelector: #isDeprecated!

Smalltalk globals removeClassNamed: #AnObsoleteSpAbstractSpecLayoutAction!

SpMorphicTextInputFieldAdapter removeSelector: #acceptOnCR!

SpMorphicTextInputFieldAdapter removeSelector: #accept:!

SpOverlayLayout removeSelector: #add:!

SpAbstractListPresenter removeSelector: #selectedItemsAtIndexes:!

SpAbstractListPresenter removeSelector: #listElementAt:ifAbsent:!

SpAbstractListPresenter removeSelector: #listElementAt:!

SpAbstractListPresenter removeSelector: #defineOutputPorts!

SpAbstractListPresenter removeSelector: #defineInputPorts!

SpMorphicBaseTextAdapter removeSelector: #autoAccept:!

SpMorphicBaseTextAdapter removeSelector: #autoAccept!

SpMorphicBaseTextAdapter removeSelector: #accept!

SpComponentListPresenter removeSelector: #defineOutputPorts!

SpComponentListPresenter removeSelector: #defineInputPorts!

SpTextInputFieldPresenter removeSelector: #whenAcceptOnCRChangedDo:!

SpTextInputFieldPresenter removeSelector: #acceptOnCR:!

SpTextInputFieldPresenter removeSelector: #acceptOnCR!

SpTextInputFieldPresenter removeSelector: #accept:!

Array removeSelector: #asSpLayout!

"Spec2-ObservableSlot"!

"Spec2-Commands"!

"Spec2-Layout"!

"Spec2-Transmission"!

"Spec2-Core"!

"Spec2-Code"!

"Spec2-Code-Tests"!

"Spec2-Adapters-Morphic"!

"Spec2-Code-Morphic"!

"Spec2-Commander2"!

"Spec2-Commander2-Tests"!

"Spec2-Commander2-ContactBook"!

"Spec2-Morphic-Backend-Tests"!

"Spec2-Backend-Tests"!

"Spec2-Tools"!

"Spec2-Morphic"!

"Spec2-Morphic-Tests"!

"Spec2-Examples"!

"Spec2-Tests"!

"Spec2-Tools-Tests"!

"Spec2-Adapters-Morphic-Tests"!
!OSPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
cHeaderExtractorFor: aSharedPool
	"IMPORATNT: first read comment of FFISharedPool #cHeaderExtractorFor:
	Subclass should likely check if platform is 32 or 64 bits and depending on that
	send the correct method (from 'platform' protocol) to FFISharedPool.
	
	Answers an instance of a FFICHeaderExtractor specially created for this platform.
	"
	^ self subclassResponsibility ! !
!MacOSXPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
cHeaderExtractorFor: aSharedPool
	"Read comment of superclass first.
	So far there is none 64 bits VMs"
	^ aSharedPool macOSX32Extractor! !
!UnixPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
cHeaderExtractorFor: aSharedPool
	"Read comment of superclass first.
	So far there is none 64 bits VMs"
	^ aSharedPool unix32Extractor! !
!FFICHeaderExtractor class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
autogeneratedMethodProtocol
	^ 'autogenerated by FFICHeaderExtractor'
! !
!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
autogeneratedMethodName
	"Answers the name/selector of the autogenerated init method. Examples of names are 'initVariablesMacOS32', 'initVariablesunix32', etc "
	^ ('initVariables', (self platformName copyWithout: Character space) , (self wordSize * 8) asString)
		! !
!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
basicGeneralFilename
	"For internal usage only. It answers the base filname from which we then base the C program filename, the binary, the log,  the output, etc"
	^ self sharedPool name , '.', self platformName ! !
!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
binaryFilename
	"Answers the filename for the compiled C program, that is, the binary file. This is typically the argument to the '-o' in gcc and cc."
	^ self basicGeneralFilename , '.o'! !
!FFICHeaderExtractor methodsFor: 'method generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
buildMethodSource
	"This method creates the source of a Smalltalk method that would initialize the class vars of the shared pool with the values obtained from the output file of the C program"
	| sourceStream ouput | 
	sourceStream := String new writeStream.
	ouput := self outputFilename asFileReference readStream contents.
	"The output file of the C program is a literal array that looks like this:
	#(SIGKILL 9 4)
	#(UNDEFINED-SIGLOST 0 0)
	#(SIGPIPE 13 4)
	"
	sourceStream nextPutAll: self autogeneratedMethodName; cr.
	sourceStream nextPutAll: '"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"'; cr.
	sourceStream tab; nextPutAll: '<platformName: '''; nextPutAll: FFISharedPool currentPlatformName; nextPutAll: ''' wordSize: '; nextPutAll: FFISharedPool currentWordSize asString; nextPutAll:'>'; cr.
	ouput linesDo: [ :aLine | 
		| array |
		array := Compiler evaluate: aLine. 
		((array first beginsWith: 'UNDEFINED') and: [ array third = 0 ])
			ifTrue: [ 
				"Undefined constants will be written in the method like this: 
				WHATEVER := nil.""WHATEVER is UNDEFINED for this platform""
				"
				sourceStream tab.
				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size); nextPutAll: ' := nil.'.
				sourceStream nextPutAll: '"'.
				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size).
				sourceStream nextPutAll: ' is UNDEFINED for this platform'.
				sourceStream nextPutAll: '"'.
			]
			ifFalse: [  
				"Defined constants will be written like:
				SIGKILL := 9.
				"
				sourceStream tab; nextPutAll: array first; nextPutAll: ' := '; nextPutAll: array second asString; nextPutAll: '.' ].
		sourceStream cr.
	].
	^ sourceStream contents! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
cFlags
	^ cFlags! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
cFlags: anObject
	cFlags := anObject! !
!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
cProgramFilename
	"Answers the filename for the autogenerated C program."
	^ self basicGeneralFilename , '.c'! !
!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
compileCProgram
	"This method takes care of compiling the autogenerated C program. The following is an example of a compilation command for the shared pool FFITestingSharedPool for MacOSX 32 bits:
	
	cd /Users/mariano/pharo/imagenes; cc -m32 -o 'FFITestingSharedPool.Mac OS.o' 'FFITestingSharedPool.Mac OS.c' > 'FFITestingSharedPool.Mac OS.log' 2>&1 
	
	As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.
	"
	| compileScriptStream | 
	compileScriptStream := String new writeStream.
	compileScriptStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.
	compileScriptStream nextPutAll: self compiler.
	compileScriptStream nextPutAll: ' '.
	compileScriptStream nextPutAll: self cFlags.
	compileScriptStream nextPutAll: ' -o '.
	compileScriptStream nextPutAll: '"', self binaryFilename, '"'.
	compileScriptStream nextPutAll: ' '.
	compileScriptStream nextPutAll: '"', self cProgramFilename, '"'.
	compileScriptStream nextPutAll: ' > '.
	compileScriptStream nextPutAll: '"', self logFilename, '"'.
	compileScriptStream nextPutAll: ' 2>&1 '.
	"Transcript show: 'Compile string: ', compileScriptStream contents; cr."
	self executeOSShellCommand: compileScriptStream contents.
	! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
compiler
	^ compiler! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
compiler: anObject
	compiler := anObject! !
!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
executeOSShellCommand: aCommandString
	"To perform the OS command, this method simply does a system() call via FFI. "
	self flag: #fixIt.
	"This won't work for Windows as it doesn't have system() function."
	self system: aCommandString! !
!FFICHeaderExtractor methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
extractAndStoreHeadersInformation
	"Main API method used by FFISharedPool. It first extracts all the constants values (defined in C header files) and then creates a smalltalk init method which is then compiled/installed in the shared pool"
	self extractHeadersInformation.	
	self storeFromExtracted.
! !
!FFICHeaderExtractor methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
extractHeadersInformation
	"This method takes care of extracting all the constants values of a FFISharedPool from C header files. The way it does this is by first autogenerating a C program that will write down into an output text file, each constant and its value. Then such C program is compiled and run."
	| log |
	[
	self 
		generateCProgram;
		compileCProgram;
		runCProgram.
	] on: Error do: [ :ex | 
		self error: 'Error: ', ex printString. '. You may want to check ', self logFilename
	].
	log := self logFilename asFileReference readStream contents.
	log ifNotEmpty: [ 
		log inspect.
		self inform: 'There was a problem in the autogeneration. You may want to check ', self logFilename
		 ].
	
	
! !
!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
ffiLibraryName 
	^ LibC ! !
!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
generateCProgram
	"This method is the one that finally autogenereates the C program"
	| stream | 
	stream := StandardFileStream forceNewFileNamed: self cProgramFilename "'/Users/mariano/prueba.c'".
	self writeCMainCommentOn: stream.
	self writeCIncludesOn: stream.
	self writeRestOfCFileOn: stream.
	stream flush; close.! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersToInclude
	^ headersToInclude! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersToInclude: anObject
	headersToInclude := anObject! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
includeFiles
	^ includeFiles! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
includeFiles: anObject
	includeFiles := anObject! !
!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
logFilename
	"Answers the log filename in which we redirect stdout and stderr in both, the compilation and execution of the C program"
	^  self basicGeneralFilename, '.log'! !
!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
outputFilename
	"Answers the filename for the output file (that contains all the names and values of the constants) that the C program will write when executed"
	^  self basicGeneralFilename, '.output'! !
!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
perror: aMessage
	"Prints the errno gloabl variable into the stderr together with aMessage string
	and then signal an error"
	self primitivePerror: aMessage.
	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
platformName
	^ platformName! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
platformName: anObject
	platformName := anObject! !
!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
primitivePerror: anErrorString

	^ self ffiCall: #( void perror(String anErrorString) )
! !
!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
primitiveSystem: commandString
	 ^ self ffiCall: #(int system(char* commandString) ) 
		! !
!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
runCProgram
	"This method takes care of executing the autogenerated and compiled C program. The following is an example of a execution command for the shared pool FFITestingSharedPool for MacOSX 32 bits:
	
	cd /Users/mariano/pharo/imagenes; ./'FFITestingSharedPool.Mac OS.o' >> 'FFITestingSharedPool.Mac OS.log' 2>&1 
	
	As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.
	"
	
	| runCStream | 
	runCStream := String new writeStream.
	runCStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.
	runCStream nextPutAll: './', '"', self binaryFilename, '"'.
	runCStream nextPutAll: ' >> '.
	runCStream nextPutAll: '"', self logFilename, '"'.
	runCStream nextPutAll: ' 2>&1 '.
	"Transcript show: 'Execute C program string: ', runCStream contents; cr."
	self executeOSShellCommand: runCStream contents.
	! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
sharedPool
	^ sharedPool! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
sharedPool: anObject
	sharedPool := anObject! !
!FFICHeaderExtractor methodsFor: 'method generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
storeFromExtracted
	"This method first takes the output file generated by the C program and creates a Smalltalk init method that would set the constants values extracted into the shared pool class variables. Then, the created method is stored in the shared pool class."
	| methodSource |
	methodSource := self buildMethodSource.
	self sharedPool class compile: methodSource classified: self class autogeneratedMethodProtocol! !
!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
system: aCommandString
	"Executes aCommandString in the OS via the system() call."
	| returnValue |
	returnValue := self primitiveSystem: aCommandString.
	(returnValue = -1) ifTrue: [ 
		self perror: 'system()'	
	].
	^ returnValue ! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
wordSize
	^ wordSize! !
!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
wordSize: anObject
	wordSize := anObject! !
!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
writeCInclude: aHeaderName on: aStream
	"Internal method for the C program creation. Giving aHeaderName like 'signal.h' this method writes the C #include definition."
	aStream 
		nextPutAll: '#include <';
		nextPutAll: aHeaderName;
		nextPutAll: '>';
		cr.	
! !
!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
writeCIncludes: aListOfHeaderNames on: stream
	"Internal method for the C program creation. It writes each of the user-defined header names (aListOfHeaderNames) as a C #include definition."
	aListOfHeaderNames do: [ :each | self writeCInclude: each on: stream ]
! !
!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
writeCIncludesOn: stream
	"Internal method for the C program creation. It writes C #include definitions for all the header names. It includes the mandatry ones for our C program (such as stdio.h and stdlib.h) and then all the user-defined ones which should define the constants defined as class variables in the shared pool."
	self writeCIncludes: #('stdio.h' 'stdlib.h') on: stream.
	self writeCIncludes: self headersToInclude on: stream.
	stream cr.
	
	
! !
!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
writeCMainCommentOn: stream
	"Internal method for the C program creation. This one just writes a general comment at the beginning."
	stream nextPutAll: ('//
//
//  Program automatically generated on <1s> by FFICHeaderExtractor.
// For more details, see https://github.com/marianopeck/FFICHeaderExtractor
//
//
'	expandMacrosWith: Date today yyyymmdd ).
	stream cr.! !
!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
writeListOfConstantsOn: aStream
	"Internal method for the C program creation. This one iterates each class variable of the shared pool and calls the correct function to write the values into the output file."
	self sharedPool classVarNames withIndexDo: [ :each :index |
		aStream nextPutAll: (('
	#ifdef <1s>
		printDefinedConstant(file, <1s>);
	#else
		printUndefinedConstant(file, <1s>);
	#endif') expandMacrosWith: each); cr
	].
	! !
!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
writeRestOfCFileOn: stream
	"Internal method for the C program creation. This one writes the end of the file, including the main(), the definition of our functions, and the opening of the FILE stream for the output. printDefinedConstant() and printUndefinedConstant() are called for each constant."
	stream cr.
	stream nextPutAll: '#define printDefinedConstant(file, const) fprintf(file, "#(%s %d %ld)\n", #const, const, sizeof(const))
	#define printUndefinedConstant(file, const) fprintf(file, "#(UNDEFINED%s %d %d)\n", #const, 0, 0)

	int main(int argc, const char * argv[]) {

	    FILE *file = fopen("', self outputFilename, '", "w");
	    if (file == NULL)
	    {
	        printf("Error opening file!!\n");
	        exit(1);
	    }
	'.
	self writeListOfConstantsOn: stream. 

	stream nextPutAll: '
	    fclose(file);    
	    return 0;
	}
	'
! !
!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
allAutogeneratedMethodSelectors
	"Answers the list of all the selectors of this class that are init methods autogenerated by FFICHeaderExtractor"
	^ self class allSelectorsInProtocol: FFICHeaderExtractor autogeneratedMethodProtocol.! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
cHeaderExtractor
	"This is a double dispatch with the OSPlatform class. Each platform should be respoonsible of sending the correct message to the shared pool (methods under protocol 'platforms') based on the current platform information (like wether it is 32 or 64 bits), such as unix32Extractor, macOSX32Extractor, etc.
	Answers an instance of a FFICHeaderExtractor specially created for current platform."
	^ Smalltalk os cHeaderExtractorFor: self! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
currentPlatformName
	"Answers the platform name of the current platform"
	^ Smalltalk os platformName! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
currentWordSize
	"Answers the word size of the current platform. This could be either 32 or 64. Right now the way we obtain this is via FFIExternalType"
	^ FFIExternalType sizeOf: #int! !
!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
didPlatformChange
	"Answers whether this shared pool was initialized for the same platform as the current one. In other words, it answers whether the platform has changed."
	^ ((self platformName = self currentPlatformName) and: [ self wordSize = self currentWordSize ]) not ! !
!FFISharedPool class methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
extractAndStoreHeadersInformation
	"Read the comment of FFICHeaderExtractor >> extractAndStoreHeadersInformation"
	self cHeaderExtractor extractAndStoreHeadersInformation.! !
!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
hasAlreadyBeenInitializedBefore
	"Answers whether this shared pool was already initialized before or not"
	^ self platformName notNil and: [ self wordSize notNil ]
 ! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersContainingVariables
	"Answers an array with the `C` header names that define all the defined constants of this SharedPool. Subclasses can override and define their own C headers."
	^ self subclassResponsibility ! !
!FFISharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initialize
	self flag: #removeIt.
	"This IF will be eliminated soon...only here temporary"
	(SystemVersion current highestUpdate >= 50558)
		ifTrue: [ 
			SessionManager default registerToolClassNamed: self name
			 ]
		ifFalse: [ 
			Smalltalk addToStartUpList: self.
 		]
	! !
!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initializeVariables
	"This method does the lookup for an autogenerated init method for this platform. If found, then initialize from it. If not found, then do nothing."
	| selector |
	selector := self lookupInitMethodForCurrentPlatform.
	selector ifNotNil: [ 
		self initializeVariablesFrom: selector.
		self updatePlatformInfo.
	] ! !
!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initializeVariablesFrom: aSelector
	"Initializes the class variables of this shared pool with the autogenerated init method aSelector"
	aSelector ifNotNil: [ self perform: aSelector. ]
	! !
!FFISharedPool class methodsFor: 'DEPRECATED' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initializeVariablesFromStonExtracted
	| stonStream parsedDict |
	stonStream := (Smalltalk os cHeaderExtractorFor: self) outputFilename asFileReference readStream. 
	parsedDict := STON fromStream: stonStream.
	"The STON file looks like this:
	{
        'SIGHUP' : [
                1,
                4
        ],
        'SIGKILL' : [
                9,
                4
        ],
        'SIGTERM' : [
                15,
                4
        ]
}
	"
	parsedDict keysAndValuesDo: [ :key :value |
		self classVarNamed: key put: value first.	
 	]! !
!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initializeVariablesIfNeeded
	"If this shared pool shared pool should be initialized, then let's do it!!"
	self shouldInitializeVariables ifTrue: [ 
		self initializeVariables.
	]
	! !
!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
lookupInitMethodForCurrentPlatform
	"This method searches an autogenerated init method for the current platform. The lookup basically means checking the selectors in a specific protocol and search for the one (if exists) with the pragma matching the #platformName and #wordSize of the current platform. If found, it answers the selector. If not found, it answers nil. "
	| selectors |
	selectors := self allAutogeneratedMethodSelectors. 
	^ selectors detect: [ :each | 
		| method arguments |
		method := self class compiledMethodAt: each. 
		arguments := (method pragmaAt: #platformName:wordSize:) arguments.
		(arguments first = self currentPlatformName) 
			and: [ (arguments second = self currentWordSize) ]
	] ifNone: [ 
		"IMPORTANT: Here we cannot throw an error becasue this method is called from the startup code (from startUp: -> initializeVariablesIfNeeded) and if we throw an error during statup, the image shutsdown and doesn't start anymore."
		Transcript show: 'There is no autogenerated init method for platform name ', self currentPlatformName, ' and word size ', self currentWordSize asString; cr.
		nil ]
! !
!FFISharedPool class methodsFor: 'platforms' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
macOSX32Extractor
	"This is the default setup of a FFICHeaderExtractor for OSX 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."
	^ FFICHeaderExtractor new
		sharedPool: self;
		platformName: 'Mac OS'; "IMPORTANT: Should match with 'Smalltalk os platformName ' "
		wordSize: 4;
		cFlags: '-m32';
		headersToInclude: self headersContainingVariables;
		compiler: 'cc';
		yourself! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
platformName
	^ platformName! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
platformName: aString
	platformName := aString! !
!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
removeAllGeneratedMethods
	"This is a facility method, likely only used for tests. It simply removes all the autogenerated init methods from this shared pool"
	self allAutogeneratedMethodSelectors do: [ :each |
		self class removeSelector: each.	
	]! !
!FFISharedPool class methodsFor: 'resetting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
reset
	"Simply resets the none-constants class vars of this shared pool. Only used for testing right now."
	platformName := nil.
	wordSize := nil.! !
!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
shouldInitializeVariables
	"We should initialize variables if: 1) the platform has changed (for example, if this image was now started in a different OS) or if 2) the class variables where never initialized before."
	^ self hasAlreadyBeenInitializedBefore not or: [ self didPlatformChange ]! !
!FFISharedPool class methodsFor: 'system startup' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
startUp: resuming
	"If 'resuming' is true, it means the image is being started. It's time then to iterate every subclass and initialize the class variables from the autogenerated init methods, for those subclasses that need such an initialization."
	resuming ifTrue: [ 
		self allSubclassesDo: [ :each | each initializeVariablesIfNeeded ]	
	]! !
!FFISharedPool class methodsFor: 'platforms' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
unix32Extractor
	"This is the default setup of a FFICHeaderExtractor for Unix 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."
	^ FFICHeaderExtractor new
		sharedPool: self;
		platformName: 'unix'; "Should match with 'Smalltalk os platformName ' "
		wordSize: 4;
		cFlags: '-m32';
		headersToInclude: self headersContainingVariables;
		compiler: 'gcc';
		yourself! !
!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
updatePlatformInfo
	"Updates this shared pool with the info of the current platform."
	platformName := self currentPlatformName.
	wordSize := self currentWordSize.! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
wordSize
	^ wordSize! !
!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
wordSize: aNumber
	wordSize := aNumber! !

"FFICHeaderExtractor"!
!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testBuildMethodSource
	| extractor methodSource | 
	extractor := self testingSharedPool cHeaderExtractor.
	extractor 
		generateCProgram;
		compileCProgram;
		runCProgram.
	methodSource := extractor buildMethodSource.
	self assert: (methodSource beginsWith: 'initVariables').
	self assert: (methodSource includesSubstring: '<platformName:').
	self assert: (methodSource includesSubstring: 'wordSize:').
	self assert: (methodSource includesSubstring: '"WHATEVER is UNDEFINED for this platform"').
	self assert: (methodSource includesSubstring: 'SIGKILL := 9.').
	self assert: (methodSource includesSubstring: 'EINVAL := 22.').
	self assert: methodSource lines size equals: 8. ! !
!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testCProgramOutput
	| extractor output | 
	extractor := self testingSharedPool cHeaderExtractor.
	extractor outputFilename asFileReference ensureDelete.
	extractor 
		generateCProgram;
		compileCProgram;
		runCProgram.
	output := extractor outputFilename asFileReference readStream contents.
	self assert: (output includesSubstring: '#(UNDEFINEDWHATEVER 0 0)').
	self assert: (output includesSubstring: '#(SIGKILL 9').
	self assert: (output includesSubstring: '#(EINVAL 22').
	self assert: output lines size equals: 5. ! !
!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testCompileCProgram
	| extractor | 
	extractor := self testingSharedPool cHeaderExtractor.
	extractor binaryFilename asFileReference ensureDelete.
	extractor 
		generateCProgram;
		compileCProgram.
	self assert: extractor binaryFilename asFileReference exists.
	self assert: extractor binaryFilename asFileReference size > 100.! !
!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testGenerateCProgram
	| extractor cProgram | 
	extractor := self testingSharedPool cHeaderExtractor.
	extractor generateCProgram.
	cProgram := extractor cProgramFilename asFileReference readStream contents.
	self assert: (cProgram includesSubstring: '#include <signal.h>').
	self assert: (cProgram includesSubstring: '#include <errno.h>').
	self assert: (cProgram includesSubstring: '#ifdef SIGKILL
		printDefinedConstant(file, SIGKILL);
	#else
		printUndefinedConstant(file, SIGKILL);
	#endif

	#ifdef SIGTERM
		printDefinedConstant(file, SIGTERM);
	#else
		printUndefinedConstant(file, SIGTERM);
	#endif

	#ifdef WHATEVER
		printDefinedConstant(file, WHATEVER);
	#else
		printUndefinedConstant(file, WHATEVER);
	#endif')
	
! !
!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testRunCProgram
	| extractor | 
	extractor := self testingSharedPool cHeaderExtractor.
	extractor outputFilename asFileReference ensureDelete.
	extractor 
		generateCProgram;
		compileCProgram;
		runCProgram.
	self assert: extractor outputFilename asFileReference exists.
	self assert: extractor outputFilename asFileReference size > 10.! !
!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testStoreMethod
	| extractor | 
	extractor := self testingSharedPool cHeaderExtractor.
	extractor 
		generateCProgram;
		compileCProgram;
		runCProgram;
		extractAndStoreHeadersInformation.
	
	self assert: (self testingSharedPool class includesSelector: extractor autogeneratedMethodName asSymbol).! !
!FFICHeaderExtractorTest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testingSharedPool
	^ FFITestingSharedPool! !
!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testChangePlatformAndTestingMethods
	self testingSharedPool reset; updatePlatformInfo.
	self deny: self testingSharedPool platformName isNil.
	self deny: self testingSharedPool wordSize isNil.
	self assert: self testingSharedPool hasAlreadyBeenInitializedBefore.
	self testingSharedPool platformName: 'whatever'. 
	self assert: self testingSharedPool shouldInitializeVariables.
	self assert: self testingSharedPool didPlatformChange.
	! !
!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testInitializeVariables
	self testingSharedPool 
		reset;
		extractAndStoreHeadersInformation.
	self assert: self testingSharedPool shouldInitializeVariables.
	self testingSharedPool initializeVariablesIfNeeded. 
	self assert: self testingSharedPool platformName equals: FFISharedPool currentPlatformName.
	self assert: self testingSharedPool wordSize equals: FFISharedPool currentWordSize.
	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 9.
	self assert: (self testingSharedPool classVarNamed: 'EINVAL') equals: 22.
	self assert: (self testingSharedPool classVarNamed: 'WHATEVER') isNil.


	
	! !
!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testInitializeVariablesWithNoMethodFound
	self testingSharedPool reset.
	self testingSharedPool removeAllGeneratedMethods.
	self testingSharedPool classVarNamed: 'SIGKILL' put: 42.
	self assert: self testingSharedPool shouldInitializeVariables.
	self testingSharedPool initializeVariablesIfNeeded.
	self assert: self testingSharedPool platformName isNil.
	self assert: self testingSharedPool wordSize isNil.
	"Class variables are untouched if the initialize does not run"
	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 42.


	
	! !
!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testLookupInitMethodForCurrentPlatform
	self testingSharedPool 
		reset;
		extractAndStoreHeadersInformation.
	self testingSharedPool class compile: 'initVariablesWhatever32
		<platformName: ''Whatever'' wordSize: 4>
	EACCES := 13.
	EINVAL := 22.
	SIGKILL := 9.
	SIGTERM := 15.
	"WHATEVER is UNDEFINED for this platform"
	' classified: 'autogenerated by FFICHeaderExtractor'.
	self assert: self testingSharedPool cHeaderExtractor autogeneratedMethodName asString equals: self testingSharedPool lookupInitMethodForCurrentPlatform asString. 
	! !
!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testRemoveAllGeneratedMethods
	self testingSharedPool 
		reset; 
		extractAndStoreHeadersInformation.
	self assert: self testingSharedPool  allAutogeneratedMethodSelectors size >= 1.	
	self testingSharedPool removeAllGeneratedMethods.
	self assert: self testingSharedPool  allAutogeneratedMethodSelectors isEmpty.	
	! !
!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testResetAndTestingMethods
	self testingSharedPool classVarNamed: 'SIGKILL' put: 9.
	self testingSharedPool reset. 
	"Class variables values are not reset"
	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') isNil not.
	self assert: self testingSharedPool platformName isNil.
	self assert: self testingSharedPool wordSize isNil.
	self deny: self testingSharedPool hasAlreadyBeenInitializedBefore.
	self assert: self testingSharedPool shouldInitializeVariables.! !
!FFISharedPoolTest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
testingSharedPool
	^ FFITestingSharedPool ! !
!FFITestingSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersContainingVariables
	^ #( 'signal.h' 'errno.h' )! !
!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesMacOS32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'Mac OS' wordSize: 4>
	EACCES := 13.
	EINVAL := 22.
	SIGKILL := 9.
	SIGTERM := 15.
	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"
! !
!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesunix32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'unix' wordSize: 4>
	EACCES := 13.
	EINVAL := 22.
	SIGKILL := 9.
	SIGTERM := 15.
	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"
! !

"FFICHeaderExtractor-Tests"!
!LibCErrnoSharedPool commentStamp: 'MarianoMartinezPeck 1/21/2016 12:29' prior: 0!
The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html!
!LibCFcntlSharedPool commentStamp: 'MarianoMartinezPeck 1/23/2016 12:11' prior: 0!
The class variables of this class was manually extracted from: 
http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html!
!LibCWaitSharedPool commentStamp: 'MarianoMartinezPeck 1/21/2016 12:34' prior: 0!
The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_wait.h.html!
!LibCErrnoSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersContainingVariables
	^ #( 'errno.h' )! !
!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesMacOS32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'Mac OS' wordSize: 4>
	E2BIG := 7.
	EACCES := 13.
	EADDRINUSE := 48.
	EADDRNOTAVAIL := 49.
	EAFNOSUPPORT := 47.
	EAGAIN := 35.
	EALREADY := 37.
	EBADF := 9.
	EBADMSG := 94.
	EBUSY := 16.
	ECANCELED := 89.
	ECHILD := 10.
	ECONNABORTED := 53.
	ECONNREFUSED := 61.
	ECONNRESET := 54.
	EDEADLK := 11.
	EDESTADDRREQ := 39.
	EDOM := 33.
	EDQUOT := 69.
	EEXIST := 17.
	EFAULT := 14.
	EFBIG := 27.
	EHOSTUNREACH := 65.
	EIDRM := 90.
	EILSEQ := 92.
	EINPROGRESS := 36.
	EINTR := 4.
	EINVAL := 22.
	EIO := 5.
	EISCONN := 56.
	EISDIR := 21.
	ELOOP := 62.
	EMFILE := 24.
	EMLINK := 31.
	EMSGSIZE := 40.
	EMULTIHOP := 95.
	ENAMETOOLONG := 63.
	ENETDOWN := 50.
	ENETRESET := 52.
	ENETUNREACH := 51.
	ENFILE := 23.
	ENOBUFS := 55.
	ENODATA := 96.
	ENODEV := 19.
	ENOENT := 2.
	ENOEXEC := 8.
	ENOLCK := 77.
	ENOLINK := 97.
	ENOMEM := 12.
	ENOMSG := 91.
	ENOPROTOOPT := 42.
	ENOSPC := 28.
	ENOSR := 98.
	ENOSTR := 99.
	ENOSYS := 78.
	ENOTCONN := 57.
	ENOTDIR := 20.
	ENOTEMPTY := 66.
	ENOTRECOVERABLE := 104.
	ENOTSOCK := 38.
	ENOTSUP := 45.
	ENOTTY := 25.
	ENXIO := 6.
	EOPNOTSUPP := 102.
	EOVERFLOW := 84.
	EOWNERDEAD := 105.
	EPERM := 1.
	EPIPE := 32.
	EPROTO := 100.
	EPROTONOSUPPORT := 43.
	EPROTOTYPE := 41.
	ERANGE := 34.
	EROFS := 30.
	ESPIPE := 29.
	ESRCH := 3.
	ESTALE := 70.
	ETIME := 101.
	ETIMEDOUT := 60.
	ETXTBSY := 26.
	EWOULDBLOCK := 35.
	EXDEV := 18.
! !
!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesunix32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'unix' wordSize: 4>
	E2BIG := 7.
	EACCES := 13.
	EADDRINUSE := 98.
	EADDRNOTAVAIL := 99.
	EAFNOSUPPORT := 97.
	EAGAIN := 11.
	EALREADY := 114.
	EBADF := 9.
	EBADMSG := 74.
	EBUSY := 16.
	ECANCELED := 125.
	ECHILD := 10.
	ECONNABORTED := 103.
	ECONNREFUSED := 111.
	ECONNRESET := 104.
	EDEADLK := 35.
	EDESTADDRREQ := 89.
	EDOM := 33.
	EDQUOT := 122.
	EEXIST := 17.
	EFAULT := 14.
	EFBIG := 27.
	EHOSTUNREACH := 113.
	EIDRM := 43.
	EILSEQ := 84.
	EINPROGRESS := 115.
	EINTR := 4.
	EINVAL := 22.
	EIO := 5.
	EISCONN := 106.
	EISDIR := 21.
	ELOOP := 40.
	EMFILE := 24.
	EMLINK := 31.
	EMSGSIZE := 90.
	EMULTIHOP := 72.
	ENAMETOOLONG := 36.
	ENETDOWN := 100.
	ENETRESET := 102.
	ENETUNREACH := 101.
	ENFILE := 23.
	ENOBUFS := 105.
	ENODATA := 61.
	ENODEV := 19.
	ENOENT := 2.
	ENOEXEC := 8.
	ENOLCK := 37.
	ENOLINK := 67.
	ENOMEM := 12.
	ENOMSG := 42.
	ENOPROTOOPT := 92.
	ENOSPC := 28.
	ENOSR := 63.
	ENOSTR := 60.
	ENOSYS := 38.
	ENOTCONN := 107.
	ENOTDIR := 20.
	ENOTEMPTY := 39.
	ENOTRECOVERABLE := 131.
	ENOTSOCK := 88.
	ENOTSUP := 95.
	ENOTTY := 25.
	ENXIO := 6.
	EOPNOTSUPP := 95.
	EOVERFLOW := 75.
	EOWNERDEAD := 130.
	EPERM := 1.
	EPIPE := 32.
	EPROTO := 71.
	EPROTONOSUPPORT := 93.
	EPROTOTYPE := 91.
	ERANGE := 34.
	EROFS := 30.
	ESPIPE := 29.
	ESRCH := 3.
	ESTALE := 116.
	ETIME := 62.
	ETIMEDOUT := 110.
	ETXTBSY := 26.
	EWOULDBLOCK := 11.
	EXDEV := 18.
! !
!LibCErrnoSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initialize
	self initializeVariables
	! !
!LibCFcntlSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersContainingVariables
	^ #( 'fcntl.h' )! !
!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesMacOS32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'Mac OS' wordSize: 4>
	AT_EACCESS := 16.
	AT_FDCWD := -2.
	AT_SYMLINK_FOLLOW := 64.
	AT_SYMLINK_NOFOLLOW := 32.
	FD_CLOEXEC := 1.
	F_DUPFD := 0.
	F_DUPFD_CLOEXEC := 67.
	F_GETFD := 1.
	F_GETFL := 3.
	F_GETLK := 7.
	F_GETOWN := 5.
	F_RDLCK := 1.
	F_SETFD := 2.
	F_SETFL := 4.
	F_SETLK := 8.
	F_SETLKW := 9.
	F_SETOWN := 6.
	F_UNLCK := 2.
	F_WRLCK := 3.
	O_ACCMODE := 3.
	O_APPEND := 8.
	O_CLOEXEC := 16777216.
	O_CREAT := 512.
	O_DIRECTORY := 1048576.
	O_DSYNC := 4194304.
	O_EXCL := 2048.
	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"
	O_NOCTTY := 131072.
	O_NOFOLLOW := 256.
	O_NONBLOCK := 4.
	O_RDONLY := 0.
	O_RDWR := 2.
	O_RSYNC := nil."O_RSYNC is UNDEFINED for this platform"
	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"
	O_SYNC := 128.
	O_TRUNC := 1024.
	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"
	O_WRONLY := 1.
	POSIX_FADV_DONTNEED := nil."POSIX_FADV_DONTNEED is UNDEFINED for this platform"
	POSIX_FADV_NOREUSE := nil."POSIX_FADV_NOREUSE is UNDEFINED for this platform"
	POSIX_FADV_NORMAL := nil."POSIX_FADV_NORMAL is UNDEFINED for this platform"
	POSIX_FADV_RANDOM := nil."POSIX_FADV_RANDOM is UNDEFINED for this platform"
	POSIX_FADV_SEQUENTIAL := nil."POSIX_FADV_SEQUENTIAL is UNDEFINED for this platform"
	POSIX_FADV_WILLNEED := nil."POSIX_FADV_WILLNEED is UNDEFINED for this platform"
! !
!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesunix32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'unix' wordSize: 4>
	AT_EACCESS := 512.
	AT_FDCWD := -100.
	AT_SYMLINK_FOLLOW := 1024.
	AT_SYMLINK_NOFOLLOW := 256.
	FD_CLOEXEC := 1.
	F_DUPFD := 0.
	F_DUPFD_CLOEXEC := 1030.
	F_GETFD := 1.
	F_GETFL := 3.
	F_GETLK := 5.
	F_GETOWN := 9.
	F_RDLCK := 0.
	F_SETFD := 2.
	F_SETFL := 4.
	F_SETLK := 6.
	F_SETLKW := 7.
	F_SETOWN := 8.
	F_UNLCK := 2.
	F_WRLCK := 1.
	O_ACCMODE := 3.
	O_APPEND := 1024.
	O_CLOEXEC := 524288.
	O_CREAT := 64.
	O_DIRECTORY := 65536.
	O_DSYNC := 4096.
	O_EXCL := 128.
	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"
	O_NOCTTY := 256.
	O_NOFOLLOW := 131072.
	O_NONBLOCK := 2048.
	O_RDONLY := 0.
	O_RDWR := 2.
	O_RSYNC := 1052672.
	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"
	O_SYNC := 1052672.
	O_TRUNC := 512.
	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"
	O_WRONLY := 1.
	POSIX_FADV_DONTNEED := 4.
	POSIX_FADV_NOREUSE := 5.
	POSIX_FADV_NORMAL := 0.
	POSIX_FADV_RANDOM := 1.
	POSIX_FADV_SEQUENTIAL := 2.
	POSIX_FADV_WILLNEED := 3.
! !
!LibCFcntlSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initialize
	self initializeVariables
	! !
!LibCSignalSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersContainingVariables
	^ #( 'signal.h' )! !
!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesMacOS32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'Mac OS' wordSize: 4>
	SIGABRT := 6.
	SIGALRM := 14.
	SIGBUS := 10.
	SIGCHLD := 20.
	SIGCLD := nil."SIGCLD is UNDEFINED for this platform"
	SIGCONT := 19.
	SIGEMT := 7.
	SIGFPE := 8.
	SIGHUP := 1.
	SIGINFO := 29.
	SIGINT := 2.
	SIGIO := 23.
	SIGIOT := 6.
	SIGKILL := 9.
	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"
	SIGPIPE := 13.
	SIGPOLL := nil."SIGPOLL is UNDEFINED for this platform"
	SIGPROF := 27.
	SIGQUIT := 3.
	SIGSEGV := 11.
	SIGSTOP := 17.
	SIGSYS := 12.
	SIGTERM := 15.
	SIGTRAP := 5.
	SIGTSTP := 18.
	SIGTTIN := 21.
	SIGTTOU := 22.
	SIGURG := 16.
	SIGUSR1 := 30.
	SIGUSR2 := 31.
	SIGVTALRM := 26.
	SIGWINCH := 28.
	SIGXCPU := 24.
	SIGXFSZ := 25.
! !
!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesunix32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'unix' wordSize: 4>
	SIGABRT := 6.
	SIGALRM := 14.
	SIGBUS := 7.
	SIGCHLD := 17.
	SIGCLD := 17.
	SIGCONT := 18.
	SIGEMT := nil."SIGEMT is UNDEFINED for this platform"
	SIGFPE := 8.
	SIGHUP := 1.
	SIGINFO := nil."SIGINFO is UNDEFINED for this platform"
	SIGINT := 2.
	SIGIO := 29.
	SIGIOT := 6.
	SIGKILL := 9.
	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"
	SIGPIPE := 13.
	SIGPOLL := 29.
	SIGPROF := 27.
	SIGQUIT := 3.
	SIGSEGV := 11.
	SIGSTOP := 19.
	SIGSYS := 31.
	SIGTERM := 15.
	SIGTRAP := 5.
	SIGTSTP := 20.
	SIGTTIN := 21.
	SIGTTOU := 22.
	SIGURG := 23.
	SIGUSR1 := 10.
	SIGUSR2 := 12.
	SIGVTALRM := 26.
	SIGWINCH := 28.
	SIGXCPU := 24.
	SIGXFSZ := 25.
! !
!LibCSignalSharedPool class methodsFor: 'initialization-release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initialize
	self initializeVariables
	! !
!LibCWaitSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
headersContainingVariables
	^ #( 'sys/wait.h' )! !
!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesMacOS32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'Mac OS' wordSize: 4>
	WCONTINUED := 16.
	WEXITED := 4.
	WNOHANG := 1.
	WNOWAIT := 32.
	WSTOPPED := 8.
	WUNTRACED := 2.
! !
!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initVariablesunix32
"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"
	<platformName: 'unix' wordSize: 4>
	WCONTINUED := 8.
	WEXITED := 4.
	WNOHANG := 1.
	WNOWAIT := 16777216.
	WSTOPPED := 2.
	WUNTRACED := 2.
! !
!LibCWaitSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!
initialize
	self initializeVariables
	! !

"FFICHeaderExtractor-LibC"!
!OSSAttachableFileStream commentStamp: 'MarianoMartinezPeck 1/10/2016 23:31' prior: 0!
OSSAttachableFileStream represents a  stream on an input or output channel provided by the underlying operating system. It behaves like an ordinary file stream, except that it can be attached myself to an input or output stream which has already been opened by the underlying operating system.

The most common use is to represent either the read or write end of a Pipe from the  Operatying System . This way, it provides a Stream API for both, reading and writing. An OSSPipe  contains a 'reader' and a 'writer' which will be two different instances of this class.!
!OSSPipe commentStamp: 'MarianoMartinezPeck 1/10/2016 23:41' prior: 0!
OSSPipe represents a pipe provided by the underlying operating system, such as a Unix pipe. I have a reader stream and a writer stream which behave similarly to a read-only FileStream and a writeable FileStream. These streams are instances of OSSAttachableFileStream which are attached  to the underlying created  pipe (to either read and write end). 

The idea of OSSPipe is to provide an Stream-like API for pipes. The write-related methods will be delagated to the 'writer' (for example, #nextPutAll:) and the read-related methods (like #upToEnd) will be forwarded to the reader.

Thanks to the Stream-API, it almos allows a code user, to either use Pipes or regular files polymorphically.  In fact, OSSUnixSubprocess can either work with regular files or with OSSPipe for dealing with stdin, stdout and stderr. 

OSSPipe uses a single-character buffer to implement #peek without losing data from the external OS pipe.!
!OSSCFile commentStamp: 'MarianoMartinezPeck 1/10/2016 23:35' prior: 0!
OSSCFile is a external object which provides  a way for mapping C-level  FILE*  in our FFI calls. We have FFI calls that either answer or receive FILE*  and in these cases we use OSSCFile for the FFI signature. !
!OSSUnixProcessExitStatus commentStamp: 'MarianoMartinezPeck 1/11/2016 11:50' prior: 0!
A OSSUnixProcessExitStatus represents the exit status of a unix process. This is an integer bit field answered by the wait() system call that contains information about exit status of the process. The meaning of the bit field varies according to the cause of process exit. 

When the OS process of a OSSUnixSubprocess exits and we collect the exit status via (#queryExitStatus which ends up doing the waitpid()), we get this bit integer bit fields. 
OSSUnixSubprocess #exitStatus answers this integer. To interpret it's result better, then we use this class OSSUnixProcessExitStatus (via #exitStatusInterpreter).
 
Ideally, we should take the resulting integer and call the macros WIFSIGNALED, WIFEXITED etc.. but since they are macros, they are not accessible via FFI. Therefore, we do the internal bit shits ourselves.

However, OSSUnixProcessExitStatus decodes the process exit status in a manner compatible with a typical GNU unix implementation. It is not guaranteed to be portable and may produce misleading results on other unix systems.

Following a normal process exit, the status may be decoded to provide a small positive integer value in the range 0 - 255, which is the value that is presented by a unix shell as the exit status of a program. If terminated by a signal, the corresponding value is the signal number of the signal that caused process exit.

!
!OSSUnixSubprocess commentStamp: 'MarianoMartinezPeck 5/30/2016 11:25' prior: 0!
OSSUnixSubprocess is the main interface for spwaning subprocesses in a Unix OS. 

A process consist at minimun of a program/command to be executed (a Unix binary..could be cat , ls, cp,  custom shell scripts, etc etc.  ) and an optional list of arguments that will be passed to that program.

This class also allows you to define streams  (either StandardFileStream or OSSPipe) that will be mapped to the underlying standard streams stdout/stderr/stdin. This way it provides an API for reading and writing from those. In addition, it takes care of opening, closing, cleaning and all the rest of streams operations. 

It also provides code for checking the status or waiting the exit of the OS process. Different strategies are supported (SIGCHLD based or delay polling). See the different methods in the protocol 'running'.' In addition, once the subprocess was started, the subprocess instance is registered in OSSVMProcess which takes care of handling the child death via the childWatcher. 

Some additional features involved env variable settings (environmentAt:put:) for the child, defining a working directory (#workingDirectory: ), facilities for shell commands, etc.

To achieve it's goals, this class relies on OSSUnixSystemAccessor for accessing Unix system calls. 

As for  implementation details to spwan processes this class relies on the posix_spwan() family of functions which we call via FFI. 

The following is ONE example of ONE possible usage. We define and set settings which are actually the default, so they wouldn't make sense..but just for showing the most of the API:

OSSUnixSubprocess new	
	command: 'ls';
	arguments: (Array with: Smalltalk image imagePath);
	defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];
	redirectStdout; "automatic default stream creation...above closure."
	redirectStderrTo: '/tmp/stderrFile.txt' asFileReference writeStream; "custom stream creation"
	createMissingStandardStreams: false; "therefore won't create stdin stream"
	workingDirectory: '/home'; "set working directory for child"
	environmentAt: 'HOME' put: '/tmp/home';
	addAllEnvVariablesFromParentWithoutOverride; "we will inherit then all but $HOME"
	runAndWaitOnExitDo: [ :command :outString :errString |
		self assert: (outString includesSubstring: Smalltalk image imagePath).	
		self assert: command isSuccess.
		self assert: errString isEmpty. 
	]
	 



!
!OSSUnixSystemAccessor commentStamp: 'GuillermoPolito 6/22/2018 14:37' prior: 0!
OSSUnixSystemAccessor provides access to the operating system in which the Pharo VM is currently running.  There is only one instance of this class, holded by 'OSSVMProcess vmProcess'  which depends on it  to provide access to the operating system process which they represent.

This class provides GENERAL funcionallity for managing files, errors, environments variables, waiting calls, etc etc. Ideally, 100% of its functionallity should be implemented via FFI calls. However, we still use some OSProcess primitives which would be a bit complicaated to implement via FFI (mostly because they access macros, or constants, or things related to a the C pre-processor that we do not have at FFI level). 

The functionallity that is NOT GENERAL (like the call to posix_spawn() family of functions), should not be here but in the concrete place such as OSSUnixSubprocess. 

For the parts that are based on FFI calls, we split each call in two sides. The first side is the method that does the FFI call (under a 'XXX - primitives' protocol, for example, #primitiveFileno:). The other side, is wrapper method that calls the primitive internally but also takes care about managing possible errors of it, informing those, etc (for example, #fileno:). Therefore, is very much likely that the "code users" of this class, will be using the latter side (wrappers) of the methods and not the primitive ones.

!!!! Management of dead processes

New processes are created as childs of the current process. The method #waitpidNoHang: is used to query the exit status of processes.
However, since we use the waitpid() function using WNOHANG, it returns a finished process id that is not necessarily the one that is asked for.
Becayse of this, the Accessor contains a map of process exit statuses.
If the asked process is the one returned by waitpid, we return the corresponding exit status, otherwise we store that value in the map for later accesses.!
!OSSVMProcess commentStamp: 'MarianoMartinezPeck 1/11/2016 13:16' prior: 0!
OSSVMProcess represents the operating system process in which this Pharo VM is currently running. OSSVMProcess has a unique instance accessed via #vmProcess and it also uses a unique instance of  OSSUnixSystemAccessor  which provides access to the external operating system.

OSSVMProcess can answer some information about the OS process running the VM, such as running PID, children, etc etc. More can be added later. 

Another important task of this class is to keep track of all the launched children processes (instances of OSSUnixSubprocess). Whenever a process is started it's registered in OSSVMProcess and unregister in certain scenarios (see senders of #unregisterChildProcess:). We keep a  list of all our children, and ocasionally prune all those that have already been exited. 

This class takes care of running what we call the "child watcher" which is basically a way to monitor children status and collect exit code when they finish. This also  guarantees not to let zombies process (a child whose parent did not collected child exit status). Basically, we use a SIGCHLD handler to capture  a child death. For more details, see method #initializeChildWatcher.
 !
!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
fileNamed: fileName
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"

	self shouldNotImplement
! !
!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isAFileNamed: fileName
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"

	self shouldNotImplement
! !
!OSSAttachableFileStream class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
name: aSymbolOrString attachTo: aFileID writable: readWriteFlag 
	"Create a new instance attached to aFileID. For write streams, this represents two
	Smalltalk streams which write to the same OS file or output stream,
	presumably with interleaved output. The purpose of this method is to
	permit a FileStream to be attached to an existing aFileID, such as
	the handle for standard input, standard output, and standard error."

	^ (super basicNew
		name: aSymbolOrString
		attachTo: aFileID
		writable: readWriteFlag) initialize! !
!OSSAttachableFileStream class methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
name: aSymbolOrString attachToCFile: aCFile writable: readWriteFlag 
	"Create a new instance attached to aCFile. For write streams, this represents two
	Smalltalk streams which write to the same OS file or output stream,
	presumably with interleaved output. The purpose of this method is to
	permit a FileStream to be attached to an existing aCFile, such as
	the handle for standard input, standard output, and standard error."

	^ (super basicNew
		name: aSymbolOrString
		attachToCFile: aCFile
		writable: readWriteFlag) initialize! !
!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
newFileNamed: fileName
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"
	
	self shouldNotImplement
! !
!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
oldFileNamed: fileName
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"
	
	self shouldNotImplement
! !
!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
readOnlyFileNamed: fileName
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"
	
	self shouldNotImplement
! !
!OSSAttachableFileStream class methodsFor: 'registry' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
register: anObject
	"An attachable file stream is generally either a second reference to an
	existing file stream, or a reference to a transient object such as a pipe
	endpoint. There is no need to register it for finalization."

	^ anObject! !
!OSSAttachableFileStream class methodsFor: 'registry' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
unregister: anObject
	"An attachable file stream is generally either a second reference to an
	existing file stream, or a reference to a transient object such as a pipe
	endpoint. There is no need to register it for finalization."

	^ anObject! !
!OSSAttachableFileStream methodsFor: 'converting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
asAttachableFileStream

	^ self
! !
!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
autoClose
	"Private. Answer true if the file should be automatically closed when 
	this object is finalized."

	^ autoClose
		ifNil: [autoClose := true]! !
!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
close
	"Close this file."

	| handle |
	(handle := self basicFileID) ifNotNil: [
		self primCloseNoError: handle.
		self unregister.
		fileID := nil
	]
! !
!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
ensureOpen
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"

	self shouldNotImplement
! !
!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
finalize
	"If #autoClose is true, then we try to close the stream upon finalization - GC "
	
	self autoClose
		ifTrue: [[self primCloseNoError: fileID] on: Error do: []]! !
!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
flush
	"Flush the external OS stream (the one in the C library)."
	
	self systemAccessor fflush: self getFilePointerAsCFile! !
!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
keepOpen
	"Do not allow the file to be closed when this object is finalized."

	autoClose := false
! !
!OSSAttachableFileStream methodsFor: 'attaching' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
name: aSymbolOrString attachTo: aFileID writable: readWriteFlag
	"Attach to an existing file handle, assumed to have been previously
	 opened by the underlying operating system.
	"
	
	name := aSymbolOrString.
	fileID := aFileID.
	readWriteFlag ifTrue: [self readWrite] ifFalse: [self readOnly].
	self ascii.
	self register

! !
!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
name: aSymbolOrString attachToCFile: externalFilePointer writable: readWriteFlag
	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.
	We assume a 32 bits machine and here we document the SQFile used by the VM:
	/* squeak file record; see sqFilePrims.c for details */
typedef struct {
  int			 sessionID;	/* ikp: must be first */
  void			*file;
  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */
  char			 writable;
  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */
  char			 lastChar;
  char			 isStdioStream;
} SQFile;
	"
	| fileIDByteArray |
	self flag: #fixIt.
	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes only
	if the fileSize was 64 bits. This is the case of Pharo OSX VM. However, Linux VM has not yet been build
	with 64 buts but 32 bits for fileSize and so, instead of 20 it is 16.
	For more details read thread with subject 'Why StandardFileStream fileID is 16 bytes in Linux while 20 bytes in OSX?'
	"
	fileIDByteArray := ByteArray new: 20. 
	name := aSymbolOrString.
	self setSessionIDTo: fileIDByteArray.
	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.
	The first 4 byets is the session ID. "
	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.
	readWriteFlag 
		ifTrue: [
			self flag: #fixIt.
			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile. 
			In Linux, instead if 17 it should be 13.
			 "
			fileIDByteArray at: 17 put: 1.
			self readWrite] 
		ifFalse: [
			self readOnly].
	fileID := fileIDByteArray.
	self ascii.
	self register
! !
!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
oldname: aSymbolOrString attachTo: externalFilePointer writable: readWriteFlag
	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.
	We assume a 32 bits machine and here we document the SQFile used by the VM:
	/* squeak file record; see sqFilePrims.c for details */
typedef struct {
  int			 sessionID;	/* ikp: must be first */
  void			*file;
  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */
  char			 writable;
  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */
  char			 lastChar;
  char			 isStdioStream;
} SQFile;
	"
	| fileIDByteArray |
	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes. "
	fileIDByteArray := ByteArray new: 20. 
	name := aSymbolOrString.
	self setSessionIDTo: fileIDByteArray.
	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.
	The first 4 byets is the session ID. "
	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.
	readWriteFlag 
		ifTrue: [
			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile.  "
			fileIDByteArray at: 17 put: 1.
			self readWrite] 
		ifFalse: [
			self readOnly].
	fileID := fileIDByteArray.
	self ascii.
	self register
! !
!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
open
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"
	
	self shouldNotImplement
! !
!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
open: fileName forWrite: writeMode
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"
	
	self shouldNotImplement
! !
!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
openReadOnly
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"
	
	self shouldNotImplement
! !
!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
position
	"Return the receiver's current file position. If the stream is not positionable,
	as in the case of a Unix pipe stream, answer 0."

	^ [super position]
		on: Error
		do: [0]
! !
!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
reopen
	"Since this is an attacheable stream it means the underlying stream in the OS
	has already been opened"
	
	self shouldNotImplement
! !
!OSSAttachableFileStream methodsFor: 'non blocking' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
setNonBlocking
	"Make this stream to be none blocking. In Linux it means 
	calling fcntl() to set the file non-blocking (O_NONBLOCK)." 

	self systemAccessor makeFileNoneBocking: fileID! !
!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
setOSFilePointerFromByteArray: externalFilePointer to: aDestByteArray offset: anOffsetNumber
	1 to: 4 do: [ :index | aDestByteArray at: (index + anOffsetNumber) put: (externalFilePointer at: index) ]
	! !
!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
setSessionIDTo: fileIDByteArray
	| currentSession |
	currentSession := OSSVMProcess vmProcess sessionID.
	1 to: currentSession size do: [ :index | fileIDByteArray at: index put: (currentSession at: index) ]! !
!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
upToEnd
	"Answer a subcollection from the current access position through the last element
	of the receiver. This is slower than the method in StandardFileStream, but it
	works with pipes which answer false to #atEnd when no further input is
	currently available, but the pipe is not yet closed."

	| newStream buffer nextBytes |
	buffer := buffer1 species new: 1000.
	newStream := WriteStream on: (buffer1 species new: 100).
	[self atEnd or: [(nextBytes := self nextInto: buffer) isEmpty]]
		whileFalse: [newStream nextPutAll: nextBytes].
	^ newStream contents
! !
!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
atEndOfFile
	"Answer whether the receiver is at its end based on the result of the last read operation. This uses feof() to test the underlying file stream status, and can be used as an alternative to #atEnd, which does not properly report end of file status for an OSPipe.
	
	Answer whether the file represented by #getFilePointerAsCFile is at end of file, as determined by a call to feof(). This is different from StandardFileStream>>primAtEnd: which answers true if the file pointer is at the end of the file, but which does not call feof() to determine that an end of file condition has occurred. The difference is significant	if aSqFileStruct represents a pipe. Another case where the difference is significant is when using StandardFileStream to communicate with a child process since  the SQFile will not automatically be updated if some other process has changed the actual size of the file.
	"

	^ fileID isNil or: [ self systemAccessor feof: self getFilePointerAsCFile ]
! !
!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
basicFileID
	^ fileID! !
!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
getFilePointerAsCFile

	| pointerSize secondFieldStart secondFieldEnd |
	pointerSize := FFIExternalType pointerSize.
	secondFieldStart := pointerSize + 1.
	secondFieldEnd := secondFieldStart + pointerSize - 1.
	^ OSSCFile new 
		setHandle: (ExternalData 
							fromHandle: ((fileID copyFrom: secondFieldStart to: secondFieldEnd) asExternalPointer  ) 
							type: ExternalType void asPointerType);
		yourself
	


! !
!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
ossIsPipe
	^ false! !
!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
systemAccessor
	^ OSSVMProcess vmProcess systemAccessor! !
!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
upToEndOfFile
	"Answer a subcollection from the current access position through the last element of the receiver.  Use #atEndOfFile to determine end of file status with feof(), required for reliable end of file test on OS pipes or in files that could have been written by another (child) process different than the VM process."
	

	| newStream buffer |
	self closed 
		ifTrue: [ self error: 'File already closed' ]
		ifFalse: [  
			buffer := buffer1 species new: 1000.
			newStream := WriteStream on: (buffer1 species new: 100).
			[self atEndOfFile] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].
			^ newStream contents
		]! !
!OSSPipe class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
newWith: fileIDsArray readBlocking: readBlocking
	"fileIDsArray is an array of two elements where the first represents a sqFile struct of the reader of the pipe and the second represents the sqFile of the writer of the pipe. 
	If readBlocking is true, then the pipe will lock the reading waiting until there is data. If false, then the streams will not lock and answer immediatly instead.  
	 "
	^ self basicNew 
			initializeWith: fileIDsArray readBlocking: readBlocking
			yourself

! !
!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
atEnd
	"Answer whether the receiver can access any more objects."

	^ writer closed and: [self peek == nil]
! !
!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
atEndOfFile
	"Answer whether the receiver is at its end based on the result of
	the last read operation. This uses feof() to test the underlying file
	stream status, and can be used as an alternative to #atEnd, which
	does not properly report end of file status for an OSSPipe."

	^ reader atEndOfFile
! !
!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
close
	"Closes both streams"
	
	self closeWriter.
	self closeReader.
! !
!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeReader

	reader ifNotNil: [reader close]
! !
!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeWriter

	writer ifNotNil: [writer close]
! !
!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closed

	^ reader closed! !
!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
contents
	"Answer contents of the pipe, and return the contents to the pipe so it can still be read."

	| string |
	self closed ifTrue:
		[self notify: self printString, ' ', self reader printString, ' closed'.
		^ nil].
	string := self reader upToEnd.
	string isEmpty ifFalse:
		[self writer closed
			ifTrue: [self notify: self printString, ' ', self writer printString,
								' closed, cannot replace contents']
			ifFalse: [self nextPutAll: string]].
	^ string! !
!OSSPipe methodsFor: 'character writing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
cr
	"Append a return character to the receiver."

	self writer cr! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
flush
	^writer flush! !
!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initializeWith: fileIDsArray readBlocking: aBoolean
	super initialize.
	readBlocking := aBoolean.
	self openReadStreamFor: fileIDsArray first withName: 'pipeReader'.
	self openWriteStreamFor: fileIDsArray second withName: 'pipeWriter'.! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
next
	"Answer the next object accessible by the receiver."

	| character |
	nextChar isNil
		ifTrue:
			[^ [reader next]
				on: Error
				do: [nil]]
		ifFalse:
			[character := nextChar.
			nextChar := nil.
			^ character]
! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
next: anInteger 
	"Answer the next anInteger elements of my collection."

	| character stream |
	stream := WriteStream on: String new.
	(1 to: anInteger) do:
		[:index |
		character := self next.
		character isNil
			ifTrue: [^ stream contents]	
			ifFalse: [stream nextPut: character. false]].
	^ stream contents
! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
nextPut: anObject 
	"Insert the argument, anObject, as the next object accessible by the 
	receiver. Answer anObject."

	^ writer nextPut: anObject! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
nextPutAll: aCollection 
	"Append the elements of aCollection to the sequence of objects accessible 
	by the receiver. Answer aCollection."

	^ writer nextPutAll: aCollection! !
!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
openReadStreamFor: aFileID withName: aReadStreamName
	"Creates a read OSSAttachableFileStream for the read end of the pipe. 
	If the readBlock is false, then make the stream to be non blocking. "
	reader := OSSAttachableFileStream name: aReadStreamName attachTo: aFileID writable: false.
	readBlocking ifFalse: [ reader setNonBlocking ].
	^ reader! !
!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
openWriteStreamFor: aFileID withName: aWriteStreamName
	"Creates a write OSSAttachableFileStream for the write end of the pipe.  "
	writer := OSSAttachableFileStream name: aWriteStreamName attachTo: aFileID writable: true.
	^ writer! !
!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
ossIsPipe

	^ true
! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
peek

	^ nextChar isNil
		ifTrue: [reader closed
				ifFalse: [nextChar := reader next]]
		ifFalse: [nextChar]! !
!OSSPipe methodsFor: 'printing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
printOn: aStream
	"The implementation of Stream>>printOn: has bad side effects when used
	for OSPipe. This implementation is copied from Object."

	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: title! !
!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
reader
	"Answer a stream on the read end of the pipe."

	^ reader! !
!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
reader: aReadStream

	reader := aReadStream! !
!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
systemAccessor
	^ OSSVMProcess vmProcess systemAccessor! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
upToEnd
	"Answer the remaining elements in the string."

	| strm s |
	strm := WriteStream on: String new.
	[(s := self next: 2000) isEmpty
		ifTrue: [^ strm contents]
		ifFalse: [strm nextPutAll: s]] repeat
! !
!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
upToEndOfFile
	"Answer the remaining elements in the pipe. Use #atEndOfFile to
	determine end of file status with feof(), required for reliable end of
	file test on OS pipes. Compare #upToEnd, which uses the generic end
	of file test in FilePlugin."

	| stream delay string |
	stream := WriteStream on: String new.
	delay := Delay forMilliseconds: 200.
	[(string := self next: 2000) isEmpty
		ifTrue: [self atEndOfFile
						ifTrue: [^ stream contents]
						ifFalse: [delay wait]]
		ifFalse: [stream nextPutAll: string]] repeat
! !
!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
writer
	"Answer a stream on the write end of the pipe."

	^ writer! !
!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
writer: aWriteStream

	writer := aWriteStream! !
!OSSUnixProcessExitStatus class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
for: integerValue

	^self new for: integerValue
! !
!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
exitStatus
	
	self isExited ifTrue: [^self statusIfExited].
	self isSignaled ifTrue: [^self statusIfSignaled].
	self isStopped ifTrue: [^self statusIfStopped].
	self notify: 'cannot decode exit status ', intValue asString.
	^intValue! !
!OSSUnixProcessExitStatus methodsFor: 'initialize-release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
for: anInteger
	intValue := anInteger! !
!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isExited
	"
	/* Nonzero if STATUS indicates normal termination.  */
	#define __WIFEXITED(status)     (__WTERMSIG(status) == 0)
	"
	^ self statusIfSignaled = 0

! !
!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isSignaled
	"
	/* Nonzero if STATUS indicates termination by a signal.  */
	#define __WIFSIGNALED(status) \
	  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)
	"
	^(((intValue bitAnd: 16r7F) + 1) >> 1) > 0

! !
!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isStopped
	"
	/* Nonzero if STATUS indicates the child is stopped.  */
	#define __WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)
	"
	^(intValue bitAnd: 16rFF) = 16r7F

! !
!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isSuccess
	^ self exitStatus = 0! !
!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
notFinished
	
	^ intValue isNil
! !
!OSSUnixProcessExitStatus methodsFor: 'printing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
printOn: aStream

	self notFinished
		ifTrue: [^ aStream nextPutAll: 'Not finished'].
	self isExited
		ifTrue: [aStream nextPutAll: 'normal termination with status ';
				 nextPutAll: self statusIfExited asString].
	self isSignaled
		ifTrue: [aStream nextPutAll: 'exit due to signal ';
				nextPutAll: self statusIfSignaled asString].
	self isStopped
		ifTrue: [aStream nextPutAll: 'stopped due to signal ';
				nextPutAll: self statusIfStopped].! !
!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
statusIfExited
	"
	/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
	#define __WEXITSTATUS(status)   (((status) & 0xff00) >> 8)
	"
	^(intValue bitAnd: 16rFF00) >> 8! !
!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
statusIfSignaled
	"
	/* If WIFSIGNALED(STATUS), the terminating signal.  */
	#define __WTERMSIG(status)      ((status) & 0x7f)
	"
	^intValue bitAnd: 16r7F! !
!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
statusIfStopped
	"
	/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
	#define __WSTOPSIG(status)      __WEXITSTATUS(status)
	"
	^self statusIfExited! !
!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
statusNotFinished

	^ 'Not finished'! !
!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
value
	^intValue! !
!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
createTempFileToBeUsedAsReadStreamOn: aDirectoryPath
	"Important: for some reason, if we use MultiByteFileStream instances, we have some test failures.
	So for the moment, until we fix or understand this, always use StandardFileStream instances.
	
	This is a simple facility method if the user wants to use regular files rather than pipes.
	In the customization of defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 
	the user may want to use this method to automatically create a temp file on a aDirectoryPath.
	If you want another way of building temp files, then simply do not use this method and
	set the closure you want in defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 
	
	"
	
	^ StandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !
!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
createTempFileToBeUsedAsWriteStreamOn: aDirectoryPath
	"See comment of #createTempFileToBeUsedAsReadStreamOn:."
	^  StandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !
!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
createTempFilename
	"Read comment of createTempFileToBeUsedAsReadStreamOn:.
	
	This answers just ONE WAY of defining a temp filename"
	
	^ self name , '-p', OSSVMProcess vmProcess pid asString, '-', UUID new printString, '.deleteme'
	! !
!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
addAllEnvVariablesFromParentWithoutOverride
	"The user may have done an explicit set of a variable via #environmentAt:put: in which case
	we do not want to override it with the inherit one.
	This method allows to set all but overriden variables inherit from parent. "
	self defaultEnvVariablesDictionary keysAndValuesDo: [ :key :value |
		envVariables at: key ifAbsentPut: value.
	]
	! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
allocatePosixSpawnFilesActionStructure
	"IMPORTANT:  It seems posix_spawn_file_actions_init() sometimes allocates AND initializes, and sometimes only initializes.
	For OSX I found it it also allocates memory, so only allocating for the pointer is enough.
	For Linux it seems we need to allocate the full structure of posix_spawn_file_actions_t.
	Wathing at the implementation of GNU libc (glibc) here: http://osxr.org:8080/glibc/source/posix/spawn.h?v=glibc-2.17 
	I found this struct definition:
	
	typedef struct
	 {
	   int __allocated;
	   int __used;
	   struct __spawn_action *__actions;
	   int __pad[16];
	 } posix_spawn_file_actions_t;
	
	We need a better solution to solve this kind of sizeof(). For the moment, see below how I estimate the size of this struct.  
	For more details see thread 'Help with FFI crash in latest Spur (only in Linux)'
	"
	OSPlatform current isMacOSX ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: self systemAccessor sizeOfPointer. ].
	OSPlatform current isUnix ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: (self systemAccessor sizeOfPointer + (self systemAccessor sizeOfInt * 2) + (16 * self systemAccessor sizeOfInt)). ].! !
!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
argVArguments
	"Answers the whole list of argV including the command as the first argument and a
	null terminated."
	^ OrderedCollection new
		add: command;
		addAll: (arguments ifNil: [#()]);
		add: 0; "shell arguments are '\0' terminated"
		yourself! !
!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
arguments: anObject
	arguments := anObject collect: [ :each | (each encodeWith: encoding) asString ]! !
!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
buildPrimitiveArgVArgument
	"Takes care of allocating and building the array of arguments as expected
	by the posix_spawn() function. 
	Answers the array ready to be used."
	| bufferPointer |
	bufferPointer := ExternalAddress allocate: self argVArguments size * self systemAccessor sizeOfPointer.
	self registerPointer: bufferPointer.
	self collectArgumentPointersInto: bufferPointer.
	 ^ bufferPointer! !
!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
buildPrimitiveEnvArgument
	"Builds the whole env argument as expected by posix_spawn(), taking into account the variables
	defined by the API #environmentAt:put:"
	| envPointer |
	"By default, if none variable was set, we add all the ones existing in parent"
	envVariables isEmpty ifTrue: [ self addAllEnvVariablesFromParentWithoutOverride ].
	"The +1 is because we will have a NULL at the end"
	envPointer := ExternalAddress allocate: (envVariables keys size + 1) * self systemAccessor sizeOfPointer.
	self registerPointer: envPointer.
	self collectEnvVariablesPointersInto: envPointer.
	^ envPointer! !
!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
cleanAndFixCopiedStreams
	"If the stream is a pipe, we must close the end that we do not use at VM level (parent).
	If we are using regular files, we must reopen them otherwise we won't be able to read what the
	child has written "
	stdinStream ifNotNil: [ stdinStream ossIsPipe ifTrue: [ stdinStream closeReader ] ifFalse: [ stdinStream reopen. ] ].
	stdoutStream ifNotNil: [ stdoutStream ossIsPipe ifTrue: [ stdoutStream closeWriter ] ifFalse: [ stdoutStream reopen. ] ].
	stderrStream ifNotNil: [ stderrStream ossIsPipe ifTrue: [ stderrStream closeWriter ] ifFalse: [ stderrStream reopen. ] ].
	 ! !
!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
cleanResources
	"Clear all resources. This step is mandatory and happens immeditaly after the process has 
	started. And this must be called even if there is an error, since we must free pointers,
	close streams, etc etc. "
	self destroyPosixSpawnFileActionsT.
	self cleanAndFixCopiedStreams.
	self freePointers.! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeAllButStandardFileStreams
	"Here I should loop and close all but fd 0 1 2"

	"do a loop with #posixSpawnFileActionsAddClose:"
	
	self flag: #toDo! !
!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeAndCleanStreams
	"This method closes all the streams that have been opened and mapped to standard steams.
	They could be either pipes or regular temp files. In the case of files, we also remove those temp files"
	self closeStreams.
	self deleteTempFilesFromStandardStreams.! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeAndDup2FilesActions
	"First, it initializes the structure for managing the file actions allowed by posix_spwan(). 
	Then defines and sets all actions we want. That is, closing or opening file descriptors,
	or doing a dup2() "
	self initPosixSpawnFileActionsT.
	self closeAllButStandardFileStreams.
	self defineActionsForStandardFileStreams.
	! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeStderrStream
	" Close stderrStream if needed"
	stderrStream ifNotNil: [ stderrStream close ]! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeStdinStream
	" Close stdinStream if needed"
	stdinStream ifNotNil: [ stdinStream close ]! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeStdoutStream
	" Close stdoutStream if needed"
	stdoutStream ifNotNil: [ stdoutStream close ]! !
!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeStreams
	"Closes all the streams that have been opened and mapped to standard steams."
	self closeStdinStream.
	self closeStdoutStream.
	self closeStderrStream.
	! !
!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
collectArgumentPointersInto: aPointer
	"Allocates each string argument with a null terminated char and add them into aPointer"
	
	"#allButLast is because the last is 0."
	self argVArguments allButLast withIndexDo: [ :string :index |
		| pointer | "0 terminated"
		pointer := ExternalAddress allocate: string size + 1.
		self registerPointer: pointer.
		LibC memCopy: string to: pointer size: string size.
		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"
		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value ].

	aPointer platformUnsignedLongAt: ((self argVArguments size - 1) * self systemAccessor sizeOfPointer) + 1 put: 0.! !
!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
collectEnvVariablesPointersInto: aPointer
	"Creates the pair of KEY=VALUE string, allocating the memory and adding a null terminated char to each of the env.
	Each processed pair of KEY=VALUE is added to aPointer. "
	envVariables keys withIndexDo: [ :aKey :index |
		| string pointer | 
		string := aKey trimmed , '=', (envVariables at: aKey) trimmed. 
		"The +1 is because string must be NULL terminated"
		pointer := ExternalAddress allocate: string size + 1.
		self registerPointer: pointer.
		LibC memCopy: string to: pointer size: string size.
		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"
		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value
	].
	"The array of pointers also needs to finish with a NULL"
	aPointer platformUnsignedLongAt: (envVariables keys size * self systemAccessor sizeOfPointer) + 1 put: 0
! !
!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
command: aString
	command := (aString encodeWith: encoding) asString! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
createADefaultReadStream
	"Creates a default read stream, most likely for stdin"
	^ defaultReadStreamCreationBlock value! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
createADefaultWriteStream
	"Creates a default write stream, most likely for stdout or stderr"
	^ defaultWriteStreamCreationBlock value! !
!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
createMissingStandardStreams: aBoolean
	"If we don't create streams for the standard streams of the child process,
	then the child will be used the inherit standard files from the parent. 
	
	If aBoolean is true, then we will automatically create streams for mapping stdout/stderr/stdin.
	Note that we will create streams ONLY for those standard streams that had not already been set by
	another parts of the API (like #redirectStdoutTo:, or #createAndSetStdeoutStream, etc.).
	In addition, the type of streams that we will automatically create is defined by defaultReadStreamCreationBlock
	and defaultWriteStreamCreationBlock. So you can customize that to define the type of stream automatically created. 
	
	"
	createMissingStandardStreams := aBoolean
	! !
!OSSUnixSubprocess methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defaultEncoding 
	^ OSEnvironment current defaultEncoding ! !
!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defaultEnvVariablesDictionary
	"Get all the env vars inherit from the vmProcess as a dictionary"
	^ Smalltalk os environment asDictionary! !
!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defaultReadStreamCreationBlock: aClosure
	"Read the comment of #createMissingStandardStreams:"
	defaultReadStreamCreationBlock := aClosure! !
!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defaultWriteStreamCreationBlock: aClosure
	"Read the comment of createMissingStandardStreams:"
	defaultWriteStreamCreationBlock := aClosure! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defineActionsForReadStream: aReadStream dupTo: aFileDescriptor
	"Sets all needed actions (close() and dup2()) for a aReadStream (stdin) FOR THE CHILD.
	"
	aReadStream ifNotNil: [ 
		aReadStream ossIsPipe 
			ifTrue: [  
				"For pipes, in the child, we close write end (the child will read), 
				then dup2 the reader to stdin, and then close the reader too. "
				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream writer basicFileID).
				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID) newFileDescritpion: aFileDescriptor.
				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID).	
			] 
			ifFalse: [ 
				| fileDesc |
				fileDesc := self getFdFromStream: aReadStream. 
				"For regular files, in the child, we dup2 the reader to stdin, and then close the reader too. "
				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.
				self posixSpawnFileActionsAddClose: fileDesc.
			
			]
	]! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defineActionsForStandardFileStreams
	"Define close() and dup2() actions for standard file streams for the child process"
	self defineActionsForStdin.
	self defineActionsForStdout.
	self defineActionsForStderr.
		! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defineActionsForStderr
	"If needed, automatically create a stream (regular files or pipes) to be used for stderr, and then perform the needed close() and dup2()
	for the mapping in the child"
	self shouldCreateStreamFor: stderrStream ifTrue: [ self redirectStderr ].
	self defineActionsForWriteStream: stderrStream dupTo: 2! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defineActionsForStdin
	"If needed, automatically create a stream (regular files or pipes) to be used for stdin, and then perform the needed close() and dup2()
	for the mapping in the child"
	self shouldCreateStreamFor: stdinStream ifTrue: [ self redirectStdin ].
	self defineActionsForReadStream: stdinStream dupTo: 0! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defineActionsForStdout
	"If needed, automatically create a stream (regular files or pipes) to be used for stdout, and then perform the needed close() and dup2()
	for the mapping in the child"
	self shouldCreateStreamFor: stdoutStream ifTrue: [ self redirectStdout ].
	self defineActionsForWriteStream: stdoutStream dupTo: 1! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
defineActionsForWriteStream: aWriteStream dupTo: aFileDescriptor
	"Sets all needed actions (close() and dup2()) for a aWriteStream (stdout or stderr) FOR THE CHILD
	"
	aWriteStream ifNotNil: [ 
		aWriteStream ossIsPipe 
			ifTrue: [  
				"For pipes, in the child, we close read end (the child will write), 
				then dup2 the writer to stderr or stdout, and then close the writer too. "
				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream reader basicFileID).
				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID) newFileDescritpion: aFileDescriptor.
				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID).	
			] 
			ifFalse: [ 
				| fileDesc |
				fileDesc := self getFdFromStream: aWriteStream. 
				"For regular files, in the child, we dup2 the writer to stdout or stderr, and then close the writer too. "
				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.
				self posixSpawnFileActionsAddClose: fileDesc.
			
			]
	]! !
!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
deleteTempFileOf: aStream
	"Deletes the temp file associated to aStream"
	aStream ifNotNil: [ 
		aStream ossIsPipe ifFalse: [ aStream fullName asFileReference ensureDelete ] 
	]
	

! !
!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
deleteTempFilesFromStandardStreams
	"Delete all temp files that were associated to standard streams."
	self deleteTempFileOf: stdinStream.
	self deleteTempFileOf: stdoutStream.
	self deleteTempFileOf: stderrStream.
	
	

! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
destroyPosixSpawnFileActionsT
	"This is part of the needed API of posix_spawn() family of functions and dismply destroys
	the struct initialized by #initPosixSpawnFileActionsT"
	posixSpawnFileActionsT ifNotNil: [ 
		| returnValue |
		returnValue := self primitivePosixSpawnFileActionsDestroy: posixSpawnFileActionsT. 
		returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_distroy()'. ].	
	].! !
!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
encoding: anEncoder
	"Specify the encoder to use to encode/decode Strings given to/retrieved from the process.
	Default encoding for Unix-like systems is UTF-8".
	" self encoding: #utf8 "
	encoding := anEncoder! !
!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
envVariables
	^ envVariables! !
!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
environmentAt: aVariableName put: aValue
	"This is the expected API to allow users to define custom variables and values."
	(aVariableName isString and: [ aValue isString ])
		ifFalse: [ self error: 'Variable names and values must be strings' ].
	envVariables at: aVariableName put: aValue! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
exitStatus
	"Answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()). "
	^ exitStatus! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
exitStatusInterpreter
	"#exitStatus answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()).
	However, sometimes you want to decode the internal meaning of the integer to get more information about the status. 
	For those purposes, you can use this method and then query the result. 
	For more details, read class comment of OSSUnixProcessExitStatus "
	^ OSSUnixProcessExitStatus for: exitStatus! !
!OSSUnixSubprocess methodsFor: 'private - support primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
ffiLibraryName 
	^ LibC! !
!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
freePointers
	"Frees all registered pointers. This must be called just after process is launched whether it
	was successful or not to avoid memory leaks... Also, all users of FFI #allocate: kind of method
	should either explicitly send #free (inside a ensure:) or register the allocated pointer so that 
	it can be free here."
	self pointers do: [ :pointer | pointer free ].
	pointers := nil! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
getFdFromStream: aStream
	^ self systemAccessor fileno: aStream getFilePointerAsCFile! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initPosixSpawnFileActionsT
	"This is part of the needed API of posix_spawn() family of functions and initializes
	the struct posix_spawn_file_actions_t"
	| returnValue |
	self allocatePosixSpawnFilesActionStructure.
	self registerPointer: posixSpawnFileActionsT.
	returnValue := self primitivePosixSpawnFileActionsInit: posixSpawnFileActionsT. 
	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_init()' ].! !
!OSSUnixSubprocess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initialize
	super initialize.
	envVariables := Dictionary new. 
	createMissingStandardStreams := false.
	"By default, we create a none blocking pipe for writers (stdout and stderr). For reader, we prefer blocking pipes (stdin), otherwise the child will exit quickly. We also allow regular StandardFileStreams instances."
	defaultReadStreamCreationBlock := [self systemAccessor makeBlockingPipe].
	defaultWriteStreamCreationBlock := [self systemAccessor makeNonBlockingPipe].
	retrievedStdout := String new writeStream. 
	retrievedStderr := String new writeStream. 
	terminateOnShutdown := false.
	waitPidCriticalSemaphore := Semaphore forMutualExclusion.
	encoding := self defaultEncoding.
! !
!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
internalRun
	"This is the real method that spwans the subprocess in the OS via the posix_spawn() function. 
	It first must deal with all the file acctions for close() and dup() in the child.
	Then spawns the process and sets the pid. 
	Finally, it registers the process in the OSSVMProcess vmProcess (so that the childWatcher considers this child).
	After this method is sent, we have to be sure to free resources (via #cleanResources)
	"
	
	| pidtPointer returnValue   |
	pidtPointer := ExternalAddress allocate: self systemAccessor sizeOfPointer.
	self registerPointer: pidtPointer.
	self closeAndDup2FilesActions.
	workingDirectory 
		ifNil: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ] 
		ifNotNil: [ 
			"This is a hack in order to support a #workingDirectory: kind of feature. 
			Please read the comment of lockCwdWithValue:during: "
			OSSVMProcess vmProcess
				lockCwdWithValue: workingDirectory
				encoding: encoding 
				during: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ]
		].
	(returnValue > 0) 
		ifTrue: [ self systemAccessor strerror: returnValue message: 'posix_spawn()'. ].
		
	"Pid is of type pid_t, which is mostly 32bits even in 64bit platforms"
	pid := pidtPointer unsignedLongAt: 1.
	OSSVMProcess vmProcess registerChildProcess: self.
	! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isComplete
	"Answers whether the process has been completed or not (to our best knowledge)"
	^ exitStatus notNil! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isRunning
	"Answers whether the process is still running or not (to our best knowledge)"
	^ pid notNil and: [ self isComplete not ]! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isSuccess
	"Answers whether the process has been completed successfuly (to our best knowledge)"
	^ self isComplete and: [ self exitStatusInterpreter exitStatus = 0 ]! !
!OSSUnixSubprocess methodsFor: 'terminating' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
kill
	^ self sigkill! !
!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
loginShellCommand: aShellCommandString
	"This is a simple facility method for the cases when the user wants to use a login shell as the program.
	See comments of shellCommand: for more information."
	self shellCommand: aShellCommandString.
	arguments := Array with: '-l' withAll: arguments.! !
!OSSUnixSubprocess methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
pid

	^ pid! !
!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
pointers
	^ pointers ifNil: [ pointers := Set new ]! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
posixSpawnFileActionsAddClose: aFileDescriptor
	"Add a close() action for aFileDescriptor for the child process"
	| returnValue |
	returnValue := self primitivePosixSpawnFileActionsAddClose: posixSpawnFileActionsT fileDescription: aFileDescriptor.
	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddclose()' ].
	^ returnValue

! !
!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
posixSpawnFileActionsAddDup2: oldFileDescription newFileDescritpion: newFileDescription
	"Add a dup2() action for from oldFileDescription to newFileDescription, for the child process"
	| returnValue |
	returnValue := self primitivePosixSpawnFileActionsAddDup2: posixSpawnFileActionsT oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription.
	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddup2()' ].
	^ returnValue

! !
!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitivePosixSpawn: pidPointer command: commandString fileActions: fileActions attributes: attributes argPointer: argPointer envPointer: envPointer

	 ^ self ffiCall: #( int posix_spawnp (void* pidPointer, String commandString, void* fileActions, void * attributes, void* argPointer, void* envPointer) ) 
				! !
!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitivePosixSpawnFileActionsAddClose: fileActions fileDescription: fileDescriptionNumber
	
	^ self ffiCall: #( int posix_spawn_file_actions_addclose ( void* fileActions, int fileDescriptionNumber) )! !
!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitivePosixSpawnFileActionsAddDup2: fileActions oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription 

	 ^ self ffiCall: #( int posix_spawn_file_actions_adddup2 ( void* fileActions, int oldFileDescription, int newFileDescription ) )! !
!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitivePosixSpawnFileActionsDestroy: aPosixSpawnFileActionsT 
	
	^ self ffiCall: #( int posix_spawn_file_actions_destroy(void*  aPosixSpawnFileActionsT) )
	


! !
!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitivePosixSpawnFileActionsInit: aPosixSpawnFileActionsT 
	
	^ self ffiCall: #( int posix_spawn_file_actions_init(void* aPosixSpawnFileActionsT) )
	
! !
!OSSUnixSubprocess methodsFor: 'printing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
printOn: aStream

	aStream
		nextPutAll: self class name asString;
		nextPut: $(;
		nextPutAll: 'Command: ';
		nextPutAll: command asString;
		nextPutAll: '; Pid: ';
		nextPutAll: pid asString;
		nextPutAll: '; Status: ';
		nextPutAll: self exitStatusInterpreter asString;
		nextPut: $)! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
processHasExitNotification
	"This method is called from the OSSVMProcess when its child watcher detects that this process has
	exited (via the receive of SIGCHLD) and so it notifies to it (via #updateActiveChildrenAndNotifyDead).
	We signal mutexForSigchld so that the #runAndWait can now finish.
	Note that the mutexForSigchld could be nil if the waitForExit API was not used"
	mutexForSigchld ifNotNil: [ mutexForSigchld signal ]! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
queryExitStatus

	^ exitStatus! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
redirectStderr
	"Creates a default stream and set it as stderr. 
	This method can be called directly by the user to note that he wants to map that standard stream,
	or by our own if createMissingStandardStreams is true."
	stderrStream := self createADefaultWriteStream ! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
redirectStderrTo: aStream
	stderrStream := aStream! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
redirectStdin
	"Creates a default stream and set it as stdin. 
	This method can be called directly by the user to note that he wants to map that standard stream,
	or by our own if createMissingStandardStreams is true."
	
	stdinStream := self createADefaultReadStream ! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
redirectStdinTo: aStream
	stdinStream := aStream! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
redirectStdout
	"Creates a default stream and set it as stdout. 
	This method can be called directly by the user to note that he wants to map that standard stream,
	or by our own if createMissingStandardStreams is true."
	
	stdoutStream := self createADefaultWriteStream ! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
redirectStdoutTo: aStream
	stdoutStream := aStream! !
!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
registerPointer: aPointer
	"Register a pointer so that it is free automatically in #freePointers"
	self pointers add: aPointer! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
retrieveWhatIsAvailableOn: aStream andAddItTo: accumulatingStream
	"This is an internal method which should only be used IF the user will NOT
	retrieve contents himself from streams while the process is still running.
	The usecase of this method is #runAndWaitOnExitDo: and #waitForExitPollingEvery:retrievingStreams:
	in which we are sure the user will not be reading from the streams. 
	What this method does is to simply get what is available in aStream and write it in  accumulatingStream, which is 
	the one we are using for appending contents (so that it is available all togther when the process has exited)
	This is important because for example, for pipes, you cannot read something twice as you consume what you read. 
	
	 "
	aStream 
		ifNotNil: [ :str | 
			accumulatingStream nextPutAll: str upToEnd 
		].! !
!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
run
	"Main method for spwaning the process. It starts the subprocess, it cleans the needed resources for that, and answers,
	it does not wait for child. There are others high end API for running the process,
	but they will all end up sending this message for starting the subprocess."
	[ self internalRun ] ensure: [ 
		self cleanResources.
	]! !
!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
runAndWait
	"IMPORTANT: read first the comment of #waitForExit.
	
	This methods runs the subprocess AND waits until the child has exited. 
	"
	self run.
	self waitForExit.
	! !
!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
runAndWaitOnExitDo: anExitClosure
	"This is a high end API for #runAndWait. IMPORTANT: read the comment in #runAndWait to know when to use this API.
	The facility this method adds over #runAndWait is that when the process has finished it:
	1) Retrieves all contents from stdout and stderr (if they were defined)
	2) It automatically closes the streams mapped to stdout/stderr (if defined)
	3) It allows you to plug anExitClosure which will be evaluated with this subprocess and the contents of stdout and stderr. 
	
	With this method, the user does not need to do anything else. 
	"
	self run.
	self waitForExit.
	self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.
	self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.
	self closeAndCleanStreams.
	anExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.
	! !
!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
runAndWaitPollingEvery: aDelay doing: aClosure onExitDo: onExitClosure
	"IMPORTANT: first read the comment of #waitForExitPollingEvery:doing:
	
	This method runs the subprocess, then waits for it doing an image-based delay polling. 
	It does not automatically retrieve from streams nor closes them on exit. 
	The user must explicitly read from streams in aClosure otherwise it might 
	have the problem mentioned in the comment of #waitForExit.
	The user must also close streams at some point. Either inside the #onExitClosure
	or later, but should be done. 
		 
	"
	self run.
	self waitForExitPollingEvery: aDelay doing: aClosure.
	onExitClosure cull: self cull: stdoutStream cull: stderrStream.
	! !
!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
runAndWaitPollingEvery: aDelay retrievingStreams: retrieveStreams onExitDo: onExitClosure
	"IMPORTANT: first read the comment of #waitForExitPollingEvery:retrievingStreams:
	
	This method runs the subprocess, then waits for it doing an image-based delay polling. 
	If retrieveStreams is true, then as part of the polling loop, it also reads from the streams and
	appends the intemediate results in retrievedStdout / retrievedStderr. 
	Once the process has finished we evaluate onExitClosure.
	If retrieveStreams was true, before evaluating onExitClosure, we automatically close streams
	so that there is nothing else to be done for the user, and we also pass as arguments the
	retrievedStdout / retrievedStderr  to the closure.
	
	With this method, the user does not need to do anything else. 
	 
	"
	self run.
	self waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams.
	retrieveStreams 
		ifTrue: [ 
			self closeAndCleanStreams.
			onExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.
		]
		ifFalse: [ 
			onExitClosure cull: self.
		]
	
	! !
!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
setExitStatus: aStatus
	"This method set's the current process exit status.
	If exitStatus was already set it will fail.
	
	This method is synchronized to avoid race conditions on the access to the exit status"
	waitPidCriticalSemaphore critical: [
		exitStatus ifNotNil: [ self error: 'Modification not allowed' ].
		exitStatus := aStatus
	]
		! !
!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
shell: aShellPath command: aShellCommandString
	"Please read comment of #shellCommand:.
	This is the same as shellCommand: but with the addition that the use can define which shell to be used via 'aBasePath' "
	command := aShellPath.
	arguments := Array with: '-c' with: (aShellCommandString encodeWith: encoding) asString. ! !
!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
shellCommand
	"We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 
	If not found, then we fallback to /bin/sh"
	^ Smalltalk platform environment at: 'SHELL' ifAbsent: ['/bin/sh']! !
!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
shellCommand: aShellCommandString
	"This is a simple facility method for the cases when the user wants to use shell as the program.
	This way, the user can directly send shellCommand: 'ls -la | grep Pharo > /tmp/test.txt ' with the whole string 
	rather than having to do set the command sh, send the '-c' argument, etc etc etc.
	We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 
	If not found, then we fallback to /bin/sh"
	
	self shell: self shellCommand command: aShellCommandString. ! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
shouldCreateStreamFor: aStream ifTrue: aBlock
	"Internal method. 
	If aStream was not specified explicitly by the user, but createMissingStandardStreams is true,
	then it evaluates aBlock"
	(aStream isNil and: [ createMissingStandardStreams ]) 
		ifTrue: [ aBlock value ]! !
!OSSUnixSubprocess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
shutDown: quitting
	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:
	This method is called if this process is still running at the time a 'Quit image' is happening 
	in Pharo. If terminateOnShutdown is true, then we simply terminate the process via sigterm
	and collect it exit status.
	If it false, then we simply stop waiting for it, and allow to finish at OS level
	(althought it may become orphan process as the parent will be die).
	"
	quitting ifTrue: [ 
		terminateOnShutdown 
			ifTrue: [ 
				self terminate.
				"To avoid problems..let's wait until we have the	exit status"
				self waitForExitPolling.
			]
			ifFalse: [ self stopWaiting ]
	] ! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigabrt
	"Send a SIGABRT signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGABRT! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigalrm
	"Send a SIGALRM signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGALRM! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigchld
	"Send a SIGCHLD signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGCHLD! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigcont
	"Send a SIGCONT signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGCONT! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sighup
	"Send a SIGHUP signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGHUP! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigint
	"Send a SIGINT signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGINT! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigkill
	"Send a SIGKILL signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGKILL! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigpipe
	"Send a SIGPIPE signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGPIPE! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigquit
	"Send a SIGQUIT signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGQUIT! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigstop
	"Send a SIGSTOP signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGSTOP! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigterm
	"Send a SIGTERM signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGTERM! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigusr1
	"Send a SIGUSR1 signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGUSR1! !
!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigusr2
	"Send a SIGUSR2 signal to the external process represented by self"

	^ self systemAccessor kill: self pid signal: SIGUSR2! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
stderrStream
	^ stderrStream! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
stdinStream
	^ stdinStream! !
!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
stdoutStream
	^ stdoutStream! !
!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
stopWaiting
	"This will work only for the High Methods API that rely in the waiting provided by the framework. If the user
	user custom waiting, this won't work.
	The wait inside this framework could be done either from #waitForExit with mutexForSigchld or via  #waitForExitPollingEvery:doing:
	with the delay polling"
	mutexForSigchld ifNotNil: [ mutexForSigchld signal ].
	(shouldContinueWaiting = true) ifTrue: [ shouldContinueWaiting := false. ] 
	! !
!OSSUnixSubprocess methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
systemAccessor 

	^ OSSVMProcess vmProcess systemAccessor! !
!OSSUnixSubprocess methodsFor: 'terminating' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
terminate
	^ self sigterm! !
!OSSUnixSubprocess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
terminateOnShutdown
	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:
	If terminateOnShutdown is true, then the external process will be terminated if it was still
	running at the time a system quit image is happening.
	If false, then we will simply stop waiting for it and allow it to finish (thought it will likely become a orphan).
	"
	terminateOnShutdown := true! !
!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
waitForExit
	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 
	that died and will send #processHasExitNotification to such a child. 
	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence
	make the #waitForExit to proceed.  
	
	IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 
	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in
	general with waiting for an external process to exit before reading its output. If the external process 
	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until
	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 
	we never read the output (because the external process did not exit) and the external process never exits 
	(because we have not read the data from the pipe).
	
	
	Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 
	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."

	exitStatus ifNotNil: [ ^ exitStatus ].

	mutexForSigchld := Semaphore new.
	mutexForSigchld wait. 
	^ exitStatus  ! !
!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
waitForExitPolling
	"Read the comment of waitForExitPollingEvery:retrievingStreams:"
	^ self waitForExitPollingEvery: (Delay forMilliseconds: 50)! !
!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
waitForExitPollingEvery: aDelay 
	"Read the comment of waitForExitPollingEvery:retrievingStreams:"
	^ self waitForExitPollingEvery: aDelay retrievingStreams: true! !
!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
waitForExitPollingEvery: aDelay doing: aClosure
	" IMPORTANT: read first the comment of #waitForExit. 
	
	This method does NOT use #runAndWait nor #waitForExit. Instead, it does an image-based polling to check status of child process. 
	Note that the loop does send #queryExitStatus which is the method that indeeds does the waitpid() to check it.
	This is not strictly necessary because the childWatcher of the OSSVMProcess
	takes care of capturing SIGCHDL and update exitStatus. 
	However, as a more reliable solution, we can also check exit status here in case there are missed SIGCHLD or whatever.
	
	As part of the loop, besides checking the exit status (#queryExitStatus) it also evaluates aClosure
	
	"
	shouldContinueWaiting := true.
	[
		"If the #shutDown: (shouldContinueWaiting was set to false) happened while this process was in the #wait 
		 then we simply check 'shouldContinueWaiting' here before doing the #queryExitStatus"
		shouldContinueWaiting 
			ifTrue: [ self queryExitStatus ]
			ifFalse: [ ^ nil ].
		"nil answer means the child has not yet finished" 
		(exitStatus isNil and: [ shouldContinueWaiting ])
	]
	whileTrue: [ 
		aDelay wait.
		aClosure cull: self cull: stdoutStream cull: stderrStream.
	].
	"We might have more contents in the streams that could have been written since the last 'aClosure value' and the moment #queryExitStatus answers non nil.
	So just in case we execute aClosure one more time"
	shouldContinueWaiting 
		ifTrue: [ aClosure cull: self cull: stdoutStream cull: stderrStream. ].
	^ exitStatus  ! !
!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams
	" IMPORTANT: read first the comment of #waitForExit. 
	Second, read the comment of #waitForExitPollingEvery:doing:
	
	If retrieveStreams is true, we read from stdout/stderr as part of the loop and
	append the answers in retrievedStdout / retrievedStderr.
	And this solves the deadlock mentioned in #waitForExit.
	
	This method (with retrieveStreams in true) should be used when mapping stdout / stderr with pipes
	and the command to be executed may write a lot to it. Does not make much sense to be used with regular files. 
	
	Answers the exit status of the child."
	^ self 
		waitForExitPollingEvery: aDelay
		doing: [ 
			retrieveStreams ifTrue: [ 
				self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.
				self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.
			]
		] 
	! !
!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
waitForExitWithTimeout: aDuration
	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 
	that died and will send #processHasExitNotification to such a child. 
	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence
	make the #waitForExit to proceed.  
	
	IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 
	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in
	general with waiting for an external process to exit before reading its output. If the external process 
	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until
	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 
	we never read the output (because the external process did not exit) and the external process never exits 
	(because we have not read the data from the pipe).
	
	
	Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 
	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."

	| expired |
	exitStatus ifNotNil: [ ^ exitStatus ].

	mutexForSigchld := Semaphore new.
	expired := mutexForSigchld waitTimeoutMSecs: aDuration asMilliSeconds.
	expired ifTrue: [ OSSTimeout signal: 'Process not finished after ', aDuration asString ].
	^ exitStatus  ! !
!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
workingDirectory: aString
	"This is a setting that allows defining a working directory for the OS process once started."
	"Working directory is not encoded when set because it is used as FileReference at some places.
	Instead, we encode it in #lockCwdWithValue:encoding:during:"
	workingDirectory := aString! !
!OSSUnixSystemAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
forVMProcess
	^ VMProcessSystemAcessor ifNil: [ VMProcessSystemAcessor := self basicNew initialize ]
! !
!OSSUnixSystemAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
new

	self error: 'You cannot create instances of OSSUnixSystemAccessor. You can only access the correct instance via OSSVMProcess >> systemAccessor '.
! !
!OSSUnixSystemAccessor methodsFor: 'cwd' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
chdir: aDirString
	"Changes the current working directory of the vmProcess to aDirString"
	| returnValue | 
	returnValue := self primitiveChdir: aDirString.
	(returnValue = -1) ifTrue: [ self perror: 'chdir()' ].
	(returnValue = 0) ifFalse: [ self error: 'Unexpected return value from chdir() ', returnValue printString ].
	! !
!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
closeFileDescriptor: aFileDescription
	"It closes the stream associated to aFileDescriptor"
	| returnValue |
	returnValue := self primitiveClose: aFileDescription.
	(returnValue = -1) ifTrue:  [ self perror: 'close()' ].
	^ returnValue
! !
!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
feof: aCFile
	"Answers whether a FILE* is at the end of the file or not. This is trustful for pipes too"
	| result |
	result := self primitiveFeof: aCFile.
	^ result ~= 0
	
! !
!OSSUnixSystemAccessor methodsFor: 'private - support primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
ffiLibraryName 
	^ LibC ! !
!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
fflush: aCFile
	"Flushes the file associated to the FILE* represented by aCFile"
	| returnValue |
	aCFile ifNil: [ self error: 'We disallow the fflush() of nil files since it will flush all open output streams' ].
	returnValue := self primitiveFflush: aCFile.
	(returnValue = 0) ifFalse: [ self perror: 'fflush()' ].
	! !
!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
fileDescriptorOpen: aFileDescription mode: aMode
	| cFile |
	cFile := self primitiveFdopen: aFileDescription mode: aMode.
	cFile isNull ifTrue: [ self perror: 'fdopen()' ].
	^ cFile
! !
!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
fileno: aCFile
	"Answers the file descriptor associated to the FILE* represented by aCFile"
	| returnValue |
	returnValue := self primitiveFileno: aCFile.
	(returnValue = -1) ifTrue: [ self perror: 'fileno()' ].
	^ returnValue "file descriptor"! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
forwardSigChld
	"Set a signal handler for SIGCHLD. Answer a new Semaphore, or nil if unable
	to set the handler (possibly because it has already been set)."

	^ self forwardSignal: self primSigChldNumber
! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
forwardSignal: signalNumber 
	"Set a signal handler in the VM which will signal a Smalltalk semaphore 
	at semaphoreIndex whenever an external signal signalNumber is received.
	Answer a new Semaphore, or nil if unable to set the handler (possibly
	because it has already been set). A Smalltalk process can wait on the
	Semaphore, and take action when a signal is detected. See man(7) signal
	for signal number definitions on your unix system."
	
	| sema index |
	sema := Semaphore new.
	index := Smalltalk registerExternalObject: sema.
	(self primForwardSignal: signalNumber toSemaphore: index)
		ifNil:
			[Smalltalk unregisterExternalObject: sema.
			^ nil].
	^ sema! !
!OSSUnixSystemAccessor methodsFor: 'general' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
getPid
	"Answers the PID of the vmProcess"
	^ self primitiveGetpid! !
!OSSUnixSystemAccessor methodsFor: 'cwd' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
getcwd 
	"Returns the current working directory of the vmProcess"
	| buffer bytesRead |
	"Ideally, we should use a smaller buffer and then if the answer is NULL 
	and errno is ERANGE then try again with a larget buffer. But...since we cannot
	have access to errno.... we simply create a very large buffer that we trust that
	any path fill fit in it..."
	buffer := ExternalAddress allocate: 4096 + 1.
	[
	bytesRead := self primitiveGetcwd: buffer size: 4096 + 1.
	bytesRead ifNil: [ self perror: 'getcwd()'].
	] ensure: [ buffer free ].
	^ bytesRead
		! !
!OSSUnixSystemAccessor methodsFor: 'initialization' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initialize

	super initialize.
	finishedChildProcesses := Dictionary new! !
!OSSUnixSystemAccessor methodsFor: 'signals' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
kill: aPid signal: aSignal
	"Sends aSignal to aPid"
	| answer | 
	answer := self primitiveKill: aPid signal: aSignal.
	(answer = -1) ifTrue: [ 
		self perror: 'kill()'.
	].
	(answer = 0) 
		ifTrue: [ ^ answer ]
		ifFalse: [ self error: 'Unkown answer for kill()' ]! !
!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
makeBlockingPipe
	" Create a pipes with blocking reads"
	^ self makePipeWithReadBlocking: true! !
!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
makeFileNoneBocking: aFileId
	"Make this stream to be none blocking. In Linux it means 
	calling fcntl() to set the file non-blocking (O_NONBLOCK)."
	self primSQFileSetNonBlocking: aFileId
! !
!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
makeNonBlockingPipe
	"Creates a pipe with non blocking read"
	^ self makePipeWithReadBlocking: false! !
!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
makePipeWithReadBlocking: aBoolean
	"Originally, we created the pipes ourselves and the answer was an array of file descriptors.
	This was complicated because we have to then create our own sqFile structure and deal
	with with offsets and their sizeof(). 
	
	So now we use OSProcess primitive primCreatePipe which directly answers an array of sqFile structs
	specifially created for them. This way we avoid all the sqFile creation and management at image side. 	
	"

" ==================== OLD CODe =======================
	| pipePointer returnValue fileDescriptors |
	pipePointer := ExternalAddress allocate: 8.
	[
		returnValue := self primitivePipe: pipePointer.	
		(returnValue = -1) ifTrue: [ self perror: 'pipe()' ]. 
		fileDescriptors := Array new: 2.
		fileDescriptors at: 1 put: (pipePointer nbUInt32AtOffset: 0).
		fileDescriptors at: 2 put: (pipePointer nbUInt32AtOffset: 4).
		^ OSSPipe newWith: fileDescriptors readBlocking: aBoolean. 
	] ensure:[
		pipePointer free.
	]
 ==================== OLD CODe =======================
"

	| fileIDsArray |
	fileIDsArray := self primCreatePipe.
	^ OSSPipe newWith: fileIDsArray readBlocking: aBoolean. 
! !
!OSSUnixSystemAccessor methodsFor: 'errors' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
perror: aMessage
	"Prints the errno gloabl variable into the stderr together with aMessage string
	and then signal an error"
	self primitivePerror: aMessage.
	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primCreatePipe
	"Create a pipe, and answer an array of two file handles (SQFile data structures in interp.c)
	for the pipe reader and writer."

	<primitive: 'primitiveCreatePipe' module: 'UnixOSProcessPlugin'>
	^ nil! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primForwardSignal: signalNumber toSemaphore: semaphoreIndex
	"Set a signal handler in the VM which will signal a Smalltalk semaphore at
	semaphoreIndex whenever an external signal sigNum is received. Answer the
	prior value of the signal handler. If semaphoreIndex is zero, the handler is
	unregistered, and the VM returns to its default behavior for handling that
	signal.

	The Smalltalk semaphore is expected to be kept at the same index location
	indefinitely during the lifetime of a Squeak session. If that is not the case, the
	handler must be unregistered prior to unregistering the Smalltalk semaphore."

	<primitive: 'primitiveForwardSignalToSemaphore' module: 'UnixOSProcessPlugin'>
	^ nil
! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primSQFileSetNonBlocking: aSQFileStruct
	"Pass a struct SQFile on the stack, and call fcntl() to set the file non-blocking."

	<primitive: 'primitiveSQFileSetNonBlocking' module: 'UnixOSProcessPlugin'>
	^ nil
! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primSemaIndexFor: sigNum
	"Answer the registration index of the semaphore currently associated with the
	signal handler for sigNum."

	<primitive: 'primitiveSemaIndexFor' module: 'UnixOSProcessPlugin'>
	^ nil
! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primSigChldNumber
	"Integer value corresponding to SIGCHLD"

	<primitive: 'primitiveSigChldNumber' module: 'UnixOSProcessPlugin'>
	^ nil
! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primUnixFileNumber: aFileID
	"Pass a struct SQFile on the stack, and answer the corresponding Unix file number."

	<primitive: 'primitiveUnixFileNumber' module: 'UnixOSProcessPlugin'>
	^ nil
! !
!OSSUnixSystemAccessor methodsFor: 'cwd - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveChdir: aDirString
	
	^ self ffiCall: #( int chdir(String aDirString) )
	! !
!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveClose: aFileDescription 
	
	^ self ffiCall: #( int close(int aFileDescription) )
	! !
!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveFdopen: aFileDescription mode: aMode
	
	^ self ffiCall: #( OSSCFile fdopen(int aFileDescription, String aMode) )
	! !
!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveFeof: filePointer

	^ self ffiCall: #( int feof( OSSCFile filePointer) )
! !
!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveFflush: file

	^ self ffiCall: #( int fflush( OSSCFile file) )
! !
!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveFgetsInto: bufferPointer size: size file: file 
	"Not directly used for the moment but could be useful to test the reading without the
	SCAttachableFileStream using a code like this:
	
	buffer := NativeBoost allocate: 1001.
	(self primitiveFgetsInto: buffer  size: 1001 file: popenFile).
	self primitivePerror: 'fgets()'.
	buffer byteAt: 1001 put: 0.
	string := buffer readString.
	buffer free.
	string inspect. 
	
	"

	^ self ffiCall: #( String fgets(void* bufferPointer, int size, OSSCFile file) )
! !
!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveFileno: file

	^ self ffiCall: #( int fileno( OSSCFile file) )
! !
!OSSUnixSystemAccessor methodsFor: 'cwd - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveGetcwd: buffer size: size
	
	^ self ffiCall: #( String getcwd(char *buffer, int size) )
	! !
!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveGetdtablesize
	
	^ self ffiCall: #( int getdtablesize(void) )

! !
!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveGetenv: variableName
	
	^ self ffiCall: #( char * getenv(char* variableName) )! !
!OSSUnixSystemAccessor methodsFor: 'general' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveGetpid

	^ self ffiCall: #( int getpid(void) )
	
! !
!OSSUnixSystemAccessor methodsFor: 'signals - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveKill: aPid signal: aSignal

	^ self ffiCall: #( int kill(int aPid, int aSignal) )
	! !
!OSSUnixSystemAccessor methodsFor: 'errors - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitivePerror: anErrorString

	^ self ffiCall: #( void perror(String anErrorString) )
! !
!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitivePipe: pipePointer
	
	^ self ffiCall: #( int pipe(void* pipePointer) )! !
!OSSUnixSystemAccessor methodsFor: 'errors - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveStrerror: errorNumber
	
	^ self ffiCall: #( String strerror( int errorNumber) )
! !
!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveSysconf: aNumber
	
	^ self ffiCall: #( long sysconf(int aNumber) )

! !
!OSSUnixSystemAccessor methodsFor: 'system - primitives' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveSystem: commandString
	 ^ self ffiCall: #(int system(char* commandString) ) 
		! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
restoreSigChld
	"Unset a SIGCHLD signal handler and unregister the Smalltalk semaphore.
	Answer the unregistered Semaphore, or nil if unable to restore the signal
	(possibly because no handler had been set)."

	^ self restoreSignal: self primSigChldNumber
! !
!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
restoreSignal: signalNumber 
	"Unset a signal handler and unregister the Smalltalk semaphore. Answer
	the unregistered Semaphore, or nil if unable to restore the signal (possibly
	because no handler had been set)."

	| semaphoreIndex sema |
	semaphoreIndex := self primSemaIndexFor: signalNumber.
	semaphoreIndex ifNotNil:
		[sema := Smalltalk externalObjects at: semaphoreIndex ifAbsent: [].
		sema ifNotNil:
			[self primForwardSignal: signalNumber toSemaphore: nil.
			Smalltalk unregisterExternalObject: sema]].
	^ sema
! !
!OSSUnixSystemAccessor methodsFor: 'sizeof' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sizeOfInt
	
	^ FFIExternalType sizeOf: #long! !
!OSSUnixSystemAccessor methodsFor: 'sizeof' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sizeOfPointer
	
	^ FFIExternalType pointerSize
	

! !
!OSSUnixSystemAccessor methodsFor: 'errors' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
strerror: aReturnValue message: aMessage
	"Get the string description of the error numnber aReturnValue and signal 
	and error with such a description together with aMessage string"
	| internalError | 
	internalError := self primitiveStrerror: aReturnValue.
	self error: 'Error: ', aMessage, ', code: ', aReturnValue asString, ', description: ', internalError! !
!OSSUnixSystemAccessor methodsFor: 'system' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
system: aCommandString
	"Executes aCommandString in the OS via the system() call. Only used for testing."
	| returnValue |
	returnValue := self primitiveSystem: aCommandString.
	(returnValue = -1) ifTrue: [ 
		self perror: 'system()'	
	].
	^ returnValue ! !
!OSSVMProcess class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initialize
	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."
	
	self initializeVMProcessInstance. 
	self flag: #removeIt.
	"This IF will be eliminated soon...only here temporary"
	(SystemVersion current highestUpdate >= 50558)
		ifTrue: [ 
			SessionManager default registerToolClassNamed: self name
			 ]
		ifFalse: [ 
			Smalltalk addToStartUpList: OSSVMProcess.
			Smalltalk addToShutDownList: OSSVMProcess.
 		]
	! !
!OSSVMProcess class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initializeVMProcessInstance
	VMProcess isNil 
		ifTrue: [ VMProcess := self basicNew. ]
		ifFalse: [ VMProcess finalizePreviousSession ].
	VMProcess initialize.! !
!OSSVMProcess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
new

	self error: 'Only one instance of OSSVMProcess or any of its subclasses should exist in the image. Use #vmProcess to obtain the singleton instance.'.
! !
!OSSVMProcess class methodsFor: 'system startup' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
shutDown: quitting
	self vmProcess shutDown: quitting! !
!OSSVMProcess class methodsFor: 'system startup' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
startUp: resuming
	
	resuming ifTrue: [ 
		"To understand why the #stopWaiting, first read the comment of 
		OSSVMProcess shutDown:
		It could happen that when the shutDown happened, the child process
		was in the wait of #waitForExitPollingEvery:doing:. Therefore, until the
		next cycle of the loop it won't do the queryExitStatus. So we may still 
		have this problem in image startup. So just in case we run it too in the startup code.
		 "
		self vmProcess activeChildren do: [ :each | each stopWaiting ].
		self initializeVMProcessInstance.
		]! !
!OSSVMProcess class methodsFor: 'OS Process' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
tryToDisableOSProcessSigchldHandler
	
	self flag: #fixIt. "hack!!!!!!!!"
	Smalltalk at: #OSProcess ifPresent: [ 
		(Smalltalk at: #OSProcess) thisOSProcess processAccessor restoreSigChld. 
		(Smalltalk at: #OSProcess) thisOSProcess processAccessor grimReaperProcess terminate.
		(Smalltalk at: #ThisOSProcess) shutDown: true.
		Smalltalk removeFromShutDownList: (Smalltalk at: #ThisOSProcess).
		Smalltalk removeFromStartUpList: (Smalltalk at: #ThisOSProcess).
	].! !
!OSSVMProcess class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
vmProcess
	"Answer a single instance representing the OS process in 
	which this Smalltalk VM and image is executing."

	^ VMProcess! !
!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
activeChildren
	"Answer child processes which are currently believed to be running."

	^ accessProtect critical: [ childProcessList select: [ :process | process isRunning ] ].
! !
!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
allMyChildren

	^ childProcessList! !
!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
checkFinishedChildren
	"Does a waitpid() with the flag WNOHANG which makes the system call to answer immediatly rather than waiting until child has exited. 
	Answers nil if child has not yet exited or the exit status if it has.
	
	http://man7.org/linux/man-pages/man2/waitpid.2.html
	waitpid man's page is ambiguous with respect of the usage of the WNOHANG option.
	It looks like waitpid ignores the first argument if WNOHANG is specified, and returns with ANY child process id.
	This means that, in combination with the previous issue, it may happen that calling waitpid for process X will unregister process Y, what will make fail a subsequent call to waitpid from Y.
	"

	| waitedChildren childrenSize |
	"Skip checking if we have no children"
	waitedChildren := 0.
	childrenSize := self activeChildren size.
	[ waitedChildren < childrenSize ]
		whileTrue: [ | statusPointer |
			[ | status returnValue |
			statusPointer := ExternalAddress allocate: systemAccessor sizeOfInt.
			returnValue := self primitiveWaitpid: -1 statusPointer: statusPointer options: WNOHANG.

			"If return value is 0 then there are no more changes, we can exit"
			returnValue = 0
				ifTrue: [ ^ self ].

			"Only throw error in case it is an error other than no childs (represented as return -1 and errno=ECHILD)"
			returnValue = -1
				ifTrue: [ systemAccessor perror: 'waitpid()' ].
			waitedChildren := waitedChildren + 1.
			status := statusPointer platformLongAt: 1.
			self updateChildProcessWithId: returnValue withStatus: status ]
				ensure: [ statusPointer free ] ]! !
!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
childPids

	^ childProcessList collect: [ :process | process pid ]
! !
!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
earlyFinishedProcesses
	
	^ earlyFinishedProcesses ifNil: [ earlyFinishedProcesses := Dictionary new ]! !
!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
exitedChildren
	"Answer child processes which have exited and are no longer running."

	^ accessProtect critical: [ childProcessList select: [ :process | process isComplete ]].
! !
!OSSVMProcess methodsFor: 'library path' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
ffiLibraryName 
	^ LibC! !
!OSSVMProcess methodsFor: 'updating' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
"protocol: updating"
finalizePreviousSession
	"This method is likely called at image startup and it's job is to finalize
	stuff related to the previous run and let everything clean so that 
	the unique instance vmProcess of OSSVMProcess can be initialized correctly at startup. "
	childWatcher ifNotNil: [ 
		childWatcher isTerminated ifFalse: [ childWatcher terminate ].
		childWatcher := nil.
	].
	sigChldSemaphore ifNotNil: [
		self systemAccessor restoreSigChld.
		sigChldSemaphore := nil
	]
! !
!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initialize
	"Set my instance variables to reflect the state of the OS process in which 
	this Smalltalk virtual machine is. executing."
	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."

	accessProtect := Semaphore forMutualExclusion.
	mutexForCwd := Semaphore forMutualExclusion.
	self initializeAllMyChildren.
	systemAccessor := OSSUnixSystemAccessor forVMProcess. 
	pid := systemAccessor getPid.
	childListTreshold := 20. "Once child list gets bigger than this number, we delete all exited processes"
	self initializeSessionID.
	self initializeSignalHandlers.
	self initializeChildWatcher.! !
!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initializeAllMyChildren
	"Use a Dictionary if process identifiers are unique. On Windows, the
	process ID is not unique, so use an OrderedCollection instead."

	^ childProcessList := OrderedCollection new
! !
!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initializeChildWatcher
	"This is a process which waits for the death of a child processes. Use SIGCHLD events rather than a Delay to poll."

	| processSynchronizationDelay |
	processSynchronizationDelay := Delay forMilliseconds: 30.
	childWatcher	 ifNil: [
		childWatcher := [[
				"OSProcess authors suspected that there were various ways in which OS signals
				could be missed under conditions of heavy load. For that reason, we use
				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,
				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead
				sends queryExitStatus which sends waitpid() )
				"
				self sigChldSemaphore waitTimeoutMSecs: 1000.
				processSynchronizationDelay wait. "Avoids lost signals in heavy process switching"
				self checkFinishedChildren.
				] repeat] newProcess priority: Processor highIOPriority.

		childWatcher resume.
		"name selected to look reasonable in the process browser"
		childWatcher name: ((ReadStream on: childWatcher hash asString) next: 5)
				, ': the OSSubprocess child watcher'
	]
! !
!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initializeSessionID
	| oldFile | 
	self flag: #fixMe. 
	"grrr I need the sessionID (first int of the SQFile). .. there is no primitive to get it. Since it is the same for all files
	lets try to grab it from a file we know there will be always there: the image file."
	oldFile := StandardFileStream oldFileNamed: Smalltalk image imagePath.
	sessionID := oldFile basicFileID copy first: (self systemAccessor sizeOfInt).
	oldFile close.! !
!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
initializeSignalHandlers
	"#sigChldSemaphore will lazily create and register the semaphore if needed"
	self sigChldSemaphore.
	! !
!OSSVMProcess methodsFor: 'cwd' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
lockCwdWithValue: cwdNewValue encoding: encoding during: aBlock
	"This method is a complete hack in order to support a #cmd: option in OSSUnixSubprocess. 
	OSSUnixSubprocess relies in posix_spawn() family of functions to spwan processes in the OS,
	and these functions do not allow specifying a starting working directory for the child process. 
	However, this is sometimes needed by subprocess.
	Therefore, we propose this hack. Basically, we change the current directory of the parent process (vmProcess) 
	BEFORE launching the subprocess. When the child is launched, it inherits the working directory of the parent.
	As soon as the child was launched, we rollback and put back the original working directory in the parent. 
	Because if this, it's very much likely that aBlock represents the launching of a child process.

	mutexForCwd is needed because we may have multiple children at the same time trying to change working
	directory (not thread safe..). So with mutexForCwd we sincronize this. 	

	Forking with userInterruptPriority is useful just in case there could be other Smalltalk process 
	using another code, trying to ALSO change the working directory (very very unlikely). So at least with 
	userInterruptPriority we make sure that we a higher priority than the rest of the normal user code
	and so we minimize that problem.
	
	"

	| completed |
	cwdNewValue asFileReference exists ifFalse: [ ^ self error: 'The directory: ', cwdNewValue, ' does not exist' ]. 
	completed :=  Semaphore new. 
	[ 
		| oldCwd |
		oldCwd := self systemAccessor getcwd.
		[
			self systemAccessor chdir: (cwdNewValue encodeWith: encoding) asString.
			mutexForCwd critical: aBlock.
		]
		ensure: [ 
			self systemAccessor chdir: oldCwd.
			completed signal.	
		]
	] forkAt: Processor userInterruptPriority.
	completed wait.
	! !
!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
pid
	^ pid! !
!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
primitiveWaitpid: aProcessId statusPointer: statusPointer options: optionBits
	
	^ self ffiCall: #( int waitpid(int aProcessId, void* statusPointer, int optionBits) )! !
!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
pruneExitedChildrenAfter: size
	"Limit the size of the child process registry. Select the last entries, and unregister
	them if they are no longer active."

	(accessProtect critical: [childProcessList allButFirst: size])
		do: [ :aProcess |
			aProcess isComplete ifTrue: [ self unregisterChildProcess: aProcess ]]
! !
!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
registerChildProcess: anOSProcess
	"Unregister anOSProcess, and trim the child process registry to prevent excessive
	accumulation of exited children.
	
	If the process finished before this registration, set it the exit status.
	Otherwise, register it"

	accessProtect critical: [ 
		self earlyFinishedProcesses
			at: anOSProcess pid
			ifPresent: [ :exitStatus |
				anOSProcess setExitStatus: exitStatus.
				self earlyFinishedProcesses removeKey: anOSProcess pid ]
			ifAbsent: [ childProcessList addFirst: anOSProcess ] ].
	self pruneExitedChildrenAfter: childListTreshold.
	^ anOSProcess
	! !
!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sessionID
	"The sessionID is something internal to the VM and it's used
	as part of the fileID structure (sqFile) of StandardFileStream. 
	We use it for some file operations"
	^ sessionID! !
!OSSVMProcess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
shutDown: quitting
	"If we have a process that do not stop automatically (like a tail -f) and it runs
	with #fork  (at Smalltalk level)	then that process will be continue running 
	after the image has stopped and started again. 
	If this process continues running, it may be waiting via a delay polling
	and that will throw an error since waitpid() will fail since the parent process 
	(the VM process) is NOT the parent anymore of the child process.
	And so.if the process fails, it makes the system startup to fail and we cannot
	open the image anymore. See https://github.com/marianopeck/OSSubprocess/issues/12
	So... to solve this we simply make all active childs to stop waiting so that the 
	next startup of the image has no problem. 
	
	"
	quitting ifTrue: [ self activeChildren do: [ :each | each shutDown: quitting ] ].! !
!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
sigChldSemaphore
	"Answer the value of sigChldSemaphore.
	If nil, then register and create a semaphore to be signaled upon SIGCHLD.
	See #forwardSigChld for more details. "

	^ sigChldSemaphore ifNil: [sigChldSemaphore := self systemAccessor forwardSigChld].
! !
!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
systemAccessor
	^ systemAccessor ! !
!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
unregisterChildProcess: anOSProcess

	"Unregister anOSProcess from the list of children"

	accessProtect critical: [childProcessList remove: anOSProcess ifAbsent: [] ].
	^ anOSProcess
! !
!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
updateChildProcessWithId: aChildPid withStatus: status
	
	| childProcess |
	childProcess := self activeChildren
		detect: [ :child | child pid = aChildPid ]
		ifNone: [ ^ self earlyFinishedProcesses at: aChildPid put: status ].
	childProcess setExitStatus: status.
	childProcess processHasExitNotification.! !

"OSSubprocess"!
!UnicodeCharacterData commentStamp: 'SvenVanCaekenberghe 1/26/2016 19:25' prior: 0!
I am UnicodeCharacterData, I represent one record in the Unicode Character Database and describe properties of one character.

I am uniquely identified by my code point (#codePoint), my Unicode scalar value.

I have an official name (#name). Sometimes I also know my older name (#oldName).

I have a general and a bidirectional category (#generalCategory  #bidirectionalCategory) and I know my canonicalCombiningClasses (#canonicalCombiningClasses).

If applicable, I know my case mapping, what code point is like me, but upper, lower or title cased (#uppercase  #lowercase #titelcase)

If applicable, I know my numerical mapping, the mathematical number that I represent (#decimalDigitValue #digitValue #numericValue).

If I am a precomposed character, I know my decomposition (#decompositionMapping). This information is needed for normalization.

I also known whether I am mirrored (#mirrored).

My class side holds the full database of all official Unicode characters, indexed by codePoint (#database), which is loaded lazily from the official URL or from a local file system cache.

Given a Unicode code point, my class method #forCodePoint: will answer an instance of me. A NotFound exception is raised if the code point is outside the allowed range.

Given an integer, #unicodeCharacterData will answer an instance of me.

	16r00C5 unicodeCharacterData.

The character that I represent is available with #character.  Given a character instance, #unicodeCharacterData will answer an instance of me.

	$a unicodeCharacterData.
	$é unicodeCharacterData.
	$7 unicodeCharacterData.

More:

For the interpretation of these concepts, please consult the Unicode documentation at http://unicode.org

In particular, the UCD dataset is described in detail in http://www.unicode.org/reports/tr44/ and available directly at http://www.unicode.org/Public/UNIDATA/ and can be downloaded as http://www.unicode.org/Public/UNIDATA/UCD.zip.

Implementation notes

To conserve space (the full database has about 30K entries), some of my fields (canonicalCombiningClass, generalCategory, bidirectionalCategory and mirrored) are combined in bitEncodedFields.

Furthermore, since many entries (about 20K) have neither decomposition, case or numeric mappings, I have no instance variables for these properties, but my extended subclass does.


Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeCharacterDataExtended commentStamp: 'SvenVanCaekenberghe 1/26/2016 14:01' prior: 0!
I am UnicodeCharacterDataExtended, a subclass of UnicodeCharacterData.

I am an implementation detail, from an external viewpoint I am identical to my superclass.

Since many UCD entries (about 20K) have neither decomposition, case or numeric mappings, my superclass has no instance variables for these properties, but I do.


Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/13/2016 22:38'!
gtInspectorGlyphIn: composite
	<gtInspectorPresentationOrder: 60>
	^ composite morph
		title: 'Glyph';
		display: [ 
			| morph largeFont |
			"Add an extra space in front to prevent rendering glitches on combining marks"
			morph := (String space , self asString) asMorph.
			(largeFont := morph font copy)
				clearRealFont;
				pointSize: 256.
			morph font: largeFont.
			morph fitContents.
			morph ]! !
!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/15/2016 10:08'!
gtInspectorUnicodeCharacterDataIn: composite
	<gtInspectorPresentationOrder: 40>
	| unicodeCharacterData |
	unicodeCharacterData := [ self unicodeCharacterData ] on: NotFound do: [ ^ self ].
	^ (unicodeCharacterData gtInspectorCharacterIn: composite)
			title: 'Unicode';
			yourself ! !
!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/26/2016 14:34'!
unicodeCharacterData
	"Answer the official record from the Unicode Character Database for me"
	
	^ UnicodeCharacterData forCodePoint: self codePoint ! !
!GTSpotter methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/28/2016 11:17'!
spotterForUnicodeCharacterFor: aStep
	<spotterOrder: 30>
	aStep listProcessor
		title: 'Unicode Character';
		allCandidates: [ UnicodeCharacterData database values ];
		itemName: [ :each | each name ];
		filter: GTFilterSubstring;
		wantsToDisplayOnEmptyQuery: false! !
!SmallInteger methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/26/2016 14:34'!
unicodeCharacterData
	"Answer the official record from the Unicode Character Database for me"
	
	^ UnicodeCharacterData forCodePoint: self ! !
!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
bidirectionalCategories
	"Return the possible values for bidirectional category"
	
	"Table 13. Bidi_Class Values in http://www.unicode.org/reports/tr44/#Bidi_Class_Values"
	
	^ #(L R AL EN ES ET AN CS NSM BN B S WS ON LRE LRO RLE RLO PDF LRI RLI FSI PDI)! !
!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/29/2016 11:18'!
cleanUp: aggressive
	"self cleanUp"
	"self cleanUp: true"

	self resetHangulDatabase.
	"Not 100% sure this is a good idea"
	aggressive
		ifTrue: [ self resetDataSets ]! !
!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
compositionExclusions
	"D112"
	
	^ CompositionExclusions ifNil: [ CompositionExclusions := self loadCompositionExclusions ]! !
!UnicodeCharacterData class methodsFor: 'private - composition exclusion' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
compositionExclusionsFile
	^ 'CompositionExclusions.txt'! !
!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
database
	"Return the Unicode Character Database an a dictionary mapping each codepoint to an instance of me. 
	Load the database if needed from the official URL over the internet or from a local filesystem cache."
	
	UnicodeCharacterDatabase ifNil: [ self initializeDatabase ].
	^ UnicodeCharacterDatabase! !
!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
decompositionCompatibilityTypes
	"Return the possible values for type of compatibility decomposition"
	
	"Table 14. Compatibility Formatting Tags in http://www.unicode.org/reports/tr44/#Character_Decomposition_Mappings"
	
	^ #(font noBreak initial medial final isolated circle super sub vertical wide narrow small square fraction compat)! !
!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
derivedNormalizationPropertiesFile
	^ 'DerivedNormalizationProps.txt'! !
!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
extractSpecialRanges: collectionOfCharacterData
	|ranges|
	ranges := (collectionOfCharacterData 
			select: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ])
				pairsCollect: [ :first :last | Array with: first with: last ].
	"Happily, in Pharo, removeAllSuchThat does *not* return the collection of removed elements..."
	collectionOfCharacterData 
			removeAllSuchThat: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ].
	^ranges! !
!UnicodeCharacterData class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
forCodePoint: integer
	"Return an instance of me for codepoint integer. Fail if there is no such codepoint."

	^ self
		forCodePoint: integer
		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !
!UnicodeCharacterData class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
forCodePoint: integer ifAbsent: block
	"Return an instance of me for codepoint integer. Execute block if there is no such codepoint."
	
	^ self database 
		at: integer 
		ifAbsent: [ self hangulDataForCodePoint: integer ifAbsent: block ]! !
!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
generalCategories
	"Return the possible values for general category"
	
	"See Table 12. General_Category Values in http://www.unicode.org/reports/tr44/#General_Category_Values"
	
	^ #(Lu Ll Lt Lm Lo Mn Mc Me Nd Nl No Pc Pd Ps Pe Pi Pf Po Sm Sc Sk So Zs Zl Zp Cc Cf Cs Co Sn)! !
!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
getUnicodeCharacterDatabaseRaw: file
	"Return the contents of file from the Unicode Character Database specification as a String.
	Optionally use a locally downloaded cache, to enable this,
	decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image."
	
	| fileReference url |
	fileReference := self unicodeCharacterDatabaseCacheDirectory / file.
	url := self unicodeCharacterDatabaseBaseUrl / file.
	^ fileReference exists
		ifTrue: [ 
			fileReference binaryReadStreamDo: [ :bin |
				(ZnCharacterReadStream on: bin) upToEnd ] ]
		ifFalse: [ 
			url retrieveContents ]! !
!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
hangulDataForCodePoint: integer
	^ self 
		hangulDataForCodePoint: integer 
		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !
!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekebenberghe 1/26/2016 16:01'!
hangulDataForCodePoint: integer ifAbsent: aBlock
	"Could use on: DomainError do: aBlock rather than check range here explicitly, not sure of the perf overhead though"

	(integer notNil and: [ self isHangulSyllableCodePoint: integer ])
		ifFalse: [ ^ aBlock value ].
	^ self hangulDatabase 
		at: integer 
		ifAbsentPut: [ 
			UnicodeCharacterDataExtended new 
				initializeFromHangulSyllable: integer;
				yourself ]! !
!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
hangulDatabase
	"Thumb-in-air figure; assume 1000 hangul characters will be a good working set."

	^ HangulCache
		ifNil: [ 
			HangulCache := LRUCache new
				maximumWeight: 1000;
				yourself ]! !
!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
initializeDatabase
	| entries |
	entries := self loadUnicodeCharacterDatabase.
	SpecialRanges := self extractSpecialRanges: entries.
	UnicodeCharacterDatabase := IdentityDictionary new: entries size.
	entries do: [ :each | 
		UnicodeCharacterDatabase at: each codePoint put: each ]! !
!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
initializeJamoShortNames
	JamoShortNames := self loadJamoShortNames ! !
!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isHangulSyllableCodePoint: codePoint
	^ codePoint between: 16rAC00 and: 16rD7A3! !
!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isSupplementaryCodePoint: codePoint
	^ codePoint between: 16r10000 and: 16r10FFFF! !
!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
jamoShortNames
	JamoShortNames ifNil: [ self initializeJamoShortNames  ].
	^JamoShortNames! !
!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
jamoShortNamesFile
	^ 'Jamo.txt'! !
!UnicodeCharacterData class methodsFor: 'private - composition exclusion' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
loadCompositionExclusions
	| compositionExclusions |
	compositionExclusions := IdentitySet new.
	(self getUnicodeCharacterDatabaseRaw: self compositionExclusionsFile) linesDo: [ :each | 
		(each notEmpty and: [ each first ~= $# ])
			ifTrue: [ compositionExclusions add: (Integer readFrom: each base: 16) ] ].
	^ compositionExclusions! !
!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
loadDerivedNormalizationProperties
	^ OrderedCollection streamContents: [ :out |
		(self getUnicodeCharacterDatabaseRaw: self derivedNormalizationPropertiesFile) linesDo: [ :line |
			(line isEmpty or: [ line first = $# ])
				ifFalse: [ 
					out nextPut: (self parseDerivedNormalizationProperty: line) ] ] ]! !
!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
loadJamoShortNames
	| shortNames |
	shortNames := IdentityDictionary new.
	(self getUnicodeCharacterDatabaseRaw: self jamoShortNamesFile)
		linesDo: [ :each | 
			(self parseUnicodeJamoShortNames: each) 
				ifNotNil: [ :shortName | shortNames add: shortName ] ].
	^ shortNames! !
!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
loadNormalizationQuickCheck
	| normalizationQuickCheck derivedNormalizationProperties values |
	normalizationQuickCheck := IdentityDictionary new.
	derivedNormalizationProperties := self loadDerivedNormalizationProperties.
	#(NFC_QC NFD_QC NFKC_QC NFKD_QC) do: [ :property |
		values := IdentityDictionary new.
		derivedNormalizationProperties 
			select: [ :each | (each at: #property) = property ] 
			thenDo: [ :each | 
				(each at: #range) isInteger
					ifTrue: [ 
						values at: (each at: #range) put: (each at: #value) asSymbol ] 
					ifFalse: [ 
						(each at: #range) do: [ :codePoint | 
							values at: codePoint put: (each at: #value) asSymbol ] ] ].
		normalizationQuickCheck at: property put: values ].
	^ normalizationQuickCheck! !
!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
loadUnicodeCharacterDatabase
	^ OrderedCollection streamContents: [ :out |
		(self getUnicodeCharacterDatabaseRaw: self unicodeCharacterDatabaseFile) linesDo: [ :each |
			out nextPut: (self parseUnicodeCharacterData: each) ] ]! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
minimalCCC	
	| ccc |
	ccc := IdentityDictionary new.
	(self database values reject: #isStarter)
		do: [ :each | ccc at: each codePoint put: each ccc ].
	^ ccc! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
minimalDecomposition
	| decomposition |
	decomposition := IdentityDictionary new.
	(self database values select: #hasDecomposition)
		do: [ :each | decomposition at: each codePoint put: each decompositionMapping ].
	^ decomposition! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/27/2016 22:08'!
nameMatching: fragment
	"Find and return the Unicode Character Data objects whose official name matches fragment."
	
	"self nameMatching: 'CAPITAL LETTER A'"
	
	| matches |
	matches := Array streamContents: [ :out |
		self database valuesDo: [ :each |
			"Note that by using #names both #name and #oldName if any will be used"
			(each names findString: fragment startingAt: 1 caseSensitive: false) ~= 0
				ifTrue: [ out nextPut: each ] ] ].
	^ matches! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/27/2016 17:15'!
named: fullName
	"Find and return the Unicode Character Data object whose official name is fullName."
	
	"self named: 'LATIN CAPITAL LETTER A'"
	
	self database valuesDo: [ :each |
		each name = fullName ifTrue: [ ^ each ] ].
	NotFound signalFor: fullName in: self ! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
nonStarterDecompositions
	"D111"
	
	^ self database values select: #isNonStarterDecomposition! !
!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
normalizationQuickCheck
	^ NormalizationQuickCheck ifNil: [ NormalizationQuickCheck := self loadNormalizationQuickCheck ]! !
!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
normalizationQuickCheck: property forCodePoint: codePoint
	"Return #Y (yes), #N (no) or #M (maybe) for property, #NFC_QC, #NFD_QC, #NFKC_QC or #NFKD_QC"
	
	^ (self normalizationQuickCheck at: property) at: codePoint ifAbsent: [ #Y ] ! !
!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
normalizationQuickCheck: property forCodePointStream: codePointStream
	| result lastCCC codePoint ccc check |
	result := #Y.
	lastCCC := 0.
	[ codePointStream atEnd ] whileFalse: [
		codePoint := codePointStream next.
		"(self isSupplementaryCodePoint: codePoint) ifTrue: [ codePointStream next ]."
		ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].
		(lastCCC > ccc and: [ ccc ~= 0 ]) ifTrue: [ ^ #N ].
		check := self normalizationQuickCheck: property forCodePoint: codePoint.
		check = #N ifTrue: [ ^ #N ].
		check = #M ifTrue: [ result := #M ]. 
		lastCCC := ccc ].
	^ result! !
!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
normalizationQuickCheck: property forString: string
	^ self 
		normalizationQuickCheck: property 
		forCodePointStream: string readStream unicodeCodePoints! !
!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 2/16/2016 11:09'!
optimizeDatabase
	"Improve the distribution at a reasonable cost (optional)"
	
	"UnicodeCharacterData database keys in: [ :known |
		[ known do: [ :each | each unicodeCharacterData ] ] bench ]"
	
	"[ 1 to: 16r10FFFF do: [ :each | UnicodeCharacterData forCodePoint: each ifAbsent: [ ] ] ] bench"
	
	self database growTo: 53233! !
!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
parseDerivedNormalizationProperty: line
	| fields range value comment |
	fields := $; split: (line copyFrom: 1 to: (line indexOf: $#) - 1).
	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.
	range := fields first trimBoth.
	range := (range indexOfSubCollection: '..' startingAt: 1 ifAbsent: [ ])
		ifNil: [ Integer readFrom: range base: 16 ]
		ifNotNil: [ :ellipsis | 
				(Integer readFrom: (range copyFrom: 1 to: ellipsis - 1) base: 16) 
					to: (Integer readFrom: (range copyFrom: ellipsis + 2 to: range size) base: 16) ].
	value := fields size = 2
					ifTrue: [ true ]
					ifFalse: [ fields third trimBoth asSymbol ].
	^ { 
		#range -> range.
		#property -> fields second trimBoth asSymbol.
		#value -> value.
		#comment -> comment trimBoth } asDictionary! !
!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekebenberghe 1/26/2016 14:41'!
parseUnicodeCharacterData: line
	| fields isCompact concreteClass |
	fields := $; split: line.
	"Test if the fields for decomposition, numerical and case mapping are all empty"
	isCompact := #(6 7 8 9 13 14 15) allSatisfy: [ :each | (fields at: each) isEmpty ].
	concreteClass := isCompact 
		ifTrue: [ UnicodeCharacterData ] 
		ifFalse: [ UnicodeCharacterDataExtended ].
	^ concreteClass new
		initializeFrom: fields;
		yourself! !
!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
parseUnicodeJamoShortNames: aLine
	| codePoint start end shortName |
	"Don't parse comments and empty lines"
	(aLine isEmpty or: [aLine first = $#]) ifTrue: [ ^nil ].
	"All lines are in format CODEPOINT; SHORTNAME #LONGNAME "
	codePoint := Number readFrom: aLine base: 16.
	start := (aLine indexOf: $;) + 2.
	end := (aLine indexOf: Character space startingAt: start) -1.
	shortName := aLine copyFrom: start to: end.
	^codePoint -> shortName	 ! !
!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/29/2016 11:17'!
resetDataSets
	"self resetDataSets"

	UnicodeCharacterDatabase := nil.
	SpecialRanges := nil.
	JamoShortNames := nil.
	NormalizationQuickCheck := nil.
	CompositionExclusions := nil! !
!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
resetHangulDatabase
	^ HangulCache ifNotNil: [ HangulCache removeAll ]! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
singletons
	"D110"
	
	^ self database values select: #isSingleton! !
!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
specialRanges
	SpecialRanges ifNil: [ self initializeDatabase ].
	^ SpecialRanges! !
!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
unicodeCharacterDatabaseBaseUrl
	"Return the base of URL where all files of the UCD dataset can be found"
	
	^ 'http://www.unicode.org/Public/UNIDATA' asZnUrl! !
!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
unicodeCharacterDatabaseCacheDirectory
	"Return the directory where a local filesystem copy of the UCD data is stored.
	Decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image"
	
	^ FileLocator imageDirectory / #UCD! !
!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
unicodeCharacterDatabaseFile
	"Return the name of the main Unicode Character Database specification file"
	
	^ 'UnicodeData.txt'! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
unmappedDecompositionCodePoints
	^ (Array streamContents: [ :out | 
			self database valuesDo: [ :ucd | 
				ucd decompositionMappingDo: [ :each | 
					self forCodePoint: each ifAbsent: [ out nextPut: each ] ] ] ]) asSet sorted! !
!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
unmappedDecompositions
	^ (self database values select: [ :ucd | 
			| missing |
			missing := false.
			ucd decompositionMappingDo: [ :each |
				self forCodePoint: each ifAbsent: [ missing := true ] ]. 
			missing ]) sorted! !
!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
<= otherUnicodeCharacterData
	^ self codePoint <= otherUnicodeCharacterData codePoint! !
!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
= anObject
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	^ codePoint = anObject codePoint! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
bidirectionalCategory
	"Return the symbol indicating the Bidirection Category of my codepoint"

	| index |
	index := (bitEncodedFields >> 13) bitAnd: 2r11111.
	^ self class bidirectionalCategories at: index + 1! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
canonicalCombiningClass
	"Return the integer indicating the Canonical Combining Class of my codepoint"

	^ bitEncodedFields bitAnd: 16rFF! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
caseMapping
	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.
	Use the accessors #uppercase, #lowercase or #titlecase instead"
	
	^ nil! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
ccc
	"A shorter alias"
	
	^ self canonicalCombiningClass ! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
character
	"Return a character instance corresponding to my codepoint"

	^ Character codePoint: codePoint! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
codePoint
	"Return my codepoint, an integer"
	
	^ codePoint! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
decimalDigitValue
	"Return the decimal digit value of my codepoint as an integer. Could be nil if not applicable."
	
	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping first ]! !
!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 14:37'!
decompositionAsUCDs
	^ self decompositionMapping ifNotNil: [ :decomposition | 
			decomposition collect: [ :each | 
				each isInteger 
					ifTrue: [ 
						self class 
							forCodePoint: each 
							ifAbsent: [ 
								self class new 
									initializeDegenerate: each;
									yourself ] ]
					ifFalse: [ each ] ] ]! !
!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
decompositionDescription
	^ String streamContents: [ :out |
			self decompositionMapping ifNotNil: [ :mapping | 
				| decomposition |
				mapping first isInteger 
					ifTrue: [ decomposition := mapping ]
					ifFalse: [ 
						out << $< << mapping first << $>; space. 
						decomposition := mapping allButFirst ].
			decomposition 
				do: [ :each | out nextPut: (Character codePoint: each) ]
				separatedBy: [ out << ' + ' ] ] ]! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
decompositionMapping
	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."
	
	^ nil! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
decompositionMappingDo: block
	"Execute block for each code point in my decomposition mapping, if any"
	
	self hasCanonicalDecomposition 
		ifTrue: [ ^ self decompositionMapping do: block ].
	self hasCompatibleDecomposition 
		ifTrue: [ ^ self decompositionMapping allButFirstDo: block ]! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/28/2016 10:28'!
decompositionString
	"Return my decomposition as a String, if I have none, return an empty string."
	
	^ String streamContents: [ :out |
			self decompositionMappingDo: [ :each | 
				out nextPut: (Character codePoint: each) ] ]! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
digitValue
	"Return the digit value of my codepoint as an integer. Could be nil if not applicable."

	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping second ]! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
generalCategory
	"Return the symbol indicating the General Category of my codepoint"

	| index |
	index := (bitEncodedFields >> 8) bitAnd: 2r11111.
	^ self class generalCategories at: index + 1! !
!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 14:37'!
gtInspectorCharacterIn: composite
	<gtInspectorPresentationOrder: 30>
	^ composite table
		title: 'Character';
		display: [
			{
				{ 'codepoint'. self codePoint }.
				{ 'codepoint hex'. 
					String streamContents: [ :stream | 
						stream << 'U+'.
						self codePoint printOn: stream base: 16 nDigits: 4 ].
					self codePoint }.
				{ 'character'. self character printString. self character }.
				{ 'name'. self name }.
				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.
				{ 'general category'. self generalCategory }.
				{ 'canonical combining class'. self canonicalCombiningClass }.
				{ 'bidirectional category'. self bidirectionalCategory }.
				{ 'mirrored'. self mirrored }.
				{ 'uppercase'. 
					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 
					self class forCodePoint: self uppercase ifAbsent: [] }.
				{ 'lowercase'. 
					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 
					self class forCodePoint: self lowercase ifAbsent: [] }.
				{ 'titlecase'. 
					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 
					self class forCodePoint: self titlecase ifAbsent: [] }.
				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.
				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.
				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.
				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }
			} ];
		column: 'Key' evaluated: #first;
		column: 'Value' evaluated: [ :entry | entry second asString ];
		send: [ :entry | entry at: 3 ifAbsent: [ entry second ] ]! !
!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
gtInspectorGlyphIn: composite
	<gtInspectorPresentationOrder: 40>
	^ self character gtInspectorGlyphIn: composite! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
hasCanonicalDecomposition
	^ self hasDecomposition and: [ self decompositionMapping first isInteger ]! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
hasCompatibleDecomposition
	^ self hasDecomposition and: [ self decompositionMapping first isSymbol ]! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
hasDecomposition
	^ false! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
hasStandardCanonicalDecomposition
	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 2 ]! !
!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
hash
	^ codePoint hash! !
!UnicodeCharacterData methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
initializeBitEncodedFieldsFrom: fields
	| generalCategory canonicalCombiningClass bidirectionalCategory mirrored generalIndex bidiIndex |
	generalCategory := fields third asSymbol.
	canonicalCombiningClass := fields fourth asNumber.
	bidirectionalCategory := fields fifth asSymbol.
	mirrored := (fields at: 10) first = $Y.
	generalIndex := self class generalCategories 
		indexOf: generalCategory ifAbsent: [ NotFound signalFor: generalCategory ].
	bidiIndex := self class bidirectionalCategories 
		indexOf: bidirectionalCategory ifAbsent: [ NotFound signalFor: bidirectionalCategory ].
	bitEncodedFields := canonicalCombiningClass 
		+ (generalIndex - 1 << 8) 
		+ (bidiIndex - 1 << 13)
		+ (mirrored asBit << 18)! !
!UnicodeCharacterData methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
initializeDegenerate: integer
	codePoint := integer.
	name := '<UNKNOWN>'.
	bitEncodedFields := 0! !
!UnicodeCharacterData methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
initializeFrom: fields
	codePoint := Integer readFrom: fields first base: 16.
	name := fields second.
	(fields at: 11) ifNotEmpty: [ :oldname | 
		name := name, Character tab asString, oldname ].
	self initializeBitEncodedFieldsFrom: fields.
! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isCompositionExclusion
	^ self class compositionExclusions includes: codePoint ! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isFullCompositionExclusion
	^ self isSingleton or: [ self isNonStarterDecomposition or: [ self isCompositionExclusion ] ]! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isLetter
	^ self generalCategory first = $L! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isLowercase
	^ self generalCategory = #Ll! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isMark
	^ self generalCategory first = $M! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isNonStarterDecomposition
	^ self hasCanonicalDecomposition 
			and: [ self isSingleton not
				and: [ 
					self isStarter not 
						or: [ (self class forCodePoint: self decompositionMapping first) isStarter not ] ] ]! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isNumber
	^ self generalCategory first = $N! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isNumberDecimal
	^ self generalCategory = #Nd! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isNumberLetter
	^ self generalCategory = #Nl! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isNumberOther
	^ self generalCategory = #No! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isOther
	^ self generalCategory first = $C! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isPrimaryComposite
	^ self hasCanonicalDecomposition and: [ self isFullCompositionExclusion not ]! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isPunctuation
	^ self generalCategory first = $P! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isSeparator
	^ self generalCategory first = $Z! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isSingleton
	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 1 ]! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isStarter
	^ self canonicalCombiningClass = 0! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isSymbol
	^ self generalCategory first = $S! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isTitlecase
	^ self generalCategory = #Lt! !
!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
isUppercase
	^ self generalCategory = #Lu! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
jamoShortName
	"As the name only exists for the few hangul base characters, they are kept in a separate table, rather than as general properties"
	
	^ self class jamoShortNames at: self codePoint ifAbsent: ''! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
lowercase
	"Return the codepoint of the lowercase version of my codepoint. Could be nil if not applicable"
	
	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping second ]! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
mirrored
	"Return if my codepoint is mirrored or not"
	
	^ (bitEncodedFields bitAt: 19) = 1! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
name
	"Return my official name"
	
	| tabIndex |
	tabIndex := name indexOf: Character tab ifAbsent: [ ^ name ].
	^ name copyFrom: 1 to: tabIndex - 1! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/27/2016 16:37'!
names
	"Return our internal name(s) representation <NAME><TAB>[<OLD-NAME>]"
	
	^ name! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
numericMapping
	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.
	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"

	^ nil! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
numericValue
	"Return the numeric value of my codepoint as an integer. Could be nil if not applicable."

	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping third ]! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
oldName
	"Return my old/legacy name, could be nil"
	
	| tabIndex |
	tabIndex := name indexOf: Character tab ifAbsent: [ ^ nil ].
	^ name copyFrom: tabIndex + 1 to: name size! !
!UnicodeCharacterData methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
printOn: stream
	stream << 'U+'.
	self codePoint printOn: stream base: 16 nDigits: 4.
	stream space; << self name.
	self oldName ifNotNil: [ stream space; nextPut: $(; << self oldName; nextPut: $) ]! !
!UnicodeCharacterData methodsFor: 'gt-spotter-extension' stamp: 'SvenVanCaekenberghe 1/27/2016 16:20'!
spotterPreviewIn: aComposite
	<spotterPreview: 10>
	^ aComposite table
		title: 'Unicode Character';
		display: [
			{
				{ 'codepoint'. self codePoint }.
				{ 'codepoint hex'. 
					String streamContents: [ :stream | 
						stream << 'U+'.
						self codePoint printOn: stream base: 16 nDigits: 4 ].
					self codePoint }.
				{ 'character'. self character printString. self character }.
				{ 'name'. self name }.
				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.
				{ 'general category'. self generalCategory }.
				{ 'canonical combining class'. self canonicalCombiningClass }.
				{ 'bidirectional category'. self bidirectionalCategory }.
				{ 'mirrored'. self mirrored }.
				{ 'uppercase'. 
					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 
					self class forCodePoint: self uppercase ifAbsent: [] }.
				{ 'lowercase'. 
					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 
					self class forCodePoint: self lowercase ifAbsent: [] }.
				{ 'titlecase'. 
					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 
					self class forCodePoint: self titlecase ifAbsent: [] }.
				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.
				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.
				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.
				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }
			} ];
		column: 'Key' evaluated: #first;
		column: 'Value' evaluated: [ :entry | entry second asString ];
		entity: self! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
titlecase
	"Return the codepoint of the titlecase version of my codepoint. Could be nil if not applicable"

	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping third ]! !
!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!
uppercase
	"Return the codepoint of the uppercase version of my codepoint. Could be nil if not applicable"

	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping first ]! !
!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
caseMapping
	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.
	Use the accessors #uppercase, #lowercase or #titlecase instead"
	
	^ caseMapping! !
!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
decompositionMapping
	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."
	
	^ decompositionMapping! !
!UnicodeCharacterDataExtended methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
hasDecomposition
	^ decompositionMapping notNil! !
!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
initializeCaseMappingFrom: fields
	| uppercase lowercase titlecase |
	uppercase := (fields at: 13) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].
	lowercase := (fields at: 14) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].
	titlecase := (fields at: 15) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].
	uppercase notNil | lowercase notNil | titlecase notNil
		ifTrue: [ caseMapping := Array with: uppercase with: lowercase with: titlecase ]! !
!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
initializeDecompositionMappingFrom: fields
	decompositionMapping := fields sixth ifEmpty: [  ] ifNotEmpty: [ :mapping | self parseDecompositionMapping: mapping ]! !
!UnicodeCharacterDataExtended methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
initializeFrom: fields
	super initializeFrom: fields.
	self initializeDecompositionMappingFrom: fields.
	self initializeNumericMappingFrom: fields.
	self initializeCaseMappingFrom: fields! !
!UnicodeCharacterDataExtended methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
initializeFromHangulSyllable: anInteger 
	"Derived from hangul syllable code point. 
	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 145, bottom part"

	| sIndex vIndex tIndex lIndex lPart vPart tPart |
	(self class isHangulSyllableCodePoint: anInteger)
		ifFalse: [ DomainError signal: 'Hangul syllable outside range' from: 16rAC00 to: 16rD7A3 ].
	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.
	 lCount := 19. vCount := 21. tCount := 28. nCount := 588."
	codePoint := anInteger.
	sIndex := codePoint - 16rAC00.
	lIndex := sIndex // 588.
	vIndex := sIndex \\ 588 // 28.
	tIndex := sIndex \\ 28.
	lPart := 16r1100 + lIndex.
	vPart := 16r1161 + vIndex.
	tPart := 16r11A7 + tIndex.
	decompositionMapping := tIndex = 0 
		ifTrue: [ Array with: lPart with: vPart ] 
		ifFalse: [ Array with: lPart with: vPart with: tPart ] .
	name := decompositionMapping 
		inject: 'HANGUL SYLLABLE ' 
		into: [ :sub :next | sub , (self class jamoShortNames at: next) ].
	bitEncodedFields := 0 "CCC=0, General=#Lu, Bidi=#L, mirrored=false"! !
!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
initializeNumericMappingFrom: fields
	| decimalDigitValue digitValue numericValue |
	decimalDigitValue := (fields at: 7) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 
	digitValue := (fields at: 8) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 
	numericValue := (fields at: 9) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ].
	decimalDigitValue notNil | digitValue notNil | numericValue notNil
		ifTrue: [ numericMapping := Array with: decimalDigitValue with: digitValue with: numericValue ]! !
!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
numericMapping
	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.
	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"

	^ numericMapping! !
!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!
parseDecompositionMapping: string
	^ ((Character space split: string)
			collect: [ :each |
				each first = $<
					ifTrue: [ (each copyFrom: 2 to: each size - 1) asSymbol ]
					ifFalse: [ Integer readFrom: each base: 16 ] ]) asArray! !

"Unicode-Character-Data"!
!CharacterFromCodePointReadStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!
I am CharacterFromCodePointReadStream, I wrap a code point Integer ReadStream and translate code point Integers to Characters.

For example

	(97 to: 122) readStream 

is a ReadStream that returns Integers, while

	(97 to: 122) readStream unicodeCharacters
	
is a ReadStream that returns the Character objects for each code point.

	(97 to: 122) readStream unicodeCharacters upToEnd

In effect I translate each Integer code point to a Character.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!CharacterToCodePointWriteStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!
I am CharacterToCodePointWriteStream. I wrap a code point Integer WriteStream and translate Characters to Integer code points.

Here is an example

	Array streamContents: [ :out |
		out unicodeCharacters nextPut: $A; nextPutAll: 'bcde' ]
	
So client code writes Characters and Strings while the underlying stream receives Integer code points,

In effect I translate each Character to an Integer code point.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!CodePointFromCharacterReadStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!
I am CodePointFromCharacterReadStream, I wrap a Character ReadStream and translate Characters into code point Integers.

For example

	'abc' readStream 

is a ReadStream that returns Character objects, while

	'abc' readStream unicodeCodePoints
	
is a ReadStream that returns the Integer code points of each character.

	Character alphabet  readStream unicodeCodePoints upToEnd

In effect I translate each Character to an Integer code point.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!CodePointToCharacterWriteStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:33' prior: 0!
I am CodePointToCharacterWriteStream. I wrap a Character WriteStream and translate code point Integers into Characters.

Here is an example

	String streamContents: [ :out |
		out unicodeCodePoints nextPutAll: (97 to: 122); nextPut: 33 ]
	
So client code writes Integer code points while the underlying stream receives Character objects.

In effect I translate each Integer code point to a Character.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!WriteStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/12/2016 09:59'!
unicodeCharacters
	"Assuming the receiver is a stream over Integer code points, return a CharacterToCodePointWriteStream over the receiver that streams over Characters"
	
	^ CharacterToCodePointWriteStream on: self! !
!WriteStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/12/2016 09:59'!
unicodeCodePoints
	"Assuming the receiver is a stream over Characters, return a CodePointToCharacterWriteStream over the receiver that streams over Integer code points"
	
	^ CodePointToCharacterWriteStream on: self! !
!CharacterFromCodePointReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!
on: codePointReadStream
	^ self new
		on: codePointReadStream;
		yourself! !
!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:14'!
atEnd
	^ readStream atEnd! !
!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:17'!
next
	^ readStream next ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !
!CharacterFromCodePointReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!
on: codePointReadStream
	readStream := codePointReadStream ! !
!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:17'!
peek
	^ readStream peek ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !
!CharacterFromCodePointReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:23'!
unicodeCodePoints
	"Return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"
	
	^ CodePointFromCharacterReadStream on: self! !
!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 1/5/2016 10:03'!
upToEnd
	| out character |
	out := (String new: 10) writeStream.
	[ self atEnd ] whileFalse: [ 
		character := self next.
		(character isOctetCharacter not and: [ out originalContents isWideString not ])
			ifTrue: [ | position wideString |
				position := out position.
				wideString := WideString from: out originalContents.
				out on: wideString; setFrom: position + 1 to: position ].
		out nextPut: character ].
	^ out contents! !
!CharacterToCodePointWriteStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!
on: codePointWriteStream
	^ self new
		on: codePointWriteStream;
		yourself! !
!CharacterToCodePointWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:15'!
nextPut: character
	writeStream nextPut: character codePoint! !
!CharacterToCodePointWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:15'!
nextPutAll: collection
	collection do: [ :each | self nextPut: each ]! !
!CharacterToCodePointWriteStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!
on: codePointWriteStream
	writeStream := codePointWriteStream ! !
!CodePointFromCharacterReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:37'!
on: characterReadStream
	^ self new
		on: characterReadStream;
		yourself! !
!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:38'!
atEnd
	^ readStream atEnd! !
!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:37'!
next
	^ readStream next ifNotNil: [ :character | character codePoint ]! !
!CodePointFromCharacterReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:36'!
on: characterReadStream
	readStream := characterReadStream ! !
!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:38'!
peek
	^ readStream peek ifNotNil: [ :character | character codePoint ]! !
!CodePointFromCharacterReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:22'!
unicodeCharacters
	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"
	
	^ CharacterFromCodePointReadStream on: self! !
!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 16:26'!
upToEnd
	^ Array streamContents: [ :out |
			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !
!CodePointToCharacterWriteStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:34'!
on: characterWriteStream
	^ self new
		on: characterWriteStream;
		yourself! !
!CodePointToCharacterWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!
nextPut: codePoint
	writeStream nextPut: (Character codePoint: codePoint)! !
!CodePointToCharacterWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!
nextPutAll: collection
	collection do: [ :each | self nextPut: each ]! !
!CodePointToCharacterWriteStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!
on: characterWriteStream
	writeStream := characterWriteStream ! !
!ReadStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/11/2016 17:10'!
unicodeCharacters
	"Assuming the receiver is a stream over Integer code points, return a CharacterFromCodePointReadStream over the receiver that streams over Characters"
	
	^ CharacterFromCodePointReadStream on: self! !
!ReadStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/11/2016 17:10'!
unicodeCodePoints
	"Assuming the receiver is a stream over Characters, return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"
	
	^ CodePointFromCharacterReadStream on: self! !

"Unicode-Stream-Support"!
!UnicodeCaser commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:08' prior: 0!
I am UnicodeCaser, a tool to change the case of a string of Unicode characters to lower, upper or title case.

Currently, this implementation is too simplistic.


Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeCaser methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/26/2016 20:16'!
case: case from: inputStream to: outputStream
	self assert: (#(uppercase lowercase titelcase) includes: case).
	inputStream do: [ :each |
		| unicodeCharacterData |
		unicodeCharacterData := each unicodeCharacterData.
		(unicodeCharacterData perform: case)
			ifNil: [ outputStream nextPut: each ] 
			ifNotNil: [ :value | outputStream nextPut: value ] ]! !
!UnicodeCaser methodsFor: 'public' stamp: 'SvenVanCaekenberghe 12/8/2015 20:16'!
case: case fromCharacters: inputStream to: outputStream
	self assert: (#(uppercase lowercase titelcase) includes: case).
	inputStream do: [ :each |
		(each unicodeCharacterData perform: case)
			ifNil: [ outputStream nextPut: each ] 
			ifNotNil: [ :value | outputStream nextPut: (Character codePoint: value) ] ]! !
!UnicodeCaser methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 12/8/2015 20:17'!
case: case string: string
	^ String streamContents: [ :out |
			self case: case fromCharacters: string readStream to: out ]! !

"Unicode-Casing"!
!UnicodeComposer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!
I am UnicodeComposer. I compose streams of unicode code points to their composed form.

I have two primary interfaces.

The first is #composeFrom:to: that operates from an input stream of code points to an output stream of code points in one process.

The second is #composeBuffer: the elementary operation of the above process that operates on a buffer of non-starters between a first and final starter. Note that this buffer can shrink.

Streaming composition can be done by UnicodeComposingReadStream that uses me for buffer composition.

I can only work 100% correct if my input is properly decomposed. 

If my input is NFD, my output will be NFC. 
If my input is NFKD, my output will be NFKC.

I know how to do algorithmic composition of Hangul.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeComposingReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!
I am UnicodeComposingReadStream. I wrap an input read stream of (normally decomposed) code points and produce a composed normalized stream of code points.

I use UnicodeComposer to compose intermediate buffers.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeConcatenator commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!
I am UnicodeConcatenator, for a given normalization form I can concatenate two strings.

This implements the algorithm described in the last paragraph of section 9.1 Stable Code Points of http://www.unicode.org/reports/tr15/ Unicode Normalization.

Try:

  UnicodeConcatenator forNFC concatenateString: 'abce' with: '́def'.

  UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102).

The last character of the first string $e (U+0065 LATIN SMALL LETTER E) and the first character of the second string $́ (U+0301 COMBINING ACUTE ACCENT aka NON-SPACING ACUTE) combine to $é (U+00E9 LATIN SMALL LETTER E WITH ACUTE) in the resulting concatenation. 

Also note that both the first and second string had 4 characters, while their concatenation has 7. This is why concatenation of Unicode strings is non-trivial.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeDecomposer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!
I am UnicodeDecomposer. I decompose streams of Unicode code points using either Canonical or Compatible combinations, NFD and NFKD, using #decomposeFrom:to: and #decomposeCompatibleFrom:to:  respectively.

I use the Unicode Character Database to recursively decompose combined characters.

An alternative, streaming implementation of the process that I implement can be found in UnicodeDecomposingReadStream's two concrete subclasses.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeDecomposingReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!
I am UnicodeDecomposingReadStream. I wrap an input read stream of code points and produce a decomposed normalized stream of code points. I am abstract.

An alternative, non-streaming implementation of the process that I implement can be found in UnicodeDecomposer.

My two concrete subclasses implement Canonical and Compatible decomposition.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeNFDReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!
I am UnicodeNFDReadStream. I implement NFD, the canonical decomposed normal form.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeNFKDReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!
I am UnicodeNFKDReadStream. I implement NFKD, the compatible decomposed normal form.

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeNormalizer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:03' prior: 0!
I am UnicodeNormalizer, I implement the normalize operation which transforms Unicode text into an equivalent composed or decomposed normal form, allowing for easier comparing, searching and sorting of text. 

I implement the forms NFC, NFD, NFKC and NFKD.

I can handle String and code point collections.

This is a high level interface that applies two fast path optimalizations:

 - don't do work on ASCII or Latin1 string when it is not needed
 - do a normalization quick check to see if normalization is really needed

Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!
!UnicodeComposer class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
default
	^ Default ifNil: [ Default := self new ]! !
!UnicodeComposer class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
resetDefault
	Default := nil! !
!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
combinationOf: first and: second
	second ifNil: [ ^ nil ].
	^ (self hangulCombinationOf: first and: second) 
			ifNil: [ self primaryCombinationOf: first and: second ]! !
!UnicodeComposer methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
combinations
	combinations ifNil: [ self initializeForComposition ].
	^ combinations! !
!UnicodeComposer methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
combiningCharacters
	combiningCharacters ifNil: [ self initializeForComposition ].
	^ combiningCharacters! !
!UnicodeComposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:40'!
composeBuffer: buffer	
	"Process decomposed CCC ordered buffer, trying to combine/compose pairs, unless blocked"
	| lastCCC index ccc combination |
	lastCCC := 0.
	index := 2.
	[ index <= buffer size ] whileTrue: [
		ccc := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].
		combination := self combinationOf: buffer first and: (buffer at: index).
		(combination notNil and: [ (lastCCC < ccc) | (lastCCC = 0) ])
			ifTrue: [ 
				buffer at: 1 put: combination.
				buffer removeAt: index ]
			ifFalse: [ 
				index := index + 1. 
				lastCCC := ccc ] ]! !
!UnicodeComposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
composeFrom: input to: output
	| buffer |
	buffer := OrderedCollection new.
	(self scanForStarterFrom: input to: output)
		ifNotNil: [ :nonStarter | buffer addLast: nonStarter ].
	[ input atEnd ] whileFalse: [
		self scanUntilStarterFrom: input to: buffer.
		"Compose the buffer <starter1> ... <starter2>" 
		self composeBuffer: buffer.
		"We're done, flush everything except <starter2> which we keep for the next iteration"
		buffer allButLastDo: [ :each | output nextPut: each ].
		buffer last in: [ :last | buffer reset; addLast: last ] ].
	output nextPutAll: buffer! !
!UnicodeComposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:47'!
composeString: string
	"Return the NFC of string, the canonical composition normal form"
	
	string isByteString ifTrue: [
		"Latin1 strings are already in NFC" 
		^ string ]. 
	^ String streamContents: [ :out |
			self 
				composeFrom: string readStream unicodeCodePoints
				to: out unicodeCodePoints ]! !
!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
hangulCombinationOf: first and: second
	"Algorithmic Hangul Syllable Componsition.
	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"
	
	(self hangulLVCombinationOf: first and: second)
		ifNotNil: [ :combination | ^ combination ].
	(self hangulSTCombinationOf: first and: second)
		ifNotNil: [ :combination | ^ combination ].
	^ nil! !
!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
hangulCombinationOf: lPart and: vPart and: tPart
	"Algorithmic Hangul Syllable Componsition.
	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"
	
	| lIndex vIndex tIndex |
	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.
   nCount := 588. tCount := 28."
	^ ((lPart between: 16r1100 and: 16r1112) 
			and: [ (vPart between: 16r1161 and: 16r1175)
				and: [ tPart between: 16r11A7 and: 16r11C2 ] ])
				ifTrue: [ 
					lIndex := lPart - 16r1100.
					vIndex := vPart - 16r1161.
					tIndex := tPart - 16r11A7.
					16rAC00 + (lIndex * 588) + (vIndex * 28) + tIndex ]! !
!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
hangulLVCombinationOf: lPart and: vPart
	"Algorithmic Hangul Syllable Componsition.
	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"
	
	| lIndex vIndex |
	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.
   nCount := 588. tCount := 28."
	^ ((lPart between: 16r1100 and: 16r1112) 
		and: [ vPart between: 16r1161 and: 16r1175 ])
			ifTrue: [ 
				lIndex := lPart - 16r1100.
				vIndex := vPart - 16r1161.
				^ 16rAC00 + (lIndex * 588) + (vIndex * 28) ]! !
!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
hangulSTCombinationOf: sPart and: tPart
	"Algorithmic Hangul Syllable Componsition.
	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"
	
	| tIndex |
	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.
   nCount := 588. tCount := 28."
	^ ((sPart between: 16rAC00 and: 16rD7A3)
		and: [ (tPart between: 16r11A7 and: 16r11C2)
			and: [ sPart - 16rAC00 \\ 28 = 0 ] ])
			ifTrue: [ 
				tIndex := tPart - 16r11A7.
				sPart + tIndex ]! !
!UnicodeComposer methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 15:39'!
initializeForComposition
	combinations := IdentityDictionary new.
	combiningCharacters := IdentitySet new.
	UnicodeCharacterData database valuesDo: [ :each |
		each isPrimaryComposite ifTrue: [ | combination |
			combination := each decompositionMapping.
			"combination first + combination second = each codePoint"
			combinations 
				at: combination first 
				ifPresent: [ :value | 
					value at: combination second put: each codePoint ]
				ifAbsent: [ | value |
					value := IdentityDictionary new at: combination second put: each codePoint; yourself.
					combinations at: combination first put: value ].
			combiningCharacters add: combination second ] ]! !
!UnicodeComposer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
isCombiningCharacter: codePoint
	^ self combiningCharacters includes: codePoint! !
!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
primaryCombinationOf: first and: second
	"Resolve Primary Composition using inverse computed table"
	
	^ (self isCombiningCharacter: second)
			ifTrue: [ 
				self combinations 
					at: first 
					ifPresent: [ :compositions | 
						compositions at: second ifAbsent: [ ] ] 
					ifAbsent: [ ] ]! !
!UnicodeComposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
scanForStarterFrom: input to: output
	| current |
	"Find the first starter in input and return it, else copy to output"
	[ input atEnd ] whileFalse: [ 
		current := input next.
		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])
			ifTrue: [ ^ current ]
			ifFalse: [ output nextPut: current ] ].
	^ nil! !
!UnicodeComposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!
scanUntilStarterFrom: input to: buffer
	| current |
	"Put non-starters and the next starter from input in the buffer, if any"
	[ input atEnd ] whileFalse: [ 
		current := input next.
		buffer addLast: current.
		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])
			ifTrue: [ ^ self ] ]! !
!UnicodeComposingReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 22:32'!
on: codePointReadStream
	^ self new
		on: codePointReadStream;
		yourself! !
!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 14:44'!
atEnd
	^ buffer isEmpty and: [ self isFirstEmpty and: [ input atEnd ] ]! !
!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:46'!
consumeFirst
	| current |
	current := first.
	first := nil.
	^ current! !
!UnicodeComposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
initialize
	super initialize.
	buffer := OrderedCollection new.
	composer := UnicodeComposer default! !
!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:43'!
isFirstEmpty
	^ first isNil or: [ first = #initialized ]! !
!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 17:04'!
next
	self isFirstEmpty
		ifFalse: [ ^ self consumeFirst ].
	self shouldGetNextChunk 
		ifTrue: [ self nextChunk ].
	self isFirstEmpty
		ifFalse: [ ^ self consumeFirst ].
	buffer ifEmpty: [ ^ nil ].
	^ buffer removeFirst! !
!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:41'!
nextChunk
	"Initialize when needed, try putting first starter in buffer"
	first = #initialized 
		ifFalse: [ 
			self scanFirstStarter 
				ifFalse: [ "Non-starter is in first" ^ self ] ].
	"buffer = <starter1>"
	[
		self scanUntilStarter.
		"buffer = <starter1> ... <starter2>"
		composer composeBuffer: buffer ] 
			doWhileFalse: [ buffer size > 1 or: [ input atEnd ] ]
	"There has to be more than one element in the buffer unless we're eof.
	Composition shrinks the buffer, sometimes recursively, but can need additional starters"
! !
!UnicodeComposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 22:32'!
on: codePointReadStream
	input := codePointReadStream ! !
!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 17:04'!
peek
	self isFirstEmpty
		ifFalse: [ ^ first ].
	self shouldGetNextChunk 
		ifTrue: [ self nextChunk ].
	self isFirstEmpty
		ifFalse: [ ^ first ].
	buffer ifEmpty: [ ^ nil ].
	^ buffer first! !
!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 2/15/2016 20:42'!
reset
	input reset.
	buffer removeAll! !
!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:14'!
scanFirstStarter
	| current |
	"Find the first starter in input to use, put it in buffer and return true.
	Else put the non-starter in first and return false.
	Switch to #initialized once we've seen the first starter or when empty."
	input atEnd ifFalse: [ 
		current := input next.
		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])
			ifTrue: [ 
				buffer addLast: current. 
				first := #initialized. 
				^ true ]
			ifFalse: [ 
				first := current. 
				^ false ] ].
	first := #inialized.
	^ false! !
!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 00:10'!
scanUntilStarter
	| current |
	"Put non-starters and the next starter from input in the buffer, if any"
	[ input atEnd ] whileFalse: [ 
		current := input next.
		buffer addLast: current.
		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])
			ifTrue: [ ^ self ] ]! !
!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 17:06'!
shouldGetNextChunk
	"One element should remain in the buffer for the next iteration unless we're eof"
	
	^ buffer isEmpty or: [ buffer size = 1 and: [ input atEnd not] ]! !
!UnicodeComposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:19'!
unicodeCharacters
	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"
	
	^ CharacterFromCodePointReadStream on: self! !
!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 22:33'!
upToEnd
	^ Array streamContents: [ :out |
			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !
!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!
forNFC
	^ self new forNFC! !
!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!
forNFD
	^ self new forNFD! !
!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!
forNFKC
	^ self new forNFKC! !
!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!
forNFKD
	^ self new forNFKD! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:01'!
codePointsToNFC: codePoints
	^ codePoints readStream unicodeNFC upToEnd! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:03'!
codePointsToNFD: codePoints
	^ codePoints readStream unicodeNFD upToEnd! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:01'!
codePointsToNFKC: codePoints
	^ codePoints readStream unicodeNFKC upToEnd! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:04'!
codePointsToNFKD: codePoints
	^ codePoints readStream unicodeNFKD upToEnd! !
!UnicodeConcatenator methodsFor: 'public' stamp: 'SvenVanCaekenberghe 12/31/2015 17:23'!
concatenateCodePoints: first with: second
	| lastStable firstStable middle result |
	first ifEmpty: [ ^ second ].
	second ifEmpty: [ ^ first ].
	lastStable := first findLast: self isStableCodePointBlock.
	lastStable = 0 ifTrue: [ lastStable := 1 ].
	firstStable := second findFirst: self isStableCodePointBlock.
	firstStable = 0 ifTrue: [ firstStable := second size ].
	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].
	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).
	middle := self normalizeCodePoints: middle.
	result := first class new: (lastStable - 1 + middle size + second size - firstStable).
	result 
		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;
		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;
		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 
	^ result! !
!UnicodeConcatenator methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/5/2016 10:30'!
concatenateString: first with: second
	| lastStable firstStable middle result |
	first ifEmpty: [ ^ second ].
	second ifEmpty: [ ^ first ].
	lastStable := first findLast: self isStableCharacterBlock.
	lastStable = 0 ifTrue: [ lastStable := 1 ].
	firstStable := second findFirst: self isStableCodePointBlock.
	firstStable = 0 ifTrue: [ firstStable := second size ].
	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].
	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).
	middle := self normalizeString: middle.
	result := first class new: (lastStable - 1 + middle size + second size - firstStable).
	result 
		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;
		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;
		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 
	^ result
! !
!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:12'!
forNFC
	property := #NFC.! !
!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:12'!
forNFD
	property := #NFD.! !
!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:13'!
forNFKC
	property := #NFKC.! !
!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:13'!
forNFKD
	property := #NFKD.! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:40'!
isStableCharacterBlock
	| quickCheckProperty |
	quickCheckProperty := self quickCheckProperty.
	^ [ :each | 
		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 
			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each codePoint) = #Y ] ]! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:40'!
isStableCodePointBlock
	| quickCheckProperty |
	quickCheckProperty := self quickCheckProperty.
	^ [ :each | 
		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 
			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each) = #Y ] ]! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/31/2015 18:21'!
normalizeCodePoints: codePoints
	| method |
	method := (#codePointsTo, property) asSymbol asMutator.
	^ self perform: method with: codePoints ! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/5/2016 10:30'!
normalizeString: string
	| method |
	method := (#stringTo, property) asSymbol asMutator.
	^ self perform: method with: string ! !
!UnicodeConcatenator methodsFor: 'acccessing' stamp: 'SvenVanCaekenberghe 1/5/2016 10:19'!
quickCheckProperty
	^ (property , #'_QC') asSymbol! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
stringToNFC: string
	^ UnicodeNormalizer new toNFC: string! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
stringToNFD: string
	^ UnicodeNormalizer new toNFD: string! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
stringToNFKC: string
	^ UnicodeNormalizer new toNFKC: string! !
!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
stringToNFKD: string
	^ UnicodeNormalizer new toNFKD: string! !
!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!
add: codePoint cccOrderedTo: buffer
	| ccc index stop otherCCC |
	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].
	index := buffer size.
	ccc = 0 
		ifFalse: [
			stop := false.
			[ index > 0 & stop not ] whileTrue: [ 
				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].
				ccc < otherCCC
					ifTrue: [ index := index - 1 ]
					ifFalse: [ stop := true ] ] ].
	buffer add: codePoint afterIndex: index! !
!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!
addCompatibleMapping: codePoint to: buffer
	| ucd |
	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].
	(ucd notNil and: [ ucd hasDecomposition ])
		ifTrue: [ 
			ucd hasCanonicalDecomposition 
				ifTrue: [ 
					ucd decompositionMapping do: [ :each | 
						self addCompatibleMapping: each to: buffer ] ]
				ifFalse: [ 
					ucd decompositionMapping allButFirstDo: [ :each | 
						self addCompatibleMapping: each to: buffer ] ] ]
		ifFalse: [ self add: codePoint cccOrderedTo: buffer ]! !
!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!
addMapping: codePoint to: buffer
	| ucd |
	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].
	(ucd notNil and: [ ucd hasCanonicalDecomposition ])
		ifTrue: [ 
			ucd decompositionMapping do: [ :each | 
				self addMapping: each to: buffer ] ]
		ifFalse: [ self add: codePoint cccOrderedTo: buffer ]! !
!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!
addNonStartersFrom: input to: buffer
	| stop |
	stop := false.
	[ input atEnd | stop ] whileFalse: [ 
		([ input peek unicodeCharacterData isStarter not ] on: NotFound do: [ false ])
			ifTrue: [ self addMapping: input next to: buffer ]
			ifFalse: [ stop := true ] ]! !
!UnicodeDecomposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:24'!
decomposeCompatibleFrom: input to: output
	| buffer |
	buffer := OrderedCollection new.
	[ input atEnd ] whileFalse: [ 
		self addCompatibleMapping: input next to: buffer.
		self addNonStartersFrom: input to: buffer.
		"The additions to the buffer above were done respecting the CCC order, so we're done"
		output nextPutAll: buffer.
		buffer reset ]! !
!UnicodeDecomposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!
decomposeFrom: input to: output
	| buffer |
	buffer := OrderedCollection new.
	[ input atEnd ] whileFalse: [ 
		self addMapping: input next to: buffer.
		self addNonStartersFrom: input to: buffer.
		"The additions to the buffer above were done respecting the CCC order, so we're done"
		output nextPutAll: buffer.
		buffer reset ]! !
!UnicodeDecomposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:48'!
decomposeString: string
	"Return the NFD of string, the canonical decomposition normal form"
	
	(string isByteString and: [ string isAsciiString ]) ifTrue: [
		"ACII strings are already in NFD" 
		^ string ]. 
	^ String streamContents: [ :out |
			self 
				decomposeFrom: string readStream unicodeCodePoints
				to: out unicodeCodePoints ]! !
!UnicodeDecomposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:48'!
decomposeStringCompatible: string
	"Return the NFKD of string, the compatible decomposition normal form"
	
	(string isByteString and: [ string isAsciiString ]) ifTrue: [
		"ACII strings are already in NFKD" 
		^ string ]. 
	^ String streamContents: [ :out |
			self 
				decomposeCompatibleFrom: string readStream unicodeCodePoints
				to: out unicodeCodePoints ]! !
!UnicodeDecomposingReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:54'!
on: codePointReadStream
	^ self new
		on: codePointReadStream;
		yourself! !
!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:28'!
addMappingFor: codePoint
	"Recursively expand codePoint to buffer"
	self subclassResponsibility! !
!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:29'!
addNonStarters
	"Peek forward for additional non-starters and add them to buffer, if any"
	| stop |
	stop := false.
	[ input atEnd | stop ] whileFalse: [ 
		([ input peek unicodeCharacterData isStarter not ] on: NotFound do: [ false ])
			ifTrue: [ self addMappingFor: input next ]
			ifFalse: [ stop := true ] ]! !
!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:55'!
addToBufferCccOrdered: codePoint
	| ccc index stop otherCCC |
	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].
	index := buffer size.
	ccc = 0 
		ifFalse: [
			stop := false.
			[ index > 0 & stop not ] whileTrue: [ 
				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].
				ccc < otherCCC
					ifTrue: [ index := index - 1 ]
					ifFalse: [ stop := true ] ] ].
	buffer add: codePoint afterIndex: index! !
!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 14:18'!
atEnd
	^ buffer isEmpty and: [ input atEnd ]! !
!UnicodeDecomposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:55'!
initialize
	super initialize.
	buffer := OrderedCollection new! !
!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 00:08'!
next
	buffer ifEmpty: [ self nextChunk ].
	buffer ifEmpty: [ ^ nil ].
	^ buffer removeFirst! !
!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 10:09'!
nextChunk
	input atEnd
		ifFalse: [  
			self addMappingFor: input next.
			self addNonStarters.
			"The additions to the buffer above were done respecting the CCC order, so we're done" ]! !
!UnicodeDecomposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:55'!
on: codePointReadStream
	input := codePointReadStream ! !
!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 00:08'!
peek
	buffer ifEmpty: [ self nextChunk ].
	buffer ifEmpty: [ ^ nil ].
	^ buffer first! !
!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'HenrikSperreJohansen 2/16/2016 00:20'!
reset
	input reset.
	buffer removeAll! !
!UnicodeDecomposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:19'!
unicodeCharacters
	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"
	
	^ CharacterFromCodePointReadStream on: self! !
!UnicodeDecomposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
unicodeCompose
	"Return a NeoUnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"
	
	^ UnicodeComposingReadStream on: self! !
!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 21:54'!
upToEnd
	^ Array streamContents: [ :out |
			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !
!UnicodeNFDReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:56'!
addMappingFor: codePoint
	| ucd |
	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].
	(ucd notNil and: [ ucd hasCanonicalDecomposition ])
		ifTrue: [ 
			ucd decompositionMappingDo: [ :each | self addMappingFor: each ] ]
		ifFalse: [ 
			self addToBufferCccOrdered: codePoint ]! !
!UnicodeNFKDReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:56'!
addMappingFor: codePoint
	| ucd |
	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].
	(ucd notNil and: [ ucd hasDecomposition ])
		ifTrue: [ 
			ucd decompositionMappingDo: [ :each | self addMappingFor: each  ] ]
		ifFalse: [ 
			self addToBufferCccOrdered: codePoint ]! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!
composeString: string
	"Return the NFC of string, the canonical composition normal form"
	
	(self isAlreadyNFC: string) ifTrue: [ ^ string ]. 
	^ string readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!
composeStringCompatible: string
	"Return the NFKC of string, the compatible composition normal form"
	
	(self isAlreadyNFKC: string) ifTrue: [ ^ string ]. 
	^ string readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!
decomposeString: string
	"Return the NFD of string, the canonical decomposition normal form"
	
	(self isAlreadyNFD: string) ifTrue: [ ^ string ]. 
	^ string readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!
decomposeStringCompatible: string
	"Return the NFKD of string, the compatible decomposition normal form"
	
	(self isAlreadyNFKD: string) ifTrue: [ ^ string ]. 
	^ string readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:37'!
isAlreadyNFC: string
	"Return true when we know string is already in NFC form, false otherwise.
	This uses a quick check algorithm.
	False means we don't know, but it is still possible. 
	The only way to know for sure is to do the actual conversion."
	
	"Latin1 strings are always in NFC"
	^ string isByteString or: [ 
		(UnicodeCharacterData normalizationQuickCheck: #NFC_QC forString: string) = #Y ]! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!
isAlreadyNFD: string
	"Return true when we know string is already in NFD form, false otherwise.
	This uses a quick check algorithm.
	False means we don't know, but it is still possible. 
	The only way to know for sure is to do the actual conversion."

	"ASCII strings are always in NFD"
	^ (string isByteString and: [ string isAsciiString ])
		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFD_QC forString: string) = #Y ]! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!
isAlreadyNFKC: string
	"Return true when we know string is already in NFKC form, false otherwise.
	This uses a quick check algorithm.
	False means we don't know, but it is still possible. 
	The only way to know for sure is to do the actual conversion."

	"ASCII strings are always in NFKC"
	^ (string isByteString and: [ string isAsciiString ])
		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKC_QC forString: string) = #Y ]! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!
isAlreadyNFKD: string
	"Return true when we know string is already in NFKD form, false otherwise.
	This uses a quick check algorithm.
	False means we don't know, but it is still possible. 
	The only way to know for sure is to do the actual conversion."

	"ASCII strings are always in NFKD"
	^ (string isByteString and: [ string isAsciiString ])
		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKD_QC forString: string) = #Y ]! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!
isNFC: string
	"Return true when string is in NFC form, false otherwise"
	
	^ string = (self toNFC: string)! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!
isNFD: string
	"Return true when string is in NFD form, false otherwise"
	
	^ string = (self toNFD: string)! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!
isNFKC: string
	"Return true when string is in NFC form, false otherwise"
	
	^ string = (self toNFKC: string)! !
!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!
isNFKD: string
	"Return true when string is in NFKD form, false otherwise"
	
	^ string = (self toNFKD: string)! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!
toNFC: string
	^ self composeString: string! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!
toNFD: string
	^ self decomposeString: string! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!
toNFKC: string
	^ self composeStringCompatible: string! !
!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:43'!
toNFKD: string
	^ self decomposeStringCompatible: string! !
!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:03'!
unicodeCompose
	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"
	
	^ UnicodeComposingReadStream on: self! !
!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/28/2016 22:30'!
unicodeNFC
	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"
	
	^ self unicodeNFD unicodeCompose! !
!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:03'!
unicodeNFD
	"Return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"
	
	^ UnicodeNFDReadStream on: self! !
!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/28/2016 22:30'!
unicodeNFKC
	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"
	
	^ self unicodeNFKD unicodeCompose! !
!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!
unicodeNFKD
	"Return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"
	
	^ UnicodeNFKDReadStream on: self! !
!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!
unicodeCompose
	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"
	
	^ UnicodeComposingReadStream on: self! !
!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!
unicodeNFC
	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"
	
	^ (UnicodeNFDReadStream on: self) unicodeCompose! !
!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!
unicodeNFD
	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"
	
	^ UnicodeNFDReadStream on: self! !
!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!
unicodeNFKC
	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"
	
	^ (UnicodeNFKDReadStream on: self) unicodeCompose! !
!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!
unicodeNFKD
	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"
	
	^ UnicodeNFKDReadStream on: self! !

"Unicode-Normalization"!
!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!
testDigitOne
	| unicodeCharacterData |
	unicodeCharacterData := $1 unicodeCharacterData.
	self assert: unicodeCharacterData codePoint equals: 49.
	self assert: unicodeCharacterData character equals: $1.
	self assert: unicodeCharacterData name equals: 'DIGIT ONE'.
	self assert: unicodeCharacterData isNumber.
	self deny: unicodeCharacterData isLetter.
	self assert: unicodeCharacterData isNumberDecimal.
	self assert: unicodeCharacterData decimalDigitValue equals: 1! !
!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!
testLatinCapitalLetterA
	| unicodeCharacterData |
	unicodeCharacterData := $A unicodeCharacterData.
	self assert: unicodeCharacterData codePoint equals: 65.
	self assert: unicodeCharacterData character equals: $A.
	self assert: unicodeCharacterData name equals: 'LATIN CAPITAL LETTER A'.
	self assert: unicodeCharacterData isLetter.
	self deny: unicodeCharacterData isNumber.
	self assert: unicodeCharacterData isUppercase.
	self assert: unicodeCharacterData lowercase equals: $a codePoint! !
!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!
testLatinSmallLetterA
	| unicodeCharacterData |
	unicodeCharacterData := $a unicodeCharacterData.
	self assert: unicodeCharacterData codePoint equals: 97.
	self assert: unicodeCharacterData character equals: $a.
	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER A'.
	self assert: unicodeCharacterData isLetter.
	self deny: unicodeCharacterData isNumber.
	self assert: unicodeCharacterData isLowercase.
	self assert: unicodeCharacterData uppercase equals: $A codePoint! !
!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!
testLatinSmallLetterEWithAcute
	| unicodeCharacterData |
	unicodeCharacterData := $é unicodeCharacterData.
	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"
	self assert: unicodeCharacterData codePoint equals: 233.
	self assert: unicodeCharacterData character equals: $é.
	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER E WITH ACUTE'.
	self assert: unicodeCharacterData isLetter.
	self deny: unicodeCharacterData isNumber.
	self assert: unicodeCharacterData isLowercase.
	self assert: unicodeCharacterData uppercase equals: $É codePoint.
	self assert: unicodeCharacterData hasStandardCanonicalDecomposition.
	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"
	self assert: unicodeCharacterData decompositionMapping equals: #(101 769)! !

"Unicode-Tests-Character-Data"!
!UnicodeCaserTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 15:07'!
setUp
	caser := UnicodeCaser new! !
!UnicodeCaserTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/8/2015 20:24'!
testLowercase
	self assert: (caser case: #lowercase string: 'ABC') equals: 'abc'.
	self assert: (caser case: #lowercase string: '123 !!= abc') equals: '123 !!= abc'.! !
!UnicodeCaserTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/8/2015 20:24'!
testUppercase
	self assert: (caser case: #uppercase string: 'abc') equals: 'ABC'.
	self assert: (caser case: #uppercase string: '123 !!= ABC') equals: '123 !!= ABC'.! !

"Unicode-Tests-Casing"!
!UnicodeNormalizerConformanceTests commentStamp: 'SvenVanCaekenberghe 12/11/2015 23:08' prior: 0!
This test uses http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt to run about 75.000 individual test cases to test conformance to the official Unicode Normalization specification.!
!UnicodeNormalizationTestResource commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:20' prior: 0!
I hold the contents of NormalizationTest.txt loaded from a URL.

  UnicodeNormalizationTestResource new setUp

http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt

# Normalization Test Suite
# Format:
#
#   Columns (c1, c2,...) are separated by semicolons
#   They have the following meaning:
#      source; NFC; NFD; NFKC; NFKD
#   Comments are indicated with hash marks
#   Each of the columns may have one or more code points.
#
# CONFORMANCE:
# 1. The following invariants must be true for all conformant implementations
#
#    NFC
#      c2 ==  toNFC(c1) ==  toNFC(c2) ==  toNFC(c3)
#      c4 ==  toNFC(c4) ==  toNFC(c5)
#
#    NFD
#      c3 ==  toNFD(c1) ==  toNFD(c2) ==  toNFD(c3)
#      c5 ==  toNFD(c4) ==  toNFD(c5)
#
#    NFKC
#      c4 == toNFKC(c1) == toNFKC(c2) == toNFKC(c3) == toNFKC(c4) == toNFKC(c5)
#
#    NFKD
#      c5 == toNFKD(c1) == toNFKD(c2) == toNFKD(c3) == toNFKD(c4) == toNFKD(c5)
#
# 2. For every code point X assigned in this version of Unicode that is not specifically
#    listed in Part 1, the following invariants must be true for all conformant
#    implementations:
#
#      X == toNFC(X) == toNFD(X) == toNFKC(X) == toNFKD(X)!
!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
testASCII
	self 
		assert: (UnicodeConcatenator forNFC concatenateString: 'abc' with: 'def')
		equals: 'abcdef'
	! !
!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
testDiacritics
	self 
		assert: (UnicodeConcatenator forNFC concatenateString: 'éle' with: '̀ves')
		equals: 'élèves'.
	self 
		assert: (UnicodeConcatenator forNFC concatenateString: 'Ko' with: '̈nigsallee')
		equals: 'Königsallee'.
	! !
!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
testSimple
	self 
		assert: (UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102))
		equals: #(97 98 99 233 100 101 102)
	! !
!UnicodeNormalizerConformanceTests class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 15:10'!
resources
	^ Array with: UnicodeNormalizationTestResource ! !
!UnicodeNormalizerConformanceTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
setUp
	normalizer := UnicodeNormalizer new.
	composer := UnicodeComposer default.
	decomposer := UnicodeDecomposer new! !
!UnicodeNormalizerConformanceTests methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 15:10'!
specification
	^ UnicodeNormalizationTestResource current data! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:18'!
testNFC
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | nfd result |
		nfd := Array streamContents: [ :out |
			decomposer decomposeFrom: (spec at: #source) readStream to: out ].
		result := Array streamContents: [ :out |
			composer composeFrom: nfd readStream to: out ].
		result = (spec at: #NFC)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFC {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:02'!
testNFCStreaming
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | result |
		result := (spec at: #source) readStream unicodeNFC upToEnd.
		result = (spec at: #NFC)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFCStreaming {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:30'!
testNFCString
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | in out result |
		in := (spec at: #source) collect: #asCharacter as: WideString.
		out := normalizer toNFC: in.
		result := out collect: #codePoint as: Array.
		result = (spec at: #NFC)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFCString {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:17'!
testNFD
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | result |
		result := Array streamContents: [ :out |
			decomposer decomposeFrom: (spec at: #source) readStream to: out ].
		result = (spec at: #NFD)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFD {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:03'!
testNFDStreaming
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | result |
		result := (spec at: #source) readStream unicodeNFD upToEnd.
		result = (spec at: #NFD)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFDStreaming {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:48'!
testNFDString
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | in out result |
		in := (spec at: #source) collect: #asCharacter as: WideString.
		out := normalizer toNFD: in.
		result := out collect: #codePoint as: Array.
		result = (spec at: #NFD)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFDString {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:20'!
testNFKC
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | nfkd result |
		nfkd := Array streamContents: [ :out |
			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].
		result := Array streamContents: [ :out |
			composer composeFrom: nfkd readStream to: out ].
		result = (spec at: #NFKC)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFKC {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:02'!
testNFKCStreaming
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | result |
		result := (spec at: #source) readStream unicodeNFKC upToEnd.
		result = (spec at: #NFKC)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFKCStreaming {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:49'!
testNFKCString
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | in out result |
		in := (spec at: #source) collect: #asCharacter as: WideString.
		out := normalizer toNFKC: in.
		result := out collect: #codePoint as: Array.
		result = (spec at: #NFKC)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFKCString {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:17'!
testNFKD
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | result |
		result := Array streamContents: [ :out |
			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].
		result = (spec at: #NFKD)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFKD {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:06'!
testNFKDStreaming
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | result |
		result := (spec at: #source) readStream unicodeNFKD upToEnd.
		result = (spec at: #NFKD)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFKDStreaming {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:48'!
testNFKDString
	| failed succeeded |
	failed := OrderedCollection new.
	succeeded := 0.
	self specification do: [ :spec | | in out result |
		in := (spec at: #source) collect: #asCharacter as: WideString.
		out := normalizer toNFKD: in.
		result := out collect: #codePoint as: Array.
		result = (spec at: #NFKD)
			ifTrue: [ succeeded := succeeded + 1 ]
			ifFalse: [ failed add: spec -> result ] ].
	self crLog: ('#testNFKDString {1}/{2} ({3}%)' format: { 
		succeeded. self specification size. 
		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).
	self assert: failed isEmpty! !
!UnicodeNormalizerTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!
setUp
	normalizer := UnicodeNormalizer new.
	composer := UnicodeComposer default.
	decomposer := UnicodeDecomposer new! !
!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/12/2016 10:44'!
testAsciiIsAlwaysNormalized
	| ascii nfc nfd nfkc nfkd |
	"ASCII strings are identical to all 4 normalization forms"
	ascii := String withAll: ((0 to: 127) collect: #asCharacter).
	"we have to circumvent the optimizations done in the convenience methods"
	nfc := ascii readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.
	self assert: nfc equals: ascii. 
	nfd := ascii readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd.
	self assert: nfd equals: ascii. 
	nfkc := ascii readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd.
	self assert: nfkc equals: ascii. 
	nfkd := ascii readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd.
	self assert: nfkd equals: ascii! !
!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:54'!
testFundamentalComposition
	| in out |
	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"
	in := #(101 769).
	out := Array streamContents: [ :writeStream |
		composer composeFrom: in readStream to: writeStream ].
	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"
	self assert: out equals: #(233)! !
!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:54'!
testFundamentalDecomposition
	| in out |
	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"
	in := #(233).
	out := Array streamContents: [ :writeStream |
		decomposer decomposeFrom: in readStream to: writeStream ].
	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"
	self assert: out equals: #(101 769).! !
!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:53'!
testHangul
	"an lpart - vpart pair"
	self 
		assert: 16rAC1C unicodeCharacterData decompositionMapping 
		equals: #(16r1100 16r1162).
	self
		assert: (composer hangulCombinationOf: 16r1100 and: 16r1162)
		equals: 16rAC1C.	
	"an lpart - vpart - tpart triplet"
	self 
		assert: 16rD4DB unicodeCharacterData decompositionMapping 
		equals: #(16r1111 16r1171 16r11B6).
	self
		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171 and: 16r11B6) 
		equals: 16rD4DB.
	"converting an lpart - vpart - tpart triplet in two steps"
	self
		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171)
		equals: 16rD4CC.	
	self
		assert: (composer hangulCombinationOf: 16rD4CC and: 16r11B6)
		equals: 16rD4DB	
! !
!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/12/2016 10:43'!
testLatin1IsAlwaysInNFC
	| latin1 nfc |
	"Latin1 strings are identical to their NFC normalization form"
	latin1 := String withAll: ((0 to: 255) collect: #asCharacter).
	"we have to circumvent the optimizations done in the convenience methods"
	nfc := latin1 readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.
	self assert: nfc equals: latin1! !
!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 12/8/2015 12:53'!
testSimple
	| original composed decomposed |
	original := 'les élèves Français'.
	decomposed := normalizer decomposeString: original.
	self assert: decomposed equals: 'les élèves Français'.
	composed := normalizer composeString: decomposed.
	self assert: composed equals: original.
	original := 'Düsseldorf Königsallee'.
	decomposed := normalizer decomposeString: original.
	self assert: decomposed equals: 'Düsseldorf Königsallee'.
	composed := normalizer composeString: decomposed.
	self assert: composed equals: original.
	! !
!UnicodeNormalizationTestResource methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 12/11/2015 09:48'!
data
	"A collection of dictionaries with keys: #source #NFC #NFD #NFKC #NFKD and #comment"
	
	^ data! !
!UnicodeNormalizationTestResource methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/28/2016 11:09'!
normalizationTestFile
	^ 'NormalizationTest.txt'! !
!UnicodeNormalizationTestResource methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 1/28/2016 11:11'!
parseLine: line
	| columns test comment |
	columns := $; split: line.
	test := SmallDictionary new.
	#(#source #NFC #NFD #NFKC #NFKD) doWithIndex: [ :key :number | 
		| value |
		value := columns at: number.
		value := $  split: value.
		value := value collect: [ :each | Integer readFrom: each base: 16 ] as: Array.
		test at: key put: value ].
	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.
	test at: #comment put: comment.
	^ test! !
!UnicodeNormalizationTestResource methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/28/2016 11:10'!
setUp
	data := Array streamContents: [ :out | 
		(UnicodeCharacterData getUnicodeCharacterDatabaseRaw: self normalizationTestFile) linesDo: [ :line | 
			(line isEmpty or: [ line first = $# or: [ line first = $@ ] ])
				ifFalse: [ 
					| test |
					test := self parseLine: line.
					out nextPut: test ] ] ]! !

"Unicode-Tests-Normalization"!
!OSSAbstractUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
commandClass
	^ OSSUnixSubprocess ! !
!OSSAbstractUnixSubprocessTest methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
newCommand
	
	^ self commandClass new! !
!OSSAbstractUnixSubprocessTest methodsFor: 'private' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
systemAccessor
	^ OSSVMProcess vmProcess systemAccessor! !
!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
blockingPipe
	^ self systemAccessor makeBlockingPipe
	! !
!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
nonBlockingPipe
	^ self systemAccessor makeNonBlockingPipe
	! !
!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
readFromAndClose: aPipe writingTo: aStream

	| s |
	[aPipe atEndOfFile] whileFalse:
		[s := aPipe next: 10000.
		aStream nextPutAll: s asString.
		(Delay forMilliseconds: 100) wait].
	(aPipe respondsTo: #reader) ifTrue: [aPipe reader close].
	^ aStream
! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicWriteAndRead
	| pipe string readString |
	string := 'this is a testing string'. 
	pipe := self blockingPipe.
	pipe writer nextPutAll: string; flush.
	readString := pipe reader next: string size.
	self assert: string equals: readString! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBlocking

	| pipe |
	pipe := self blockingPipe.
	(1 to: 10) do: [:i | pipe nextPutAll: 'this is line ', i printString; cr].
	pipe flush. "protect against buggy clib that may never flush output"
	self should: ['this is line 1*' match: (pipe next: 15)].
	self should: ['this is line 2*' match: (pipe next: 15)].
	self should: ['this is line 3*' match: (pipe next: 15)].
	self should: ['this is line 4*' match: (pipe next: 15)].
	self should: ['this is line 5*' match: (pipe next: 15)].
	self should: ['this is line 6*' match: (pipe next: 15)].
	self should: ['this is line 7*' match: (pipe next: 15)].
	self should: ['this is line 8*' match: (pipe next: 15)].
	self should: ['this is line 9*' match: (pipe next: 15)].
	pipe writer close.
	self shouldnt: pipe atEnd.
	self should: ['this is line 10*' match: (pipe next: 16)].
	self should: pipe atEnd.
	pipe close
! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBlockingPeek

		| pipe |
	pipe := self blockingPipe.
	pipe nextPutAll: 'abc'.
	pipe flush. "protect against buggy clib that may never flush output"
	self assert: (pipe peek == $a).
	self assert: (pipe next == $a).
	self assert: (pipe peek == $b).
	self assert: (pipe next == $b).
	self assert: (pipe peek == $c).
	self deny: pipe atEnd.
	self assert: (pipe next == $c).
	self deny: pipe atEnd.
	pipe closeWriter.
	self assert: pipe atEnd.
	pipe close
! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testIsAtEndOfFile

	| pipe |
	pipe := self nonBlockingPipe.

	self deny: (pipe reader atEndOfFile).
	self deny: pipe reader atEnd.
	self deny: pipe atEnd.
	self assert: (pipe reader basicNext == nil).
	self deny: (pipe reader atEndOfFile).
	self deny: pipe reader atEnd.
	self deny: pipe atEnd.
	pipe writer nextPut: $X; flush.
	self assert: (pipe reader basicNext == $X).
	self deny: (pipe reader atEndOfFile).
	self deny: pipe reader atEnd.
	self deny: pipe atEnd.
	self assert: (pipe reader basicNext == nil).
	self deny: (pipe reader atEndOfFile).
	self deny: pipe reader atEnd.
	self deny: pipe atEnd.

	pipe writer close.
	self deny: (pipe reader atEndOfFile).
	self deny: pipe atEndOfFile. "no read yet, so flag has not been set"
	
	"From Pharo 7 on, #atEnd does detect EOF on a pipe"
	SystemVersion current major >= 7
		ifTrue: [ self assert: pipe reader atEnd ].

	self assert: pipe atEnd. "writer closed and read gives nil"

	self assert: (pipe reader basicNext == nil). "read operation should set flag"
	self assert: (pipe reader atEndOfFile).

	"From Pharo 7 on, #atEnd does detect EOF on a pipe"
	SystemVersion current major >= 7
		ifTrue: [ self assert: pipe reader atEnd ].
	
	self assert: pipe reader atEndOfFile.
	self assert: pipe atEnd.
	pipe close
! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testIsAtEndOfFile2

	| pipe string |
	pipe := self nonBlockingPipe.
	[pipe nextPutAll: 'hello'; flush.
	string := pipe next: 100.
	self assert: string = 'hello'.
	self deny: pipe atEndOfFile.
	pipe closeWriter.
	self deny: pipe atEndOfFile.
	string := pipe next: 100.
	self assert: string = ''.
	self assert: pipe atEndOfFile]
		ensure: [pipe close]
! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testNonBlocking

	| pipe writeStream string |
	pipe := self nonBlockingPipe.
	self writeStuffOnThenClose: pipe.
	writeStream := self readFromAndClose: pipe writingTo: (WriteStream on: String new).
	string := (writeStream contents last: 16).
	self should: ['this is line 10*' match: string].
	pipe close
! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testNonBlockingPeek

	| pipe |
	pipe := self nonBlockingPipe.
	pipe nextPutAll: 'abc'; flush.
	self assert: (pipe peek == $a).
	self assert: (pipe next == $a).
	self assert: (pipe peek == $b).
	self assert: (pipe next == $b).
	self assert: (pipe peek == $c).
	self deny: pipe atEnd.
	self assert: (pipe next == $c).
	self deny: pipe atEnd.
	pipe closeWriter.
	self assert: pipe atEnd.
	pipe close
! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testReadAfterClosedReadEnd
	| pipe writeStream readStream string |
	string := 'this is a testing string'. 
	pipe := self blockingPipe.
	pipe writer nextPutAll: string; flush.
	readStream := pipe reader.
	pipe closeReader.
	self assert: readStream closed.
	self should: [ readStream upToEndOfFile ] raise: Error.
	self should: [ readStream upToEnd ] raise: Error.
	! !
!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWriteAfterClosedWriteEnd
	| pipe writeStream string |
	string := 'this is a testing string'. 
	pipe := self blockingPipe.
	pipe closeWriter.
	self should: [ pipe writer nextPutAll: string; flush ] raise: Error.
	! !
!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
writeStuffOnThenClose: aPipe

	^ [(1 to: 10) do:
		[:i |
		[aPipe nextPutAll: 'this is line ', i printString; cr]
			on: Error
			do: ["Ignore error. Test case will still fail, and throwing an error in this
				process would cause a debugger to be scheduled inconveniently."].
		(Delay forMilliseconds: 50) wait].
	(aPipe respondsTo: #writer)
		ifTrue: [[aPipe writer close]
					on: Error
					do: ["Ignore error to avoid a debugger"]]
		ifFalse: [[aPipe close]
					on: Error
					do: ["Ignore error to avoid a debugger"]]]
		forkAt: Processor userBackgroundPriority! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
assertStreamsInfoWithPrevious: beforeArray
	| afterArray |
	afterArray := self getStreamsInfoForRunningTest.
	self assert: beforeArray first equals: afterArray first.
	self assert: beforeArray second equals: afterArray second.! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
getStreamsInfoForRunningTest
	"We obtain the open tmp files before the open files because apparently getting the entries of /tmp using
	    '/tmp' asFileReference entries
	
	opens a file descriptor and lets the FD open. Thus #numberOfOpenFiles, using lsof, detects /tmp as an open file and makes the test fail.
	
	This happens only in travis under Ubuntu.
	"
	| openTmpFiles |
	openTmpFiles := self numberOfExistingTempStreamFiles.
	^ Array with: self numberOfOpenFiles with: openTmpFiles! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
newCommand
	| command |
	command := self commandClass new.
	command defaultReadStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsReadStreamOn: '/tmp' ].
	command defaultWriteStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsWriteStreamOn: '/tmp' ].
	^ command 
	! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
numberOfExistingTempStreamFiles
	"This answers the number of files that were created for mapping standard files.
	Note that in OSSUnixSubprocessTest >> newCommand we define that temp files must be created in /tmp
	and in OSSUnixSubprocess >> createTempFilename we can see the format of the name 
	"
	
	^ ('/tmp' asFileReference entries select: [ :each | 
		(each name beginsWith: 'OSSUnixSubprocess-p')  and: [ each name endsWith: '.deleteme' ]  ]) size	! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandWriteToStdin
"testBasicCommandWriteToStdin  fails because of what the documentation says:
	> **Important** We have found some problems when using regular files for the `stdin`. While we do not strictly forbid that, we recommend you do so only if you know very well what you are doing. Otherwise, use blocking pipes for `stdin` (default behavior).

"	
	! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM
	
	"testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM fails on Travis on OSX. It looks like if another test would have run while this one was sleeping and hence in #assertStreamsInfoWithPrevious: it fails because there are 2 new not-closed files...which I suspect that those are from another running test..."
	Smalltalk platform isMacOS 
		ifFalse: [ super testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM ]

! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testReadingFromStdoutDoesNotBlocksVM
	| command | 
	"With files, the reading from stdout does not lock the VM"
	command := self newCommand
					command: '/bin/sleep';
					arguments: (Array with: '4');
					redirectStdout.
	
	command run. 
	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 1. 
	command waitForExit.
	command closeAndCleanStreams.! !
!OSSFileBasedUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testSigTerm
	"Same as super impl but special handling for #assertStreamsInfoWithPrevious:. Read comment at the bottom"
	| process exited streamsInfo |
	
	"We set the sunit test timeout to 2 times the sleep duration.
	Otherwise default sunit test timeout is 1 minute.
	This is for Pharo version >= 6.0"
	(self respondsTo: #timeLimit:) ifTrue: [ 
		self timeLimit: 30 seconds.
	].
	
	exited := false.
	streamsInfo := self getStreamsInfoForRunningTest.
	process := self newCommand.
	[
	process 
		command: 'tail';
		arguments: (Array with: '-f' with: Smalltalk image changesName);
		redirectStdout;
		redirectStderr;
		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 
		doing: [ :aProcess :outStream :errStream |  
		 	outStream upToEnd.
			errStream upToEnd.
		]
		onExitDo: [ :aProcess :outStream :errStream  |
			process closeAndCleanStreams.
			exited := true.
			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'
		].
	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."	
	] forkAt: Processor userInterruptPriority.

	(Delay forSeconds: 2) wait. 
	process sigterm. 
	(Delay forSeconds: 10) wait. 
	self assert: exited.	
	[ 	
		"I could never understood why but only with OSSFileBasedUnixSubprocessTest and only on OSX, randomly (when running many tests together) below assertion fails. I cannod add this test as #expectedFailure because sometimes it works and then when it does it is marked as failure becasue it didn't fail. So I simply skip the test if it failed"
		self assertStreamsInfoWithPrevious: streamsInfo.
	] on: TestFailure do: [ self skip ]! !
!OSSPipeBasedUnixSubprocessTest methodsFor: 'helper' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
newCommand
	
	^ self commandClass new
			"For pipes, we can use a pipe for both reading or writing"
			defaultReadStreamCreationBlock: [self systemAccessor makeBlockingPipe];
			defaultWriteStreamCreationBlock: [self systemAccessor makeNonBlockingPipe];
			yourself 
	
	! !
!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCommandTryToWriteToStdoutButHasNoReader
	| command errString  | 
	command := self newCommand
					shellCommand: 'sleep 2; echo 42';
					redirectStdout;
					redirectStderr.
	
	command run.
	command stdoutStream closeReader.				
	command waitForExit.
	"This should be a SIGPIPE because there is no reader opened for the pipe and someone is trying to write to it. " 
	errString := command stderrStream upToEndOfFile.
	self assert: command exitStatusInterpreter exitStatus > 0. "It ended with error".
	"Ideally I would also add this assert, but it seems not all OS write this on stderr. For example,
	OSX does write it, while Linux does not."
	"self assert:( errString includesSubstring: 'Broken pipe')."
	command closeAndCleanStreams.! !
!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testReadingFromStdoutBlocksVM
	| command customStream | 
	customStream := self systemAccessor makeBlockingPipe.
	command := self newCommand
					command: '/bin/sleep';
					arguments: (Array with: '4');
					redirectStdoutTo: customStream.
	
	command run. 
	self assert:[ command stdoutStream upToEnd ] timeToRun seconds > 2. 
	command waitForExit.
	command closeAndCleanStreams.! !
!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testReadingFromStdoutDoesNotBlocksVM
	| command customStream | 
	customStream := self systemAccessor makeNonBlockingPipe.
	command := self newCommand
					command: '/bin/sleep';
					arguments: (Array with: '4');
					redirectStdoutTo: customStream.
	
	command run. 
	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 2. 
	command waitForExit. 
	command closeAndCleanStreams.! !
!OSSUnixSubprocessTest class methodsFor: 'testing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self name = #OSSUnixSubprocessTest
			! !
!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
assertStreamsInfoWithPrevious: anObject 
	self assert: self getStreamsInfoForRunningTest equals: anObject! !
!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
getStreamsInfoForRunningTest
	^ self numberOfOpenFiles ! !
!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
numberOfOpenFiles
	"This is estimation number. Not to be used for real code. IT's basically 
	to check the number of opened files (regular files, directories, pipes) at the beginning of a  test and at the end, to validate we are not leaving behind opened files. 
	This should work in most Unix-like and Linux
	"
	| tmpFileName openFiles |
	tmpFileName := (FileSystem workingDirectory / 'openFilesByPharoVM-' , UUID new printString) fullName.
	tmpFileName asFileReference ensureDelete.
	self systemAccessor system: ('lsof -p ', OSSVMProcess vmProcess pid printString, ' > "', tmpFileName, '" 2>&1').
	openFiles := tmpFileName asFileReference readStreamDo: [ :str | | lines |
		"We avoid the first header line" 
		lines := str contents lines allButFirst sorted.
		
		"We then ignore all file properties except for the file name"
		lines collect: [ :each | each substrings last ]
	].
	tmpFileName asFileReference ensureDelete.
	^ openFiles
	! !
!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
numberOfZombiesProcesses
	"This is estimation number. Not to be used for real code. IT's basically 
	to check the number of zombies at the beginning of a  test and at the end, to validate we are not leaving behind new zombies. 
	This should work in most Unix-like and Linux
	"
	| tmpFileName zombiesCount |
	tmpFileName := (FileSystem workingDirectory / 'zombiesByPharoVM-' , UUID new printString) fullName.
	tmpFileName asFileReference ensureDelete.
	self systemAccessor system: ('ps axo ppid=,stat= | grep ', OSSVMProcess vmProcess pid printString, ' | awk ''$2~/^Z/ { print $2 }'' | wc -l  > "', tmpFileName, '" 2>&1').
	zombiesCount := tmpFileName asFileReference readStreamDo: [ :str |
		str contents trimmed asNumber
	].
	tmpFileName asFileReference ensureDelete.
	^ zombiesCount
	! !
!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
ppidOf: childPid
	"Answers the parent pid (ppid) of the childPid
	"
	| tmpFileName openFilesNumber |
	tmpFileName := (FileSystem workingDirectory / ' ppidof-' , UUID new printString) fullName.
	tmpFileName asFileReference ensureDelete.
	Transcript show: tmpFileName; cr.
	self systemAccessor system: ('ps -p ', childPid , ' -o ppid=').
	openFilesNumber := tmpFileName asFileReference readStreamDo: [ :str |
		"The -1 is because the above command brings one line which is a header." 
		str contents trimmed asNumber
	].
	tmpFileName asFileReference ensureDelete.
	^ openFilesNumber
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testAddAllEnvVariablesFromParent
	| command | 
	command := self newCommand
					command: '/bin/ls';
					environmentAt: 'WHATEVER' put: 'vi';
					addAllEnvVariablesFromParentWithoutOverride. 

	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size) + 1.
	
	
! !
!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testAddAllEnvVariablesFromParentWithoutOverride
	| command | 
	"Here we assume that the parent process will have the $PATH defined."
	command := self newCommand
					command: '/bin/ls';
					environmentAt: 'PATH' put: 'whatever';
					addAllEnvVariablesFromParentWithoutOverride. 

	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size).
	self assert: (command envVariables at: 'PATH') equals: 'whatever'
	
	
! !
!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testAddOnlyOneVariable
	| command | 
	command := self newCommand
					command: '/bin/ls';
					environmentAt: 'EDITOR' put: 'vi'.

	self assert: command envVariables size equals: 1.
	
	
! !
!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommand
	| command |
	command := self newCommand 
					command: '/bin/ls'.
	command runAndWait.
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandReadFromStderr
	| streamsInfo |
	streamsInfo := self getStreamsInfoForRunningTest.
	self newCommand
		command: '/bin/ls';
		arguments: (Array with: '-' with: 'foo');
		redirectStderr;
		runAndWaitOnExitDo: [ :command :outString :errString |
			self assert: (errString includesSubstring: ': No such file or directory').
			self assert: command stdoutStream isNil.
			self assert: command stderrStream closed.
			self assertStreamsInfoWithPrevious: streamsInfo.
		].
	
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandReadFromStdout
	| streamsInfo |
	streamsInfo := self getStreamsInfoForRunningTest.
	self newCommand
		command: '/bin/ls';
		arguments: (Array with: Smalltalk image imagePath);
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: (outString includesSubstring: Smalltalk image imagePath).
			self assertStreamsInfoWithPrevious: streamsInfo.
		].
	
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandWithArgument
	| command | 
	
	command := self newCommand
					command: '/bin/ls';
					arguments: { Smalltalk image imagePath. }.
	
	command runAndWait! !
!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandWithNonAsciiArgument
	| command | 
	
	self withNonAsciiDirectoryDo: [ :dir |
		command := self newCommand
					command: '/bin/ls';
					arguments: { dir fullName }.
		command runAndWait
	]
! !
!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandWithoutFullPath

	self newCommand
		command: 'ls';
		arguments: (Array with: Smalltalk image imagePath);
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: (outString includesSubstring: Smalltalk image imagePath).					
		]
		 
! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandWriteToStdin
	| command stdOutString string streamsInfo | 
	streamsInfo := self getStreamsInfoForRunningTest.
	string := 'this is a test shat should have been printed in the stdout'.
	command := self newCommand
					command: '/bin/cat';
					redirectStdin;
					redirectStdout.
					
	command run.
	command stdinStream 
		nextPutAll: string;
		close.
	command waitForExit.
	stdOutString := command stdoutStream upToEndOfFile.
	command closeAndCleanStreams.
	self assert: command isSuccess.
	self assert: stdOutString equals: string.
	self assertStreamsInfoWithPrevious: streamsInfo.
	
	
! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicCommandWriteToStdin2
	| command streamsInfo outString | 
	streamsInfo := self getStreamsInfoForRunningTest.

	command := self newCommand
					command: 'wc';
					redirectStdin;
					redirectStdout;
					run. 

	command stdinStream 
			nextPutAll: Smalltalk image imagePath;
			close.

	command waitForExit.
	outString := command stdoutStream upToEndOfFile. 
	command closeAndCleanStreams.				
	self assert: command isSuccess.
	"It's hard to test the output of wc crossplatform..."
	self assert: outString size > 5.
	self assertStreamsInfoWithPrevious: streamsInfo.
	
	
! !
!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicShellCommand
	| command | 
	
	command := self newCommand
					shellCommand: 'ls'.
	
	command runAndWait.
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicShellCommandWithNonAsciiCharacters
	
	self withNonAsciiDirectoryDo: [ :dir |
		(dir / 'ok.txt') ensureCreateFile.
		self newCommand
			shellCommand: 'ls ', dir fullName;
			redirectStdout;
			runAndWaitOnExitDo: [ :command :outString |
				self assert: (outString includesSubstring: 'ok.txt').						
		]
	]! !
!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testBasicShellCommandWithStdout

	self newCommand
		shellCommand: 'ls "', Smalltalk image imagePath, '"';
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: (outString includesSubstring: Smalltalk image imagePath).						
		]
		 
! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCheckZombieStateAndTestChildWatcherWorking
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand 
				command: '/bin/sleep';
				arguments: {'1'}.
	
	command run. 
	self assert: command pid > 0.
	(Duration seconds: 2) wait.
	"In this case we are NOT going to do the queryExitStatus since we want to know 
	if the child watcher is doing it's job."
	"self assert: command queryExitStatus isNil not."
	"Now it should not be a zombie anymore"
	self assert: self numberOfZombiesProcesses equals: oldZombies.
	
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCheckZombieStateWithNonExistingCommang
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand 
				command: 'whatever'.
				
		"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.
	So...if error, then it;s ok. But if not, also."
	[ command runAndWait ] on: Error do: [  :ex | 
		self assert: (ex printString includesSubstring: 'No such file or directory') .
		self assert: command pid isNil.
		^ nil
	].
	
	self assert: command exitStatusInterpreter exitStatus > 0.
	self assert: self numberOfZombiesProcesses equals: oldZombies.
	
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCheckZombieStateWithOnExitApi
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand 
				command: '/bin/sleep';
				arguments: {'1'};
				runAndWaitOnExitDo: [  ].
	
	self assert: self numberOfZombiesProcesses equals: oldZombies.
	
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCheckZombieStateWithWaitChild
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand 
				command: '/bin/sleep';
				arguments: {'1'}.
	
	command run.
	command waitForExit. 
	self assert: self numberOfZombiesProcesses equals: oldZombies.
	
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCommandReturningDifferentThanZero
	| command | 
	
	"When the file does not exists ls returns 1"
	command := self newCommand 
					command: '/bin/ls';
					arguments: {'asdasdasdasdsad'}.
	
	command runAndWait. 
	
	"Do not use #deny:equals: for Pharo 6 compatibility"
	self deny: (command exitStatusInterpreter exitStatus = 0)! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCreateMissingStandardStreamsDisabled
	| command | 
	
	command := self newCommand
					command: '/bin/ls'.
					
	command runAndWait. 
	self assert: command stdinStream isNil.
	self assert: command stdoutStream isNil.
	self assert: command stderrStream isNil.
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCreateMissingStandardStreamsEnabled
	| command streamsInfo | 
	streamsInfo := self getStreamsInfoForRunningTest.
	"The output of the ls command should be displayed in the stdout of the Pharo image. See comment of #createPipesForMissingStreams: for more details"
	command := self newCommand
					command: '/bin/ls';
					createMissingStandardStreams: true.
					
	command runAndWait. 
	self assert: command stdinStream isNil not.
	self assert: command stdoutStream isNil not.
	self assert: command stderrStream isNil not.
	command closeAndCleanStreams.
	self assertStreamsInfoWithPrevious: streamsInfo.
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCustomShellWithStdout

	self newCommand
		shell: '/bin/bash' command: 'ls "', Smalltalk image imagePath, '"';
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: (outString includesSubstring: Smalltalk image imagePath).					
		]
		 
! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testCustomStdoutStream
	| customStream streamsInfo | 
	streamsInfo := self getStreamsInfoForRunningTest.
	customStream := self newCommand createADefaultWriteStream.
	self newCommand
		command: '/bin/ls';
		arguments: (Array with: Smalltalk image imagePath);
		redirectStdoutTo: customStream;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: (outString includesSubstring: Smalltalk image imagePath).
			self assert: command stdoutStream == customStream	.				
			self assertStreamsInfoWithPrevious: streamsInfo.
		].
	
	

! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testGetChildPid
	| command | 
	
	command := self newCommand 
					command: '/bin/ls'.
	
	command run.
	self assert: command pid > 0.
	command waitForExit. ! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testGetChildStatusAfterFailingCommand
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand
					command: '/bin/ls';
					arguments: {'whatever'}.
	command run.
	self assert: command pid > 0.
	command waitForExit.
	command queryExitStatus.
	self assert: command exitStatusInterpreter exitStatus >  0. 
	self deny: command isSuccess.
	self assert: command isComplete.
	self deny: command isRunning.
	self assert: self numberOfZombiesProcesses equals: oldZombies.! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testGetChildStatusAfterFinishesMultipleTimes
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand
					command: '/bin/ls'.
	
	command run. 
	self assert: command pid > 0.
	command waitForExit.
	"Just wanted to be sure there is no problem calling waitpid() multiple times"
	command queryExitStatus.
	command queryExitStatus.
	command queryExitStatus.
	command queryExitStatus.
	
	self assert: command exitStatusInterpreter exitStatus equals: 0. 
	self assert: command isSuccess.
	self assert: command isComplete.
	self deny: command isRunning.
	self assert: self numberOfZombiesProcesses equals: oldZombies.! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testGetChildStatusAfterFinishesSuccess
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand
					command: '/bin/ls'.
	
	command run. 
	self assert: command pid > 0.
	command waitForExit.
	command queryExitStatus.
	self assert: command exitStatusInterpreter exitStatus equals: 0. 
	self assert: command isSuccess.
	self assert: command isComplete.
	self deny: command isRunning.
	self assert: self numberOfZombiesProcesses equals: oldZombies.! !
!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testGetChildStatusBeforeAndAfterFinishing
	| command oldZombies | 
	oldZombies := self numberOfZombiesProcesses.
	command := self newCommand 
				command: '/bin/sleep';
				arguments: {'3'}.
	
	command run. 
	self assert: command pid > 0.
	(Duration seconds: 1) wait.
	self assert: command queryExitStatus isNil.
	self deny: command isComplete.
	self assert: command isRunning.
	command waitForExit.
	self assert: command queryExitStatus isNil not.
	self assert: command exitStatusInterpreter exitStatus equals: 0.
	self assert: command isComplete.
	self assert: self numberOfZombiesProcesses equals: oldZombies.
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testInheritVarFromEnv
	| command | 
	command := self newCommand
					shellCommand: 'echo ${HOME} 2>&1 > /tmp/testReadUserDefinedEnvVar ';
					runAndWait.
	
	self assert: ('/tmp/testReadUserDefinedEnvVar' asFileReference readStreamDo: [ :str | str contents ]) trimmed equals: (Smalltalk os environment at: 'HOME') trimmed.
	'/tmp/testReadUserDefinedEnvVar' asFileReference ensureDelete. ! !
!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testNoneExistingCommand
	| command stdout stderr | 
	
	command := self newCommand
					command: 'whatever';
					redirectStdout;
					redirectStderr.
	
	"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.
	So...if error, then it;s ok. But if not, also."
	[ command runAndWait ] on: Error do: [  :ex | 
		self assert: (ex printString includesSubstring: 'No such file or directory') .
		self assert: command pid isNil.
		command closeAndCleanStreams.
		^ nil
	].
	
	self assert: command exitStatusInterpreter exitStatus > 0.
	command closeAndCleanStreams.! !
!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM
	| command streamsInfo | 
	
	"We set the sunit test timeout to 30 seconds.
	Otherwise default sunit test timeout is 10 seconds.
	This is for Pharo version >= 6.0"
	(self respondsTo: #timeLimit:) ifTrue: [ 
		self timeLimit: 30 seconds.
	].
	
	streamsInfo := self getStreamsInfoForRunningTest.
	command := self newCommand
					command: '/bin/sleep';
					arguments: (Array with: '15');
					redirectStdout;
					runAndWait.
					
	"Even with a blocking stream, if the command has finished, we have
	all data ready to read and hence it's not blocking"
	self assert:[ command stdoutStream upToEndOfFile ] timeToRun seconds <= 5. 
	command closeAndCleanStreams.
	self assertStreamsInfoWithPrevious: streamsInfo.
	

	! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testRunAndWaitPollingEveryRetrievingStreamsOnExitDo
	self newCommand 
		command: '/bin/ls';
		arguments: (Array with: Smalltalk image imagePath);
		redirectStdout;
		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |
			self assert: command pid > 0.
			self assert: command exitStatusInterpreter exitStatus equals: 0. 
			self assert: (outString includesSubstring: Smalltalk image imagePath).
			self assert: command stdoutStream closed.
		]				
! !
!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testSetAndReadCustomVariable
	self newCommand 
		shellCommand: 'echo ${WHATEVER}';
		environmentAt: 'WHATEVER' put: 'hello';
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: outString trimmed equals: 'hello'
		]
! !
!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testSetAndReadCustomVariableOutsideShell
	self newCommand 
		command: 'printenv';
		arguments: (Array with: 'WHATEVER');
		environmentAt: 'WHATEVER' put: 'hello';
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: outString trimmed equals: 'hello'. 					
		]
! !
!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testSetCustomVariableOutsideShellAndPassedToCommand
	" This test demonstrates that we do not expand variables automatically. So if you don't use the shell, or any other special command that
	will search for special variables (like git searching $GIT_EDITOR), these will not be resolved. 
	If you want that, then you must execute the command with the arguments already expandaded. That is, for example,
	in this case, you should pass the argument 'hello' rather than ${WHATEVER} "
	
	self newCommand 
		command: '/bin/echo';
		arguments: (Array with: '${WHATEVER}');
		environmentAt: 'WHATEVER' put: 'hello';
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: outString trimmed equals: '${WHATEVER}'. 			
		]
! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testShellCommandReturningDifferentThanZero
	| command | 
	
	command := self newCommand shellCommand: 'exit 2'.
	command runAndWait. 
	
	self assert: command exitStatusInterpreter exitStatus equals: 2. ! !
!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testShellCommandWithPipingStdout

	self newCommand
		shellCommand: 'ps -fea | grep Pharo';
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: (outString includesSubstring: 'Pharo').						
		]
		 
! !
!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testShellCommandWithStreamRedirects
	| stdOutContents | 

	self newCommand
		shellCommand: 'ps -fea | grep Pharo > /tmp/testShellCommandWithStreamRedirects.deleteme';
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: outString isEmpty. 
			stdOutContents := '/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference readStreamDo: [ :str | str contents ] .
			self assert: (stdOutContents includesSubstring: 'Pharo').						
		].
	'/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference ensureDelete. 
		 
	
	
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testSigTerm

	| process exited streamsInfo |
	
	"We set the sunit test timeout to 30 seconds.
	Otherwise default sunit test timeout is 10 seconds.
	This is for Pharo version >= 6.0"
	(self respondsTo: #timeLimit:) ifTrue: [ 
		self timeLimit: 30 seconds.
	].
	
	exited := false.
	streamsInfo := self getStreamsInfoForRunningTest.
	process := self newCommand.
	[
	process 
		command: 'tail';
		arguments: (Array with: '-f' with: Smalltalk image changesName);
		redirectStdout;
		redirectStderr;
		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 
		doing: [ :aProcess :outStream :errStream |  
		 	outStream upToEnd.
			errStream upToEnd.
		]
		onExitDo: [ :aProcess :outStream :errStream  |
			process closeAndCleanStreams.
			exited := true.
			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'
		].
	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."	
	] forkAt: Processor userInterruptPriority.

	(Delay forSeconds: 2) wait. 
	process sigterm. 
	(Delay forSeconds: 10) wait. 
	self assert: exited.	
	self assertStreamsInfoWithPrevious: streamsInfo.
! !
!OSSUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testSigTermInsideLoop

	| process exited streamsInfo |
	
	exited := false.
	streamsInfo := self getStreamsInfoForRunningTest.
	process := self newCommand.
	
	process 
		command: 'tail';
		arguments: (Array with: '-f' with: Smalltalk image changesName);
		redirectStdout;
		redirectStderr;
		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 
		doing: [ :aProcess :outStream :errStream |  
		 	"Imagine here that you have some condition...say.. elapsedTime > 1 h .. 
			or ... stdOutStream size > 1MB  or whatever..  "
			
			"#sigterm will throw an error (no such process) if the process with the given pid doesn't exist. Because of the looping of this method it COULD happen that we send #sigterm again even if the process was already killed in the previous loop. So we simply make sure the process is running before doing the #sigterm"
			aProcess isRunning ifTrue: [ aProcess sigterm. ]
 	]
		onExitDo: [ :aProcess :outStream :errStream  |
			process closeAndCleanStreams.
			exited := true.
			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'
		].

	self assert: exited.	
	self assertStreamsInfoWithPrevious: streamsInfo.
! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testStopWaitingWithPolling
	| process counter oldZombies |
	process := self newCommand.
	oldZombies := self numberOfZombiesProcesses.
	counter := 0.
	[
		process
			command: 'tail';
			arguments:  (Array with: '-f' with: Smalltalk image imagePath);
			redirectStdout;
			runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |
				"The counter is to demonstrate that the exit happens only once we did the #stopWaiting
				and not before"
				self assert: counter equals: 0. 
				self assert: process exitStatus isNil.
				"Since we did not wait for the child to finish we must do a sigterm to avoid zombies
				when running the tests"
				command sigterm.
				"Not sure about while this delay but it seems it's needed so that the next queryExitStatus
				does collect exit status and hence avoid zombies"
				(Delay forSeconds: 4) wait.
				command queryExitStatus.
				self assert: self numberOfZombiesProcesses equals: oldZombies.
				
			]			
	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."	
	] forkAt: Processor userInterruptPriority.


	(Delay forSeconds: 3) wait.
	"Just to demonstrate that tail will run forever until explicitly closed".
	self assert: process isRunning. 
	process stopWaiting.
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testStopWaitingWithSigchld
	| process counter oldZombies |
	process := self newCommand.
	oldZombies := self numberOfZombiesProcesses.
	counter := 0.
	[
	process
		command: 'tail';
		arguments:  (Array with: '-f' with: Smalltalk image imagePath);
		redirectStdout;
		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |
			"The counter is to demonstrate that the exit happens only once we did the #stopWaiting
			and not before"
			self assert: counter equals: 0. 
			self assert: command exitStatus isNil.
			"Since we did not wait for the child to finish we must do a sigterm to avoid zombies
			when running the tests"
			command sigterm.
			"Not sure about while this delay but it seems it's needed so that the next queryExitStatus
			does collect exit status and hence avoid zombies"
			(Delay forSeconds: 4) wait.
			command queryExitStatus.
			self assert: self numberOfZombiesProcesses equals: oldZombies.
		]
	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."	
	] forkAt: Processor userInterruptPriority.				

	(Delay forSeconds: 3) wait.
	"Just to demonstrate that tail will run forever until explicitly closed".
	self assert: process isRunning. 
	process stopWaiting.
	! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWaitForExit
	| command | 
	
	command := self newCommand 
					command: '/bin/sleep';
					arguments: {'3'}.
	
	command run. 
	self assert: command pid > 0.
	self assert: [ command waitForExit ] timeToRun asSeconds >= 2.
	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWaitForExitPolling
	| command | 
	
	command := self newCommand 
					command: '/bin/sleep';
					arguments: {'3'}.
	
	command run. 
	self assert: command pid > 0.
	self assert: [ command waitForExitPolling ] timeToRun asSeconds >= 2.
	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWaitForExitPollingEvery
	| command | 
	
	command := self newCommand 
					command: '/bin/sleep';
					arguments: {'3'}.
	
	command run. 
	self assert: command pid > 0.
	self assert: [ command waitForExitPollingEvery: (Delay forSeconds: 1) ] timeToRun asSeconds >= 2.
	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !
!OSSUnixSubprocessTest methodsFor: 'tests - high API' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWaitForExitPollingEveryDoing
	| streamsInfo totalRead |
	totalRead := String new writeStream.
	streamsInfo := self getStreamsInfoForRunningTest.
	self newCommand
		command: '/bin/ls';
		arguments: (Array with: Smalltalk image imagePath);
		redirectStdout;
		redirectStderr;
		runAndWaitPollingEvery: (Delay forMilliseconds: 50) 
		doing: [ :process :outStream :errStream |  
			| read | 
			read := outStream upToEnd.
			totalRead nextPutAll: read.
		]
		onExitDo: [ :process :outStream :errStream  |
			self assert: (totalRead contents includesSubstring: Smalltalk image imagePath).
			process closeAndCleanStreams.
			self assertStreamsInfoWithPrevious: streamsInfo.
		].

	! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWaitForExitWithTimeoutWillFailIfProcessDoesNotFinish
	| command | 
	
	command := self newCommand 
					command: '/bin/sleep';
					arguments: {'2'}.
	
	command run.
	
	self
		should: [ command waitForExitWithTimeout: 10 milliSeconds ]
		raise: OSSTimeout.
	self assert: command isRunning.! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWaitForExitWithTimeoutWillNotTimeoutIfProcessFinishes
	| command | 
	
	command := self newCommand 
					command: '/bin/sleep';
					arguments: {'1'}.
	
	command run.
	command waitForExitWithTimeout: 2 seconds.
	
	self assert: command pid > 0.
	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !
!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWaitpidIsNoneBocking
	| command childStatus | 
	
	command := self newCommand
					command: '/bin/sleep';
					arguments: {'5'}.
	
	command run. 
	self assert: command pid > 0.
	(Duration seconds: 1) wait.
	self assert: [ childStatus := command exitStatusInterpreter ] timeToRun asSeconds < 1.
	self assert: childStatus value isNil.
	command waitForExit.! !
!OSSUnixSubprocessTest methodsFor: 'tests - pwd' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testWorkingDirectory
	| oldWorkingDirectory | 

	oldWorkingDirectory := self systemAccessor getcwd.
	(FileSystem workingDirectory / 'testing') ensureCreateDirectory.
	
	self newCommand
		shellCommand: 'pwd';
		workingDirectory: (FileSystem workingDirectory / 'testing') fullName;
		redirectStdout;
		runAndWaitOnExitDo: [ :command :outString |
			self assert: outString trimmed equals: (FileSystem workingDirectory / 'testing') fullName.	
		].
 
	self assert: self systemAccessor getcwd trimmed equals: oldWorkingDirectory trimmed.
		 
	(FileSystem workingDirectory / 'testing') ensureDelete.
	
! !
!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
withNonAsciiDirectoryDo: aBlock 
	| directory |
	directory := FileLocator temp / (self class name , '-éoï-' , UUIDGenerator next asString).
	directory ensureCreateDirectory.
	[ aBlock cull: directory asFileReference ]
	ensure: [ directory ensureDeleteAll ]! !
!OSSVMProcessTest methodsFor: 'accessing' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
runCaseManaged
	"testChangeDirWithNonAsciiCharacters test has to download the unicode table that can take some time.
	Disable test timeout."
	^ self runCase! !
!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testChangeDir
	| oldDir | 
	oldDir := self systemAccessor getcwd.
	OSSVMProcess vmProcess
		lockCwdWithValue: '/tmp'
		encoding: #utf8 
		during: [
			"Grrr in latest OSX /tmp is mapped to /private/tmp..."
			self assert: ((self systemAccessor getcwd = '/tmp') or: [ self systemAccessor getcwd = '/private/tmp' ]).
		].
	self assert: self systemAccessor getcwd equals: oldDir
				! !
!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testChangeDirWithNonAsciiCharacters
	| oldDir newDir duringSystemCwd | 
	oldDir := self systemAccessor getcwd.
	newDir := FileLocator temp / 'strangË foldér namê'.
	newDir ensureCreateDirectory.

	OSSVMProcess vmProcess
		lockCwdWithValue: newDir fullName
		encoding: #utf8
		during: [ duringSystemCwd := self systemAccessor getcwd ].
	duringSystemCwd := UnicodeNormalizer new toNFC: duringSystemCwd asByteArray utf8Decoded.

	"Grrr in latest OSX /tmp is mapped to /private/tmp..."
	self assert: ((duringSystemCwd = newDir fullName) or: [ duringSystemCwd = ('/private' , newDir fullName) ]).
	self assert: self systemAccessor getcwd equals: oldDir.
	newDir ensureDelete.! !
!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testChangeDirWithNonExistingDir
	| oldDir |
	oldDir := self systemAccessor getcwd.
	[ OSSVMProcess vmProcess
		lockCwdWithValue: '/tmpWhatever'
		encoding: #utf8
		during: [  ] ]
	on: Error
	do: [ :ex | self assert: (ex printString includesSubstring: 'does not exist') ].
	self assert: self systemAccessor getcwd equals: oldDir! !
!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testChildrenCollectionsWithOneProcessBeforeAndAfter
	| command | 
	OSSVMProcess vmProcess initializeAllMyChildren. 
	command := self newCommand 
		command: '/bin/sleep';
		arguments: {'2'}.
	
	command run. 
	
	self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.
	self assert: OSSVMProcess vmProcess allMyChildren first == command.
	self assert: OSSVMProcess vmProcess activeChildren size equals: 1.
	self assert: OSSVMProcess vmProcess activeChildren first == command.
	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.
	self assert: OSSVMProcess vmProcess childPids size equals: 1.
	self assert: OSSVMProcess vmProcess childPids first equals: command pid.
	
	command waitForExit. 
	
	self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.
	self assert: OSSVMProcess vmProcess allMyChildren first == command.
	self assert: OSSVMProcess vmProcess activeChildren size equals: 0.
	self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.
	self assert: OSSVMProcess vmProcess exitedChildren first == command.
	self assert: OSSVMProcess vmProcess childPids size equals: 1.
	self assert: OSSVMProcess vmProcess childPids first equals: command pid.
			
! !
!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testInitializeChildren

	OSSVMProcess vmProcess initializeAllMyChildren.
	
	self assert: OSSVMProcess vmProcess allMyChildren isEmpty.
	self assert: OSSVMProcess vmProcess activeChildren isEmpty.
	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.
	self assert: OSSVMProcess vmProcess childPids isEmpty.
	
	
			
! !
!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
testPruneExitedChildrenAfter
	| command | 
	OSSVMProcess vmProcess initializeAllMyChildren. 
	command := self newCommand 
		command: '/bin/ls'.
	command runAndWait. 
	
	self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.
	OSSVMProcess vmProcess pruneExitedChildrenAfter: 0. 
	
	self assert: OSSVMProcess vmProcess allMyChildren isEmpty.
	self assert: OSSVMProcess vmProcess activeChildren isEmpty.
	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.
	self assert: OSSVMProcess vmProcess childPids isEmpty.
	
	! !

"OSSubprocess-Tests-Unit"!
!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
launchAndWaitForProcessesToFinish: numberOfProcesses

	"We set the sunit test timeout to 2 times the sleep duration.
	Otherwise default sunit test timeout is 1 minute."
	
	| processes |
	"We set the sunit test timeout to 1 second per process.
	Except for short running processes, where we keep the default timeout.
	This is for Pharo version >= 6.0"
	(self respondsTo: #timeLimit:) ifTrue: [ 
		self timeLimit: (numberOfProcesses seconds max: self defaultTimeLimit).
	].

	
	processes := (1 to: numberOfProcesses) collect: [ :index |
		self newCommand
			command: '/bin/sleep';
			arguments: { '1s' };
			yourself ].
	
	processes do: #run.
	
	processes do: [ :command | command waitForExitWithTimeout: 5 seconds ]
! !
!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
test100ProcessEventuallyFinishes

	self launchAndWaitForProcessesToFinish: 100! !
!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
test10ProcessEventuallyFinishes

	self launchAndWaitForProcessesToFinish: 10! !
!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
test1ProcessEventuallyFinishes

	self launchAndWaitForProcessesToFinish: 1! !
!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
doTestProcessEventuallyFinishesForSeconds: aDuration

	| command |
	"We set the sunit test timeout to 2 times the sleep duration.
	Otherwise default sunit test timeout is 1 minute.
	This is for Pharo version >= 6.0"
	(self respondsTo: #timeLimit:) ifTrue: [ 
		self timeLimit: aDuration * 2.
	].

	command := self newCommand
		command: '/bin/sleep';
		arguments: { aDuration asSeconds asString };
		yourself.
	command run.
	
	"We should wait and finish without a timeout exception"
	command waitForExitWithTimeout: aDuration * 2.! !
!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
test100SecondProcessEventuallyFinishes

	self doTestProcessEventuallyFinishesForSeconds: 100 second! !
!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
test10SecondProcessEventuallyFinishes

	self doTestProcessEventuallyFinishesForSeconds: 10 second! !
!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
test1SecondProcessEventuallyFinishes

	self doTestProcessEventuallyFinishesForSeconds: 1 second! !
!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/24/2020 17:07:53'!
test300SecondProcessEventuallyFinishes
	"Wait for five minutes.
	Times > 10 minutes make travis timeout."
	self doTestProcessEventuallyFinishesForSeconds: 300 second! !

"OSSubprocess-Tests-Stress"!
!OSWSProcessCreationFailed commentStamp: '' prior: 0!
Error thrown when the creation of a sub process fails.!
!OSWSWinTypes commentStamp: '' prior: 0!
Definition of Windows types used in prototypes of the functions needed to manage processes.!
!OSWSProcessInformation commentStamp: '' prior: 0!
Structure needed to make FFI calls to createProcess.
It contains information about a newly created process and its primary thread.
See PhLProcess class for more information.
documentation: https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information!
!OSWSStartupInfoW commentStamp: '' prior: 0!
Structure needed to make FFI calls to createProcess.
Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation time.
See PhLWinProcess class for more information.
Documentation: https://docs.microsoft.com/fr-fr/windows/desktop/api/processthreadsapi/ns-processthreadsapi-_startupinfow!
!OSWSWinProcess commentStamp: '' prior: 0!
I reprensent a Windows process.
You can instantiate me and configure me to run a child process of Pharo. You can wait for my completion or run me in an asynchronuous way (default).
I use a FFI library PhLWinProcessLibrary to make system calls to the Windows API.
I do not manage standard and error outputs.

WARNING: waiting a process will freeze your image while the process is running.

You can use me as following:
	PhLWinProcess new 
		shellCommand: 'echo ok';
		runAndWait.
		
	PhLWinProcess new
		shellCommand: 'timeout 1';
		run.!
!OSWSWinProcessLibrary commentStamp: '' prior: 0!
PhLProcess can be used to run new processes on Windows.
It uses Windows MSVCRT dll.

https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa!
!OSWSWinProcessWatcher commentStamp: '' prior: 0!
This class is in charge of watching the execution of the process given as input to check regularly if it is still running or not.
When the process is completed, I do a callback on the process so that it cleans the process fields.!
!String methodsFor: '*OSWinSubprocess'!
surroundedByDoubleQuotes
	"Answer the receiver with leading and trailing double quotes.  "

	^ self surroundedBy: ($" asString)! !
!OSWSProcessCreationFailed methodsFor: 'accessing'!
description
	^ 'Failed to create a new process'! !
!OSWSProcessInformation class methodsFor: 'field definition'!
fieldsDesc
	"self rebuildFieldAccessors"
	
	^ #(
	HANDLE hProcess;
	HANDLE hThread;
	DWORD  dwProcessId;
	DWORD  dwThreadId;	
	)! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
dwProcessId
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWPROCESSID! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
dwProcessId: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWPROCESSID put: anObject! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
dwThreadId
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWTHREADID! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
dwThreadId: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWTHREADID put: anObject! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
hProcess
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_HPROCESS) type: ExternalType void asPointerType! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
hProcess: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_HPROCESS put: anObject getHandle.! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
hThread
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_HTHREAD) type: ExternalType void asPointerType! !
!OSWSProcessInformation methodsFor: 'accessing structure variables'!
hThread: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_HTHREAD put: anObject getHandle.! !
!OSWSProcessInformation methodsFor: 'initialization'!
initialize
	super initialize.
	OSWSWinProcessLibrary clear: self! !
!OSWSStartupInfoW class methodsFor: 'field definition'!
fieldsDesc
	"self rebuildFieldAccessors"

	^ #(
	DWORD	cb;
	LPWSTR	lpReserved;
	LPWSTR	lpDesktop;
	LPWSTR	lpTitle;
	DWORD	dwX;
	DWORD	dwY;
	DWORD	dwXSize;
	DWORD	dwYSize;
	DWORD	dwXCountChars;
	DWORD	dwYCountChars;
	DWORD	dwFillAttribute;
	DWORD	dwFlags;
	WORD	 wShowWindow;
	WORD	 cbReserved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
)! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
cb
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_CB! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
cb: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_CB put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
cbReserved2
	"This method was automatically generated"
	^handle unsignedShortAt: OFFSET_CBRESERVED2! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
cbReserved2: anObject
	"This method was automatically generated"
	handle unsignedShortAt: OFFSET_CBRESERVED2 put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwFillAttribute
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWFILLATTRIBUTE! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwFillAttribute: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWFILLATTRIBUTE put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwFlags
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWFLAGS! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwFlags: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWFLAGS put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwX
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWX! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwX: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWX put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwXCountChars
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWXCOUNTCHARS! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwXCountChars: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWXCOUNTCHARS put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwXSize
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWXSIZE! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwXSize: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWXSIZE put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwY
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWY! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwY: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWY put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwYCountChars
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWYCOUNTCHARS! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwYCountChars: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWYCOUNTCHARS put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwYSize
	"This method was automatically generated"
	^handle unsignedLongAt: OFFSET_DWYSIZE! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
dwYSize: anObject
	"This method was automatically generated"
	handle unsignedLongAt: OFFSET_DWYSIZE put: anObject! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
hStdError
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_HSTDERROR) type: ExternalType void asPointerType! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
hStdError: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_HSTDERROR put: anObject getHandle.! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
hStdInput
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_HSTDINPUT) type: ExternalType void asPointerType! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
hStdInput: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_HSTDINPUT put: anObject getHandle.! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
hStdOutput
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_HSTDOUTPUT) type: ExternalType void asPointerType! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
hStdOutput: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_HSTDOUTPUT put: anObject getHandle.! !
!OSWSStartupInfoW methodsFor: 'initialization'!
initialize
	super initialize.
	OSWSWinProcessLibrary clear: self! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpDesktop
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPDESKTOP) type: ExternalType void asPointerType! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpDesktop: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_LPDESKTOP put: anObject getHandle.! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpReserved
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPRESERVED) type: ExternalType void asPointerType! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpReserved2
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPRESERVED2) type: ExternalType char asPointerType! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpReserved2: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_LPRESERVED2 put: anObject getHandle.! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpReserved: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_LPRESERVED put: anObject getHandle.! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpTitle
	"This method was automatically generated"
	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPTITLE) type: ExternalType void asPointerType! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
lpTitle: anObject
	"This method was automatically generated"
	handle pointerAt: OFFSET_LPTITLE put: anObject getHandle.! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
wShowWindow
	"This method was automatically generated"
	^handle unsignedShortAt: OFFSET_WSHOWWINDOW! !
!OSWSStartupInfoW methodsFor: 'accessing structure variables'!
wShowWindow: anObject
	"This method was automatically generated"
	handle unsignedShortAt: OFFSET_WSHOWWINDOW put: anObject! !
!OSWSWinProcess class methodsFor: 'private'!
TIMEOUT_INFINITE
	^ 16rffffffff! !
!OSWSWinProcess class methodsFor: 'constants'!
WAIT_FAILED
	^ 16rFFFFFFFF
! !
!OSWSWinProcess class methodsFor: 'constants'!
WAIT_OBJECT_0
	^ 0! !
!OSWSWinProcess class methodsFor: 'constants'!
WAIT_TIMEOUT
	^ 16r00000102! !
!OSWSWinProcess methodsFor: 'configuring'!
arguments: aListOfArguments
	arguments := aListOfArguments asArray.! !
!OSWSWinProcess methodsFor: 'accessing'!
argumentsString
	| args |
	args := Character space join: 
		(surroundArgumentsWithDoubleQuotes
			ifTrue: [ arguments collect: #surroundedByDoubleQuotes ]
			ifFalse: [ arguments ]).

	"cmd.exe /C waits a unique argument. Wrap the whole command but /C to run with double quotes"
	^ (command = self shellCommandPath)
		ifTrue: [ '/C ', args surroundedByDoubleQuotes ]
		ifFalse: [ args ]! !
!OSWSWinProcess methodsFor: 'running'!
basicRun
	| kNoWindow creationSucceeded |
	kNoWindow := 16r08000000.
	startupInfo := OSWSStartupInfoW externalNew.
	startupInfo cb: startupInfo class structureSize.
	processInfo := OSWSProcessInformation externalNew.
	
	creationSucceeded := self ffiLibrary
		createProcess: (Win32WideString fromString: command) getHandle
		command: (Win32WideString fromString: self argumentsString) getHandle
		processAttributes: ExternalAddress null
		threadAttributes: ExternalAddress null
		inheritHandles: false
		creationFlags: kNoWindow
		environment: ExternalAddress null
		directory: self workingDirectoryHandle
		startup: startupInfo
		processInformation: processInfo.
		
	creationSucceeded
		ifFalse: [ self setLastErrorCode. OSWSProcessCreationFailed signal: lastErrorCode ].
	isRunning := true.! !
!OSWSWinProcess methodsFor: 'private'!
clean
	processInfo getHandle
		ifNotNil: 
			[ self closeHandle: processInfo hProcess.
			self closeHandle: processInfo hThread ].
	processInfo free.
	startupInfo free! !
!OSWSWinProcess methodsFor: 'private'!
closeHandle: handle
	^ self ffiLibrary closeHandle: handle! !
!OSWSWinProcess methodsFor: 'configuring'!
command: appName
	"The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.

The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed."
	command := appName! !
!OSWSWinProcess methodsFor: 'private'!
completionCallback
	self setExitCode.
	self clean! !
!OSWSWinProcess methodsFor: 'accessing'!
exitCode
	^ exitCode ! !
!OSWSWinProcess methodsFor: 'private'!
ffiLibrary
	^ OSWSWinProcessLibrary uniqueInstance! !
!OSWSWinProcess methodsFor: 'testing'!
hasTimedOut
	^ self isRunning not 
		and: [ lastErrorCode isNil 
		and: [ exitCode isNil ] ]! !
!OSWSWinProcess methodsFor: 'initialization'!
initialize
	isRunning := false.
	surroundArgumentsWithDoubleQuotes := false.! !
!OSWSWinProcess methodsFor: 'testing'!
isComplete
	^ isRunning not and: [exitCode notNil]! !
!OSWSWinProcess methodsFor: 'testing'!
isRunning
	"see https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject for more information"
	| returnValue |
	
	(processInfo isNil 
	or: [ processInfo getHandle isNil 
	or: [ processInfo hProcess getHandle isNil ] ])
		ifTrue: [ ^ false ].
	
	returnValue := self ffiLibrary
		waitForSingleObject: processInfo hProcess
		milliSeconds: 0.
	^ returnValue = self class WAIT_TIMEOUT! !
!OSWSWinProcess methodsFor: 'testing'!
isSuccess
	^ self isRunning not 
		and: [ lastErrorCode isNil 
		and: [ self exitCode = 0 ] ]! !
!OSWSWinProcess methodsFor: 'public'!
lastError
	^ self ffiLibrary getLastError! !
!OSWSWinProcess methodsFor: 'running'!
run
	self basicRun.
	self watch.! !
!OSWSWinProcess methodsFor: 'running'!
runAndWait
	" This methods runs the subprocess AND waits until the child has exited. "
	
	self basicRun.
	self waitForCompletion.! !
!OSWSWinProcess methodsFor: 'running'!
runAndWaitTimeOut: nbMilliSeconds
	" This methods runs the subprocess AND waits until the child has exited. "
	
	self basicRun.
	self waitForCompletionTimeout: nbMilliSeconds.! !
!OSWSWinProcess methodsFor: 'running'!
runUnwatch 
	"Used to run a process and forget about it"
	[ self basicRun ]
	ensure: [ self clean ]! !
!OSWSWinProcess methodsFor: 'private'!
setExitCode
	| exitCodeValueHolder succeeded |
	
	exitCode ifNotNil: [ ^ self ]. "already set"
	processInfo getHandle ifNil: [ ^ self ]. "process already cleaned. No way to get the exit code"
	
	exitCodeValueHolder := LPDWORD new.
	succeeded := self ffiLibrary
		getProcess: processInfo hProcess
		exitCode: exitCodeValueHolder.
	succeeded ifFalse: [ Warning new messageText: 'Cannot get exit code of the process'; signal ].
	exitCode := exitCodeValueHolder value! !
!OSWSWinProcess methodsFor: 'private'!
setLastErrorCode
	^ lastErrorCode := self lastError! !
!OSWSWinProcess methodsFor: 'configuring'!
shellCommand
	command := self shellCommandPath! !
!OSWSWinProcess methodsFor: 'configuring'!
shellCommand: aShellCommandString
	"This is a simple facility method for the cases when the user wants to use shell as the program.
	This way, the user can directly send shellCommand: 'ECHO y| DEL *.txt' with the whole string 
	rather than having to do set the command cmd.exe, send the '/C' argument, etc etc etc."
	self shellCommand.
	arguments := Array withAll: (Character space split: aShellCommandString).! !
!OSWSWinProcess methodsFor: 'configuring'!
shellCommand: aShellCommandName arguments: aListOfArguments
	"This is a simple facility method for the cases when the user wants to use shell as the program.
	This way, the user can directly send shellCommand: 'ECHO' arguments: #('1 + 1' '>' 'a filename with spaces.txt')' 
	rather than having to do set the command cmd.exe, send the '/C' argument, etc etc etc."
	self shellCommand.
	arguments := OrderedCollection with: aShellCommandName.
	arguments addAll: aListOfArguments.
	arguments := arguments asArray.! !
!OSWSWinProcess methodsFor: 'configuring'!
shellCommandPath
	^ 'C:\Windows\System32\cmd.exe'.! !
!OSWSWinProcess methodsFor: 'configuring'!
surroundArgumentsWithDoubleQuotes
	surroundArgumentsWithDoubleQuotes := true.! !
!OSWSWinProcess methodsFor: 'public'!
terminate
	| success |
	self isRunning ifFalse: [ ^ true ].
	
	success := self ffiLibrary 
		terminate: processInfo hProcess 
		exitCode: 3	"Kill the process, set a non-success exit code".
	success ifTrue: [ self clean ].
	^ success! !
!OSWSWinProcess methodsFor: 'private'!
waitForCompletion
	self waitForCompletionTimeout: self class TIMEOUT_INFINITE.! !
!OSWSWinProcess methodsFor: 'private'!
waitForCompletionTimeout: nbMilliSeconds
	| returnValue |
	[ returnValue := self ffiLibrary
		waitForSingleObject: processInfo hProcess
		milliSeconds: nbMilliSeconds.
	isRunning := false.
	returnValue = self class WAIT_OBJECT_0
		ifTrue: [ self setExitCode ].	"successful process termination"
	returnValue = self class WAIT_FAILED
		ifTrue: [ self setLastErrorCode ] ]
	ensure: [ self terminate ]! !
!OSWSWinProcess methodsFor: 'private'!
watch
	(OSWSWinProcessWatcher on: self) watch! !
!OSWSWinProcess methodsFor: 'configuring'!
workingDirectory: aPathString
	workingDirectory := aPathString! !
!OSWSWinProcess methodsFor: 'private'!
workingDirectoryHandle
	^ workingDirectory 
		ifNil: [ ExternalAddress null ]
		ifNotNil: [ (Win32WideString fromString: workingDirectory) getHandle ]! !
!OSWSWinProcessLibrary class methodsFor: 'public'!
clear: externalStructure
	^ self memSet: externalStructure value: 0! !
!OSWSWinProcessLibrary class methodsFor: 'private'!
memSet: externalStructure value: value
	^ self uniqueInstance
		memSet: externalStructure getHandle
		value: value
		size: externalStructure class structureSize! !
!OSWSWinProcessLibrary methodsFor: 'public'!
closeHandle: handle
	^ self ffiCall: #(int CloseHandle(void * handle)) module: #Kernel32! !
!OSWSWinProcessLibrary methodsFor: 'public'!
createProcess: appName command: commandLine processAttributes: processAttributes threadAttributes: threadAttributes inheritHandles: inheritHandles creationFlags: creationFlags environment: environment directory: currentDirectory startup: startupInfo processInformation: processInformation
	^ self ffiCall: 
#(Boolean CreateProcessW(
  LPCWSTR                appName,
  LPCWSTR                 commandLine,
  void* "LPSECURITY_ATTRIBUTES"  processAttributes,
  void* "LPSECURITY_ATTRIBUTES"  threadAttributes,
  Boolean                inheritHandles,
  DWORD                  creationFlags,
  LPVOID                 environment,
  LPCWSTR                currentDirectory,
  #OSWSStartupInfoW        *startupInfo,
  #OSWSProcessInformation *processInformation
)) module: #Kernel32
	
"
	#(int CreateProcessA (const char * appName, char * command, 0, 0, 0, ulong flags, 0, 0, ExternalAddress * startup, ExternalAddress * processInfo)) module: #Kernel32"! !
!OSWSWinProcessLibrary methodsFor: 'public'!
getLastError
	^ self ffiCall: #(DWORD GetLastError(void)) module: #Kernel32! !
!OSWSWinProcessLibrary methodsFor: 'public'!
getProcess: hProcess exitCode: lpExitCode
	^ self ffiCall: 
#(Boolean GetExitCodeProcess(
  HANDLE  hProcess,
  LPDWORD *lpExitCode
)) module: #Kernel32! !
!OSWSWinProcessLibrary methodsFor: 'public'!
memSet: ptr value: value size: size
	^ self ffiCall: #(void* memset(void* ptr, int value, size_t size))! !
!OSWSWinProcessLibrary methodsFor: 'public'!
terminate:hProcess exitCode:uExitCode
	^ self ffiCall: #(
Boolean TerminateProcess(
  HANDLE hProcess,
  uint   uExitCode
)) module: #Kernel32! !
!OSWSWinProcessLibrary methodsFor: 'public'!
waitForSingleObject: handle milliSeconds: ms
	^ self ffiCall: #( uint WaitForSingleObject (void * handle, uint ms)) module: #Kernel32! !
!OSWSWinProcessLibrary methodsFor: 'public'!
win32ModuleName
	^ 'msvcrt.dll'! !
!OSWSWinProcessWatcher class methodsFor: 'instance creation'!
on: aProcess
	^ self new 
		process: aProcess! !
!OSWSWinProcessWatcher methodsFor: 'accessing'!
process: aProcess
	process := aProcess! !
!OSWSWinProcessWatcher methodsFor: 'watching'!
watch
	"active loop to catch the end of the process"

	watchProcess := [ [ process isRunning ]
		whileTrue: [ 200 milliSeconds wait ].
		process completionCallback ]
		forkAt: 35
		named: 'WinProcess watcher'! !
!OSWSWinTypes class methodsFor: 'class initialization'!
initialize 
	DWORD := #uint32.
	HANDLE := 'void*'.
	LPSTR := String.
	LPCSTR := String.
	LPWSTR := 'void*'. "Cannot use Win32WideString directly because FFI will not accept null pointers"
	LPCWSTR := 'void*'. "Cannot use Win32WideString directly because FFI will not accept null pointers"
	LPVOID := 'void*'.
	WORD := #uint16.
	LPBYTE := 'char*'.
	LPDWORD := FFIExternalValueHolder ofType: #uint32.! !

"OSWinSubprocess"!
!OSWSWinProcessTest methodsFor: 'tests'!
testBasicCommand
	| newprocess |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].
	
	newprocess := OSWSWinProcess new 
		shellCommand: 'echo ok';
		runAndWait.
	self deny: newprocess isRunning.
	self assert: newprocess exitCode equals: 0.
	self assert: newprocess isSuccess
! !
!OSWSWinProcessTest methodsFor: 'tests'!
testBasicCommandWithArguments
	| newprocess |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].
	
	newprocess := OSWSWinProcess new 
		shellCommand: 'echo'
		arguments: #('ok');
		runAndWait.
	self deny: newprocess isRunning.
	self assert: newprocess exitCode equals: 0.
	self assert: newprocess isSuccess
! !
!OSWSWinProcessTest methodsFor: 'tests'!
testCanDetectIfProcessIsRunning
	| newprocess |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].
	
	newprocess := OSWSWinProcess new
		shellCommand: 'timeout 1';
		run.
	self assert: newprocess isRunning.
	1 seconds wait.
	self deny: newprocess isRunning.
		! !
!OSWSWinProcessTest methodsFor: 'tests'!
testCanTerminateProcess
	| newprocess succeeded |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].
	
	newprocess := OSWSWinProcess new 
		shellCommand: 'timeout 50';
		run.
	self assert: newprocess isRunning.
	succeeded := newprocess terminate.
	self assert: succeeded.
	1 second wait. "let time to the cleanup being executed"
	self deny: newprocess isRunning.
	self deny: newprocess isSuccess.! !
!OSWSWinProcessTest methodsFor: 'tests'!
testGivenACommandIncludingNonAsciiCharsThenCommandSucceed
	| newprocess tempDir |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].
	
	tempDir := (FileLocator temp / 'Yann-Gaël Bérès') asFileReference.
	self deny: tempDir exists.
	
	[ newprocess := OSWSWinProcess new 
		shellCommand: 'mkdir'
		arguments: {tempDir fullName surroundedByDoubleQuotes};
		runAndWait.
	self assert: newprocess isSuccess.
	self assert: tempDir exists. ]
		ensure: [ tempDir ensureDelete ]
	
! !
!OSWSWinProcessTest methodsFor: 'tests'!
testGivenBasicCommandWhenCommandDoesNotExistThenExitCodeIsNot0
	| newprocess |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].
	
	newprocess := OSWSWinProcess new 
		shellCommand: 'nonexistingcommand foo bar'.
	self deny: newprocess exitCode equals: 0.
	self deny: newprocess isSuccess! !
!OSWSWinProcessTest methodsFor: 'tests'!
testProcessTimeOut
	| newprocess start delta |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].
	
	start := Time now asMilliSeconds.
	newprocess := OSWSWinProcess new 
		shellCommand: 'sleep 50';
		run;
		waitForCompletionTimeout: 3 seconds asMilliSeconds.
	"wait is blocking"
	delta := Time now asMilliSeconds - start.
	self deny: newprocess isRunning.
	self deny: newprocess isSuccess.
	self assert: newprocess hasTimedOut.
	self 
		assert: (delta between: 3 seconds asMilliSeconds and: 4 seconds asMilliSeconds)
		description: 'expected 3 seconds wait, got ', delta asString , ' milliseconds'.! !

"OSWinSubprocess-Tests"!
!BitmapCharacterSet commentStamp: '' prior: 0!
This class implements a set of Character objects similar to CharacterSet and WideCharacterSet, but it uses a bitmap internally to test if wide (multibyte) characters belong to it rather than using a Dictionary like WideCharacterSet does. For byte characters, a simple 256-element Array is used, the same as with CharacterSet, which is faster but uses more memory.

(Used by and heavily optimized for XMLParser; please refactor carefully)!
!BitmapCharacterSet class methodsFor: 'inspecting'!
inspectorClass
	"does not use Set class>>inspectorClass because it is incompatible"
	^ Smalltalk tools inspectorClass! !
!BitmapCharacterSet class methodsFor: 'instance creation'!
new
	^ self new: 256! !
!BitmapCharacterSet class methodsFor: 'instance creation'!
new: aCapacity
	^ self basicNew initialize: aCapacity! !
!BitmapCharacterSet class methodsFor: 'instance creation'!
newFrom: aCollection
	"for GS portability"
	^ self new
		addAll: aCollection;
		yourself	! !
!BitmapCharacterSet methodsFor: 'copying'!
, aCollection
	"GS doesn't define #, for non-Sequenceable collections"
	^ self copy
		addAll: aCollection;
		yourself! !
!BitmapCharacterSet methodsFor: 'comparing'!
= anObject
	self == anObject
		ifTrue: [^ true].

	(self species == anObject species
		and: [self size = anObject size])
		ifFalse: [^ false].

	self do: [:each |
		(anObject includes: each)
			ifFalse: [^ false]].
	^ true.! !
!BitmapCharacterSet methodsFor: 'adding'!
add: aCharacter
	| asciiValue |

	"optimized for speed with inlining; do not refactor"
	(asciiValue := aCharacter asciiValue) < 256
		ifTrue: [
			(byteCharacters at: asciiValue + 1)
				ifFalse: [tally := tally + 1].
			byteCharacters
				at: asciiValue + 1
				put: true]
		ifFalse: [| byteIndex byte bitmask |
			"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc
			(with 'bitShift: -3' used over '// 8' for speed)"
			byteIndex := (asciiValue bitShift: -3) - 31.
			(wideCharacters == nil
				or: [byteIndex > wideCharacters size])
				ifTrue: [self growWideCharacterBitmapTo: (byteIndex * 1.5) asInteger].

			"raises an error if asciiValue > 16r10FFFF"
			byte := wideCharacters at: byteIndex.

			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)
			(with 'bitAnd: 7' used over '\\ 8' for speed)"
			bitmask := 1 bitShift: 7 - (asciiValue bitAnd: 7).
			
			"increment the tally if the character is not already present"
			(byte bitAnd: bitmask) == 0
				ifTrue: [tally := tally + 1].

			wideCharacters
				at: byteIndex
				put: (byte bitOr: bitmask)].
	^ aCharacter.! !
!BitmapCharacterSet methodsFor: 'adding'!
addRangeFrom: aStartCharacter to: aStopCharacter
	"Adds character range from aStartCharacter to aStopCharacter inclusive
	or none if aStartCharacter > aStopCharacter. Returns self to avoid
	creating a temp collection of the added characters."

	"chars don't support to:do: (compiled inline) and using to: and do:
	separately needlessly creates a (possibly large) temp array"
	aStartCharacter asciiValue
		to: aStopCharacter asciiValue
		do: [:i | self add: (Character value: i)]! !
!BitmapCharacterSet methodsFor: 'private'!
byteCharacters
	^ byteCharacters! !
!BitmapCharacterSet methodsFor: 'enumerating'!
byteCharactersDo: aBlock
	1 to: byteCharacters size do: [:i |
		(byteCharacters at: i)
			ifTrue: [aBlock value: (Character value: i - 1)]]! !
!BitmapCharacterSet methodsFor: 'accessing'!
capacity
	^ byteCharacters size +
		(wideCharacters
			ifNil: [0]
			ifNotNil: [wideCharacters size * 8]).! !
!BitmapCharacterSet methodsFor: 'converting'!
complement
	| copy |

	copy := self copyEmpty.
	0 to: 16r10FFFF do: [:i | | character |
		character := (Character value: i).
		(self includes: character)
			ifFalse: [copy add: character]].
	^ copy.! !
!BitmapCharacterSet methodsFor: 'copying'!
copyEmpty
	"reimplemented for GS and Squeak compatibility"
	^ self species new: self capacity! !
!BitmapCharacterSet methodsFor: 'enumerating'!
do: aBlock
	self
		byteCharactersDo: aBlock;
		wideCharactersDo: aBlock! !
!BitmapCharacterSet methodsFor: 'private'!
growWideCharacterBitmapTo: aSizeInBytes
	| newSize |

	newSize := aSizeInBytes min: self maxWideCharactersSize.
	wideCharacters
		ifNil: [wideCharacters := ByteArray new: newSize]
		ifNotNil: [
			wideCharacters :=
				(ByteArray new: newSize)
					replaceFrom: 1
					to: wideCharacters size
					with: wideCharacters
					startingAt: 1].! !
!BitmapCharacterSet methodsFor: 'testing'!
hasWideCharacters
	self wideCharactersDo: [:each | ^ true].
	^ false.! !
!BitmapCharacterSet methodsFor: 'comparing'!
hash
	| hash |

	hash := self species hash.
	self byteCharactersDo: [:each |
		hash := hash bitXor: each hash].
	^ hash bitXor: self size hash.! !
!BitmapCharacterSet methodsFor: 'testing'!
includes: aCharacter
	| asciiValue |

	"optimized for speed with inlining; do not refactor"
	(asciiValue := aCharacter asciiValue) < 256
		ifTrue: [^ byteCharacters at: asciiValue + 1]
		ifFalse: [| byteIndex |
			wideCharacters
				ifNil: [^ false].

			"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc
			(with 'bitShift: -3' used over '// 8' for speed)"
			(byteIndex := (asciiValue bitShift: -3) - 31) > wideCharacters size
				ifTrue: [^ false].

			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)
			(with 'bitAnd: 7' used over '\\ 8' for speed)"
			^ ((wideCharacters at: byteIndex) bitAnd:
				(1 bitShift: 7 - (asciiValue bitAnd: 7))) > 0]! !
!BitmapCharacterSet methodsFor: 'testing'!
includesRangeFrom: aStartCharacter to: aStopCharacter
	"Tests for character range from aStartCharacter to aStopCharacter
	inclusive. Always returns true if aStartCharacter > aStopCharacter."

	"chars don't support to:do: (compiled inline) and using to: and do:
	separately needlessly creates a (possibly large) temp array"
	aStartCharacter asciiValue
		to: aStopCharacter asciiValue
		do: [:i |
			(self includes: (Character value: i))
				ifFalse: [^ false]].
	^ true.! !
!BitmapCharacterSet methodsFor: 'initialization'!
initialize: aCapacity
	byteCharacters := Array new: 256 withAll: false.
	aCapacity > 256
		ifTrue: [
			"(257 - 1) // 8 - 31 = 1 (first byte),
			(257 + 8 - 1) // 8 - 31 = 2 (second byte), etc
			(with 'bitShift: -3' used over '// 8' for speed)"
			self growWideCharacterBitmapTo: ((aCapacity - 1) bitShift: -3) - 31].
	tally := 0.! !
!BitmapCharacterSet methodsFor: 'testing'!
isEmpty
	"Squeak's Collection>>#isEmpty is inefficient"
	^ self size = 0! !
!BitmapCharacterSet methodsFor: 'private'!
maxWideCharactersSize
	^ 139232 "(16r10FFFF bitShift: -3) - 31"! !
!BitmapCharacterSet methodsFor: 'copying'!
postCopy
	byteCharacters := byteCharacters copy.
	wideCharacters
		ifNotNil: [wideCharacters := wideCharacters copy].! !
!BitmapCharacterSet methodsFor: 'removing'!
remove: aCharacter ifAbsent: aBlock
	| asciiValue |

	"optimized for speed with inlining; do not refactor"
	(asciiValue := aCharacter asciiValue) < 256
		ifTrue: [
			(byteCharacters at: asciiValue + 1)
				ifFalse: [^ aBlock value].
			byteCharacters
				at: asciiValue + 1
				put: false]
		ifFalse: [| byteIndex byte bitmask |
			wideCharacters
				ifNil: [^ aBlock value].
	
			"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc
			(with 'bitShift: -3' used over '// 8' for speed)"
			(byteIndex := (asciiValue bitShift: -3) - 31) > wideCharacters size
				ifTrue: [^ aBlock value].

			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)
			(with 'bitAnd: 7' used over '\\ 8' for speed)"
			bitmask := 1 bitShift: 7 - (asciiValue bitAnd: 7).
			((byte := wideCharacters at: byteIndex) bitAnd: bitmask) == 0
				ifTrue: [^ aBlock value].

			wideCharacters
				at: byteIndex
				put: (byte bitAnd: bitmask bitInvert)].
	tally := tally - 1.
	^ aCharacter.! !
!BitmapCharacterSet methodsFor: 'removing'!
removeAll
	"empties but preserves the capacity"

	1 to: byteCharacters size do: [:i |
		byteCharacters
			at: i
			put: false].
	wideCharacters
		ifNotNil: [
			1 to: wideCharacters size do: [:i |
				wideCharacters
					at: i
					put: 0]].
	tally := 0.! !
!BitmapCharacterSet methodsFor: 'removing'!
removeRangeFrom: aStartCharacter to: aStopCharacter
	"Removes character range from aStartCharacter to aStopCharacter inclusive
	or none if aStartCharacter > aStopCharacter. Returns self to avoid
	creating a temp collection of the removed characters."

	"chars don't support to:do: (compiled inline) and using to: and do:
	separately needlessly creates a (possibly large) temp array"
	aStartCharacter asciiValue
		to: aStopCharacter asciiValue
		do: [:i | self remove: (Character value: i)]! !
!BitmapCharacterSet methodsFor: 'accessing'!
size
	^ tally! !
!BitmapCharacterSet methodsFor: 'private'!
wideCharacters
	^ wideCharacters! !
!BitmapCharacterSet methodsFor: 'enumerating'!
wideCharactersDo: aBlock
	"optimized for speed with to:do: and inlining; do not refactor"
	| baseValue |

	wideCharacters
		ifNil: [^ self].

	baseValue := 256.
	1 to: wideCharacters size do: [:byteIndex | | byte |
		(byte := wideCharacters at: byteIndex) == 0
			ifFalse: [
				0 to: 7 do: [:shiftIndex |
					(byte bitAnd: (1 bitShift: 7 - shiftIndex)) == 0
						ifFalse: [
							aBlock value:
								(Character value: baseValue + shiftIndex)]]].
		baseValue := baseValue + 8].! !

"Collections-BitmapCharacterSet"!
!StandardOrderedDictionary commentStamp: '' prior: 0!
This class is a dictionary that uses key insertion order when enumerating, printing, or returing collections of keys/values/associations, but not when testing for equality.

Insertion, updating, and inclusion testing have O(1) complexity while removing has O(n) worst-case.!
!OrderPreservingDictionary commentStamp: '' prior: 0!
An order-preserving dictionary that returns a configurable default value (nil by default) when an absent key or value is requested from it rather than raising an exception.!
!OrderPreservingIdentityDictionary commentStamp: '' prior: 0!
An IdentityDictionary version that uses == instead of = for key comparing.!
!OrderPreservingStringDictionary commentStamp: '' prior: 0!
An order-preserving dictionary for strings that returns empty strings instead of raising errors when absent keys/values are accessed.!
!OrderPreservingIdentityStringDictionary commentStamp: '' prior: 0!
An IdentityDictionary version that uses == instead of = for key comparing.!
!StandardOrderedIdentityDictionary commentStamp: '' prior: 0!
An IdentityDictionary version that uses == instead of = for key comparing.!
!OrderPreservingDictionary class methodsFor: 'instance creation'!
defaultValue: aDefaultValue
	^ self new defaultValue: aDefaultValue! !
!OrderPreservingDictionary class methodsFor: 'instance creation'!
new: aCapacity withDefaultValue: aDefaultValue
	^ self basicNew
		initialize: aCapacity
		withDefaultValue: aDefaultValue! !
!OrderPreservingDictionary class methodsFor: 'instance creation'!
newFrom: anAssociationCollection
	| newDictionary |

	newDictionary := super newFrom: anAssociationCollection.
	(anAssociationCollection respondsTo: #defaultValue)
		ifTrue: [newDictionary defaultValue: anAssociationCollection defaultValue].
	^ newDictionary.! !
!OrderPreservingDictionary methodsFor: 'accessing'!
associationAt: aKey
	^ self
		associationAt: aKey
		ifAbsent: [nil]! !
!OrderPreservingDictionary methodsFor: 'accessing'!
at: aKey
	^ self
		at: aKey
		ifAbsent: [defaultValue]! !
!OrderPreservingDictionary methodsFor: 'copying'!
copyEmpty
	^ self species defaultValue: defaultValue! !
!OrderPreservingDictionary methodsFor: 'accessing'!
defaultValue
	^ defaultValue! !
!OrderPreservingDictionary methodsFor: 'accessing'!
defaultValue: aDefaultValue
	defaultValue := aDefaultValue! !
!OrderPreservingDictionary methodsFor: 'initialization'!
initialize: aCapacity withDefaultValue: aDefaultValue
	self initialize: aCapacity.
	defaultValue := aDefaultValue.! !
!OrderPreservingDictionary methodsFor: 'accessing'!
keyAtIdentityValue: aValue
	^ self
		keyAtIdentityValue: aValue
		ifAbsent: [defaultValue]! !
!OrderPreservingDictionary methodsFor: 'accessing'!
keyAtIndex: anIndex
	^ self
		keyAtIndex: anIndex
		ifAbsent: [defaultValue]! !
!OrderPreservingDictionary methodsFor: 'accessing'!
keyAtValue: aValue
	^ self
		keyAtValue: aValue
		ifAbsent: [defaultValue]! !
!OrderPreservingDictionary methodsFor: 'removing'!
removeKey: aKey
	^ self
		removeKey: aKey
		ifAbsent: [defaultValue]! !
!OrderPreservingDictionary methodsFor: 'private'!
speciesNewFrom: anAssociationCollection
	^ (self species newFrom: anAssociationCollection)
		defaultValue: defaultValue! !
!OrderPreservingIdentityDictionary methodsFor: 'accessing'!
dictionaryClass
	^ IdentityDictionary! !
!OrderPreservingIdentityDictionary methodsFor: 'accessing'!
indexOfKey: aKey ifAbsent: aBlock
	^ self
		identityIndexOfKey: aKey
		ifAbsent: aBlock! !
!OrderPreservingIdentityDictionary methodsFor: 'testing'!
isIdentityDictionary
	^ true! !
!OrderPreservingIdentityDictionary methodsFor: 'private'!
orderedKeysIndexOf: aKey
	^ self orderedKeysIdentityIndexOf: aKey! !
!OrderPreservingIdentityStringDictionary methodsFor: 'accessing'!
dictionaryClass
	^ IdentityDictionary! !
!OrderPreservingIdentityStringDictionary methodsFor: 'accessing'!
indexOfKey: aKey ifAbsent: aBlock
	^ self
		identityIndexOfKey: aKey
		ifAbsent: aBlock! !
!OrderPreservingIdentityStringDictionary methodsFor: 'testing'!
isIdentityDictionary
	^ true! !
!OrderPreservingIdentityStringDictionary methodsFor: 'private'!
orderedKeysIndexOf: aKey
	^ self orderedKeysIdentityIndexOf: aKey! !
!OrderPreservingStringDictionary methodsFor: 'accessing'!
associationAt: aKey
	^ self
		associationAt: aKey
		ifAbsent: [nil]! !
!OrderPreservingStringDictionary methodsFor: 'accessing'!
at: aKey
	^ self
		at: aKey
		ifAbsent: ['']! !
!OrderPreservingStringDictionary methodsFor: 'accessing'!
keyAtIdentityValue: aValue
	^ self
		keyAtIdentityValue: aValue
		ifAbsent: ['']! !
!OrderPreservingStringDictionary methodsFor: 'accessing'!
keyAtIndex: anIndex
	^ self
		keyAtIndex: anIndex
		ifAbsent: ['']! !
!OrderPreservingStringDictionary methodsFor: 'accessing'!
keyAtValue: aValue
	^ self
		keyAtValue: aValue
		ifAbsent: ['']! !
!OrderPreservingStringDictionary methodsFor: 'removing'!
removeKey: aKey
	^ self
		removeKey: aKey
		ifAbsent: ['']! !
!StandardOrderedDictionary class methodsFor: 'inspecting'!
inspectorClass
	^ Dictionary inspectorClass! !
!StandardOrderedDictionary class methodsFor: 'instance creation'!
new
	^ self new: 10! !
!StandardOrderedDictionary class methodsFor: 'instance creation'!
new: aCapacity
	^ self basicNew initialize: aCapacity! !
!StandardOrderedDictionary class methodsFor: 'instance creation'!
newFrom: anAssociationCollection
	| newDictionary |

	newDictionary := self new: anAssociationCollection size.
	anAssociationCollection associationsDo: [:each |
		newDictionary
			at: each key
			put: each value].
	^ newDictionary.! !
!StandardOrderedDictionary class methodsFor: 'instance creation'!
newFromPairs: aSequenceableCollection
	| newDictionary |

	newDictionary := self new: (aSequenceableCollection size / 2) floor.
	1 to: aSequenceableCollection size - 1 by: 2 do: [:i |
		newDictionary
			at: (aSequenceableCollection at: i)
			put: (aSequenceableCollection at: i + 1)].
	^ newDictionary.! !
!StandardOrderedDictionary methodsFor: 'comparing'!
= anObject
	"Returns true if the receiver and argument are identical, or if they
	are both some kind of order-preserving dictionary and if they have
	the same associations regardless of order."

	self == anObject
		ifTrue: [^ true].

	(anObject isOrderPreservingDictionary
		and: [self isIdentityDictionary = anObject isIdentityDictionary
			and: [self size = anObject size]])
		ifFalse: [^ false].

	dictionary associationsDo: [:each |
		(anObject at: each key ifAbsent: [^ false]) = each value
			ifFalse: [^ false]].
	^ true.! !
!StandardOrderedDictionary methodsFor: 'adding'!
add: anAssociation
	| oldSize |

	oldSize := dictionary size.
	dictionary add: anAssociation.
	dictionary size > oldSize
		ifTrue: [
			orderedKeys size > oldSize
				ifFalse: [self growOrderedKeys].
			orderedKeys at: oldSize + 1 put: anAssociation key].
	^ anAssociation.! !
!StandardOrderedDictionary methodsFor: 'adding'!
addAll: anAssociationCollection
	"Since Collection implements #associationsDo:, this method can accept
	any collection of associations including Arrays and OrderedCollections"

	anAssociationCollection associationsDo: [:each | self add: each].
	^ anAssociationCollection.! !
!StandardOrderedDictionary methodsFor: 'accessing'!
associationAt: aKey
	^ dictionary associationAt: aKey! !
!StandardOrderedDictionary methodsFor: 'accessing'!
associationAt: aKey ifAbsent: aBlock
	^ dictionary
		associationAt: aKey
		ifAbsent: aBlock! !
!StandardOrderedDictionary methodsFor: 'accessing'!
associationAt: aKey ifPresent: aBlock
	"Squeak and GS do not have #associationAt:ifPresent: so it
	is reimplemented for portability"
	^ aBlock cull:
		(dictionary
			associationAt: aKey
			ifAbsent: [^ nil])! !
!StandardOrderedDictionary methodsFor: 'accessing'!
associations
	| associations i |

	associations := Array new: self size.
	i := 1.
	self associationsDo: [:each |
		associations at: i put: each.
		i := i + 1].
	^ associations.! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
associationsDo: aBlock
	self keysDo: [:each |
		aBlock value: (self associationAt: each)]! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
associationsSelect: aBlock
	^ self speciesNewFrom: (self associations select: aBlock)! !
!StandardOrderedDictionary methodsFor: 'accessing'!
at: aKey
	^ dictionary at: aKey! !
!StandardOrderedDictionary methodsFor: 'accessing'!
at: aKey ifAbsent: aBlock
	^ dictionary
		at: aKey
		ifAbsent: aBlock! !
!StandardOrderedDictionary methodsFor: 'accessing'!
at: aKey ifAbsentPut: aBlock
	^ self
		at: aKey
		ifAbsent: [
			self
				at: aKey
				put: aBlock value]! !
!StandardOrderedDictionary methodsFor: 'accessing'!
at: aKey ifPresent: aBlock
	"Squeak and GS don't use #cull: for the ifPresent:
	block, so it is reimplemented for portability"
	^ aBlock cull:
		(self
			at: aKey
			ifAbsent: [^ nil])! !
!StandardOrderedDictionary methodsFor: 'accessing'!
at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock
	"Squeak and GS don't use #cull: for the ifPresent:
	block, so it is reimplemented for portability"
	self
		at: aKey
		ifPresent: [:value | ^ aPresentBlock cull: value].
	^ anAbsentBlock value.! !
!StandardOrderedDictionary methodsFor: 'accessing'!
at: aKey put: aValue
	| oldSize |

	oldSize := dictionary size.
	dictionary
		at: aKey
		put: aValue.
	dictionary size > oldSize
		ifTrue: [
			orderedKeys size > oldSize
				ifFalse: [self growOrderedKeys].
			orderedKeys at: oldSize + 1 put: aKey].
	^ aValue.! !
!StandardOrderedDictionary methodsFor: 'accessing'!
capacity
	^ dictionary capacity! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
collect: aBlock
	^ self speciesNewFrom:
		(self associations collect: [:each |
			each key -> (aBlock value: each value)])! !
!StandardOrderedDictionary methodsFor: 'copying'!
copyEmpty
	"Squeak and GS don't have Collection>>#copyEmpty:, so it is
	reimplemented for portability"
	^ self species new! !
!StandardOrderedDictionary methodsFor: 'private'!
dictionary
	^ dictionary! !
!StandardOrderedDictionary methodsFor: 'accessing'!
dictionaryClass
	^ Dictionary! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
do: aBlock
	self valuesDo: aBlock! !
!StandardOrderedDictionary methodsFor: 'private'!
errorInvalidIndex: anIndex
	"Squeak and GS do not have SubscriptOutOfBounds, so Error is used
	for portability"
	Error signal: 'Invalid index: ', anIndex printString! !
!StandardOrderedDictionary methodsFor: 'private'!
errorValueNotFound: aValue
	"Squeak and GS do not have ValueNotFound, so Error is used
	for portability"
	Error signal: 'Value not found'! !
!StandardOrderedDictionary methodsFor: 'private'!
growOrderedKeys
	orderedKeys :=
		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))
			replaceFrom: 1
			to: orderedKeys size
			with: orderedKeys
			startingAt: 1.! !
!StandardOrderedDictionary methodsFor: 'comparing'!
hash
	^ dictionary hash! !
!StandardOrderedDictionary methodsFor: 'accessing'!
identityIndexOfKey: aKey
	^ self
		identityIndexOfKey: aKey
		ifAbsent: [0]! !
!StandardOrderedDictionary methodsFor: 'accessing'!
identityIndexOfKey: aKey ifAbsent: aBlock
	1 to: self size do: [:i |
		(orderedKeys at: i) == aKey
			ifTrue: [^ i]].
	^ aBlock value.! !
!StandardOrderedDictionary methodsFor: 'testing'!
includes: anObject
	^ dictionary includes: anObject! !
!StandardOrderedDictionary methodsFor: 'testing'!
includesAssociation: anAssociation
	"IndentityDictionary>>includesAssociation: works differently on GS
	testing both key and value identity, so it is reimplemented here
	to behave like Pharo/Squeak"
	^ (dictionary
		at: anAssociation key
		ifAbsent: [^ false]) = anAssociation value! !
!StandardOrderedDictionary methodsFor: 'testing'!
includesIdentity: anObject
	"GS does not have includesIdentity:"
	self valuesDo: [:each |
		each == anObject
			ifTrue: [^ true]].
	^ false.! !
!StandardOrderedDictionary methodsFor: 'testing'!
includesKey: aKey
	^ dictionary includesKey: aKey! !
!StandardOrderedDictionary methodsFor: 'accessing'!
indexOfKey: aKey
	^ self
		indexOfKey: aKey
		ifAbsent: [0]! !
!StandardOrderedDictionary methodsFor: 'accessing'!
indexOfKey: aKey ifAbsent: aBlock
	1 to: self size do: [:i |
		(orderedKeys at: i) = aKey
			ifTrue: [^ i]].
	^ aBlock value.! !
!StandardOrderedDictionary methodsFor: 'initialization'!
initialize: aCapacity
	dictionary := self dictionaryClass new: aCapacity.
	orderedKeys := Array new: aCapacity.! !
!StandardOrderedDictionary methodsFor: 'testing'!
isDictionary
	^ true! !
!StandardOrderedDictionary methodsFor: 'testing'!
isEmpty
	"Squeak's Collection>>#isEmpty is inefficient"
	^ self size = 0! !
!StandardOrderedDictionary methodsFor: 'testing'!
isIdentityDictionary
	^ false! !
!StandardOrderedDictionary methodsFor: 'testing'!
isOrderPreservingDictionary
	^ true! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keyAtIdentityValue: aValue
	^ self
		keyAtIdentityValue: aValue
		ifAbsent: [self errorValueNotFound: aValue]! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keyAtIdentityValue: aValue ifAbsent: aBlock
	"GS does not have keyAtIdentityValue:ifAbsent:"
	self keysAndValuesDo: [:key :value |
		value == aValue
			ifTrue: [^ key]].
	^ aBlock value.! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keyAtIndex: anIndex
	^ self
		keyAtIndex: anIndex
		ifAbsent: [self errorInvalidIndex: anIndex]! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keyAtIndex: anIndex ifAbsent: aBlock
	(anIndex > 0 and: [anIndex <= self size])
		ifTrue: [^ orderedKeys at: anIndex]
		ifFalse: [^ aBlock value]! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keyAtValue: aValue
	^ dictionary keyAtValue: aValue! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keyAtValue: aValue ifAbsent: aBlock
	^ dictionary
		keyAtValue: aValue
		ifAbsent: aBlock! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keyForIdentity: anObject
	"reimplemented for portability"
	self keysAndValuesDo: [:key :value |
		value == anObject
			ifTrue: [^ key]].
	^ nil.! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keys
	^ orderedKeys
		copyFrom: 1
		to: self size! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
keysAndValuesDo: aBlock
	self keysDo: [:each |
		aBlock
			value: each
			value: (self at: each)]! !
!StandardOrderedDictionary methodsFor: 'removing'!
keysAndValuesRemove: aTwoArgumentBlock
	| removedAssociations |

	removedAssociations := OrderedCollection new.
	self associationsDo: [:each |
		(aTwoArgumentBlock
			value: each key
			value: each value)
			ifTrue: [removedAssociations add: each]].
	removedAssociations do: [:each | self removeKey: each key].! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
keysDo: aBlock
	"use to:do: for speed"
	1 to: self size do: [:i |
		aBlock value: (orderedKeys at: i)]! !
!StandardOrderedDictionary methodsFor: 'accessing'!
keysSortedSafely
	"GS's #keysSortedSafely returns a SortedCollection instead of
	an Array, so this is reimplemented directly for portability, and
	'self keys' is used instead of 'dictionary keys', because GS's
	#keys returns a Set which can't be sorted"
	^ self keys sort! !
!StandardOrderedDictionary methodsFor: 'private'!
orderedKeys
	^ orderedKeys! !
!StandardOrderedDictionary methodsFor: 'private'!
orderedKeysIdentityIndexOf: aKey
	"GS does not have #identityIndexOf:"
	1 to: orderedKeys size do: [:i |
		(orderedKeys at: i) == aKey
			ifTrue: [^ i]].
	^ 0.! !
!StandardOrderedDictionary methodsFor: 'private'!
orderedKeysIndexOf: aKey
	^ orderedKeys indexOf: aKey! !
!StandardOrderedDictionary methodsFor: 'private'!
orderedKeysRemove: aRemovedKey
	| index |

	index := self orderedKeysIndexOf: aRemovedKey.

	"shift every remaining key after to the left by one"
	orderedKeys
		replaceFrom: index
		to: self size
		with: orderedKeys
		startingAt: index + 1.

	"one key was removed and the rest shifted, so nil what was the last
	key slot before removing and shifting"
	orderedKeys
		at: self size + 1
		put: nil.! !
!StandardOrderedDictionary methodsFor: 'copying'!
postCopy
	orderedKeys := orderedKeys copy.
	dictionary := dictionary copy.! !
!StandardOrderedDictionary methodsFor: 'printing'!
printElementsOn: aStream
	aStream nextPut: $(.
	self size > 100
		ifTrue: [
			aStream nextPutAll: 'size '.
			self size printOn: aStream]
		ifFalse: [
			self associations withIndexDo: [:each :i |
				aStream
					print: each key;
					nextPutAll: '->';
					print: each value.
				(i < self size)
					ifTrue: [aStream space]]].
	aStream nextPut: $).! !
!StandardOrderedDictionary methodsFor: 'removing'!
remove: anObject ifAbsent: aBlock
	self shouldNotImplement! !
!StandardOrderedDictionary methodsFor: 'removing'!
removeAll
	1 to: self size do: [:i |
		orderedKeys
			at: i
			put: nil].
	dictionary removeAll.! !
!StandardOrderedDictionary methodsFor: 'removing'!
removeKey: aKey
	| value |

	value := dictionary removeKey: aKey.
	self orderedKeysRemove: aKey.
	^ value.! !
!StandardOrderedDictionary methodsFor: 'removing'!
removeKey: aKey ifAbsent: aBlock
	| oldSize value |

	oldSize := dictionary size.
	value :=
		dictionary
			removeKey: aKey
			ifAbsent: aBlock.
	dictionary size < oldSize
		ifTrue: [self orderedKeysRemove: aKey].
	^ value.! !
!StandardOrderedDictionary methodsFor: 'removing'!
removeKeys: aKeyCollection
	"Fast removal of multiple keys; returns self to avoid
	having to create a removed value collection and does not
	raise errors."

	aKeyCollection	size > 1
		ifTrue: [| oldSize newOrderedKeys newOrderedKeysIndex |
			oldSize := self size.
			aKeyCollection do: [:each |
				dictionary
					removeKey: each
					ifAbsent: [nil]].

			newOrderedKeys := Array new: oldSize.
			newOrderedKeysIndex := 0.
			1 to: oldSize do: [:i | | key |
				(dictionary includesKey: (key := orderedKeys at: i))
					ifTrue: [
						newOrderedKeys
							at: (newOrderedKeysIndex := newOrderedKeysIndex + 1)
							put: key]].

			orderedKeys := newOrderedKeys]
		ifFalse: [
			aKeyCollection size = 1
				ifTrue: [
					"use #anyOne, because it can be a Set"
					self
						removeKey: aKeyCollection anyOne
						ifAbsent: [nil]]]! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
select: aBlock
	^ self speciesNewFrom:
		(self associations select: [:each | aBlock value: each value])! !
!StandardOrderedDictionary methodsFor: 'accessing'!
size
	^ dictionary size! !
!StandardOrderedDictionary methodsFor: 'private'!
speciesNewFrom: anAssociationCollection
	^ self species newFrom: anAssociationCollection! !
!StandardOrderedDictionary methodsFor: 'accessing'!
values
	^ self associations collect: [:each | each value]! !
!StandardOrderedDictionary methodsFor: 'enumerating'!
valuesDo: aBlock
	self keysDo: [:each |
		aBlock value: (self at: each)]! !
!StandardOrderedIdentityDictionary methodsFor: 'accessing'!
dictionaryClass
	^ IdentityDictionary! !
!StandardOrderedIdentityDictionary methodsFor: 'accessing'!
indexOfKey: aKey ifAbsent: aBlock
	^ self
		identityIndexOfKey: aKey
		ifAbsent: aBlock! !
!StandardOrderedIdentityDictionary methodsFor: 'testing'!
isIdentityDictionary
	^ true! !
!StandardOrderedIdentityDictionary methodsFor: 'private'!
orderedKeysIndexOf: aKey
	^ self orderedKeysIdentityIndexOf: aKey! !
!Object methodsFor: '*Collections-OrderPreservingDictionary'!
isOrderPreservingDictionary
	"Defined here because not all collections inherit from Collection,
	so just defining it in Collection and StandardOrderedDictionary
	and using #isCollection with #isOrderPreservingDictionary in
	StandardOrderedDictionary>>#= would trigger a DNU."

	^ false! !

"Collections-OrderPreservingDictionary"!
!DTDAttributeDefinitionParser commentStamp: '' prior: 0!
This class parses an attribute definition in an ATTLIST declaration and returns a new XMLAttributeValidator for it. It assumes the type has already been checked for well-formedness by the tokenizer and that it contains a value like "ID", "ENTITY", or an enumeration list.!
!DTDStandaloneExternalAttributeDefinitionParser commentStamp: '' prior: 0!
This class parses standalone externally defined ATTLIST attribute definitions and returns XMLAttributeValidators for them that disallow attributes needing further value normalization or substitution with default or fixed default values.!
!DTDContentModelParser commentStamp: '' prior: 0!
This is a base class for DTD content model parsers that turn element declarations into XMLElementValidators.!
!DTDElementContentModelParser commentStamp: '' prior: 0!
This class parses element content models. It uses postfix conversion and an XMLNFABuilder to build an NFA before converting it to a lazy DFA (states are built when needed and cached) and returns it as an XMLElementValidator.

It assumes all spaces have been removed from the input and that it's been checked for well-formedness, meaning no missing names or misplaced operators/parentheses.!
!DTDStandaloneExternalElementContentModelParser commentStamp: '' prior: 0!
This class parses standalone externally defined element content models and returns XMLElementValidators for them. Validators for content models that specify element content like "(one|two+)" won't treat whitespace as ignorable.!
!DTDLiteralContentModelParser commentStamp: '' prior: 0!
This class parses literal "ANY" and "EMPTY" element content models and returns XMLElementValidators accepting any content or no content (not even whitespace, comments, or PIs).!
!DTDMixedContentModelParser commentStamp: '' prior: 0!
This class parses mixed content declarations like "(#PCDATA|one|two)*" using a DTDEnumerationListParser and returns an XMLElementValidator accepting any sequence of PCDATA and the named elements in any order.!
!DTDDoctypeDefinition commentStamp: '' prior: 0!
This class represents the parsed internal and external subset of a DTD taken together.!
!DTDEntity commentStamp: '' prior: 0!
This is an abstract base class for internal and external parsed entities with replacements that can be inserted into an XML document.!
!DTDParsedEntity commentStamp: '' prior: 0!
This is an abstract base class for parsed entities with replacements that can be inserted into an XML document.!
!DTDExternalParsedEntity commentStamp: '' prior: 0!
This is an abstract base class for external parsed entities with external replacements that can be inserted into an XML document.

The external replacements are resolved lazily the first time #replacement or #replacementStream is sent.!
!DTDExternalGeneralParsedEntity commentStamp: '' prior: 0!
This is a class for external general parsed entities with external replacements that can be inserted into an XML document.!
!DTDStandaloneExternalExternalGeneralParsedEntity commentStamp: '' prior: 0!
This is a class for standalone externally defined external general entities that cannot be referenced in documents.!
!DTDExternalParameterParsedEntity commentStamp: '' prior: 0!
This is a class for external parameter parsed entities with external replacements that can be inserted into an XML document.!
!DTDInternalParsedEntity commentStamp: '' prior: 0!
This is an abstract base class for internal parsed entities with replacements that can be inserted into an XML document.!
!DTDInternalGeneralParsedEntity commentStamp: '' prior: 0!
This is a class for internal general parsed entities with replacements that can be inserted into documents.!
!DTDStandaloneExternalInternalGeneralParsedEntity commentStamp: '' prior: 0!
This is a class for standalone externally defined external general entities that cannot be referenced in documents except in ATTLIST attribute declaration default values.!
!DTDInternalParameterParsedEntity commentStamp: '' prior: 0!
This is a class for internal parameter parsed entities with replacements that can be inserted into documents.!
!DTDUnresolvableExternalParsedEntity commentStamp: '' prior: 0!
This is an abstract base class for unresolvable external parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!
!DTDUnresolvableExternalGeneralParsedEntity commentStamp: '' prior: 0!
This is a class for unresolvable external general parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!
!DTDUnresolvableExternalParameterParsedEntity commentStamp: '' prior: 0!
This is a class for unresolvable external parameter parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!
!DTDUnparsedEntity commentStamp: '' prior: 0!
A class for unparsed entities. These should never be directly referenced in content with the &name; syntax, but can be named in values of ENTITY and ENTITIES attributes.!
!DTDEntityConfiguration commentStamp: '' prior: 0!
This class contains configurations for entity replacement/retrieval. It is separate from XMLConfiguration so it is only lazy initialized when needed and saves memory.!
!DTDEnumerationListParser commentStamp: '' prior: 0!
This is a parser of lists in the form of "(one|two|...)".  It assumes there is no whitespace around the "|" separated list values.!
!DTDMixedContentEnumerationListParser commentStamp: '' prior: 0!
This is a parser of mixed content lists in the form of "(#PCDATA|one|two|...)*".  It assumes there is no whitespace around the "|" separated list values.!
!DTDNotationEnumerationListParser commentStamp: '' prior: 0!
This class parses notation attribute value lists in the form of "NOTATION (one|two|...)". It assumes there is no whitespace around the "|" separated list values.!
!DTDExternalEntityLimits commentStamp: '' prior: 0!
This class places security limits on the number and size of external parsed entities. You can set these using the configuration messages in DTDExternalEntityResolver or remove them using removeLimits.!
!DTDExternalEntityResolver commentStamp: '' prior: 0!
This class resolves external entity references using XMLURI, XMLHTTPRequest, and XMLFileHandle.

The #externalEntityURIFromPublicID:systemID: and #externalEntityURIFromPublicID:systemID:baseURI: convert public IDs and system IDs into resolvable XMLURI objects.

The #resolveExternalEntityURI: and #streamResolveExternalEntityURI: messages can resolve external entity XMLURIs or URI strings as either a string or a stream on the undecoded entity content. If the entity is in a file, then #streamResolveExternalEntityURI: can be used to avoid storing it in-memory, but if it's fetched over HTTP, it will just return a stream on the entire in-memory HTTP response.!
!DTDCachingExternalEntityResolver commentStamp: '' prior: 0!
This class is a resolver that caches non-local entities in a global cache so they don't have to be retrieved again (like over HTTP). This is the default resolver.!
!DTDStaticExternalEntityResolver commentStamp: '' prior: 0!
This class is a resolver that maps entity URIs to string replacements so resolution can be done without HTTP or file access. Used during testing.!
!DTDExternalEntityResolverLimitingDecorator commentStamp: '' prior: 0!
This class is a decorator for DTDExternalEntityResolvers that limits the number of entities that can be resolved. This is not handled directly by resolvers to make them less stateful and more reusable.!
!DTDNotation commentStamp: '' prior: 0!
A class for notation declarations.!
!DTDResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!
This is an abstract class for resolved external entity replacements.!
!DTDDecodedResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!
This class stores the decoded resolved replacement of an external parsed entity.!
!DTDUndecodedResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!
This class stores the undecoded resolved replacement of an external parsed entity as well as its likely encoding.!
!DTDUnresolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!
This class stores an entity resolver and the public ID, system ID, and base URI of an external entity so its replacement can be lazily resolved only if the entity is referenced.!
!SAX2ContentHandler commentStamp: '' prior: 0!
This is a base class for SAX2 content handler classes that can be injected into SAX2Parser instances with #contentHandler: before parsing:
	(SAX2Parser on: xmlStringOrStream)
		contentHandler: MyContentHandlerClass new;
		parseDocument.

See SAX2Parser and SAXHandler for more info.!
!SAX2DeclarationHandler commentStamp: '' prior: 0!
This is a base class for SAX2 declaration handler classes that can be injected into SAX2Parser instances with #declarationHandler: before parsing:
	(SAX2Parser on: xmlStringOrStream)
		declarationHandler: MyDeclarationHandlerClass new;
		parseDocument.

See SAX2Parser and SAXHandler for more info.!
!SAX2ElementHandler commentStamp: '' prior: 0!
This is a base class for SAX2 element handlers to be used with SAX2ElementParsers.

SAX2ElementParsers use individual SAX2ElementHandlers to handle the #startElement*, #endElement*, and #characters: events of each element in the document.

The parser can be accessed with #parser, and the parent element handler (if any) can be accessed with #parent.!
!SAX2ElementCharacterHandler commentStamp: '' prior: 0!
This class is a SAX2ElementHandler that handles #characters: events. Sending #characters returns the complete character data of the element as a string.!
!SAX2ElementHandlerFactory commentStamp: '' prior: 0!
This is a base class for element handler factories used by SAX2ElementParsers to create element handlers. Instances can be injected into a SAX2ElementParser with #elementHandlerFactory: before parsing.

This factory just uses the default handler class SAX2ElementHandler for all elements.!
!SAX2PluggableElementHandlerFactory commentStamp: '' prior: 0!
This class is a pluggable element handler factory with an API like XMLPluggableElementFactory. Instances can be injected into a SAX2ElementParser with #elementHandlerFactory: before parsing.

You can map combinations of element name, namespace URI, and attributes to specific element handler classes using the "handling" messages, and change the default element handler class used when there's no mapping with #elementHandlerClass:.

Instances can be saved and reused for performance and safely modified after copying.!
!SAX2ElementHandlerFactoryMapper commentStamp: '' prior: 0!
This is a base class for mappers to map element handler objects to element handler factories.

Requesting the factory for an element handler checks the handler's #elementHandlerFactory message first and then the mapper's own #elementHandlerFactory message which can be (and is) overridden in subclasses to return a default factory.

When a SAX2ElementParser requests the factory for a new element handler, if none is found, it will reuse (inherit) the current factory.!
!SAX2PluggableElementHandlerFactoryMapper commentStamp: '' prior: 0!
This class is a pluggable mapper to map element handler objects to element handler factories.

Requesting the factory for an element handler checks for a mapping set with  #mapElementHandlerClass: toFactory:, then the handler's  #elementHandlerFactory message, then the mapper's own #elementHandlerFactory message, which returns a default factory (unlike in the base class) which can be changed with #elementHandlerFactory:.

When a SAX2ElementParser requests the factory for a new element handler, if none is found, it will reuse (inherit) the current factory, but this won't happen unless the default factory is cleared by setting #elementHandlerFactory: to nil.

Instances can be saved and reused for performance and safely modified after copying.!
!SAX2LexicalHandler commentStamp: '' prior: 0!
This is a base class for SAX2 lexical handler classes that can be injected into SAX2Parser instances with #lexicalHandler: before parsing:
	(SAX2Parser on: xmlStringOrStream)
		lexicalHandler: MyLexicalHandlerClass new;
		parseDocument.

See SAX2Parser and SAXHandler for more info.!
!SAXHandler commentStamp: '' prior: 0!
This class is an event-handling XML parser. To use it, subclass it and override event handlers in the "handling" categories, such as #startDocument, #startElement:attributes:, #endElement:, and #endDocument.

By default XML namespace support and validation are enabled but not external entity resolution.

Once the subclass is ready, use the class "parsing" messages to parse XML:
	result := SAXHandlerSubclass parse: xmlStringOrStream.
	resultFromURL := SAXHandlerSubclass parseURL: xmlURLString.
	resultFromFile := SAXHandlerSubclass parseFileNamed: xmlFileName.

The class "instance creation" messages create and return new parsers on the input so they can be configured with messages in the  "configuring" category before parsing:
	result :=
		(SAXHandlerSubclass on: xmlStringOrStream)
			isValidating: true;
			resolvesExternalEntities: true;
			parseDocument.

#interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil: 
	result :=
		(SAXHandlerSubclass on: xmlStringOrStream)
			parseDocumentWhile: [self shouldKeepParsing].

To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:
	(handler := SAXHandlerSubclass on: xmlStringOrStream)
		isValidating: false; 
		preservesUndeclaredEntityReferences: true.
	parser := handler parser.

	"Only parse the first 10 tokens:"
	10 timesRepeat: [parser parseToken].

There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:
	result :=
		(SAXHandlerSubclass on: xmlStringOrStream)
			removeLimits;
			documentReadLimit: newReadLimit;
			maxEntityReplacementDepth: newMaxEntityDepth;
			parseDocument.
		
#optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.!
!SAX2Parser commentStamp: '' prior: 0!
This class is a parser with an API like SAX 2.0, with separate SAX2ContentHandler, SAX2LexicalHandler, and SAX2DeclarationHandler classes that are subclassed unlike SAX 1.0 where a single,  unified handler class is subclassed directly. Parsers can be created with #on: or other instance creation messages, and instances of the content, lexical, and declaration handlers can be injected before parsing with #contentHandler:, #lexicalHandler:, and #declarationHandler:, like this:
	(SAX2Parser on: xmlStringOrStream)
		contentHandler: MyContentHandlerClass new;
		declarationHandler: MyDeclarationHandlerClass new;
		lexicalHandler: MyLexicalHandlerClass new;
		parseDocument.

Each handler can access the SAX2Parser object with #parser and set the parsing result returned by #parseDocument with #parsingResult:.

SAXHandler is not deprecated and can still be used if you prefer the SAX 1.0 style API.!
!SAX2ElementParser commentStamp: '' prior: 0!
This class is a SAX2Parser that uses individual SAX2ElementHandlers to handle the #startElement*, #endElement*, and #characters: events of each element in the document. All other content events are handled by a single SAX2ContentHandler as usual.

Custom subclasses of SAX2ElementHandler can be mapped to element names, namespace URIs, and attributes using a SAX2PluggableElementHandlerFactory. Factories can be injected with #elementHandlerFactory: before parsing.
See #testParsingSampleBooks for an example.

You can have multiple factories by mapping specific SAX2ElementHandlers to specific factories using a SAX2PluggableElementHandlerFactoryMapper, which can be injected with #elementHandlerFactoryMapper: before parsing. This can be used to create a finite-state machine, with the element handler instances being the states and the mapped factories being their transitions.
See #testParsingSamplePerson for an example.!
!XMLDOMParser commentStamp: '' prior: 0!
This class is an XML parser that parses XML into a tree of nodes with an XMLDocument node as the root:
	document := XMLDOMParser parse: xmlStringOrStream.

See the XML-Parser-DOM category for info on the node classes.

By default, XML comments are ignored during parsing and "<!![CDATA[...]]>" sections are merged with adjacent character data as XMLString nodes. Use #preservesCommentNodes: or #preservesCDataNodes: before parsing to change this. You can also use #preservesIgnorableWhitespace: to preserve ignorable whitespace as XMLString nodes, but this requires a DTD with <!!ELEMENT> declarations to distinguish ignorable and unignorable whitespace.

To control what node classes the parser uses to construct the tree, inject a custom node factory with #nodeFactory: prior to parsing. See XMLNodeFactory.

See the superclass for more info.!
!XMLAbstractFactory commentStamp: '' prior: 0!
An abstract class for dynamically choosing a supported concrete implementation from a class hierarchy for this platform.

Each root subclass needs to override #preferredImplementation to return the preferred subclass and #noSupportedImplementationFound to signal an error if none are supported, and then each subclass of the root needs to define #isSupportedImplementation to return true if it supports this platform.!
!XMLFileHandle commentStamp: '' prior: 0!
This is an abstract class for file handles to read/write/delete files. Subclasses need to implement the abstract methods, and then instances of the correct concrete class for this platform can be created by sending #asXMLFileHandle to a string.

The #readStream/#writeStream messages return file streams that do decoding/encoding, while the #rawReadStream/#rawWriteStream streams don't.

These classes implement the #get/#getUpToLimit:decoding: and #streamGet/#streamGetUpToLimit:decoding: interface of XMLURI.!
!XMLFileDirectoryFileHandle commentStamp: '' prior: 0!
This class uses FileDirectory/DirectoryEntry to implement file IO. This is used on Squeak and Gemstone, which don't support the Pharo FileSystem API.!
!XMLFileSystemFileHandle commentStamp: '' prior: 0!
This class uses the Pharo FileSystem API to implement file IO. The preferred implementation.!
!XMLFileReadStreamFactory commentStamp: '' prior: 0!
An abstract factory for file read streams used by XMLFileHandles.

Subclasses should create read streams that return raw byte characters and not characters decoded from some encoding (like UTF-8), so that XMLParser can do its own decoding later looking at byte-order marks and the <?xml ...?> encoding attribute.!
!XMLStandardFileStreamReadStreamFactory commentStamp: '' prior: 0!
A StandardFileStream read stream factory. This stream is preferred for Squeak/Pharo because it does no decoding and returns byte characters so XMLParser can do its own decoding.!
!XMLFileWriteStreamFactory commentStamp: '' prior: 0!
An abstract factory for file write streams used by XMLFileHandles.

Subclasses should create write streams that do no automatic encoding and accept raw byte characters, so XMLParser can do its own encoding.!
!XMLStandardFileStreamWriteStreamFactory commentStamp: '' prior: 0!
A StandardFileStream write stream factory. This stream is preferred for Pharo/Squeak because it does no encoding and accepts byte characters so XMLParser can do its own encoding.!
!XMLHTTPMessage commentStamp: '' prior: 0!
This is an abstract class for HTTP messages.!
!XMLHTTPRequest commentStamp: '' prior: 0!
This is an abstract base class for HTTP requests.

These classes implement the #get/#getUpToLimit:decoding: and #streamGet/#streamGetUpToLimit:decoding: interface of XMLURI.!
!XMLHTTPWebClientRequest commentStamp: '' prior: 0!
This class uses the WebClient library to implement HTTP requests. This is used on Squeak when Zinc isn't installed.!
!XMLHTTPZincRequest commentStamp: '' prior: 0!
This class uses Zinc HTTP Components to implement HTTP requests and is the preferred implementation.!
!XMLHTTPResponse commentStamp: '' prior: 0!
This is an abstract base class for HTTP responses.!
!XMLHTTPWebClientResponse commentStamp: '' prior: 0!
This class uses the WebClient library to implement HTTP responses. This is used on Squeak when Zinc isn't installed.!
!XMLHTTPZincResponse commentStamp: '' prior: 0!
This class uses Zinc HTTP Components to implement HTTP responses and is the preferred implementation.!
!XMLKeyValueCache commentStamp: '' prior: 0!
A simple key-value cache that automatically empties when it reaches a maximum size. Uses a reentrant mutex to ensure thread-safety.!
!XMLStandardKeyValueCache commentStamp: '' prior: 0!
This class is the standard key-value cache implementation used on Pharo/Squeak.!
!XMLReentrantMutex commentStamp: '' prior: 0!
An abstract class for reentrant mutexes that support nested sends of #critical: by the same process without deadlocking.!
!XMLStandardReentrantMutex commentStamp: '' prior: 0!
This class is the standard implementation that uses Pharo and Squeak's Mutex class to implement a reentrant mutex.!
!XMLAbstractReadStream commentStamp: '' prior: 0!
An abstract class for read streams.!
!XMLNullReadStream commentStamp: '' prior: 0!
This class is a null read stream that is already #atEnd and also makes sending #atEnd after #close or sending #close more than once safe, which is needed for the XMLNestedStreamReader null stream.!
!XMLSingleCharacterReadStream commentStamp: '' prior: 0!
A read stream for single characters. This is faster and uses less memory than converting a char to a string and using a read stream on it.!
!XMLAbstractReadStreamParser commentStamp: '' prior: 0!
This class is a generic abstract parser class for read-stream based parsers. It wraps its input stream with an XMLReadStreamAdapter and can parse tokens using #nextDelimitedBy: and #nextDelimitedByAny: and a temp write stream buffer.!
!XMLHTTPMIMETypeParser commentStamp: '' prior: 0!
This is a class to parse MIME types with a main type and sub type separated by a "/", like "text/plain", and optional name=value parameters separated by ";" after. Adapted from ZnMimeType.!
!XMLURIParser commentStamp: '' prior: 0!
This class is a parser that can extract the scheme, user info, host, port, path segments, query (as an OrderedCollection of associations), and fragment of a URI. It does not handle percent decoding and raises no errors.!
!XMLAttributeDefaultValidator commentStamp: '' prior: 0!
This is a base class for attribute default validators that implement constraints from the default declaration part of an ATTLIST attribute definition.!
!XMLAttributeImpliedDefaultValidator commentStamp: '' prior: 0!
This class allows an attribute to be absent (the #IMPLIED constraint).!
!XMLAttributeRequiredDefaultValidator commentStamp: '' prior: 0!
This class makes sure an attribute is present (the #REQUIRED constrant).!
!XMLAttributeValueDefaultValidator commentStamp: '' prior: 0!
This class will put a default value for an attribute if the attribute is absent.!
!XMLAttributeFixedValueDefaultValidator commentStamp: '' prior: 0!
This class will put a default value for an attribute if the attribute is absent and also makes sure that any value matches the default (the #FIXED constraint).!
!XMLStandaloneExternalAttributeFixedValueDefaultValidator commentStamp: '' prior: 0!
This class will make sure the value of a standalone externally defined attribute is present and that it matches a fixed default value (the #FIXED constraint).!
!XMLStandaloneExternalAttributeValueDefaultValidator commentStamp: '' prior: 0!
This class will make sure the value of a standalone externally defined attribute is present (the default value is never used).!
!XMLAttributeSpec commentStamp: '' prior: 0!
This is a base class for attribute specifications. Subclasses need to implement matchesAttributes: to return true if the argument attribute dictionary matches the spec and false otherwise.!
!XMLBasicAttributeSpec commentStamp: '' prior: 0!
A simple attribute spec that checks for attributes being present and optionally having a specific value.!
!XMLPluggableAttributeSpec commentStamp: '' prior: 0!
A block-based pluggable attribute spec that evaluates blocks with the attribute dictionary to test matching.!
!XMLAttributeValidator commentStamp: '' prior: 0!
This is a base class for attribute validators.!
!XMLCDataAttributeValidator commentStamp: '' prior: 0!
This class validates CDATA attributes, which are not whitespace-normalized further.!
!XMLStandaloneExternalCDataAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined CDATA attributes. It disallows attributes that need substitution with default or fixed default values.!
!XMLEntityAttributeValidator commentStamp: '' prior: 0!
This class validates attributes that contain unparsed entity names (that must be declared).!
!XMLEntitiesAttributeValidator commentStamp: '' prior: 0!
This class validates attributes with lists of unparsed entity name values (that must be declared) separated by spaces.!
!XMLStandaloneExternalEntitiesAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined attributes with lists of unparsed entity name values (that must be declared) separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLStandaloneExternalEntityAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined attributes that contain unparsed entity names (that must be declared). It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLEnumerationAttributeValidator commentStamp: '' prior: 0!
This class validates attributes that can have any value taken from a list like "(one|two|thee)".!
!XMLNotationEnumerationAttributeValidator commentStamp: '' prior: 0!
This class validates attributes that can have NOTATION names from a list as values.!
!XMLStandaloneExternalNotationEnumerationAttributeValidator commentStamp: '' prior: 0!
This class validates attributes that can have NOTATION names from a list as values. It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLStandaloneExternalEnumerationAttributeValidator commentStamp: '' prior: 0!
This class validates attributes that can have any value taken from a list like "(one|two|thee)". It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLIDAttributeValidator commentStamp: '' prior: 0!
This class validates ID attributes that must have unique (not repeated in the same document) values.!
!XMLStandaloneExternalIDAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined ID attributes that must have unique (not repeated in the same document) values. It disallows attributes that require further value normalization.!
!XMLXMLIDAttributeValidator commentStamp: '' prior: 0!
This class validates ID attributes for the xml:id spec.!
!XMLStandaloneExternalXMLIDAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined xml:id ID attributes. It disallows attributes that require further value normalization.!
!XMLIDRefAttributeValidator commentStamp: '' prior: 0!
This class validates attributes that refer to an ID of another element with a ID attribute.!
!XMLIDRefsAttributeValidator commentStamp: '' prior: 0!
This class validates attributes with lists of ID ref values separated by spaces.!
!XMLStandaloneExternalIDRefsAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined attributes with lists of ID ref values separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLStandaloneExternalIDRefAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined attributes that refer to an ID of another element with an ID attribute. It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLNmtokenAttributeValidator commentStamp: '' prior: 0!
This class validates Nmtoken name attributes.!
!XMLNmtokensAttributeValidator commentStamp: '' prior: 0!
This class validates attributes with lists of Nmtoken name values separated by spaces.!
!XMLStandaloneExternalNmtokensAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined attributes with lists of Nmtoken name values separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLStandaloneExternalNmtokenAttributeValidator commentStamp: '' prior: 0!
This class validates standalone externally defined Nmtoken name attributes. It disallows attributes that require further value normalization or substitution with default or fixed default values.!
!XMLClassFinder commentStamp: '' prior: 0!
A simple cross-platform interface for finding classes that may not be in the image.!
!XMLConfiguration commentStamp: '' prior: 0!
This class stores the settings and components of a parser. For performance it uses separate inst vars instead of a dictionary and lazy initializes some components.!
!XMLDOMConfiguration commentStamp: '' prior: 0!
This class stores additional settings and components relevant to the DOM parser and DOM nodes.!
!XMLDFAState commentStamp: '' prior: 0!
This class is a DFA state made by grouping one or more NFA states.!
!XMLDFAStateCache commentStamp: '' prior: 0!
This class uses a dictionary with NFAStateSet keys to cache DFA states. (Does not use the regular XML key/value  cache for performance)!
!XMLDocumentValidator commentStamp: '' prior: 0!
This is a base class for XML document validators.!
!DTDDocumentValidator commentStamp: '' prior: 0!
This class validates documents using a DTD.!
!XMLElementClassMapper commentStamp: '' prior: 0!
This is a base class for element class mappers. Subclasses need to implement the abstract methods to register and lookup classes mapped to element names, namespace URIs, and attributes.!
!XMLBasicElementClassMapper commentStamp: '' prior: 0!
This class can match elements to classes based on their names, namespace URIs, and attributes.

The precedence of mapping goes:
-Qualified name, namespace URI, and attributes
-Qualified name and namespace URI
-Qualified name and attributes
-Qualified name
-Non-qualified name, namespace URI, and attributes
-Non-qualified name and namespace URI
-Non-qualified name and attributes
-Non-qualified name!
!XMLElementIDValidator commentStamp: '' prior: 0!
This class is shared by attribute validators to validate element IDs and ID references, including xml:id IDs.!
!XMLElementNester commentStamp: '' prior: 0!
This is a base class for element nesters that are used by parser tokenizers and drivers to keep track of which elements are open while parsing and ensure they are properly nested.!
!XMLElementValidator commentStamp: '' prior: 0!
This is a base class for element validators.!
!XMLAnyElementValidator commentStamp: '' prior: 0!
This class validates elements that can contain any content.!
!XMLDFAElementValidator commentStamp: '' prior: 0!
This class validates elements using a regular expression converted to a DFA. It ignores PCDATA, comments, and PIs.!
!XMLDFAElementContentElementValidator commentStamp: '' prior: 0!
This class validates elements that can only contain element content (no PCDATA) using a regular expression converted to a DFA. It ignores comments, PIs, and whitespace.!
!XMLStandaloneExternalDFAElementContentElementValidator commentStamp: '' prior: 0!
This class validates standalone externally defined elements with element content that cannot have whitespace between elements unlike the superclass.!
!XMLEmptyElementValidator commentStamp: '' prior: 0!
This class validates EMPTY elements, which can't contain elements, PCDATA, or even comments or PIs.!
!XMLMixedContentElementValidator commentStamp: '' prior: 0!
This class validates elements that can contain a mix of PCDATA and certain elements.!
!XMLEncodingDetector commentStamp: '' prior: 0!
This is a class for automatic encoding detection of streams that infers encodings from a leading byte order mark (BOM) sequence.!
!XMLImplicitEncodingDetector commentStamp: '' prior: 0!
This is a class for automatic encoding detection of streams that infers explicit encodings from a leading byte order mark (BOM) sequence and implicit encodings from a sequence of one or three null bytes before or after a leading ASCII character (implicit UTF 16/32).

(It actually implements the YAML implicit encoding detection algorithm, looking for any leading ASCII char, not just '<', before or after a null byte sequence. This algorithm is more general than the XML one, supporting non-XML text, and since the XML one is in a "(Non-Normative)" section of the spec, we don't actually have to implement it.)!
!XMLHTTPDecompressingReadStreamAdapterFactory commentStamp: '' prior: 0!
This class is a read stream adapter factory for decoding content compressed with compression schemes like GZip and DEFLATE.!
!XMLHTTPGZipDecompressingReadStreamAdapterFactory commentStamp: '' prior: 0!
A read stram adapter factory for the GZip compression scheme. Uses GZipReadStream if available.!
!XMLHTTPMIMEType commentStamp: '' prior: 0!
This is an immutable class for HTTP MIME types. Adapted from ZnMimeType.!
!XMLHTTPResponseContentReader commentStamp: '' prior: 0!
This is an abstract base class for response content readers. The #readUpToLimit:decoding: message returns the entire  decoded (if enabled) response content, raising an XMLLimitException if it exceeds the specified limit.

Subclasses need to implement #rawReadWithLength:upToLimit: to read and return the raw response content and signal an error if it exceeds the limit.!
!XMLHTTPWebClientResponseContentReader commentStamp: '' prior: 0!
A WebClient content reader.!
!XMLHTTPZincResponseContentReader commentStamp: '' prior: 0!
A Zinc content reader. Zinc handles decompression automatically, so this class doesn't.!
!XMLIntegerReader commentStamp: '' prior: 0!
This class reads positive hex or decimal integers from minimal streams supporting #next, #peek, and #atEnd. It returns nil instead of raising errors for invalid integers.!
!XMLSmallIntegerReader commentStamp: '' prior: 0!
This class reads positive hex or decimal integers up to the maximum a SmallInteger can hold from minimal streams supporting #next, #peek, and #atEnd, handling overflow with saturation. It returns nil instead of raising errors for invalid integers.!
!XMLNFABuilder commentStamp: '' prior: 0!
This class builds an NFA using a stack of NFAFragments.!
!XMLNFAFragment commentStamp: '' prior: 0!
This class implements NFA fragments for an XMLNFABuilder. It stores a first state and either a single terminal state or a collection of terminal states (using an OrderedCollection instead of an XMLNFAStateSet), and it can be connected to a state or another fragment.!
!XMLNFAState commentStamp: '' prior: 0!
This is a base class for NFA states.!
!XMLNFAAcceptingState commentStamp: '' prior: 0!
An NFA in this state is considered to accept the input.!
!XMLNFABranchingState commentStamp: '' prior: 0!
This state can branch off into two different states without matching against anything.!
!XMLNFAMatchingState commentStamp: '' prior: 0!
This state can pass to a next state if the input matches against an object.!
!XMLNamespaceScope commentStamp: '' prior: 0!
A namespace scope is a possibly empty set of mappings from namespace prefixes to URIs and an optional default namespace URI to be used for unprefixed elements. Scopes can be created from other scopes by copying. (Uses copy-on-write to reduce memory use.)!
!XMLNamespaceScopeAllocator commentStamp: '' prior: 0!
This class allocates namespace scopes with a stack. Sending #enterScope pushes a new scope onto the stack that inherits all mappings from the previous (enclosing) scope, and #exitScop pops it off.!
!XMLNestedStreamReader commentStamp: '' prior: 0!
This class represents a stream reader that implements pushBack: using nested streams. This enables subsitution/replacement to be performed without modifying the underlying collections streamed-over or having to copy them. It also performs line-ending normalization, transforming a CR or a CRLF sequence into a single LF character.

(The code in this class is optimized; refactor with care.)!
!XMLNode commentStamp: '' prior: 0!
This is a base class for XML nodes. It has testing messages, messages to access the parent, sibling, and ancestor nodes, and messages to control printing.!
!XMLAttribute commentStamp: '' prior: 0!
The class represents an attribute node stored in an attribute node list. The name of an attribute node can be namespaced using prefixes, but the prefix must be mapped to a namespace URI in the containing element node. Unprefixed attributes have no namespace, not even a default if one is in scope, per the XML namespace standard.

The element of an attribute can be accessed with #element, but also with #parent, because attributes are modeled so their element is their parent (to simplify the implementation of the XPath library).!
!XMLComment commentStamp: '' prior: 0!
This class represents a comment node. Comments are ignored during parsing by default. If you want them preserved as comment nodes, use #preservesCommentNodes: with the DOM parser before parsing.!
!XMLDeclarationNode commentStamp: '' prior: 0!
This is an abstract class for markup declaration nodes in the internal subset.!
!XMLAttributeDeclaration commentStamp: '' prior: 0!
This is a class for <!!ATTLIST> declarations with definitions for single attributes. (An ATTLIST with multiple attribute defs is the same as a series of separate ATTLISTs for each def)!
!XMLElementDeclaration commentStamp: '' prior: 0!
This is a class for <!!ELEMENT> declarations.!
!XMLEntityDeclaration commentStamp: '' prior: 0!
This is an abstract class for general and parameter <!!ENTITY> declarations.!
!XMLGeneralEntityDeclaration commentStamp: '' prior: 0!
This is a class for general <!!ENTITY> declarations.!
!XMLParameterEntityDeclaration commentStamp: '' prior: 0!
This is a class for parameter <!!ENTITY> declarations.!
!XMLNotationDeclaration commentStamp: '' prior: 0!
This is class for <!!NOTATION> declarations.
!
!XMLNodeWithChildren commentStamp: '' prior: 0!
This is an abstract class for nodes that can contain child nodes.

It has messages to access, add and remove child nodes. The nodes are stored in a kind of XMLObservableList returned by #nodes, which can be modified directly to add or remove nodes from the owner of #nodes (copy it first if that isn't what you want).

There are three types of "enumerating" messages: the #nodes* messages enumerate child nodes of the receiver, the #allNode* forms enumerate (using depth-first traversal) the receiver and all descendant nodes, and the #descendantNode* forms  enumerate only descendant nodes.!
!XMLDoctypeDeclaration commentStamp: '' prior: 0!
This class represents a <!!DOCTYPE ...> declaration. It stores the root element name, public/system ID, and its nodes are the internal subset.!
!XMLNodeWithElements commentStamp: '' prior: 0!
This is an abstract class for nodes with elements.

Instances provide "accessing" messages to retrieve child elements by their name and namespace information. The #elementAt: forms return the first matching element, while the #elementsAt: forms return all matching child elements.

There are three different modes of enumeration: the #elements* enumerating messages enumerate child elements, the #allElements* forms enumerate the receiver (if it's an element) and all descendant elements, and the #descendantElement* forms enumerate descendant elements only.

The #findElementNamed:* forms search the receicer (if it's an element) and descendants for a specific element.

Element name matching is done the qualified and local name, so 'prefix:element-name' will only match 'prefix:element-name' while 'element-name' will match 'element-name', 'prefix:element-name' or 'different-prefix:element-name' and so on.

The inner XML can be accessed as a string using #innerXML and set (reparsed) using #innerXML:.!
!XMLDocument commentStamp: '' prior: 0!
This class represents a document node, which is often the root of a DOM tree. Nodes can access their document ancestor with #document.!
!XMLElement commentStamp: '' prior: 0!
The class represents an element node, which has a qualified or unqualified name and optionally attributes, namespace declarations and child nodes.

Element names can be tested using #isNamed: and #isNamedAny:, which test both the qualified and local name.

If the name is qualified and namespace support is enabled (the default), then the prefix must be mapped to a namespace URI in the element or an ancestor. The class-side instance creation #name:namespaceURI:* and #name:namespaces:* messages and the instance-side #name:namespaceURI: message can set both simultaneously. If namespace support is disabled, prefixes are not checked.

The #attribute* messages provide a Dictionary-like protocol for manipulating attribute nodes. Unlike the #elementAt:* messages, they match qualified names only, and attribute value accessors return empty strings if the attribute is absent. The underlying attribute node list can be accessed using #attributeNodes (copy before modifying if you don't want to change the element's attributes), and the names/values can be obtained as an (order-preserving) dictionary using #attributes.

See the superclasses for more info.!
!XMLPI commentStamp: '' prior: 0!
This class represents a processing instruction node.!
!XMLString commentStamp: '' prior: 0!
This class represents a string (character data) node. Instances are mutable, but the string is treated as immutable. String nodes can be created using the class-side #string: message or by sending a String #asXMLStringNode. 

When printing, XML-escaping of special characters is done.!
!XMLCData commentStamp: '' prior: 0!
This class represents a preserved <!![CDATA[...]]> section. By default these are handled as XMLString nodes and merged with adjacent string nodes during parsing.  To preserve CDATA nodes, use #preservesCDataNodes: with the DOM parser before parsing.!
!XMLNodeFactory commentStamp: '' prior: 0!
This class is the default node factory. Its accessor messages return the classes used by the DOM parser to build a node tree. You can override these messages to return different classes and inject an instance with the DOM parser's #nodeFactory: message before parsing.!
!XMLPluggableNodeFactory commentStamp: '' prior: 0!
This is a pluggable node factory that can be used to change which classes the DOM parser uses to build the DOM tree. Here is an example:

	(XMLDOMParser on: anXMLStringOrStream)
		nodeFactory:
			(XMLPluggableNodeFactory new
				documentClass: MyDocumentClass;
				elementClass: MyElementClass;
				stringNodeClass: MyStringNodeClass);
		parseDocument.

Instances can be saved and reused for performance and safely modified after copying.!
!XMLPluggableElementFactory commentStamp: '' prior: 0!
This class is a pluggable node factory that can also map elements to different XMLElement subclasses based on the name, namespace information, and attributes of those elements. You have to create an instance, configure it to handle certain elements with certain classes, and then inject your instance into a DOM parser using #nodeFactory: before parsing. Here is an example:

	(XMLDOMParser on: anXMLStringOrStream)
		nodeFactory:
			(XMLPluggableElementFactory new
				elementClass: GenericElement;
				handleElement: 'user' withClass: UserElement;
				handleElement: 'report' withClass: ReportElement;
				handleElement: 'report' namespaceURI: 'urn:specialreprot' withClass: SpecialReportElement);
		parseDocument.

Instances can be saved and reused for performance and safely modified after copying.!
!XMLNodeVisitor commentStamp: '' prior: 0!
This is a base class for DOM node tree visitors. Subclasses can implement any of the "visiting" messages, and instances can be used by sending a node #acceptNodeVisitor: with it as the argument.!
!XMLMutatingNodeVisitor commentStamp: '' prior: 0!
This is a mutating node visitor that can remove nodes during enumeration by returning nil from a #visit* method, or replace a node by returning a new node other than the argument.!
!XMLValidatingNodeVisitor commentStamp: '' prior: 0!
A validating node visitor that can validate DOM node trees using XMLDocumentValidators.!
!XMLParser commentStamp: '' prior: 0!
This class is a facade that parses XML using a driver and tokenizer. See SAXHandler and XMLDOMParser for ready-made front ends to it.!
!XMLParserDriver commentStamp: '' prior: 0!
This is a base class for parser drivers. Subclasses should override any of the "handling" or "handling - dtd" messages sent by tokenizers to parse tokens.!
!DTDSubsetParserDriver commentStamp: '' prior: 0!
An abstract class for handling internal and external DTD subset events.!
!DTDExternalSubsetParserDriver commentStamp: '' prior: 0!
This class is used by SAXParserDriver for parsing the external subset of a DTD.!
!SAXParserDriver commentStamp: '' prior: 0!
SAXParserDriver together with SAXHandler provides a SAX-like API for XML parsing. The driver processes XML tokens and signals SAX events to a SAXHandler. See SAXHandler for more info.!
!XMLParserLimits commentStamp: '' prior: 0!
This class places security limits on input. Setting a limit to nil disables it, and removeAll disables all.!
!XMLParserTokenizer commentStamp: '' prior: 0!
This is a base class for parser tokenizers that read tokens from a stream using an XMLNestedStreamReader and state objects. Sending #nextToken causes a token to be read and handler messages to be sent to a driver.

Be careful changing the code in this class or subclasses because it's optimized.!
!XMLWellFormedParserTokenizer commentStamp: '' prior: 0!
This is a tokenizer for well-formed XML documents that supports DTD subsets and entity replacement.!
!XMLPushedBackEntity commentStamp: '' prior: 0!
An abstract base class for decorating pushed-back entities to keep track of the nesting of markup within entity replacements.!
!XMLPushedBackGeneralEntity commentStamp: '' prior: 0!
A class to decorate pushed-back general entities to keep track of the nesting of elements within entity replacements.

Each time a start tag is parsed from the entity's replacement, the count is incremented, and each time an end tag is parsed, it's decremented. If it goes negative, then an end tag terminated an element not started by the entity. When the entity is popped, the count should be zero. (This is more efficient than having the element nester also keep track of which entity replacement an element began in.)!
!XMLPushedBackParameterEntity commentStamp: '' prior: 0!
A class to decorate pushed-back parameter entities to keep track of the nesting of include sections within entity replacements.!
!XMLPushedBackStream commentStamp: '' prior: 0!
A base class to store a nested stream for XMLNestedStreamReader, along with its callback and the current position, line number, and line start position of the current external stream.!
!XMLPushedBackExternalStream commentStamp: '' prior: 0!
A class to store a nested external stream for XMLNestedStreamReader.!
!XMLPushedBackInternalStream commentStamp: '' prior: 0!
A class to store a nested internal stream for XMLNestedStreamReader. It reports the current position, line number, and line start position of its enclosing external stream.!
!XMLStreamAdapter commentStamp: '' prior: 0!
An abstract class for read and write stream adapters.!
!XMLReadStreamAdapter commentStamp: '' prior: 0!
A base class for read stream adapters for basic streams that support #next, #peek, #atEnd, #position, #position:, and #reset. It adds support for skipping and reading upto a character or the end of the stream, and ensures #next and #peek return nil when the stream is #atEnd instead of raising an error.!
!XMLDecodingReadStreamAdapter commentStamp: '' prior: 0!
A read stream adapter that decodes stream contents using a stream converter. Used to handle encoded external streams.

The class  #on: and #on:streamConverter: instance creation messages accept character and binary streams.!
!XMLLimitedReadStreamAdapter commentStamp: '' prior: 0!
This class is a limited read stream adapter that will not read beyond a limit. Position changes are limited so you can only move forward as many positions as the limit allows, and moving backwards increases the number of objects that can be read.!
!XMLPercentDecodingReadStreamAdapter commentStamp: '' prior: 0!
This class percent decodes octets for URIs.!
!XMLStringReadStreamAdapter commentStamp: '' prior: 0!
A read stream adapter for string read streams that accepts character input and converts it to binary output.!
!XMLWriteStreamAdapter commentStamp: '' prior: 0!
A base class for write stream adapters for basic streams that support #nextPut:, #nextPutAll:, #contents, #position, #position:, and #reset. It adds support for writing characters like tabs, spaces, and line endings.!
!XMLEncodingWriteStreamAdapter commentStamp: '' prior: 0!
A write stream adapter that encodes stream contents using a stream converter.!
!XMLNodeContentWriteStreamAdapter commentStamp: '' prior: 0!
A write stream adapter for writing node content with whitespace insertion if needed between writes.!
!XMLPercentEncodingWriteStreamAdapter commentStamp: '' prior: 0!
A write stream adapter for percent encoding octets for URIs.!
!XMLStringWriteStreamAdapter commentStamp: '' prior: 0!
A write stream adapter that accepts binary input and converts it to character output for string write streams.!
!XMLStreamConverter commentStamp: '' prior: 0!
An abstract class for stream converters.

Subclasses need to implement #nextFromStream: to use #basicNext on the argument to read byte characters and decode them, and implement #nextPut:toStream: to use #basicNextPut:/#basicNextPutByte: on the second argument to encode the first.

The class #basicEncodingNames method should return a basic list of names for the encoding handled by the class, and #byteOrderMarkBytes can return the bytes of a BOM if the encoding has one.!
!XMLStatelessStreamConverter commentStamp: '' prior: 0!
This is a base class for stateless, immutable stream converter classes. Each subclass has a single instance that is shared.!
!XMLASCIIStreamConverter commentStamp: '' prior: 0!
A stream converter for ASCII.!
!XMLLatin1StreamConverter commentStamp: '' prior: 0!
A stream converter for ISO Latin-1.!
!XMLNullStreamConverter commentStamp: '' prior: 0!
A stream converter that does no encoding or decoding.!
!XMLUTFStreamConverter commentStamp: '' prior: 0!
An abstract class for Unicode stream converters.!
!XMLUTF16StreamConverter commentStamp: '' prior: 0!
An abstract class for UTF-16 stream converters.!
!XMLUTF16BigEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for big endian UTF-16 streams, and the default converter class used when a UTF-16 stream converter is created with newForEncoding: or asXMLStreamConverter and no endian is specified by the encoding name.!
!XMLImplicitUTF16BigEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for implicit big endian UTF-16 streams.!
!XMLUTF16LittleEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for little endian UTF-16 streams.!
!XMLImplicitUTF16LittleEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for implicit little endian UTF-16 streams.!
!XMLUTF32StreamConverter commentStamp: '' prior: 0!
An abstract class for UTF-32 stream converters.!
!XMLUTF32BigEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for big endian UTF-32 streams, and the default converter class used when a UTF-32 stream converter is created with newForEncoding: or asXMLStreamConverter and no endian is specified by the encoding name.!
!XMLImplicitUTF32BigEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for implicit big endian UTF-32 streams.!
!XMLUTF32LittleEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for little endian UTF-32 streams.!
!XMLImplicitUTF32LittleEndianStreamConverter commentStamp: '' prior: 0!
A stream converter for implicit little endian UTF-32 streams.!
!XMLUTF8StreamConverter commentStamp: '' prior: 0!
A stream converter for UTF-8 streams. (Rejects overlong encodings.)!
!XMLImplicitUTF8StreamConverter commentStamp: '' prior: 0!
A stream converter for implicit UTF-8 streams.!
!XMLZincByteEncoderStreamConverter commentStamp: '' prior: 0!
A stream converter that wraps the ZnByteEncoder legacy byte encoder class. (Requires Zinc.)!
!XMLTokenizerState commentStamp: '' prior: 0!
This is an abstract class for states to control tokenization. Subclasses must implement #nextTokenFrom: to send a tokenizing message to the argument tokenizer.!
!XMLContentState commentStamp: '' prior: 0!
A state for content tokens, everything from the first stat tag to the end of the document.!
!XMLExternalSubsetState commentStamp: '' prior: 0!
A state for external subset tokens.!
!XMLExternalSubsetTextDeclarationState commentStamp: '' prior: 0!
A state for <?xml ...?> text declaration tokens at the start of the external DTD subset.

This state #canTerminateInput unlike XMLXMLDeclarationState because external subsets and parsed entities can be empty, but documents must have at least one element.!
!XMLPrologState commentStamp: '' prior: 0!
A state for prolog tokens.!
!XMLDoctypeDeclarationState commentStamp: '' prior: 0!
A state for <!!DOCTYPE ...> and internal subset tokens.!
!XMLInternalSubsetState commentStamp: '' prior: 0!
A state for internal subset tokens.!
!XMLPostDoctypeDeclarationState commentStamp: '' prior: 0!
A state for parsing prolog tokens after <!!DOCTYPE ...> declarations.!
!XMLXMLDeclarationState commentStamp: '' prior: 0!
A state for parsing the <?xml ...?> token.!
!XMLTerminatedState commentStamp: '' prior: 0!
A state for when tokenizing has stopped.!
!XMLUninitializedState commentStamp: '' prior: 0!
A state for before tokenizing has started.!
!XMLURI commentStamp: '' prior: 0!
A class for XML URIs. Instances are immutable and support combining with other XMLURIs or URI strings using / (to resolve relative URIs in the context of the receiver), accessing URI components, creating copies with replaced components, and retrieving the contents of http:// and file:// URLs using XMLHTTPRequest and XMLFileHandle.

Uses XMLURIParser to parse URIs lazily (for example, when a URI compoenent is accessed with an "accessing" message) when created from a string and eagerly when created from a stream.

URI components are stored internally in encoded form and decoded only when needed, because the XML standard requires delaying decoding for as long as possible.!
!XMLUnparsedEntityValidator commentStamp: '' prior: 0!
Used by attribute validators to validate attribute references to unparsed entities and notations.!
!XMLAttributeDictionary commentStamp: '' prior: 0!
This class is an OrderPreservingStringDictionary for XML attributes that returns empty strings instead of raising errors when absent keys are looked up. It has messages to lookup the namespace URI of an attribute key and to lookup an attribute value or association by local or qualified name and namespace URI.!
!XMLNamespacedAttributeDictionary commentStamp: '' prior: 0!
This subclass is used when namespaces are enabled. It has an extra inst var for namespace scopes.!
!XMLException commentStamp: '' prior: 0!
A generic exception class that supports message formatting. Used as a base class for exceptions in XMLParser and related packages like XPath.!
!XMLParserException commentStamp: '' prior: 0!
A base class for XMLParser exceptions that supports line number error info and can be used with on:do: to catch any XMLParser-related errors.!
!XMLDOMException commentStamp: '' prior: 0!
Invoked when a DOM tree is manipulated wrong.!
!XMLEncodingException commentStamp: '' prior: 0!
Invoked for encoding errors.!
!XMLFileException commentStamp: '' prior: 0!
Invoked for file IO errors.!
!XMLHTTPException commentStamp: '' prior: 0!
Invoked for HTTP errors.!
!XMLLimitException commentStamp: '' prior: 0!
Invoked when a security limit on input is exceeded. Use the messages in XMLParserLimits and DTDExternalEntityLimits to configure these limits or the removeLimits message to remove them completely.!
!XMLNamespaceException commentStamp: '' prior: 0!
Invoked when namespaces are used improperly and namespace checking is on.!
!XMLParsingInterruptException commentStamp: '' prior: 0!
Used to interrupt parsing from a SAXHandler. Will be silently caught.!
!XMLValidationException commentStamp: '' prior: 0!
Invoked when invalid XML is detected and validation is on.!
!XMLWellFormednessException commentStamp: '' prior: 0!
Invoked when XML markup is not well-formed.!
!XMLLazyAttributeDictionary commentStamp: '' prior: 0!
A lazy version of XMLAttributeDictionary that uses less memory until it's modified.!
!XMLLazyNamespacedAttributeDictionary commentStamp: '' prior: 0!
A lazy version of XMLNamespacedAttributeDictionary that uses less memory until it's modified.!
!XMLNFAStateSet commentStamp: '' prior: 0!
This class is a set of NFA states. It wraps an IdentitySet and keeps track of if any of its states is accepting.!
!XMLOrderedList commentStamp: '' prior: 0!
This class functions as an OrderedCollection that will not raise exceptions when attempts are made to access absent objects. This means messages like #at:, #after:, and #first will return nil when the requested object cannot be retrieved. Messages that modify the collection will still raise exceptions as usual.

!
!XMLObservableList commentStamp: '' prior: 0!
This class is an ordered list that sends notifications to an observer when objects are added to it or removed from it. Subclasses should override the #beforeAdding:, #afterAdding:at:, #afterAddingLast: and #afterRemoving: messages to send custom notifications.!
!XMLAttributeList commentStamp: '' prior: 0!
This class represents an ordered list of attribute nodes. It is not the default attribute list class, but it can be used by injecting it into a DOM parser before parsing:
	(parser := XMLDOMParser on: xmlSource)
		nodeFactory:
			(XMLPluggableNodeFactory new
				attributeListClass: XMLAttributeList);
		parseDocument.

It should be used over the default class when you want to reduce memory use at the cost of slower attribute lookup.!
!XMLCachingAttributeList commentStamp: '' prior: 0!
This class represents an ordered list of attribute nodes that also keeps a dictionary mapping attribute names to nodes for faster lookup.

This is the default attribute list class.!
!XMLInternalSubsetList commentStamp: '' prior: 0!
This class represents the list of nodes that comprise a document's internal DTD subset.!
!XMLNodeList commentStamp: '' prior: 0!
This class represents an ordered list of child nodes for an XML document or element. Non-modifying accessing messages like #first and #last return nil instead of raising exceptions.!
!XMLCachingNodeList commentStamp: '' prior: 0!
This is a node list that caches child elements by name, keeping both an ordered list of elements and a dictionary that allows for faster retrieval of elements by qualified or local name. To use it, inject it into a DOM parser before parsing:
	(parser := XMLDOMParser on: xmlSource)
		nodeFactory:
			(XMLPluggableNodeFactory new
				nodeListClass: XMLCachingNodeList);
		parseDocument.

It should only be used when you know the DOM tree will be queried much more often than parsed or modified and the extra memory use is OK.!
!DTDAttributeDefinitionParser class methodsFor: 'private'!
attributeDefaultValidatorClassForPragma: aDefaultPragma
	"the default pragma should have been checked for well-formedness by the
	tokenizer so it's either empty, 'FIXED', 'REQUIRED', or 'IMPLIED'"
	aDefaultPragma size > 0
		ifTrue: [
			(aDefaultPragma at: 1) == $F
				ifTrue: [^ XMLAttributeFixedValueDefaultValidator].
			(aDefaultPragma at: 1) == $I
				ifTrue: [^ XMLAttributeImpliedDefaultValidator].
			^ XMLAttributeRequiredDefaultValidator].
	^ XMLAttributeValueDefaultValidator.! !
!DTDAttributeDefinitionParser class methodsFor: 'instance creation'!
element: anElement attribute: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	^ self new
		setElement: anElement
		attribute: anAttribute
		type: aType
		defaultValidator:
			((self attributeDefaultValidatorClassForPragma: aDefaultPragma)
				attribute: anAttribute
				value: aDefaultValue)! !
!DTDAttributeDefinitionParser methodsFor: 'private'!
attributeValidatorClassForType
	"the tokenizer should have checked the type for well-formedness
	so it's only one of CDATA, ID, IDREF, IDREFS, etc"
	
	| nextChar |

	(nextChar := type at: 1) == $C
		ifTrue: [^ XMLCDataAttributeValidator].
	nextChar == $I
		ifTrue: [
			type size = 2 "'ID' size"
				ifTrue: [
					attribute = 'xml:id'
						ifTrue: [^ XMLXMLIDAttributeValidator].
					^ XMLIDAttributeValidator].
			type size = 5 "'IDREF' size"
				ifTrue: [^ XMLIDRefAttributeValidator].
			"'IDREF' size < 'IDREFS' size"
			^ XMLIDRefsAttributeValidator].
	nextChar == $E
		ifTrue: [
			type size = 6 "'ENTITY' size"
				ifTrue: [^ XMLEntityAttributeValidator].
			"'ENTITY' size < 'ENTITIES' size"
			^ XMLEntitiesAttributeValidator].
	nextChar == $N
		ifTrue: [
			type size = 7 "'NMTOKEN' size"
				ifTrue: [^ XMLNmtokenAttributeValidator].
			type size = 8 "'NMTOKENS' size"
				ifTrue: [^ XMLNmtokensAttributeValidator].
			"'NMTOKENS' size < 'NOTATION (' size"
			enumerationListParserClass := DTDNotationEnumerationListParser.
			^ XMLNotationEnumerationAttributeValidator].

	"otherwise it's a (one|two|...) enumeration attribute"
	enumerationListParserClass := DTDEnumerationListParser.
	^ XMLEnumerationAttributeValidator.! !
!DTDAttributeDefinitionParser methodsFor: 'parsing'!
parse
	| validator |
	
	validator :=
		self attributeValidatorClassForType
			element: element
			attribute: attribute
			defaultValidator: defaultValidator.

	enumerationListParserClass
		ifNotNil: [
			validator allowedValues:
				(enumerationListParserClass on: type) parse].

	^ validator.! !
!DTDAttributeDefinitionParser methodsFor: 'initialization'!
setElement: anElement attribute: anAttribute type: aType defaultValidator: aDefaultValidator
	element := anElement.
	attribute := anAttribute.
	type := aType.
	defaultValidator := aDefaultValidator.! !
!DTDStandaloneExternalAttributeDefinitionParser class methodsFor: 'private'!
attributeDefaultValidatorClassForPragma: aDefaultPragma
	^ (super attributeDefaultValidatorClassForPragma: aDefaultPragma)
		standaloneExternalClass! !
!DTDStandaloneExternalAttributeDefinitionParser methodsFor: 'private'!
attributeValidatorClassForType
	^ super attributeValidatorClassForType standaloneExternalClass! !
!DTDContentModelParser class methodsFor: 'instance creation'!
element: anElement contentModel: aContentModel
	^ self new
		setElement: anElement
		contentModel: aContentModel! !
!DTDContentModelParser class methodsFor: 'accessing'!
parserClassForContentModel: aContentModel
	"the tokenizer removes all spaces from the content model
	and checks it for well-formedness"
	(aContentModel at: 1) == $(
		ifTrue: [
			(aContentModel at: 2) == $# "#PCDATA mixed content"
				ifTrue: [^ DTDMixedContentModelParser]
				ifFalse: [^ DTDElementContentModelParser]]
		ifFalse: [^ DTDLiteralContentModelParser]! !
!DTDContentModelParser class methodsFor: 'defaults'!
standaloneExternalClass
	^ self! !
!DTDContentModelParser methodsFor: 'parsing'!
parse
	self subclassResponsibility! !
!DTDContentModelParser methodsFor: 'initialization'!
setElement: anElement contentModel: aContentModel
	element := anElement.
	contentModel := aContentModel.! !
!DTDElementContentModelParser class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self
		initializeSpecialCharacterParsers;
		initializeOperatorApplicators! !
!DTDElementContentModelParser class methodsFor: 'class initialization'!
initializeOperatorApplicators
	"use an array instead of a dictionary for speed, and
	assign after with #yourself to avoid possible race
	conditions when reinitializing the class"
	OperatorApplicators :=
		(Array new: 255)
			at: $, asciiValue put: #applyConcatenation;
			at: $| asciiValue put: #applyBranch;
			at: $? asciiValue put: #applyOptional;
			at: $* asciiValue put: #applyStar;
			at: $+ asciiValue put: #applyPlus;
			yourself! !
!DTDElementContentModelParser class methodsFor: 'class initialization'!
initializeSpecialCharacterParsers
	"use an array instead of a dictionary for speed, and
	assign after with #yourself to avoid possible race
	conditions when reinitializing the class"
	SpecialCharacterParsers :=
		(Array new: 255)
			at: $( asciiValue put: #parseOpeningParenthesis:;
			at: $) asciiValue put: #parseClosingParenthesis:;
			at: $, asciiValue put: #parseBinaryOperator:;
			at: $| asciiValue put: #parseBinaryOperator:;
			at: $? asciiValue put: #parseUnaryOperator:;
			at: $* asciiValue put: #parseUnaryOperator:;
			at: $+ asciiValue put: #parseUnaryOperator:;
			yourself! !
!DTDElementContentModelParser class methodsFor: 'defaults'!
standaloneExternalClass
	^ DTDStandaloneExternalElementContentModelParser! !
!DTDElementContentModelParser methodsFor: 'private'!
applyBinaryOperatorOnStack
	self applyOperator: binaryOperatorStack removeLast! !
!DTDElementContentModelParser methodsFor: 'private'!
applyOperator: aCharacter
	nfaBuilder perform:
		(OperatorApplicators at: aCharacter asciiValue)! !
!DTDElementContentModelParser methodsFor: 'defaults'!
elementValidatorClass
	^ XMLDFAElementContentElementValidator! !
!DTDElementContentModelParser methodsFor: 'private'!
hasBinaryOperatorOnStack
	^ binaryOperatorStack size > 0
		and: [binaryOperatorStack last ~~ $(]! !
!DTDElementContentModelParser methodsFor: 'parsing'!
parse
	"the tokenizer removes all spaces from the content model and checks
	it for well-formedness (meaning no missing names or misplaced
	operators/parentheses), which simplifies parsing"
	| nameStart |

	binaryOperatorStack := OrderedCollection new.
	nfaBuilder := XMLNFABuilder new.
	1 to: contentModel size do: [:i |
		(self parserForSpecialCharacter: (contentModel at: i))
			ifNil: [
				nameStart
					ifNil: [nameStart := i]]
			ifNotNil: [:selector |
				nameStart
					ifNotNil: [
						nfaBuilder pushFragmentMatching:
							(contentModel copyFrom: nameStart to: i - 1).
						nameStart := nil].
				self
					perform: selector
					with: (contentModel at: i)]].
	self popRemainingBinaryOperators.

	^ self elementValidatorClass
		element: element
		dfa: nfaBuilder asAcceptingNFA asDFAState.! !
!DTDElementContentModelParser methodsFor: 'private'!
parseBinaryOperator: aCharacter
	binaryOperatorStack addLast: aCharacter! !
!DTDElementContentModelParser methodsFor: 'private'!
parseClosingParenthesis: aCharacter
	self popRemainingBinaryOperators.
	(binaryOperatorStack size > 0
		and: [binaryOperatorStack last == $(])
		ifTrue: [binaryOperatorStack removeLast].! !
!DTDElementContentModelParser methodsFor: 'private'!
parseOpeningParenthesis: aCharacter
	binaryOperatorStack addLast: $(! !
!DTDElementContentModelParser methodsFor: 'private'!
parseUnaryOperator: aCharacter
	self applyOperator: aCharacter! !
!DTDElementContentModelParser methodsFor: 'private'!
parserForSpecialCharacter: aCharacter
	| asciiValue |

	"avoid at:ifAbsent: for speed"
	((asciiValue := aCharacter asciiValue) > 0
		and: [asciiValue <= SpecialCharacterParsers size])
			ifTrue: [^ SpecialCharacterParsers at: asciiValue]
			ifFalse: [^ nil]! !
!DTDElementContentModelParser methodsFor: 'private'!
popRemainingBinaryOperators
	[self hasBinaryOperatorOnStack]
		whileTrue: [self applyBinaryOperatorOnStack]! !
!DTDStandaloneExternalElementContentModelParser methodsFor: 'defaults'!
elementValidatorClass
	^ XMLStandaloneExternalDFAElementContentElementValidator! !
!DTDLiteralContentModelParser methodsFor: 'parsing'!
parse
	"either ANY or EMPTY"
	(contentModel at: 1) == $A
		ifTrue: [^ XMLAnyElementValidator element: element]
		ifFalse: [^ XMLEmptyElementValidator element: element]! !
!DTDMixedContentModelParser methodsFor: 'parsing'!
parse
	^ XMLMixedContentElementValidator
		element: element
		allowedContent:
			(DTDMixedContentEnumerationListParser on: contentModel)
				parse! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addExternalGeneralEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString
	(self generalEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self generalEntities
		at: aName
		put:
			(DTDExternalGeneralParsedEntity
				name: aName
				resolver: aResolver
				publicID: aPublicID
				systemID: aSystemID
				baseURI: aBaseURIString).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addExternalParameterEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString
	(self parameterEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self parameterEntities
		at: aName
		put:
			(DTDExternalParameterParsedEntity
				name: aName
				resolver: aResolver
				publicID: aPublicID
				systemID: aSystemID
				baseURI: aBaseURIString).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addGeneralEntitiesFrom: aDoctypeDefinition
	aDoctypeDefinition generalEntities keysAndValuesDo: [:name :entity |
		self generalEntities
			at: name
			ifAbsentPut: [entity]]! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addInternalGeneralEntity: aName replacement: aReplacement baseURI: aBaseURIString
	(self generalEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self generalEntities
		at: aName
		put:
			(DTDInternalGeneralParsedEntity 
				name: aName
				replacement: aReplacement
				uri: aBaseURIString).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addInternalParameterEntity: aName replacement: aReplacement baseURI: aBaseURIString
	(self parameterEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self parameterEntities
		at: aName
		put:
			(DTDInternalParameterParsedEntity
				name: aName
				replacement: aReplacement
				uri: aBaseURIString).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addNotation: aName publicID: aPublicID systemID: aSystemID
	(self notations includesKey: aName)
		ifTrue: [^ nil].
	^ self notations
		at: aName
		put:
			(DTDNotation
				name: aName
				publicID: aPublicID
				systemID: aSystemID).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addStandaloneExternalExternalGeneralEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString
	(self generalEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self generalEntities
		at: aName
		put:
			(DTDStandaloneExternalExternalGeneralParsedEntity
				name: aName
				resolver: aResolver
				publicID: aPublicID
				systemID: aSystemID
				baseURI: aBaseURIString).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addStandaloneExternalInternalGeneralEntity: aName replacement: aReplacement baseURI: aBaseURIString
	(self generalEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self generalEntities
		at: aName
		put:
			(DTDStandaloneExternalInternalGeneralParsedEntity 
				name: aName
				replacement: aReplacement
				uri: aBaseURIString).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addStandaloneExternalValidatorForAttributeIn: anElement named: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	| attributes |

	attributes :=
		self attributeValidators
			at: anElement
			ifAbsentPut: [Dictionary new].
	(attributes includesKey: anAttribute)
		ifTrue: [^ nil].
	^ attributes
		at: anAttribute
		put:
			((DTDStandaloneExternalAttributeDefinitionParser
				element: anElement
				attribute: anAttribute
				type: aType
				defaultPragma: aDefaultPragma
				defaultValue: aDefaultValue) parse
					initializeWithValidatorsFrom: self).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addStandaloneExternalValidatorForElement: anElement contentModel: aContentModel
	(self elementValidators includesKey: anElement)
		ifTrue: [^ nil].
	^ self elementValidators
		at: anElement
		put:
			((DTDContentModelParser parserClassForContentModel: aContentModel)
				standaloneExternalClass
					element: anElement
					contentModel: aContentModel) parse.! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addUnparsedEntity: aName publicID: aPublicID systemID: aSystemID ndata: aNotation
	(self generalEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self generalEntities
		at: aName
		put:
			(self unparsedEntities
				at: aName
				put:
					(DTDUnparsedEntity
						name: aName
						publicID: aPublicID
						systemID: aSystemID
						ndata: aNotation)).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addUnresolvableExternalGeneralEntity: aName
	(self generalEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self generalEntities
		at: aName
		put: (DTDUnresolvableExternalGeneralParsedEntity named: aName).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addUnresolvableExternalParameterEntity: aName
	(self parameterEntities includesKey: aName)
		ifTrue: [^ nil].
	^ self parameterEntities
		at: aName
		put: (DTDUnresolvableExternalParameterParsedEntity named: aName).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addValidatorForAttributeIn: anElement named: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	| attributes |

	attributes :=
		self attributeValidators
			at: anElement
			ifAbsentPut: [Dictionary new].
	(attributes includesKey: anAttribute)
		ifTrue: [^ nil].
	^ attributes
		at: anAttribute
		put:
			((DTDAttributeDefinitionParser
				element: anElement
				attribute: anAttribute
				type: aType
				defaultPragma: aDefaultPragma
				defaultValue: aDefaultValue) parse
					initializeWithValidatorsFrom: self).! !
!DTDDoctypeDefinition methodsFor: 'adding'!
addValidatorForElement: anElement contentModel: aContentModel
	(self elementValidators includesKey: anElement)
		ifTrue: [^ nil].
	^ self elementValidators
		at: anElement
		put:
			((DTDContentModelParser parserClassForContentModel: aContentModel)
				element: anElement
				contentModel: aContentModel) parse.! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
attributeValidators
	^ attributeValidators ifNil: [attributeValidators := Dictionary new]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
attributeValidatorsAt: aName
	^ self
		attributeValidatorsAt: aName
		ifAbsent: [nil]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
attributeValidatorsAt: aName ifAbsent: aBlock
	^ self attributeValidators
		at: aName
		ifAbsent: aBlock! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
elementIDValidator
	^ elementIDValidator ifNil: [elementIDValidator := XMLElementIDValidator new]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
elementValidators
	^ elementValidators ifNil: [elementValidators := Dictionary new]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
elementValidatorsAt: aName
	^ self
		elementValidatorsAt: aName
		ifAbsent: [nil]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
elementValidatorsAt: aName ifAbsent: aBlock
	^ self elementValidators
		at: aName
		ifAbsent: aBlock! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
generalEntities
	^ generalEntities ifNil: [generalEntities := Dictionary new]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
generalEntityAt: aName
	^ self
		generalEntityAt: aName
		ifAbsent: [nil]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
generalEntityAt: aName ifAbsent: aBlock
	^ self generalEntities
		at: aName
		ifAbsent: aBlock! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasAttributeValidators
	"optimized to avoid lazy initialization"
	attributeValidators == nil
		ifTrue: [^ false].
	^ attributeValidators size > 0.! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasElementIDReferences
	"direct access to avoid lazy initialization"
	^ elementIDValidator notNil
		and: [elementIDValidator hasIDReferences]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasElementIDs
	"direct access to avoid lazy initialization"
	^ elementIDValidator notNil
		and: [elementIDValidator hasIDs]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasElementValidators
	"optimized to avoid lazy initialization"
	elementValidators == nil
		ifTrue: [^ false].
	^ elementValidators size > 0.! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasEntities
	^ self hasGeneralEntities
		or: [self hasParameterEntities
			or: [self hasUnparsedEntities]]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasGeneralEntities
	"direct access to avoid lazy initialization"
	^ generalEntities notNil
		and: [generalEntities notEmpty]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasNotationAttributeValidators
	^ self hasAttributeValidators
		and: [self unparsedEntityValidator hasNotationAttributeValidators]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasNotations
	"direct access to avoid lazy initialization"
	^ notations notNil
		and: [notations notEmpty]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasParameterEntities
	"direct access to avoid lazy initialization"
	^ parameterEntities notNil
		and: [parameterEntities notEmpty]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasRoot
	^ root notNil and: [root notEmpty]! !
!DTDDoctypeDefinition methodsFor: 'testing'!
hasUnparsedEntities
	"direct access to avoid lazy initialization"
	^ unparsedEntities notNil
		and: [unparsedEntities notEmpty]! !
!DTDDoctypeDefinition methodsFor: 'instance creation'!
newValidator
	^ DTDDocumentValidator doctypeDefinition: self! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
notations
	^ notations ifNil: [notations := Dictionary new]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
parameterEntities
	^ parameterEntities ifNil: [parameterEntities := Dictionary new]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
parameterEntityAt: aName
	^ self
		parameterEntityAt: aName
		ifAbsent: [nil]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
parameterEntityAt: aName ifAbsent: aBlock
	^ self parameterEntities
		at: aName
		ifAbsent: aBlock! !
!DTDDoctypeDefinition methodsFor: 'processing'!
processStartTag: anElement attributes: aDictionary
	self hasAttributeValidators
		ifFalse: [^ self].
	(self
		attributeValidatorsAt: anElement
		ifAbsent: [^ self])
		valuesDo: [:each | each processAttributes: aDictionary]! !
!DTDDoctypeDefinition methodsFor: 'removing'!
removeElementIDReferences
	self hasElementIDReferences
		ifTrue: [self elementIDValidator removeIDReferences]! !
!DTDDoctypeDefinition methodsFor: 'removing'!
removeElementIDs
	self hasElementIDs
		ifTrue: [self elementIDValidator removeIDs]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
root
	^ root ifNil: [root := '']! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
root: aRootElement
	root := aRootElement! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
unparsedEntities
	^ unparsedEntities ifNil: [unparsedEntities := Dictionary new]! !
!DTDDoctypeDefinition methodsFor: 'accessing'!
unparsedEntityValidator
	^ unparsedEntityValidator
		ifNil: [
			unparsedEntityValidator :=
				XMLUnparsedEntityValidator
					unparsedEntities: self unparsedEntities
					notations: self notations]! !
!DTDDoctypeDefinition methodsFor: 'validation'!
validateCompletedDefinition
	self hasUnparsedEntities
		ifTrue: [self unparsedEntityValidator validateUnparsedEntityDeclarations].
	self hasNotationAttributeValidators
		ifTrue: [self unparsedEntityValidator validateNotationAttributeDeclarationDefaults].! !
!DTDEntity class methodsFor: 'instance creation'!
name: aName
	^ self named: aName! !
!DTDEntity class methodsFor: 'instance creation'!
named: aName
	^ self new name: aName! !
!DTDEntity methodsFor: 'converting'!
asReference
	^ String streamContents: [:stream | self printReferenceOn: stream]! !
!DTDEntity methodsFor: 'testing'!
isExternal
	^ false! !
!DTDEntity methodsFor: 'testing'!
isParameter
	^ false! !
!DTDEntity methodsFor: 'testing'!
isStandaloneExternal
	^ false! !
!DTDEntity methodsFor: 'testing'!
isUnparsed
	^ false! !
!DTDEntity methodsFor: 'accessing'!
name
	^ name ifNil: [name := '']! !
!DTDEntity methodsFor: 'accessing'!
name: aName
	name := aName! !
!DTDEntity methodsFor: 'printing'!
printNameOn: aStream
	aStream nextPutAll: self name! !
!DTDEntity methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self printNameOn: aStream.
	aStream nextPut: $).! !
!DTDEntity methodsFor: 'printing'!
printReferenceOn: aStream
	aStream
		nextPut: self referencePrefix;
		nextPutAll: self name;
		nextPut: $;! !
!DTDEntity methodsFor: 'private '!
referencePrefix
	^ self isParameter
		ifTrue: [$%]
		ifFalse: [$&]! !
!DTDEntity methodsFor: 'accessing'!
uri
	^ uri ifNil: [uri := '']! !
!DTDEntity methodsFor: 'accessing'!
uri: aURIString
	uri := aURIString! !
!DTDStandaloneExternalExternalGeneralParsedEntity methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!DTDExternalParameterParsedEntity methodsFor: 'testing'!
isParameter
	^ true! !
!DTDExternalParsedEntity class methodsFor: 'instance creation'!
name: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString
	^ self new
		setName: aName
		unresolvedReplacement:
			(DTDUnresolvedExternalParsedEntityReplacement
				resolver: aResolver
				publicID: aPublicID
				systemID: aSystemID
				baseURI: aBaseURIString)! !
!DTDExternalParsedEntity methodsFor: 'testing'!
hasReplacement
	^ self resolvedReplacement notEmpty! !
!DTDExternalParsedEntity methodsFor: 'testing'!
hasUnresolvedReplacement
	^ self unresolvedReplacement notNil! !
!DTDExternalParsedEntity methodsFor: 'testing'!
isExternal
	^ true! !
!DTDExternalParsedEntity methodsFor: 'printing'!
printNameOn: aStream
	aStream
		nextPut: ${;
		nextPutAll: self uri;
		nextPut: $}.
	super printNameOn: aStream.! !
!DTDExternalParsedEntity methodsFor: 'accessing'!
replacement
	^ self resolvedReplacement contents! !
!DTDExternalParsedEntity methodsFor: 'accessing'!
replacementStream
	^ self resolvedReplacement readStream! !
!DTDExternalParsedEntity methodsFor: 'resolving'!
resolveUnresolvedReplacement
	self hasUnresolvedReplacement
		ifTrue: [self unresolvedReplacement resolveForExternalEntity: self]! !
!DTDExternalParsedEntity methodsFor: 'accessing'!
resolvedReplacement
	self resolveUnresolvedReplacement.
	^ resolvedReplacement.! !
!DTDExternalParsedEntity methodsFor: 'accessing'!
resolvedReplacement: aResolvedReplacement
	resolvedReplacement := aResolvedReplacement! !
!DTDExternalParsedEntity methodsFor: 'initialization'!
setName: aName unresolvedReplacement: anUnresolvedReplacement
	name := aName.
	unresolvedReplacement := anUnresolvedReplacement.! !
!DTDExternalParsedEntity methodsFor: 'accessing'!
unresolvedReplacement
	^ unresolvedReplacement! !
!DTDExternalParsedEntity methodsFor: 'accessing'!
unresolvedReplacement: anUnresolvedReplacement
	unresolvedReplacement := anUnresolvedReplacement! !
!DTDStandaloneExternalInternalGeneralParsedEntity methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!DTDInternalParameterParsedEntity methodsFor: 'testing'!
isParameter
	^ true! !
!DTDInternalParsedEntity class methodsFor: 'instance creation'!
name: aName replacement: aReplacementString
	^ self
		name: aName
		replacement: aReplacementString
		uri: ''! !
!DTDInternalParsedEntity class methodsFor: 'instance creation'!
name: aName replacement: aReplacementString uri: aURIString
	^ self new
		setName: aName
		replacement: aReplacementString
		uri: aURIString! !
!DTDInternalParsedEntity methodsFor: 'testing'!
hasReplacement
	^ self replacement notEmpty! !
!DTDInternalParsedEntity methodsFor: 'accessing'!
replacement
	^ replacement ifNil: [replacement := '']! !
!DTDInternalParsedEntity methodsFor: 'accessing'!
replacement: aReplacementString
	replacement := aReplacementString! !
!DTDInternalParsedEntity methodsFor: 'accessing'!
replacementStream
	^ self replacement readStream! !
!DTDInternalParsedEntity methodsFor: 'initialization'!
setName: aName replacement: aReplacementString uri: aURIString
	name := aName.
	replacement := aReplacementString.
	uri := aURIString.! !
!DTDParsedEntity methodsFor: 'converting'!
asPushedBackEntity
	^ self isParameter
		ifTrue: [XMLPushedBackParameterEntity entity: self]
		ifFalse: [XMLPushedBackGeneralEntity entity: self]! !
!DTDParsedEntity methodsFor: 'testing'!
hasReplacement
	self subclassResponsibility! !
!DTDParsedEntity methodsFor: 'accessing'!
replacement
	self subclassResponsibility! !
!DTDParsedEntity methodsFor: 'accessing'!
replacementStream
	self subclassResponsibility! !
!DTDUnresolvableExternalParameterParsedEntity methodsFor: 'testing'!
isParameter
	^ true! !
!DTDUnresolvableExternalParsedEntity methodsFor: 'private'!
errorUnresolvableExternalEntity
	XMLParserException
		formatSignal:
			'External entity {1} can''t be resolved unless resolution is ',
			'enabled; use #resolvesExternalEntityReferences: before parsing ',
			'to enable'
		with: self asReference! !
!DTDUnresolvableExternalParsedEntity methodsFor: 'testing'!
hasReplacement
	^ true! !
!DTDUnresolvableExternalParsedEntity methodsFor: 'testing'!
isExternal
	^ true! !
!DTDUnresolvableExternalParsedEntity methodsFor: 'accessing'!
replacement
	self errorUnresolvableExternalEntity! !
!DTDUnresolvableExternalParsedEntity methodsFor: 'accessing'!
replacementStream
	self errorUnresolvableExternalEntity! !
!DTDUnparsedEntity class methodsFor: 'instance creation'!
name: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName
	^ self new
		setName: aName
		publicID: aPublicID
		systemID: aSystemID
		ndata: aNotationName! !
!DTDUnparsedEntity methodsFor: 'testing'!
isUnparsed
	^ true! !
!DTDUnparsedEntity methodsFor: 'accessing'!
ndata
	^ ndata ifNil: [ndata := '']! !
!DTDUnparsedEntity methodsFor: 'accessing'!
ndata: aNotationName
	ndata := aNotationName! !
!DTDUnparsedEntity methodsFor: 'accessing'!
publicID
	^ publicID ifNil: [publicID := '']! !
!DTDUnparsedEntity methodsFor: 'accessing'!
publicID: aPublicID
	publicID := aPublicID! !
!DTDUnparsedEntity methodsFor: 'initialization'!
setName: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName
	name := aName.
	publicID := aPublicID.
	systemID := aSystemID.
	ndata := aNotationName.! !
!DTDUnparsedEntity methodsFor: 'accessing'!
systemID
	^ systemID ifNil: [systemID := '']! !
!DTDUnparsedEntity methodsFor: 'accessing'!
systemID: aSystemID
	systemID := aSystemID! !
!DTDEntityConfiguration methodsFor: 'accessing'!
externalEntityResolver
	"uses the caching resolver by default"
	^ externalEntityResolver
		ifNil: [externalEntityResolver := DTDExternalEntityResolver default]! !
!DTDEntityConfiguration methodsFor: 'accessing'!
externalEntityResolver: anExternalEntityResolver
	externalEntityResolver := anExternalEntityResolver! !
!DTDEntityConfiguration methodsFor: 'copying'!
postCopy
	super postCopy.

	externalEntityResolver
		ifNotNil: [externalEntityResolver := externalEntityResolver copy].! !
!DTDEntityConfiguration methodsFor: 'accessing'!
preservesUndeclaredEntityReferences
	^ preservesUndeclaredEntityReferences
		ifNil: [preservesUndeclaredEntityReferences := false]! !
!DTDEntityConfiguration methodsFor: 'accessing'!
preservesUndeclaredEntityReferences: aBoolean
	preservesUndeclaredEntityReferences := aBoolean! !
!DTDEntityConfiguration methodsFor: 'accessing'!
replacesContentEntityReferences
	^ replacesContentEntityReferences ifNil: [replacesContentEntityReferences := true]! !
!DTDEntityConfiguration methodsFor: 'accessing'!
replacesContentEntityReferences: aBoolean
	replacesContentEntityReferences := aBoolean! !
!DTDEntityConfiguration methodsFor: 'accessing'!
resolvesExternalEntities
	^ resolvesExternalEntities ifNil: [resolvesExternalEntities := false]! !
!DTDEntityConfiguration methodsFor: 'accessing'!
resolvesExternalEntities: aBoolean
	resolvesExternalEntities := aBoolean! !
!DTDEnumerationListParser class methodsFor: 'instance creation'!
on: aString
	^ self new on: aString! !
!DTDEnumerationListParser methodsFor: 'private'!
errorDuplicateListValue: aValue
	XMLValidationException
		formatSignal: 'Duplicate value "{1}" in list'
		with: aValue! !
!DTDEnumerationListParser methodsFor: 'private'!
listEndOffset
	^ 1 "')' size"! !
!DTDEnumerationListParser methodsFor: 'private'!
listStartOffset
	^ 1 "'(' size"! !
!DTDEnumerationListParser methodsFor: 'initialization'!
on: aString
	listString := aString! !
!DTDEnumerationListParser methodsFor: 'parsing'!
parse
	"the tokenizer removes all spaces from lists"
	| listStartIndex listEndIndex totalListValues listValues nextListValuesIndex nextValueStartIndex |

	listStartIndex := 1 + self listStartOffset.
	listEndIndex := listString size - self listEndOffset.
	"count the values to preallocate an Array"
	totalListValues := 1.
	listStartIndex to: listEndIndex do: [:i |
		(listString at: i) == $|
			ifTrue: [totalListValues := totalListValues + 1]].

	listValues := Array new: totalListValues.
	nextListValuesIndex := 1.
	nextValueStartIndex := listStartIndex.
	listStartIndex to: listEndIndex do: [:i | 
		(listString at: i) == $|
			ifTrue: [
				listValues
					at: nextListValuesIndex
					put:
						(listString
							copyFrom: nextValueStartIndex
							to: i - 1).
				nextListValuesIndex := nextListValuesIndex + 1.
				nextValueStartIndex := i + 1]].
	listValues
		at: nextListValuesIndex
		put:
			(listString
				copyFrom: nextValueStartIndex
				to: listEndIndex).

	^ listValues.! !
!DTDMixedContentEnumerationListParser methodsFor: 'private'!
listEndOffset
	^ listString last == $*
		ifTrue: [2] "')*' size"
		ifFalse: [1] "')' size"! !
!DTDNotationEnumerationListParser methodsFor: 'private'!
listStartOffset
	^ 10 "'NOTATION (' size"! !
!DTDExternalEntityLimits class methodsFor: 'accessing'!
defaultExternalSubsetReadLimit
	^ XMLParserLimits defaultReadLimit
		ifNotNil: [:limit | (limit / 4) asInteger]! !
!DTDExternalEntityLimits class methodsFor: 'accessing'!
defaultMaxExternalEntities
	^ 20! !
!DTDExternalEntityLimits class methodsFor: 'accessing'!
defaultMaxExternalEntitySize
	^ 2500000! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
externalSubsetReadLimit
	^ externalSubsetReadLimit! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
externalSubsetReadLimit: anInteger
	externalSubsetReadLimit := anInteger! !
!DTDExternalEntityLimits methodsFor: 'initialization'!
initialize
	super initialize.

	externalSubsetReadLimit := self class defaultExternalSubsetReadLimit.
	maxExternalEntities := self class defaultMaxExternalEntities.
	maxExternalEntitySize := self class defaultMaxExternalEntitySize.
	resolvesLocalFromNonLocal := false.! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
maxExternalEntities
	^ maxExternalEntities! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
maxExternalEntities: anInteger
	maxExternalEntities := anInteger! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
maxExternalEntitySize
	^ maxExternalEntitySize! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
maxExternalEntitySize: anInteger
	maxExternalEntitySize := anInteger! !
!DTDExternalEntityLimits methodsFor: 'removing'!
removeAll
	externalSubsetReadLimit := nil.
	maxExternalEntities := nil.
	maxExternalEntitySize := nil.
	resolvesLocalFromNonLocal := true.! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
resolvesLocalFromNonLocal
	^ resolvesLocalFromNonLocal! !
!DTDExternalEntityLimits methodsFor: 'accessing'!
resolvesLocalFromNonLocal: aBoolean
	resolvesLocalFromNonLocal := aBoolean! !
!DTDCachingExternalEntityResolver class methodsFor: 'clearing'!
clearEntityCache
	"self clearEntityCache"
	self entityCache clear! !
!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!
entityCache
	"a class variable so it's shared by all subclasses, but lazy initialized
	so it isn't initialized unless needed"
	^ EntityCache
		ifNil: [EntityCache := XMLKeyValueCache maxSize: 64]! !
!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!
entityCacheAtURI: anXMLURIOrURIString
	^ self entityCache
		at: anXMLURIOrURIString asXMLURI
		ifAbsent: [nil]! !
!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!
entityCacheAtURI: anXMLURIOrURIString ifAbsent: aBlock
	^ self entityCache
		at: anXMLURIOrURIString asXMLURI
		ifAbsent: aBlock! !
!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!
entityCacheAtURI: anXMLURIOrURIString ifAbsentPut: aBlock
	^ self entityCache
		at: anXMLURIOrURIString asXMLURI
		ifAbsentPut: aBlock! !
!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!
entityCacheAtURI: anXMLURIOrURIString put: aStringOrByteArray
	^ self entityCache
		at: anXMLURIOrURIString asXMLURI
		put: aStringOrByteArray! !
!DTDCachingExternalEntityResolver class methodsFor: 'class initialization'!
initialize
	"self initialize"

	"reset to nil instead of just clearing to force reinitialization"
	EntityCache := nil! !
!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!
maxCachedEntities
	^ self entityCache maxSize! !
!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!
maxCachedEntities: anInteger
	self entityCache maxSize: anInteger! !
!DTDCachingExternalEntityResolver methodsFor: 'clearing'!
clearEntityCache
	self class clearEntityCache! !
!DTDCachingExternalEntityResolver methodsFor: 'accessing'!
maxCachedEntities
	^ self class maxCachedEntities! !
!DTDCachingExternalEntityResolver methodsFor: 'accessing'!
maxCachedEntities: anInteger
	self class maxCachedEntities: anInteger! !
!DTDCachingExternalEntityResolver methodsFor: 'private'!
resolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	| uri |

	uri := anXMLURIOrURIString asXMLURI.
	"avoid #entityCacheAtURI:ifAbsent: and #entityCacheAtURI:ifAbsentPut:
	so the cache isn't locked during resolution which could stall other
	processes"
	^ (self class entityCacheAtURI: uri)
		ifNil: [
			self class
				entityCacheAtURI: uri
				put:
					(super
						resolveNonLocalExternalEntityURI: uri
						upToLimit: aMaxSize)].! !
!DTDExternalEntityResolver class methodsFor: 'instance creation'!
default
	^ self defaultClass new! !
!DTDExternalEntityResolver class methodsFor: 'accessing'!
defaultClass
	^ DTDCachingExternalEntityResolver! !
!DTDExternalEntityResolver methodsFor: 'converting'!
asLimitingExternalEntityResolver
	^ DTDExternalEntityResolverLimitingDecorator externalEntityResolver: self! !
!DTDExternalEntityResolver methodsFor: 'private'!
errorLocalFromNonLocal
	XMLLimitException signal:
		'Local URI referenced from non-local URI; ',
		'use #resolvesLocalFromNonLocal: to change'! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
externalEntityLimits
	^ externalEntityLimits
		ifNil: [externalEntityLimits := DTDExternalEntityLimits new]! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
externalEntityLimits: anExternalEntityLimits
	externalEntityLimits := anExternalEntityLimits! !
!DTDExternalEntityResolver methodsFor: 'resolving'!
externalEntityURIFromPublicID: aPublicID systemID: aSystemID
	^ aSystemID asXMLURI! !
!DTDExternalEntityResolver methodsFor: 'resolving'!
externalEntityURIFromPublicID: aPublicID systemID: aSystemID baseURI: aBaseXMLURIOrURIString
	| baseURI externalEntityURI |

	baseURI := aBaseXMLURIOrURIString asXMLURI.
	externalEntityURI :=
		baseURI combinedWith:
			(self
				externalEntityURIFromPublicID: aPublicID
				systemID: aSystemID).
	(externalEntityURI isLocal
		and: [baseURI isLocal not
			and: [self resolvesLocalFromNonLocal not]])
		ifTrue: [self errorLocalFromNonLocal].

	^ externalEntityURI.! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
externalSubsetReadLimit
	^ self externalEntityLimits externalSubsetReadLimit! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
externalSubsetReadLimit: anInteger
	"change the external subset read limit or nil to disable"

	self externalEntityLimits externalSubsetReadLimit: anInteger! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
maxExternalEntities
	^ self externalEntityLimits maxExternalEntities! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
maxExternalEntities: anInteger
	self externalEntityLimits maxExternalEntities: anInteger! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
maxExternalEntitySize
	^ self externalEntityLimits maxExternalEntitySize! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
maxExternalEntitySize: anInteger
	self externalEntityLimits maxExternalEntitySize: anInteger! !
!DTDExternalEntityResolver methodsFor: 'copying'!
postCopy
	super postCopy.

	externalEntityLimits
		ifNotNil: [externalEntityLimits := externalEntityLimits copy].! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
removeLimits
	self externalEntityLimits removeAll! !
!DTDExternalEntityResolver methodsFor: 'resolving'!
resolveExternalEntityURI: anXMLURIOrURIString
	^ self
		resolveExternalEntityURI: anXMLURIOrURIString
		upToLimit: self maxExternalEntitySize! !
!DTDExternalEntityResolver methodsFor: 'resolving'!
resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	| uri |

	^ (uri := anXMLURIOrURIString asXMLURI) isLocal
		ifTrue: [
			self
				resolveLocalExternalEntityURI: uri
				upToLimit: aMaxSize]
		ifFalse: [
			self
				resolveNonLocalExternalEntityURI: uri
				upToLimit: aMaxSize]! !
!DTDExternalEntityResolver methodsFor: 'private'!
resolveLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	^ DTDUndecodedResolvedExternalParsedEntityReplacement rawContents:
		(anXMLURIOrURIString asXMLFileHandle
			getUpToLimit: aMaxSize
			decoding: false)! !
!DTDExternalEntityResolver methodsFor: 'private'!
resolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	| response |

	response :=
		anXMLURIOrURIString asXMLHTTPRequest
			resolveUpToLimit: aMaxSize
			decoding: false.

	"saves the undecoded replacement with its Content-Type
	charset encoding tag for later decoding (if needed)"
	^ DTDUndecodedResolvedExternalParsedEntityReplacement
		rawContents: response content
		encoding: response contentCharset.! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
resolvesLocalFromNonLocal
	^ self externalEntityLimits resolvesLocalFromNonLocal! !
!DTDExternalEntityResolver methodsFor: 'configuring'!
resolvesLocalFromNonLocal: aBoolean
	"allow non-local (http) entities to reference local (file) entities?
	(default disabled)"

	self externalEntityLimits resolvesLocalFromNonLocal: aBoolean! !
!DTDExternalEntityResolver methodsFor: 'resolving'!
streamResolveExternalEntityURI: anXMLURIOrURIString
	^ self
		streamResolveExternalEntityURI: anXMLURIOrURIString
		upToLimit: self maxExternalEntitySize! !
!DTDExternalEntityResolver methodsFor: 'resolving'!
streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	| uri |

	^ (uri := anXMLURIOrURIString asXMLURI) isLocal
		ifTrue: [
			self
				streamResolveLocalExternalEntityURI: uri
				upToLimit: aMaxSize]
		ifFalse: [
			self
				streamResolveNonLocalExternalEntityURI: uri
				upToLimit: aMaxSize]! !
!DTDExternalEntityResolver methodsFor: 'private'!
streamResolveLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	"return our own decoding adapter on the raw, undecoded stream
	to avoid looking for any byte-order mark until later"
	^ XMLDecodingReadStreamAdapter nonDecodingOn:
		(anXMLURIOrURIString asXMLFileHandle
			streamGetUpToLimit: aMaxSize
			decoding: false)! !
!DTDExternalEntityResolver methodsFor: 'private'!
streamResolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	^ (self
		resolveNonLocalExternalEntityURI: anXMLURIOrURIString
		upToLimit: aMaxSize) readStream! !
!DTDStaticExternalEntityResolver class methodsFor: 'instance creation'!
externalEntities: anAssociationCollection
	^ self new externalEntities: anAssociationCollection! !
!DTDStaticExternalEntityResolver methodsFor: 'private'!
errorMaxExternalEntitySize: aMaxSize exceededByURI: anXMLURIOrURIString
	XMLLimitException
		formatSignal: 'Entity exceeds max size of {1} bytes: {2}'
		with: aMaxSize
		with: anXMLURIOrURIString asString! !
!DTDStaticExternalEntityResolver methodsFor: 'private'!
errorUnresolvableExternalEntityURI: anXMLURIOrURIString
	XMLParserException
		formatSignal: 'Unresolvable external entity URI: {1}'
		with: anXMLURIOrURIString asString! !
!DTDStaticExternalEntityResolver methodsFor: 'accessing'!
externalEntities
	^ externalEntities ifNil: [externalEntities := Dictionary new]! !
!DTDStaticExternalEntityResolver methodsFor: 'accessing'!
externalEntities: anAssociationCollection
	self hasExternalEntities
		ifTrue: [self removeExternalEntities].
	anAssociationCollection associationsDo: [:each |
		self
			externalEntityAtURI: each key
			put: each value].! !
!DTDStaticExternalEntityResolver methodsFor: 'accessing'!
externalEntityAtURI: anXMLURIOrURIString
	^ self
		externalEntityAtURI: anXMLURIOrURIString asXMLURI
		ifAbsent: ['']! !
!DTDStaticExternalEntityResolver methodsFor: 'accessing'!
externalEntityAtURI: anXMLURIOrURIString ifAbsent: aBlock
	^ self externalEntities
		at: anXMLURIOrURIString asXMLURI
		ifAbsent: aBlock! !
!DTDStaticExternalEntityResolver methodsFor: 'accessing'!
externalEntityAtURI: anXMLURIOrURIString ifAbsentPut: aBlock
	^ self externalEntities
		at: anXMLURIOrURIString asXMLURI
		ifAbsentPut: aBlock! !
!DTDStaticExternalEntityResolver methodsFor: 'accessing'!
externalEntityAtURI: anXMLURIOrURIString put: aReplacement
	^ self externalEntities
		at: anXMLURIOrURIString asXMLURI
		put: aReplacement! !
!DTDStaticExternalEntityResolver methodsFor: 'testing'!
hasExternalEntities
	^ self externalEntities notEmpty! !
!DTDStaticExternalEntityResolver methodsFor: 'testing'!
includesExternalEntityURI: anXMLURIOrURIString
	^ self externalEntities includesKey: anXMLURIOrURIString asXMLURI! !
!DTDStaticExternalEntityResolver methodsFor: 'copying'!
postCopy
	super postCopy.

	externalEntities
		ifNotNil: [externalEntities := externalEntities copy].! !
!DTDStaticExternalEntityResolver methodsFor: 'removing'!
removeExternalEntities
	self externalEntities removeAll! !
!DTDStaticExternalEntityResolver methodsFor: 'removing'!
removeExternalEntityURI: anXMLURIOrURIString
	^ self externalEntities removeKey: anXMLURIOrURIString asXMLURI! !
!DTDStaticExternalEntityResolver methodsFor: 'removing'!
removeExternalEntityURI: anXMLURIOrURIString ifAbsent: aBlock
	^ self externalEntities
		removeKey: anXMLURIOrURIString asXMLURI
		ifAbsent: aBlock! !
!DTDStaticExternalEntityResolver methodsFor: 'resolving'!
resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	| replacement |

	replacement :=
		self
			externalEntityAtURI: anXMLURIOrURIString
			ifAbsent: [
				self errorUnresolvableExternalEntityURI: anXMLURIOrURIString].

	(aMaxSize notNil
		and: [replacement size > aMaxSize])
		ifTrue: [
			self
				errorMaxExternalEntitySize: aMaxSize
				exceededByURI: anXMLURIOrURIString].
	
	^ DTDUndecodedResolvedExternalParsedEntityReplacement rawContents: replacement.! !
!DTDStaticExternalEntityResolver methodsFor: 'resolving'!
streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	^ (self
		resolveExternalEntityURI: anXMLURIOrURIString
		upToLimit: aMaxSize) readStream! !
!DTDExternalEntityResolverLimitingDecorator class methodsFor: 'instance creation'!
externalEntityResolver: anExternalEntityResolver
	^ self new externalEntityResolver: anExternalEntityResolver! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'converting'!
asLimitingExternalEntityResolver
	^ self! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!
checkExternalEntityLimit
	| maxExternalEntities |

	((maxExternalEntities := self externalEntityResolver maxExternalEntities) notNil
		and: [self totalResolvedExternalEntities >= maxExternalEntities])
		ifTrue: [self erorrExternalEntityLimitExceeded]! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!
erorrExternalEntityLimitExceeded
	XMLLimitException signal:
		'External entity limit exceeded; ',
		'use #maxExternalEntities: to change or disable'! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
externalEntityLimits
	^ self externalEntityResolver externalEntityLimits! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
externalEntityLimits: anExternalEntityLimits
	self externalEntityResolver externalEntityLimits: anExternalEntityLimits! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!
externalEntityResolver
	^ externalEntityResolver! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!
externalEntityResolver: anExternalEntityResolver
	externalEntityResolver := anExternalEntityResolver! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!
externalEntityURIFromPublicID: aPublicID systemID: aSystemID
	^ self externalEntityResolver
		externalEntityURIFromPublicID: aPublicID
		systemID: aSystemID! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!
externalEntityURIFromPublicID: aPublicID systemID: aSystemID baseURI: aBaseXMLURIOrURIString
	^ self externalEntityResolver
		externalEntityURIFromPublicID: aPublicID
		systemID: aSystemID
		baseURI: aBaseXMLURIOrURIString! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
externalSubsetReadLimit
	^ self externalEntityResolver externalSubsetReadLimit! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
externalSubsetReadLimit: anInteger
	self externalEntityResolver externalSubsetReadLimit: anInteger! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!
incrementTotalResolvedExternalEntities
	totalResolvedExternalEntities :=
		totalResolvedExternalEntities
			ifNil: [1]
			ifNotNil: [totalResolvedExternalEntities + 1]! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
maxExternalEntities
	^ self externalEntityResolver maxExternalEntities! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
maxExternalEntities: anInteger
	self externalEntityResolver maxExternalEntities: anInteger! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
maxExternalEntitySize
	^ self externalEntityResolver maxExternalEntitySize! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
maxExternalEntitySize: anInteger
	self externalEntityResolver maxExternalEntitySize: anInteger! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		print: self externalEntityResolver;
		nextPut: $).! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
removeLimits
	self externalEntityResolver removeLimits! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!
resolveExternalEntityURI: anXMLURIOrURIString
	^ self resolveExternalEntityWith: [
		self externalEntityResolver resolveExternalEntityURI:
			anXMLURIOrURIString]! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!
resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	^ self resolveExternalEntityWith: [
		self externalEntityResolver
			resolveExternalEntityURI: anXMLURIOrURIString
			upToLimit: aMaxSize]! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!
resolveExternalEntityWith: aBlock
	| result |

	self checkExternalEntityLimit.
	result := aBlock value.
	self incrementTotalResolvedExternalEntities.

	^ result.! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
resolvesLocalFromNonLocal
	^ self externalEntityResolver resolvesLocalFromNonLocal! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!
resolvesLocalFromNonLocal: aBoolean
	self externalEntityResolver resolvesLocalFromNonLocal: aBoolean! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!
streamResolveExternalEntityURI: anXMLURIOrURIString
	^ self resolveExternalEntityWith: [
		self externalEntityResolver streamResolveExternalEntityURI:
			anXMLURIOrURIString]! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!
streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize
	^ self resolveExternalEntityWith: [
		self externalEntityResolver
			streamResolveExternalEntityURI: anXMLURIOrURIString
			upToLimit: aMaxSize]! !
!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!
totalResolvedExternalEntities
	^ totalResolvedExternalEntities ifNil: [totalResolvedExternalEntities := 0]! !
!DTDNotation class methodsFor: 'instance creation'!
name: aName publicID: aPublicID
	^ self
		name: aName
		publicID: aPublicID
		systemID: ''! !
!DTDNotation class methodsFor: 'instance creation'!
name: aName publicID: aPublicID systemID: aSystemID
	^ self new
		setName: aName
		publicID: aPublicID
		systemID: aSystemID! !
!DTDNotation methodsFor: 'accessing'!
name
	^ name ifNil: [name := '']! !
!DTDNotation methodsFor: 'accessing'!
name: aName
	name := aName! !
!DTDNotation methodsFor: 'accessing'!
publicID
	^ publicID ifNil: [publicID := '']! !
!DTDNotation methodsFor: 'accessing'!
publicID: aPublicID
	publicID := aPublicID! !
!DTDNotation methodsFor: 'initialization'!
setName: aName publicID: aPublicID systemID: aSystemID
	name := aName.
	publicID := aPublicID.
	systemID := aSystemID.! !
!DTDNotation methodsFor: 'accessing'!
systemID
	^ systemID ifNil: [systemID := '']! !
!DTDNotation methodsFor: 'accessing'!
systemID: aSystemID
	systemID := aSystemID! !
!DTDDecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!
contents: aString
	^ self new setContents: aString! !
!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
contents
	^ contents! !
!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'testing'!
isEmpty
	^ self contents isEmpty! !
!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		nextPutAll: self contents;
		nextPut: $).! !
!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
readStream
	^ self contents readStream! !
!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'initialization'!
setContents: aString
	contents := aString! !
!DTDResolvedExternalParsedEntityReplacement methodsFor: 'converting'!
asString
	^ self contents! !
!DTDResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
contents
	self subclassResponsibility! !
!DTDResolvedExternalParsedEntityReplacement methodsFor: 'testing'!
isEmpty
	self subclassResponsibility! !
!DTDResolvedExternalParsedEntityReplacement methodsFor: 'testing'!
notEmpty
	^ self isEmpty not! !
!DTDResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
readStream
	self subclassResponsibility! !
!DTDUndecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!
rawContents: aString
	^ self
		rawContents: aString
		encoding: ''! !
!DTDUndecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!
rawContents: aString encoding: anEncodingName
	^ self new
		setRawContents: aString
		encoding: anEncodingName! !
!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
contents
	^ self readStream upToEnd! !
!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
encoding
	^ encoding! !
!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'testing'!
isEmpty
	^ self rawContents isEmpty! !
!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		nextPutAll: self encoding;
		nextPut: $).! !
!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
rawContents
	^ rawContents! !
!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
readStream
	^ XMLDecodingReadStreamAdapter
		on: self rawContents readStream
		streamConverter: self encoding asXMLStreamConverter! !
!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'initialization'!
setRawContents: aString encoding: anEncodingName
	rawContents := aString.
	encoding := anEncodingName.! !
!DTDUnresolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!
resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString
	^ self new
		setResolver: aResolver
		publicID: aPublicID
		systemID: aSystemID
		baseURI: aBaseURIString! !
!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
baseURI
	^ baseURI ifNil: [baseURI := '']! !
!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self publicID isEmpty
		ifTrue: [aStream nextPutAll: 'SYSTEM']
		ifFalse: [
			aStream
				nextPutAll: 'PUBLIC "';
				nextPutAll: self publicID;
				nextPut: $"].

	aStream
		nextPutAll: ' "';
		nextPutAll: self systemID;
		nextPutAll: '")'.! !
!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
publicID
	^ publicID ifNil: [publicID := '']! !
!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'resolving'!
resolveForExternalEntity: anExternalEntity
	| externalEntityURI |

	externalEntityURI :=
		self resolver
			externalEntityURIFromPublicID: self publicID
			systemID: self systemID
			baseURI: self baseURI.

	anExternalEntity
		resolvedReplacement:
			(self resolver resolveExternalEntityURI: externalEntityURI);
		uri: externalEntityURI asString;
		unresolvedReplacement: nil.! !
!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
resolver
	^ resolver ifNil: [resolver := DTDExternalEntityResolver default]! !
!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'initialization'!
setResolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString
	resolver := aResolver.
	publicID := aPublicID.
	systemID := aSystemID.
	baseURI := aBaseURIString.! !
!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!
systemID
	^ systemID ifNil: [systemID := '']! !
!Object methodsFor: '*XML-Parser'!
isXMLBinaryOrExternalStream
	"Not every stream or stream-like object is a subclass of Stream, so this
	must be defined here.

	At a minimum, these streams must accept binary objects (like SmallIntegers
	and ByteArrays) when writing. When reading, they can return byte values
	as SmallIntegers or Characters and collections of byte values as ByteArrays
	or ByteStrings."

	^ self isStream
		and: [(self respondsTo: #isBinary)
			and: [self isBinary]]! !
!Object methodsFor: '*XML-Parser'!
isXMLConvertingStreamAdapter
	^ false! !
!SAX2ContentHandler class methodsFor: 'instance creation'!
parser: aParser
	^ self new parser: aParser! !
!SAX2ContentHandler methodsFor: 'handling - content'!
characters: aString
	"Handles character data in an element, such as the 'test' in
	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.
	
	It may be sent multiple times for different sections of character data
	in a single element if they're separated by other nodes or entity
	references like in '<characters>one<!!--comment-->two</characters>'.
	
	See ignorableWhitespace:"! !
!SAX2ContentHandler methodsFor: 'handling - content'!
endDocument
	"Handles the end of an XML document. No more handlers are invoked after this."! !
!SAX2ContentHandler methodsFor: 'handling - content'!
endElement: aQualifiedName
	"Handles the end of an element if a subclass doesn't implement
	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !
!SAX2ContentHandler methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI
	"Handles the end of an element if a subclass doesn't implement
	#endElement:prefix:uri:localName:. By default it forwards to a simpler
	handler, #endElement:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string"

	self endElement: aQualifiedName! !
!SAX2ContentHandler methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName
	"Handles the end of an element, either an end tag like '</end>' or a
	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,
	#endElement:prefix:uri:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	aLocalName - the local part of the qualified name"

	self
		endElement: aQualifiedName
		prefix: aPrefix
		uri:  aURI! !
!SAX2ContentHandler methodsFor: 'handling - content'!
endPrefixMapping: aPrefix
	"Handles the end of a namespace prefix/URI mapping when namespaces are
	enabled. After, aPrefix (empty for the default namespace) will be either
	unmapped or mapped to a different URI. The 'xml' prefix is predefined
	and never unmapped."! !
!SAX2ContentHandler methodsFor: 'handling - content'!
ignorableWhitespace: aString
	"When validation is enabled and a DTD with element declarations is
	present, this can be used to handle ignorable whitespace in elements
	with 'element content' (meaning they can only contain other elements
	and no PCDATA), such as between '<element-content>' and '<mixed-content>'
	or between '</mixed-content>' and '</element-content>' in this sample:
		'<!!DOCTYPE element-content [
			<!!--this has element content, so its whitespace is ignorable-->
			<!!ELEMENT element-content (mixed-content)>
			<!!--this has mixed content, so its whitespace is not ignorable-->
			<!!ELEMENT mixed-content (#PCDATA|any-content)*>
			<!!--this has any content, so its whitespace is not ignorable-->
			<!!ELEMENT any-content ANY>
		]>
		<element-content>
			<mixed-content>
				<any-content> any </any-content>
			</mixed-content>
		</element-content>'

	Not sent if validation is disabled or if there's no DTD with element
	declarations."! !
!SAX2ContentHandler methodsFor: 'accessing'!
parser
	"Returns the SAX2Parser this handler was injected into"

	^ parser! !
!SAX2ContentHandler methodsFor: 'accessing'!
parser: aParser
	parser := aParser! !
!SAX2ContentHandler methodsFor: 'handling - content'!
processingInstruction: aTargetString data: aDataString
	"Handles processing instructions like '<?name value?>', where 'name' is
	the target and 'value' is the data.
	
	XML declarations may look like PIs but are different and are handled
	with xmlVersion:encoding:standalone: instead."! !
!SAX2ContentHandler methodsFor: 'handling - content'!
skippedEntity: anEntityName
	"Sent when a general parsed entity reference like '&name;' is
	unreplaced in content. Only sent when validation is turned off
	or entity replacement is disabled."! !
!SAX2ContentHandler methodsFor: 'handling - content'!
startDocument
	"Handles the start of an XML document, the first handler invoked."! !
!SAX2ContentHandler methodsFor: 'handling - content'!
startElement: aQualifiedName attributes: anAttributeDictionary
	"Handles the start of an element if a subclass doesn't implement
	#startElement:prefix:uri:localName:attributes: or
	#startElement:prefix:uri:attributes:.

	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !
!SAX2ContentHandler methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary
	"Handles the start of an element if a subclass doesn't implement
	#startElement:prefix:uri:localName:attributes:. By default it forwards
	to a simpler handler, #startElement:attributes:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	anAttributeDictionary - an XMLAttributeDictionary of attributes"

	self
		startElement: aQualifiedName
		attributes: anAttributeDictionary! !
!SAX2ContentHandler methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary
	"Handles the start of an element, either a start tag like '<start>' or a
	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,
	#startElement:prefix:uri:attributes:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	aLocalName - the local part of the qualified name
	anAttributeDictionary - an XMLAttributeDictionary of attributes"

	self
		startElement: aQualifiedName
		prefix: aPrefix
		uri: aURI
		attributes: anAttributeDictionary! !
!SAX2ContentHandler methodsFor: 'handling - content'!
startPrefixMapping: aPrefix uri: aURI
	"Handles the start of a namespace prefix/URI mapping when namespaces are
	enabled. The 'xml' prefix is predefined and never remapped.

	aPrefix - the prefix of the namespace (empty for the default namesapce)
	aURI - the namespace URI"! !
!SAX2DeclarationHandler class methodsFor: 'instance creation'!
parser: aParser
	^ self new parser: aParser! !
!SAX2DeclarationHandler methodsFor: 'handling - declaration'!
attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !
!SAX2DeclarationHandler methodsFor: 'handling - declaration'!
elementDeclaration: anElementName contentModel: aContentModel
! !
!SAX2DeclarationHandler methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName! !
!SAX2DeclarationHandler methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName replacement: aReplacement! !
!SAX2DeclarationHandler methodsFor: 'handling - declaration'!
notationDeclaration: aName publicID: aPublicID systemID: aSystemID
! !
!SAX2DeclarationHandler methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !
!SAX2DeclarationHandler methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName replacement: aReplacement! !
!SAX2DeclarationHandler methodsFor: 'accessing'!
parser
	"Returns the SAX2Parser this handler was injected into"

	^ parser! !
!SAX2DeclarationHandler methodsFor: 'accessing'!
parser: aParser
	parser := aParser! !
!SAX2ElementCharacterHandler methodsFor: 'accessing'!
characters
	"This returns the combined #characters: events handled by the receiver
	as a string."

	^ characters ifNil: [characters := '']! !
!SAX2ElementCharacterHandler methodsFor: 'handling - content'!
characters: aString
	"building the string this way is simpler and performs as well in tests
	as using a write stream"
	characters :=
		characters
			ifNil: [aString]
			ifNotNil: [characters, aString]! !
!SAX2ElementHandler class methodsFor: 'parsing'!
parser: aParser
	^ self
		parser: aParser
		parent: aParser elementHandler
		parentFactory: aParser elementHandlerFactory! !
!SAX2ElementHandler class methodsFor: 'parsing'!
parser: aParser parent: anElementHandler parentFactory: anElementHandlerFactory
	^ self new
		setParser: aParser
		parent: anElementHandler
		parentFactory: anElementHandlerFactory! !
!SAX2ElementHandler methodsFor: 'accessing'!
ancestors	
	"Returns a list of all ancestor element handlers of the receiver."

	| ancestors |

	ancestors := XMLOrderedList new.
	self ancestorsDo: [:each | ancestors addLast: each].
	^ ancestors.! !
!SAX2ElementHandler methodsFor: 'enumerating'!
ancestorsDo: aBlock
	| ancestor |

	ancestor := self parent.
	[ancestor notNil]
		whileTrue: [
			aBlock value: ancestor.
			ancestor := ancestor parent].! !
!SAX2ElementHandler methodsFor: 'accessing'!
characters
	"This handler ignores #characters: events, so this always returns
	an empty string."

	^ ''! !
!SAX2ElementHandler methodsFor: 'handling - content'!
characters: aString
	"Handles character data in an element, such as the 'test' in
	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.
	
	It may be sent multiple times for different sections of character data
	in a single element if they're separated by other nodes or entity
	references like in '<characters>one<!!--comment-->two</characters>'."! !
!SAX2ElementHandler methodsFor: 'accessing'!
elementHandlerFactory
	"Can be overridden to return a default factory to use by a factory
	mapper when no other factory is mapped to the receiver."

	^ nil! !
!SAX2ElementHandler methodsFor: 'handling - content'!
endElement: aQualifiedName
	"Handles the end of an element if a subclass doesn't implement
	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !
!SAX2ElementHandler methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI
	"Handles the end of an element if a subclass doesn't implement
	#endElement:prefix:uri:localName:. By default it forwards to a simpler
	handler, #endElement:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string"

	self endElement: aQualifiedName! !
!SAX2ElementHandler methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName
	"Handles the end of an element, either an end tag like '</end>' or a
	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,
	#endElement:prefix:uri:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	aLocalName - the local part of the qualified name"

	self
		endElement: aQualifiedName
		prefix: aPrefix
		uri:  aURI! !
!SAX2ElementHandler methodsFor: 'testing'!
hasParent
	"Returns true if the receiver has a parent element handler (meaning it's
	not the root element handler)"

	^ parent notNil! !
!SAX2ElementHandler methodsFor: 'accessing'!
parent
	"Returns the parent element handler or nil if there isn't one (if
	the receiver is handling the root element)."

	^ parent! !
!SAX2ElementHandler methodsFor: 'accessing'!
parentFactory
	"Returns the factory that created the receiver."

	^ parentFactory! !
!SAX2ElementHandler methodsFor: 'accessing'!
parser
	"Returns the SAX2ElementParser"

	^ parser! !
!SAX2ElementHandler methodsFor: 'initialization'!
setParser: aParser parent: anElementHandler parentFactory: anElementHandlerFactory
	parser := aParser.
	parent := anElementHandler.
	parentFactory := anElementHandlerFactory.! !
!SAX2ElementHandler methodsFor: 'handling - content'!
startElement: aQualifiedName attributes: anAttributeDictionary
	"Handles the start of an element if a subclass doesn't implement
	#startElement:prefix:uri:localName:attributes: or
	#startElement:prefix:uri:attributes:.

	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !
!SAX2ElementHandler methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary
	"Handles the start of an element if a subclass doesn't implement
	#startElement:prefix:uri:localName:attributes:. By default it forwards
	to a simpler handler, #startElement:attributes:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	anAttributeDictionary - an XMLAttributeDictionary of attributes"

	self
		startElement: aQualifiedName
		attributes: anAttributeDictionary! !
!SAX2ElementHandler methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary
	"Handles the start of an element, either a start tag like '<start>' or a
	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,
	#startElement:prefix:uri:attributes:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	aLocalName - the local part of the qualified name
	anAttributeDictionary - an XMLAttributeDictionary of attributes"

	self
		startElement: aQualifiedName
		prefix: aPrefix
		uri: aURI
		attributes: anAttributeDictionary! !
!SAX2ElementHandlerFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection
	^ self elementHandlerClass! !
!SAX2ElementHandlerFactory methodsFor: 'accessing'!
elementHandlerClass
	^ SAX2ElementHandler! !
!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection
	^ elementClassMapper
		classForElement: aQualifiedName
		namespaceURI: aURI
		attributes: anAssociationCollection
		ifNone: [self elementHandlerClass]! !
!SAX2PluggableElementHandlerFactory methodsFor: 'private'!
elementClassMapper
	^ elementClassMapper! !
!SAX2PluggableElementHandlerFactory methodsFor: 'private'!
elementClassMapper: anElementClassMapper
	elementClassMapper := anElementClassMapper! !
!SAX2PluggableElementHandlerFactory methodsFor: 'defaults'!
elementClassMapperClass
	^ XMLBasicElementClassMapper! !
!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!
elementHandlerClass
	^ elementHandlerClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!
elementHandlerClass: aClass
	"set the default element handler class"
	elementHandlerClass := aClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElement: anElementName attributes: aCollectionOrAttributeSpec withClass: aClass
	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a
	collection of associations of required attribute names and values, and the
	required values can be strings, blocks, or nil meaning the attribute is
	required but can take any value"

	elementClassMapper
		mapElement: anElementName
		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec
		toClass: aClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElement: anElementName namespaceURI: aURI attributes: aCollectionOrAttributeSpec withClass: aClass
	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a
	collection of associations of required attribute names and values, and the
	required values can be strings, blocks, or nil meaning the attribute is
	required but can take any value"

	elementClassMapper
		mapElement: anElementName
		namespaceURI: aURI
		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec
		toClass: aClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElement: anElementName namespaceURI: aURI withClass: aClass
	elementClassMapper
		mapElement: anElementName
		namespaceURI: aURI
		toClass: aClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElement: anElementName withClass: aClass
	elementClassMapper
		mapElement: anElementName
		toClass: aClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElements: anElementNameCollection namespaceURI: aNamespaceURI withClass: aClass
	elementClassMapper
		mapElements: anElementNameCollection
		namespaceURI: aNamespaceURI
		toClass: aClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElements: anElementNameCollection withClass: aClass
	elementClassMapper
		mapElements: anElementNameCollection
		toClass: aClass! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElementsMatchingClass: aClass
	"This will handle all elements matching the name of a class with that
	class, but igoring the class's prefix and any 'Element' or 'ElementHandler'
	suffix.

	For example, it will match MyUserDefinedElement to:
		<UserDefined>
		<userDefined>
		<user-defined>
		<user_defined>"

	elementClassMapper
		mapAllMatchingElementsToClass: aClass
		ignoringSuffixes: self ignorableClassNameSuffixes! !
!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!
handleElementsMatchingClasses: aClassCollection
	"See the comment in #handleElementsMatchingClass:"

	elementClassMapper
		mapAllMatchingElementsToClasses: aClassCollection
		ignoringSuffixes: self ignorableClassNameSuffixes! !
!SAX2PluggableElementHandlerFactory methodsFor: 'defaults'!
ignorableClassNameSuffixes
	^ #('Element' 'ElementHandler')! !
!SAX2PluggableElementHandlerFactory methodsFor: 'initialization'!
initialize
	super initialize.

	elementClassMapper := self elementClassMapperClass new.
	elementHandlerClass := SAX2ElementHandler.! !
!SAX2PluggableElementHandlerFactory methodsFor: 'copying'!
postCopy
	super postCopy.

	elementClassMapper := elementClassMapper copy.! !
!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!
elementHandlerFactory
	"Can be overridden to return a default element handler factory to use
	if no other mapping is defined for it."

	^ nil! !
!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!
factoryForElementHandler: anElementHandler
	^ self
		factoryForElementHandler: anElementHandler
		ifNone: [nil]! !
!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!
factoryForElementHandler: anElementHandler ifNone: aBlock
	^ anElementHandler elementHandlerFactory
		ifNil: [
			self elementHandlerFactory
				ifNil: [aBlock value]]! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'defaults'!
defaultElementHandlerFactoryClass
	^ SAX2ElementHandlerFactory! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!
elementHandlerFactory
	^ elementHandlerFactory! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!
elementHandlerFactory: anElementHandlerFactory
	"set the default element handler factory"
	elementHandlerFactory := anElementHandlerFactory! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'private'!
elementHandlerFactoryMap
	^ elementHandlerFactoryMap! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!
factoryForElementHandler: anElementHandler ifNone: aBlock
	"optimization to skip any unneeded hash lookups"
	elementHandlerFactoryMap size > 0
		ifTrue: [
			^ elementHandlerFactoryMap
				at: anElementHandler class
				ifAbsent: [
					super
						factoryForElementHandler: anElementHandler
						ifNone: aBlock]]
		ifFalse: [
			^ super
				factoryForElementHandler: anElementHandler
				ifNone: aBlock]! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'initialization'!
initialize
	super initialize.

	elementHandlerFactoryMap := IdentityDictionary new.
	elementHandlerFactory := self defaultElementHandlerFactoryClass new.! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'mapping'!
mapElementHandlerClass: aClass toFactory: aFactory
	elementHandlerFactoryMap
		at: aClass
		put: aFactory! !
!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'copying'!
postCopy
	super postCopy.

	elementHandlerFactoryMap := elementHandlerFactoryMap copy.! !
!SAX2LexicalHandler class methodsFor: 'instance creation'!
parser: aParser
	^ self new parser: aParser! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
comment: aString
	"Handles '<!!--comment-->' sections in documents."! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
endCData
	"Sent after the character data of a '<!![CDATA[...]]>' section."! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
endDTD
! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
endEntity: anEntityName
	"Handles the end of some general entity's replacement in content.
	Not sent if the entity is undeclared or if content entity replacement
	is disabled."! !
!SAX2LexicalHandler methodsFor: 'accessing'!
parser
	"Returns the SAX2Parser this handler was injected into"

	^ parser! !
!SAX2LexicalHandler methodsFor: 'accessing'!
parser: aParser
	parser := aParser! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
startCData
	"Sent before the character data of a '<!![CDATA[...]]>' section."! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
startDTD: aRootElementName publicID: aPublicID systemID: aSystemID
	"Handles the start of a '<!!DOCTYPE ...>' declaration. Any events
	after this and until endDTD is sent are part of the internal subset
	of the DTD.
	
	aRootElementName - the expected name of the document's root element
	aPublicID - the public ID of the external DTD subset or an empty string
	aSystemID - the URI where the external subset can be found or an empty string"! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
startEntity: anEntityName
	"Handles the start of some general entity's replacement in content.
	Not sent if the entity is undeclared or if content entity replacement
	is disabled."! !
!SAX2LexicalHandler methodsFor: 'handling - lexical'!
xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean
	"Handles the '<?xml ...?>' declaration of a document.
	
	aVersionFloat - the version of XML the document uses, usually 1.0
	anEncoding - the name of the encoding or an empty string
	aBoolean - true if standalone='yes'"! !
!SAX2ElementParser methodsFor: 'handling - content'!
characters: aString
	self elementHandler characters: aString! !
!SAX2ElementParser methodsFor: 'defaults'!
defaultElementHandlerFactoryClass
	^ SAX2ElementHandlerFactory! !
!SAX2ElementParser methodsFor: 'defaults'!
defaultElementHandlerFactoryMapperClass
	^ SAX2ElementHandlerFactoryMapper! !
!SAX2ElementParser methodsFor: 'accessing'!
elementHandler
	^ elementHandler! !
!SAX2ElementParser methodsFor: 'accessing'!
elementHandler: anElementHandler
	elementHandler := anElementHandler! !
!SAX2ElementParser methodsFor: 'accessing'!
elementHandlerFactory
	^ elementHandlerFactory! !
!SAX2ElementParser methodsFor: 'accessing'!
elementHandlerFactory: anElementHandlerFactory
	elementHandlerFactory := anElementHandlerFactory! !
!SAX2ElementParser methodsFor: 'accessing'!
elementHandlerFactoryMapper
	^ elementHandlerFactoryMapper! !
!SAX2ElementParser methodsFor: 'accessing'!
elementHandlerFactoryMapper: anElementHandlerFactoryMapper
	elementHandlerFactoryMapper := anElementHandlerFactoryMapper! !
!SAX2ElementParser methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName
	| oldElementHandler |

	(oldElementHandler := self elementHandler)
		endElement: aQualifiedName
		prefix: aPrefix
		uri: aURI
		localName: aLocalName.
	self
		elementHandler: oldElementHandler parent;
		elementHandlerFactory: oldElementHandler parentFactory.! !
!SAX2ElementParser methodsFor: 'initialization'!
on: aStringOrStream
	super on: aStringOrStream.

	elementHandlerFactory := self defaultElementHandlerFactoryClass new.
	elementHandlerFactoryMapper := self defaultElementHandlerFactoryMapperClass new.! !
!SAX2ElementParser methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary
	| newElementHandler |

	newElementHandler :=
		(self elementHandlerFactory
			classForElement: aQualifiedName
			namespaceURI: aURI
			localName: aLocalName
			attributes: anAttributeDictionary)
				parser: self
				parent: self elementHandler
				parentFactory: self elementHandlerFactory.
	self
		elementHandler: newElementHandler;
		elementHandlerFactory:
			(self elementHandlerFactoryMapper
				factoryForElementHandler: newElementHandler
				ifNone: [self elementHandlerFactory]).

	newElementHandler
		startElement: aQualifiedName
		prefix: aPrefix
		uri: aURI
		localName: aLocalName
		attributes: anAttributeDictionary.! !
!SAX2Parser class methodsFor: 'private '!
generateHandlerForwardingMethods
	"
	self generateHandlerForwardingMethods
	"

	(Array
		with: 'contentHandler' -> #'handling - content'
		with: 'lexicalHandler' -> #'handling - lexical'
		with: 'declarationHandler' -> #'handling - declaration')
		do: [:handlerAccessorAndCategory | | handlerAccessor handlerCategory |
			handlerAccessor := handlerAccessorAndCategory key.
			handlerCategory := handlerAccessorAndCategory value.

			(SAXHandler selectorsInCategory: handlerCategory) do: [:each | | parsedMethod sourceStream |
				parsedMethod := RBParser parseMethod: (SAXHandler sourceCodeAt: each).
				(sourceStream := String new writeStream)
					nextPutAll: parsedMethod selectorAndArgumentNames;
					cr;
					nextPutAll: '	self ';
					nextPutAll: handlerAccessor.
				1 to: parsedMethod keywords size do: [:i |
					parsedMethod keywords size > 1
						ifTrue: [
							sourceStream
								cr;
								tab;
								tab]
						ifFalse: [sourceStream space].
					sourceStream nextPutAll: (parsedMethod keywords at: i).
					parsedMethod argumentNames
						ifNotEmpty: [
							sourceStream
								space;
								nextPutAll: (parsedMethod argumentNames at: i)]].

				self
					compile: sourceStream contents
					classified: handlerCategory]]! !
!SAX2Parser class methodsFor: 'private '!
generateMethodsInHandlerClasses
	"
	self generateMethodsInHandlerClasses
	"

	(Array
		with: SAX2ContentHandler -> #'handling - content'
		with: SAX2LexicalHandler -> #'handling - lexical'
		with: SAX2DeclarationHandler -> #'handling - declaration')
		do: [:handlerClassAndCategory | | handlerClass handlerCategory |
			handlerClass := handlerClassAndCategory key.
			handlerCategory := handlerClassAndCategory value.

			(SAXHandler selectorsInCategory: handlerCategory) do: [:each |
				handlerClass
					compile: (SAXHandler sourceCodeAt: each)
					classified: handlerCategory]]! !
!SAX2Parser methodsFor: 'handling - declaration'!
attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	self declarationHandler
		attributeDeclaration: anElementName
		name: anAttributeName
		type: aType
		defaultPragma: aDefaultPragma
		defaultValue: aDefaultValue! !
!SAX2Parser methodsFor: 'handling - content'!
characters: aString
	self contentHandler characters: aString! !
!SAX2Parser methodsFor: 'handling - lexical'!
comment: aString
	self lexicalHandler comment: aString! !
!SAX2Parser methodsFor: 'accessing'!
contentHandler
	^ contentHandler! !
!SAX2Parser methodsFor: 'accessing'!
contentHandler: aContentHandler
	(contentHandler :=
		aContentHandler ifNil: [self defaultContentHandlerClass new])
			parser: self! !
!SAX2Parser methodsFor: 'accessing'!
declarationHandler
	^ declarationHandler! !
!SAX2Parser methodsFor: 'accessing'!
declarationHandler: aDeclarationHandler
	(declarationHandler :=
		aDeclarationHandler ifNil: [self defaultDeclarationHandlerClass new])
			parser: self! !
!SAX2Parser methodsFor: 'defaults'!
defaultContentHandlerClass
	^ SAX2ContentHandler! !
!SAX2Parser methodsFor: 'defaults'!
defaultDeclarationHandlerClass
	^ SAX2DeclarationHandler! !
!SAX2Parser methodsFor: 'defaults'!
defaultLexicalHandlerClass
	^ SAX2LexicalHandler! !
!SAX2Parser methodsFor: 'defaults'!
defaultParsingResult
	"the default parsing result of SAXHandler"
	^ self! !
!SAX2Parser methodsFor: 'handling - declaration'!
elementDeclaration: anElementName contentModel: aContentModel
	self declarationHandler
		elementDeclaration: anElementName
		contentModel: aContentModel! !
!SAX2Parser methodsFor: 'handling - lexical'!
endCData
	self lexicalHandler endCData! !
!SAX2Parser methodsFor: 'handling - lexical'!
endDTD
	self lexicalHandler endDTD! !
!SAX2Parser methodsFor: 'handling - content'!
endDocument
	self contentHandler endDocument! !
!SAX2Parser methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName
	self contentHandler
		endElement: aQualifiedName
		prefix: aPrefix
		uri: aURI
		localName: aLocalName! !
!SAX2Parser methodsFor: 'handling - lexical'!
endEntity: anEntityName
	self lexicalHandler endEntity: anEntityName! !
!SAX2Parser methodsFor: 'handling - content'!
endPrefixMapping: aPrefix
	self contentHandler endPrefixMapping: aPrefix! !
!SAX2Parser methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName
	self declarationHandler
		generalEntityDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID
		ndata: aNotationName! !
!SAX2Parser methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName replacement: aReplacement
	self declarationHandler
		generalEntityDeclaration: aName
		replacement: aReplacement! !
!SAX2Parser methodsFor: 'handling - content'!
ignorableWhitespace: aString
	self contentHandler ignorableWhitespace: aString! !
!SAX2Parser methodsFor: 'accessing'!
lexicalHandler
	^ lexicalHandler! !
!SAX2Parser methodsFor: 'accessing'!
lexicalHandler: aLexicalHandler
	(lexicalHandler :=
		aLexicalHandler ifNil: [self defaultLexicalHandlerClass new])
			parser: self! !
!SAX2Parser methodsFor: 'handling - declaration'!
notationDeclaration: aName publicID: aPublicID systemID: aSystemID
	self declarationHandler
		notationDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID! !
!SAX2Parser methodsFor: 'initialization'!
on: aStringOrStream
	super on: aStringOrStream.

	contentHandler := self defaultContentHandlerClass parser: self.
	lexicalHandler := self defaultLexicalHandlerClass parser: self.
	declarationHandler := self defaultDeclarationHandlerClass parser: self.
	parsingResult := self defaultParsingResult.! !
!SAX2Parser methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID
	self declarationHandler
		parameterEntityDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID! !
!SAX2Parser methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName replacement: aReplacement
	self declarationHandler
		parameterEntityDeclaration: aName
		replacement: aReplacement! !
!SAX2Parser methodsFor: 'parsing'!
parsingResult
	^ parsingResult! !
!SAX2Parser methodsFor: 'parsing'!
parsingResult: anObject
	parsingResult := anObject! !
!SAX2Parser methodsFor: 'handling - content'!
processingInstruction: aTargetString data: aDataString
	self contentHandler
		processingInstruction: aTargetString
		data: aDataString! !
!SAX2Parser methodsFor: 'handling - content'!
skippedEntity: anEntityName
	self contentHandler skippedEntity: anEntityName! !
!SAX2Parser methodsFor: 'handling - lexical'!
startCData
	self lexicalHandler startCData! !
!SAX2Parser methodsFor: 'handling - lexical'!
startDTD: aRootElementName publicID: aPublicID systemID: aSystemID
	self lexicalHandler
		startDTD: aRootElementName
		publicID: aPublicID
		systemID: aSystemID! !
!SAX2Parser methodsFor: 'handling - content'!
startDocument
	self contentHandler startDocument! !
!SAX2Parser methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: aDictionary
	self contentHandler
		startElement: aQualifiedName
		prefix: aPrefix
		uri: aURI
		localName: aLocalName
		attributes: aDictionary! !
!SAX2Parser methodsFor: 'handling - lexical'!
startEntity: anEntityName
	self lexicalHandler startEntity: anEntityName! !
!SAX2Parser methodsFor: 'handling - content'!
startPrefixMapping: aPrefix uri: aURI
	self contentHandler
		startPrefixMapping: aPrefix
		uri: aURI! !
!SAX2Parser methodsFor: 'handling - lexical'!
xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean
	self lexicalHandler
		xmlVersion: aVersionFloat
		encoding: anEncoding
		standalone: aBoolean! !
!SAXHandler class methodsFor: 'instance creation'!
new
	Error signal:
		'Parsers should be created with #on: or ',
		'some other "instance creation" message'! !
!SAXHandler class methodsFor: 'instance creation'!
on: aStringOrStream
	"Returns a new parser on the string or stream argument but doesn't parse it.

	Can be used to configure a parser with 'configuring' messages before
	parsing with #parseDocument."

	^ self basicNew initialize on: aStringOrStream! !
!SAXHandler class methodsFor: 'instance creation'!
on: aStringOrStream documentURI: aURIString
	"Returns a new parser on the string or stream argument treating the
	specified URI as the base URI of the document but doesn't parse it.

	Can be used to configure a parser with 'configuring' messages before
	parsing with #parseDocument."

	^ (self on: aStringOrStream) documentURI: aURIString! !
!SAXHandler class methodsFor: 'instance creation'!
onFileNamed: aFileName
	"Returns a new parser on the specified file but doesn't parse it.
	If aFileName is a relative path, it will be resolved in the context of
	the current working directory.

	Can be used to configure file parsers with 'configuring' messages before
	parsing with #parseDocument."

	^ self
		on:
			"return an XMLDecodingReadStreamAdapter on the undecoded file
			stream so we can do our own decoding looking at byte order
			marks and <?xml ...?> encoding attributes"
			(XMLDecodingReadStreamAdapter nonDecodingOn:
				aFileName asXMLFileHandle rawReadStream)
		documentURI: aFileName! !
!SAXHandler class methodsFor: 'instance creation'!
onURL: aURLString
	"Fetches the URL and returns new parser on the response content but doesn't
	parse it. If the URL has no scheme, it will be treated as a file path.

	Can be used to configure URL parsers with 'configuring' messages before
	parsing with #parseDocument."

	^ self
		onURL: aURLString
		upToLimit: XMLParserLimits defaultDocumentReadLimit! !
!SAXHandler class methodsFor: 'instance creation'!
onURL: aURLString upToLimit: aMaxSize
	"Fetches a URL and returns new parser on the response content up to the
	input limit (use nil to disable) but doesn't parse it. If the URL has
	no scheme, it will be treated as a file path.

	Can be used to configure limited URL parsers with 'configuring' messages
	before parsing with #parseDocument."

	^ (self
		on:
			(DTDExternalEntityResolver new
				streamResolveExternalEntityURI: aURLString
				upToLimit: aMaxSize)
		documentURI: aURLString)
			documentReadLimit: aMaxSize! !
!SAXHandler class methodsFor: 'parsing'!
parse: aStringOrStream
	"Parses the document in the string or stream argument"

	^ (self on: aStringOrStream) parseDocument! !
!SAXHandler class methodsFor: 'parsing'!
parse: aStringOrStream documentURI: aURIString
	"Parses the document in the string or stream argument treating the specified
	URI as the base URI of the document."

	^ (self
		on: aStringOrStream
		documentURI: aURIString) parseDocument! !
!SAXHandler class methodsFor: 'parsing'!
parse: aStringOrStream usingNamespaces: aBoolean
	"Parses the document in the string or stream argument possibly with namespace
	checking enabled (default)"

	^ (self on: aStringOrStream)
		usesNamespaces: aBoolean;
		parseDocument! !
!SAXHandler class methodsFor: 'parsing'!
parse: aStringOrStream usingNamespaces: aNamespaceBoolean validation: aValidationBoolean
	"Parses the document in the string or stream argument possibly with namespace
	checking (default) and validation (default) enabled."

	^ (self on: aStringOrStream)
		usesNamespaces: aNamespaceBoolean;
		isValidating: aValidationBoolean;
		parseDocument! !
!SAXHandler class methodsFor: 'parsing'!
parse: aStringOrStream usingNamespaces: aNamespaceBoolean validation: aValidationBoolean externalEntities: anEntityResolutionBoolean
	"Parses the document in the string or stream argument possibly with namespace
	checking (default), validation (default), or external entity resolution (not
	default) enabled."

	^ (self on: aStringOrStream)
		usesNamespaces: aNamespaceBoolean;
		isValidating: aValidationBoolean;
		resolvesExternalEntities: anEntityResolutionBoolean;
		parseDocument! !
!SAXHandler class methodsFor: 'deprecated'!
parseDocumentFrom: aStringOrStream
	self deprecated: 'Use #parse: instead'.

	^ self parse: aStringOrStream.! !
!SAXHandler class methodsFor: 'deprecated'!
parseDocumentFromFileNamed: aFileName
	self deprecated: 'Use #parseFileNamed: instead'.

	^ self parseFileNamed: aFileName.! !
!SAXHandler class methodsFor: 'parsing'!
parseFileNamed: aFileNameString
	"Parses the specified file. If aFileName is a relative path, it will be
	resolved in the context of the current working directory."

	^ (self onFileNamed: aFileNameString) parseDocument! !
!SAXHandler class methodsFor: 'parsing'!
parseURL: aURLString
	"Fetches the URL and parses the response content. If the URL has no scheme,
	it will be treated as a file path."

	^ (self onURL: aURLString) parseDocument! !
!SAXHandler class methodsFor: 'parsing'!
parseURL: aURLString upToLimit: aMaxSize
	"Fetches the URL upto the input limit (nil to disable) and parses the
	response content. If the URL has no scheme, it will be treated as a file
	path."

	^ (self
		onURL: aURLString
		upToLimit: aMaxSize) parseDocument! !
!SAXHandler methodsFor: 'handling - declaration'!
attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !
!SAXHandler methodsFor: 'handling - content'!
characters: aString
	"Handles character data in an element, such as the 'test' in
	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.
	
	It may be sent multiple times for different sections of character data
	in a single element if they're separated by other nodes or entity
	references like in '<characters>one<!!--comment-->two</characters>'.
	
	See #isInCDataSection and #ignorableWhitespace:"! !
!SAXHandler methodsFor: 'handling - lexical'!
comment: aString
	"Handles '<!!--comment-->' sections in documents."! !
!SAXHandler methodsFor: 'accessing'!
configuration
	^ configuration! !
!SAXHandler methodsFor: 'accessing'!
configuration: aConfiguration
	(configuration := aConfiguration) parserHandlerClass: self class! !
!SAXHandler methodsFor: 'defaults'!
configurationClass
	^ XMLConfiguration! !
!SAXHandler methodsFor: 'configuring'!
decodesCharacters
	^ self configuration decodesCharacters! !
!SAXHandler methodsFor: 'configuring'!
decodesCharacters: aBoolean
	"When enabled, encoding detection and character decoding will be attemped if:
		1) the input stream or string is binary/external
		2) it starts with a byte-order mark (BOM) byte sequence
		3) the input is wrapped with an XMLDecodingReadStreamAdapter that has
			a null or implicit stream converter
	(Default.)"

	self configuration decodesCharacters: aBoolean! !
!SAXHandler methodsFor: 'defaults'!
defaultDocumentURI
	^ ''! !
!SAXHandler methodsFor: 'private'!
doctypeDefinition: aDoctypeDefinition! !
!SAXHandler methodsFor: 'configuring'!
documentReadLimit
	^ self configuration documentReadLimit! !
!SAXHandler methodsFor: 'configuring'!
documentReadLimit: anInteger
	"change the document read limit (maximum number of chars that can be read)
	or nil to disable"

	self configuration documentReadLimit: anInteger! !
!SAXHandler methodsFor: 'accessing'!
documentURI
	"Returns current document base URI string"
	^ documentURI ifNil: [documentURI := self defaultDocumentURI]! !
!SAXHandler methodsFor: 'accessing'!
documentURI: aURIString
	documentURI := aURIString! !
!SAXHandler methodsFor: 'defaults'!
driverClass
	^ SAXParserDriver! !
!SAXHandler methodsFor: 'handling - declaration'!
elementDeclaration: anElementName contentModel: aContentModel
! !
!SAXHandler methodsFor: 'handling - lexical'!
endCData
	"Sent after the character data of a '<!![CDATA[...]]>' section."! !
!SAXHandler methodsFor: 'handling - lexical'!
endDTD
! !
!SAXHandler methodsFor: 'handling - content'!
endDocument
	"Handles the end of an XML document. No more handlers are invoked after this."! !
!SAXHandler methodsFor: 'handling - content'!
endElement: aQualifiedName
	"Handles the end of an element if a subclass doesn't implement
	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !
!SAXHandler methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI
	"Handles the end of an element if a subclass doesn't implement
	#endElement:prefix:uri:localName:. By default it forwards to a simpler
	handler, #endElement:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string"

	self endElement: aQualifiedName! !
!SAXHandler methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName
	"Handles the end of an element, either an end tag like '</end>' or a
	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,
	#endElement:prefix:uri:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	aLocalName - the local part of the qualified name"

	self
		endElement: aQualifiedName
		prefix: aPrefix
		uri:  aURI! !
!SAXHandler methodsFor: 'handling - lexical'!
endEntity: anEntityName
	"Handles the end of some general entity's replacement in content.
	Not sent if the entity is undeclared or if content entity replacement
	is disabled."! !
!SAXHandler methodsFor: 'handling - content'!
endPrefixMapping: aPrefix
	"Handles the end of a namespace prefix/URI mapping when namespaces are
	enabled. After, aPrefix (empty for the default namespace) will be either
	unmapped or mapped to a different URI. The 'xml' prefix is predefined
	and never unmapped."! !
!SAXHandler methodsFor: 'private'!
errorInstancesCannotHaveMultipleParsers
	XMLParserException
		formatSignal: 'Instances of {1} cannot have multiple parsers'
		with: self class name! !
!SAXHandler methodsFor: 'configuring'!
externalEntityResolver
	^ self configuration externalEntityResolver! !
!SAXHandler methodsFor: 'configuring'!
externalEntityResolver: anExternalEntityResolver
	"This can be used to set a different DTDExternalEntityResolver"

	self configuration externalEntityResolver: anExternalEntityResolver! !
!SAXHandler methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName! !
!SAXHandler methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName replacement: aReplacement! !
!SAXHandler methodsFor: 'testing'!
hasParser
	^ hasParser! !
!SAXHandler methodsFor: 'handling - content'!
ignorableWhitespace: aString
	"When validation is enabled and a DTD with ELEMENT declarations is
	present, this can be used to handle ignorable whitespace in elements
	with 'element content' (meaning they can only contain other elements
	and no PCDATA), such as between '<element-content>' and '<mixed-content>'
	or between '</mixed-content>' and '</element-content>' in this sample:
		'<!!DOCTYPE element-content [
			<!!--this has element content, so its whitespace is ignorable-->
			<!!ELEMENT element-content (mixed-content)>
			<!!--this has mixed content, so its whitespace is not ignorable-->
			<!!ELEMENT mixed-content (#PCDATA|any-content)*>
			<!!--this has any content, so its whitespace is not ignorable-->
			<!!ELEMENT any-content ANY>
		]>
		<element-content>
			<mixed-content>
				<any-content> any </any-content>
			</mixed-content>
		</element-content>'

	Not sent if validation is disabled or if there's no DTD with element
	declarations."! !
!SAXHandler methodsFor: 'initialization'!
initializeParser: aParser! !
!SAXHandler methodsFor: 'accessing'!
input
	"the input being parsed or to be parsed"
	^ input! !
!SAXHandler methodsFor: 'private'!
input: aStringOrStream
	"here for backwards compatibility; use #on: instead"

	input := aStringOrStream! !
!SAXHandler methodsFor: 'parsing'!
interruptParsing
	"Can be sent within a handler to stop parsing;
	will be silently caught within #parseDocument or other parsing methods"

	XMLParsingInterruptException signal! !
!SAXHandler methodsFor: 'testing'!
isInCDataSection
	"Can be used by characters: handlers to distinguish ordinary character
	data from characters within '<!![CDATA[...]]>' sections"

	^ isInCDataSection! !
!SAXHandler methodsFor: 'private'!
isInCDataSection: aBoolean
	isInCDataSection := aBoolean! !
!SAXHandler methodsFor: 'testing'!
isInContent
	"True if parsing has reached the first element of the document."

	^ isInContent! !
!SAXHandler methodsFor: 'configuring'!
isValidating
	^ self configuration isValidating! !
!SAXHandler methodsFor: 'configuring'!
isValidating: aBoolean
	"If true and the document has a schema (like a DTD with ELEMENT and ATTLIST
	declarations) the document will be validated against it. Otherwise only
	entity references and xml:id attributes will be validated.
	
	(This is unlike the standard which requires validating parsers to reject
	all documents without DTDs or other schemas. To get that behavior,
	use requiresDocumentConstraints:)

	Enabling disables preservesUndeclaredEntityReferences.
	Disabling disables requiresDocumentConstraints."

	self configuration isValidating: aBoolean! !
!SAXHandler methodsFor: 'configuring'!
maxEntityReplacementDepth
	^ self configuration maxEntityReplacementDepth! !
!SAXHandler methodsFor: 'configuring'!
maxEntityReplacementDepth: anInteger
	"change the max replacement depth or nil to disable"

	self configuration maxEntityReplacementDepth: anInteger! !
!SAXHandler methodsFor: 'handling - declaration'!
notationDeclaration: aName publicID: aPublicID systemID: aSystemID
! !
!SAXHandler methodsFor: 'initialization'!
on: aStringOrStream
	input := aStringOrStream.

	"a single instance can parse multiple documents with #on:,
	so each variable must be reset"
	documentURI := nil.
	configuration
		ifNil: [self configuration: self configurationClass new]
		ifNotNil: [self configuration: configuration copy].
	hasParser := false.
	isInContent := false.
	isInCDataSection := false.! !
!SAXHandler methodsFor: 'configuring'!
optimizeForLargeDocuments
	"use this for faster parsing/less memory use with large documents"

	self
		isValidating: false;
		usesNamespaces: false;
		documentReadLimit: nil! !
!SAXHandler methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !
!SAXHandler methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName replacement: aReplacement! !
!SAXHandler methodsFor: 'parsing'!
parseDocument
	"Parse the entire input string or stream and return the result"

	self parser parseDocument.

	^ self parsingResult.! !
!SAXHandler methodsFor: 'parsing'!
parseDocumentUntil: aBlock
	"Parse the input string or stream only until aBlock evalautes as true
	and return the result"

	self parser parseDocumentUntil: aBlock.

	^ self parsingResult.! !
!SAXHandler methodsFor: 'parsing'!
parseDocumentWhile: aBlock
	"Parse the input string or stream only as long as aBlock evalautes as true
	and return the result"

	self parser parseDocumentWhile: aBlock.

	^ self parsingResult.! !
!SAXHandler methodsFor: 'parsing'!
parser
	"returns a new XMLParser object for this handler"

	| parser |

	hasParser
		ifTrue: [self errorInstancesCannotHaveMultipleParsers].
	hasParser := true.

	parser :=
		self parserClass
			driver: (self driverClass saxHandler: self)
			on: self input.
	self initializeParser: parser.

	^ parser.! !
!SAXHandler methodsFor: 'defaults'!
parserClass
	^ XMLParser! !
!SAXHandler methodsFor: 'parsing'!
parsingResult
	"value returned by parseDocument and other parsing methods"

	^ self! !
!SAXHandler methodsFor: 'configuring'!
preservesUndeclaredEntityReferences
	^ self configuration preservesUndeclaredEntityReferences! !
!SAXHandler methodsFor: 'configuring'!
preservesUndeclaredEntityReferences: aBoolean
	"If true, references to undeclared entities in content are
	preserved (not default).
	Disables validation.
	
	(See also replacesContentEntityReferences:, which is usually more appropriate.)"

	self configuration preservesUndeclaredEntityReferences: aBoolean! !
!SAXHandler methodsFor: 'handling - content'!
processingInstruction: aTargetString data: aDataString
	"Handles processing instructions like '<?name value?>', where 'name' is
	the target and 'value' is the data.
	
	XML declarations may look like PIs but are different and are handled
	with #xmlVersion:encoding:standalone: instead."! !
!SAXHandler methodsFor: 'configuring'!
removeLimits
	"remove all input security limits (unsafe)"

	self configuration removeLimits! !
!SAXHandler methodsFor: 'configuring'!
replacesContentEntityReferences
	^ self configuration replacesContentEntityReferences! !
!SAXHandler methodsFor: 'configuring'!
replacesContentEntityReferences: aBoolean
	"Replace general parsed entity and character references
	in content (default)"

	self configuration replacesContentEntityReferences: aBoolean! !
!SAXHandler methodsFor: 'deprecated'!
requiresDocumentConstraints
	"will be deprecated; use #requiresSchema instead"
	^ self requiresSchema! !
!SAXHandler methodsFor: 'deprecated'!
requiresDocumentConstraints: aBoolean
	"will be deprecated; use #requiresSchema: instead"
	self requiresSchema: aBoolean! !
!SAXHandler methodsFor: 'configuring'!
requiresSchema
	^ self configuration requiresSchema! !
!SAXHandler methodsFor: 'configuring'!
requiresSchema: aBoolean
	"If true, a schema containing constraints on elements and attributes
	(like a DTD with ELEMENT and ATTLIST declarations) will be required.
	Enables validation.

	(Not default)."

	self configuration requiresSchema: aBoolean! !
!SAXHandler methodsFor: 'configuring'!
resolvesExternalEntities
	^ self configuration resolvesExternalEntities! !
!SAXHandler methodsFor: 'configuring'!
resolvesExternalEntities: aBoolean
	"When true, external DTDs and parsed entities will be
	fetched (not default)."

	self configuration resolvesExternalEntities: aBoolean! !
!SAXHandler methodsFor: 'private'!
schema
	^ nil! !
!SAXHandler methodsFor: 'handling - content'!
skippedEntity: anEntityName
	"Sent when a general parsed entity reference like '&name;' is
	unreplaced in content. Only sent when validation is turned off
	or entity replacement is disabled."! !
!SAXHandler methodsFor: 'handling - lexical'!
startCData
	"Sent before the character data of a '<!![CDATA[...]]>' section."! !
!SAXHandler methodsFor: 'private'!
startContent
	isInContent := true! !
!SAXHandler methodsFor: 'handling - lexical'!
startDTD: aRootElementName publicID: aPublicID systemID: aSystemID
	"Handles the start of a '<!!DOCTYPE ...>' declaration. Any events
	after this and until #endDTD is sent are part of the internal subset
	of the DTD.
	
	aRootElementName - the expected name of the document's root element
	aPublicID - the public ID of the external DTD subset or an empty string
	aSystemID - the URI where the external subset can be found or an empty string"! !
!SAXHandler methodsFor: 'handling - content'!
startDocument
	"Handles the start of an XML document, the first handler invoked."! !
!SAXHandler methodsFor: 'handling - content'!
startElement: aQualifiedName attributes: anAttributeDictionary
	"Handles the start of an element if a subclass doesn't implement
	#startElement:prefix:uri:localName:attributes: or
	#startElement:prefix:uri:attributes:.

	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !
!SAXHandler methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary
	"Handles the start of an element if a subclass doesn't implement
	#startElement:prefix:uri:localName:attributes:. By default it forwards
	to a simpler handler, #startElement:attributes:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	anAttributeDictionary - an XMLAttributeDictionary of attributes"

	self
		startElement: aQualifiedName
		attributes: anAttributeDictionary! !
!SAXHandler methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary
	"Handles the start of an element, either a start tag like '<start>' or a
	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,
	#startElement:prefix:uri:attributes:.
	
	aQualifiedName - the full name, including any prefix, such as 'prefix:name'
	aPrefix - the prefix of the qualified name or an empty string
	aURI - the namespace URI of the element or an empty string
	aLocalName - the local part of the qualified name
	anAttributeDictionary - an XMLAttributeDictionary of attributes"

	self
		startElement: aQualifiedName
		prefix: aPrefix
		uri: aURI
		attributes: anAttributeDictionary! !
!SAXHandler methodsFor: 'handling - lexical'!
startEntity: anEntityName
	"Handles the start of some general entity's replacement in content.
	Not sent if the entity is undeclared or if content entity replacement
	is disabled."! !
!SAXHandler methodsFor: 'handling - content'!
startPrefixMapping: aPrefix uri: aURI
	"Handles the start of a namespace prefix/URI mapping when namespaces are
	enabled. The 'xml' prefix is predefined and never remapped.

	aPrefix - the prefix of the namespace (empty for the default namesapce)
	aURI - the namespace URI"! !
!SAXHandler methodsFor: 'private'!
startScope: aNamespaceScope! !
!SAXHandler methodsFor: 'configuring'!
usesNamespaces
	^ self configuration usesNamespaces! !
!SAXHandler methodsFor: 'configuring'!
usesNamespaces: aBoolean
	"Namespace checking when true (default)"

	self configuration usesNamespaces: aBoolean! !
!SAXHandler methodsFor: 'handling - lexical'!
xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean
	"Handles the '<?xml ...?>' declaration of a document.
	
	aVersionFloat - the version of XML the document uses, usually 1.0
	anEncoding - the name of the encoding or an empty string
	aBoolean - true if standalone='yes'"! !
!XMLDOMParser methodsFor: 'handling - declaration'!
attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	self topNodeAdd:
		(self nodeFactory attributeDeclarationClass
			element: anElementName
			attribute: anAttributeName
			type: aType
			defaultPragma: aDefaultPragma
			defaultValue: aDefaultValue)! !
!XMLDOMParser methodsFor: 'handling - content'!
characters: aString
	(self isInCDataSection
		and: [self preservesCDataNodes])
		ifTrue: [self topNodeAdd: (self nodeFactory newCData: aString)]
		ifFalse: [self topNodeAddString: aString]! !
!XMLDOMParser methodsFor: 'handling - lexical'!
comment: aString
	self preservesCommentNodes
		ifTrue: [self topNodeAdd: (self nodeFactory newComment: aString)]! !
!XMLDOMParser methodsFor: 'defaults'!
configurationClass
	^ XMLDOMConfiguration! !
!XMLDOMParser methodsFor: 'private'!
doctypeDefinition: aDoctypeDefinition
	self document doctypeDefinition: aDoctypeDefinition! !
!XMLDOMParser methodsFor: 'accessing'!
document
	^ document! !
!XMLDOMParser methodsFor: 'accessing'!
document: aDocument
	document := aDocument! !
!XMLDOMParser methodsFor: 'handling - declaration'!
elementDeclaration: anElementName contentModel: aContentModel
	self topNodeAdd:
		(self nodeFactory elementDeclarationClass
			element: anElementName
			contentModel: aContentModel)! !
!XMLDOMParser methodsFor: 'handling - lexical'!
endDTD
	self popNode! !
!XMLDOMParser methodsFor: 'handling - content'!
endDocument
	"nodeStack is not popped here for efficiency because #document keeps
	a reference to the root too, and there may not be a root to pop
	anyway if it's an inner XML parser"! !
!XMLDOMParser methodsFor: 'handling - content'!
endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName
	self popNode! !
!XMLDOMParser methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName
	self topNodeAdd:
		(self nodeFactory generalEntityDeclarationClass
			name: aName
			publicID: aPublicID
			systemID: aSystemID
			ndata: aNotationName)! !
!XMLDOMParser methodsFor: 'handling - declaration'!
generalEntityDeclaration: aName replacement: aReplacement
	self topNodeAdd:
		(self nodeFactory generalEntityDeclarationClass
			name: aName
			replacement: aReplacement)! !
!XMLDOMParser methodsFor: 'handling - content'!
ignorableWhitespace: aString
	self preservesIgnorableWhitespace
		ifTrue: [self characters: aString]! !
!XMLDOMParser methodsFor: 'initialization'!
initializeInnerXMLParser: aParser
	self document
		ifNotNil: [
			aParser driver isStandalone: self document isStandalone.
			self document hasDoctypeDefinition
				ifTrue: [
					aParser driver doctypeDefinition addGeneralEntitiesFrom:
						self document doctypeDefinition]].

	self nodeStack do: [:each |
		each isElement
			ifTrue: [
				self
					startInnerXMLElement: each
					forParser: aParser]].

	aParser state: self topNode newInnerXMLState.
	aParser state isContentState
		ifTrue: [self startContent].! !
!XMLDOMParser methodsFor: 'initialization'!
initializeParser: aParser
	super initializeParser: aParser.

	self nodeStack size > 0
		ifTrue: [self initializeInnerXMLParser: aParser].! !
!XMLDOMParser methodsFor: 'private'!
innerXMLRootNode: aRootNode
	self
		configuration: aRootNode configuration;
		document: aRootNode document;
		pushNode: aRootNode! !
!XMLDOMParser methodsFor: 'configuring'!
nodeFactory
	^ self configuration nodeFactory! !
!XMLDOMParser methodsFor: 'configuring'!
nodeFactory: aNodeFactory
	self configuration nodeFactory: aNodeFactory! !
!XMLDOMParser methodsFor: 'deprecated'!
nodeListClass
	"will be deprecated"
	^ self configuration nodeListClass! !
!XMLDOMParser methodsFor: 'deprecated'!
nodeListClass: aClass
	"will be deprecated"
	self configuration nodeListClass: aClass! !
!XMLDOMParser methodsFor: 'private'!
nodeStack
	^ nodeStack! !
!XMLDOMParser methodsFor: 'handling - declaration'!
notationDeclaration: aName publicID: aPublicID systemID: aSystemID
	self topNodeAdd:
		(self nodeFactory notationDeclarationClass
			name: aName
			publicID: aPublicID
			systemID: aSystemID)! !
!XMLDOMParser methodsFor: 'initialization'!
on: aStringOrStream
	super on: aStringOrStream.

	document := nil.
	nodeStack := OrderedCollection new: 10.
	currentScope := nil.! !
!XMLDOMParser methodsFor: 'configuring'!
optimizeForLargeDocuments
	super optimizeForLargeDocuments.

	"use the non-caching attribute list class to save memory"
	self configuration attributeListClass: XMLAttributeList.! !
!XMLDOMParser methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID
	self topNodeAdd:
		(self nodeFactory parameterEntityDeclarationClass
			name: aName
			publicID: aPublicID
			systemID: aSystemID)! !
!XMLDOMParser methodsFor: 'handling - declaration'!
parameterEntityDeclaration: aName replacement: aReplacement
	self topNodeAdd:
		(self nodeFactory parameterEntityDeclarationClass
			name: aName
			replacement: aReplacement)! !
!XMLDOMParser methodsFor: 'parsing'!
parsingResult
	^ self document! !
!XMLDOMParser methodsFor: 'private'!
popNode
	^ self nodeStack removeLast! !
!XMLDOMParser methodsFor: 'configuring'!
preservesCDataNodes
	^ self configuration preservesCDataNodes! !
!XMLDOMParser methodsFor: 'configuring'!
preservesCDataNodes: aBoolean
	"if enabled, <!![CDATA[...]]> sections will be preserved as CDATA nodes
	and not ordinary string nodes and won't be merged with adjacent string
	nodes (not default)"
	self configuration preservesCDataNodes: aBoolean! !
!XMLDOMParser methodsFor: 'configuring'!
preservesCommentNodes
	^ self configuration preservesCommentNodes! !
!XMLDOMParser methodsFor: 'configuring'!
preservesCommentNodes: aBoolean
	"if enabled, comments will be preserved as comment nodes (not default)"
	self configuration preservesCommentNodes: aBoolean! !
!XMLDOMParser methodsFor: 'configuring'!
preservesIgnorableWhitespace
	^ self configuration preservesIgnorableWhitespace! !
!XMLDOMParser methodsFor: 'configuring'!
preservesIgnorableWhitespace: aBoolean
	"If enabled, ignorable whitespace (identified by DTD element declarations
	with element content) will be preserved as string nodes. Enables validation.
	(Not default)"

	self configuration preservesIgnorableWhitespace: aBoolean! !
!XMLDOMParser methodsFor: 'handling - content'!
processingInstruction: aTargetString data: aDataString
	self topNodeAdd:
		(self nodeFactory newPI
			target: aTargetString;
			data: aDataString)! !
!XMLDOMParser methodsFor: 'private'!
pushElement: anElement
	self topNodeAdd: anElement.
	^ self pushNode: anElement.! !
!XMLDOMParser methodsFor: 'private'!
pushNode: aNode
	^ self nodeStack addLast: aNode
! !
!XMLDOMParser methodsFor: 'handling - lexical'!
startDTD: aRootElementName publicID: aPublicID systemID: aSystemID
	| doctypeDeclaration |

	doctypeDeclaration := 
		self nodeFactory doctypeDeclarationClass
			root: aRootElementName
			publicID: aPublicID
			systemID: aSystemID.
	self pushNode: doctypeDeclaration.
	self document doctypeDeclaration: doctypeDeclaration.! !
!XMLDOMParser methodsFor: 'handling - content'!
startDocument
	"inner XML parsers should ignore this event"
	self nodeStack size > 0
		ifFalse: [
			self
				document: self nodeFactory newDocument;
				pushNode: self document.

			self document configuration: self configuration]! !
!XMLDOMParser methodsFor: 'handling - content'!
startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary
	self pushElement:
		((self nodeFactory
			classForElement: aQualifiedName
			namespaceURI: aURI
			localName: aLocalName
			attributes: anAttributeDictionary) new
				setConfiguration: self configuration
				name: aQualifiedName
				localName: aLocalName
				attributes: anAttributeDictionary
				namespaceScope: currentScope)! !
!XMLDOMParser methodsFor: 'private'!
startInnerXMLElement: anElement forParser: aParser
	aParser driver currentElement: anElement name.
	anElement hasNamespaces
		ifTrue: [aParser driver currentScope: anElement namespaceScope].! !
!XMLDOMParser methodsFor: 'private'!
startScope: aNamespaceScope
	currentScope := aNamespaceScope! !
!XMLDOMParser methodsFor: 'accessing'!
topNode
	^ self nodeStack xmlLastOrNil! !
!XMLDOMParser methodsFor: 'private'!
topNodeAdd: aNode
	^ self nodeStack last addNode: aNode! !
!XMLDOMParser methodsFor: 'private'!
topNodeAddString: aString
	^ self nodeStack last addString: aString! !
!XMLDOMParser methodsFor: 'handling - lexical'!
xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean
	self document ifNotNil: [
		self document
			version: aVersionFloat;
			encoding: anEncoding;
			isStandalone: aBoolean]! !
!XMLAbstractFactory class methodsFor: 'testing'!
canBeImplemented
	^ false! !
!XMLAbstractFactory class methodsFor: 'clearing'!
clearAllImplementations
	"self clearAllImplementations"

	self
		implementation: nil;
		allSubclassesDo: [:each | each implementation: nil]! !
!XMLAbstractFactory class methodsFor: 'finding'!
findSupportedImplementation
	self canBeImplemented
		ifTrue: [
			self isSupportedImplementation
				ifTrue: [^ self].

			(self preferredImplementation notNil
				and: [self preferredImplementation isSupportedImplementation])
				ifTrue: [^ self preferredImplementation].
			self allSubclassesDo: [:each |
				each isSupportedImplementation
					ifTrue: [^ each]]].

	^ nil.! !
!XMLAbstractFactory class methodsFor: 'testing'!
hasSupportedImplementation
	^ self findSupportedImplementation notNil! !
!XMLAbstractFactory class methodsFor: 'accessing'!
implementation
	^ implementation
		ifNil: [
			"avoid assigning to the class inst var unless an implementation
			was found to minimize write conflicts on GS"
			self findSupportedImplementation
				ifNil: [self noSupportedImplementationFound]
				ifNotNil: [:supportedImplementation |
					implementation := supportedImplementation].
			implementation]! !
!XMLAbstractFactory class methodsFor: 'accessing'!
implementation: aClassOrNil
	implementation := aClassOrNil! !
!XMLAbstractFactory class methodsFor: 'instance creation'!
implementationNew
	^ self implementation basicNew initialize! !
!XMLAbstractFactory class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self clearAllImplementations! !
!XMLAbstractFactory class methodsFor: 'testing'!
isSupportedImplementation
	^ false! !
!XMLAbstractFactory class methodsFor: 'instance creation'!
new
	^ self implementationNew! !
!XMLAbstractFactory class methodsFor: 'finding'!
noSupportedImplementationFound
	Error signal: 'No implementation available'! !
!XMLAbstractFactory class methodsFor: 'defaults'!
preferredImplementation
	^ nil! !
!XMLFileDirectoryFileHandle class methodsFor: 'basic'!
basicCurrentWorkingDirectory
	^ (XMLClassFinder classNamed: #FileDirectory) default pathName! !
!XMLFileDirectoryFileHandle class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #FileDirectory! !
!XMLFileDirectoryFileHandle methodsFor: 'basic'!
basicDelete
	"FileDirectory's deleteFileNamed: is used because DirectoryEntry
	doesn't understand #delete on GS"
	self fileDirectory deleteFileNamed: self path! !
!XMLFileDirectoryFileHandle methodsFor: 'basic'!
basicFileSize
	^ self directoryEntry fileSize! !
!XMLFileDirectoryFileHandle methodsFor: 'accessing'!
directoryEntry
	"a bug on Squeak (but not GS) with the handling of dot relative paths
	like './file.xml' requires fully qualifying the path before creating
	the DirectoryEntry"
	^ self fileDirectory directoryEntryFor:
		(self fileDirectory fullPathFor: self path)! !
!XMLFileDirectoryFileHandle methodsFor: 'testing'!
exists
	^ self directoryEntry notNil! !
!XMLFileDirectoryFileHandle methodsFor: 'accessing'!
fileDirectory
	^ fileDirectory
		ifNil: [fileDirectory := (XMLClassFinder classNamed: #FileDirectory) default]! !
!XMLFileDirectoryFileHandle methodsFor: 'testing'!
isFile
	^ self exists
		and: [self directoryEntry isDirectory not]! !
!XMLFileHandle class methodsFor: 'basic'!
basicCurrentWorkingDirectory
	self subclassResponsibility! !
!XMLFileHandle class methodsFor: 'testing'!
canBeImplemented
	^ true! !
!XMLFileHandle class methodsFor: 'accessing'!
currentWorkingDirectory
	"returns a path string for the current working directory"

	^ self implementation basicCurrentWorkingDirectory! !
!XMLFileHandle class methodsFor: 'finding'!
noSupportedImplementationFound
	XMLFileException signal: 'File IO unsupported'! !
!XMLFileHandle class methodsFor: 'instance creation'!
path: aPathString
	^ self new setPath: aPathString! !
!XMLFileHandle class methodsFor: 'defaults'!
preferredImplementation
	^ XMLFileSystemFileHandle! !
!XMLFileHandle class methodsFor: 'accessing'!
xmlDocumentFileExtensions
	"a class variable so it's shared by all subclasses, but lazy initialized
	so it isn't initialized unless needed"
	^ XMLDocumentFileExtensions
		ifNil: [
			XMLDocumentFileExtensions :=
				#('atom' "Atom Syndication Format"
					'dbk' "DocBook XML"
					'docm' "Office Open XML Document"
					'docx' "Office Open XML Document"
					'pptm' "Office Open XML Presentation"
					'pptx' "Office Open XML Presentation"
					'rdf' "Resource Description Framework"
					'rss' "Rich Site Summary"
					'svg' "Scalable Vector Graphics"
					'xbel' "XML Bookmark Exchange Language"
					'xfd' "Extensible Forms Description Language"
					'xfdl' "Extensible Forms Description Language"
					'xhtml'
					'xlsm' "Office Open XML Workbook"
					'xlsx' "Office Open XML Workbook"
					'xml'
					'xsd' "XML Schema Definition"
					'xspf' "XML Shareable Playlist Format"
					'xul' "XML User Interface Language"
				) asSet]! !
!XMLFileHandle class methodsFor: 'accessing'!
xmlDocumentFileExtensions: aCollectionOrNil
	XMLDocumentFileExtensions :=
		aCollectionOrNil
			ifNotNil: [aCollectionOrNil asSet]! !
!XMLFileHandle methodsFor: 'converting'!
asXMLFileHandle
	^ self! !
!XMLFileHandle methodsFor: 'basic'!
basicDelete
	self subclassResponsibility! !
!XMLFileHandle methodsFor: 'basic'!
basicFileSize
	"This is named #basicFileSize instead of #basicSize to avoid conflicting
	with the Object>>#basicSize primitive"

	self subclassResponsibility! !
!XMLFileHandle methodsFor: 'accessing'!
contents
	^ self readStreamDo: [:readStream | readStream upToEnd]! !
!XMLFileHandle methodsFor: 'deleting'!
delete
	self exists
		ifFalse: [self errorFileDoesNotExist].

	[self basicDelete]
		on: Error
		do: [:error | XMLFileException signalMessageFrom: error].! !
!XMLFileHandle methodsFor: 'private'!
errorFileDoesNotExist
	XMLFileException
		formatSignal: 'File does does not exist: {1}'
		with: self path! !
!XMLFileHandle methodsFor: 'private'!
errorFileExceedsMaxSize: aMaxSize
	XMLLimitException
		formatSignal: 'File exceeds max size of {1} bytes: {2}'
		with: aMaxSize
		with: self path! !
!XMLFileHandle methodsFor: 'private'!
errorNotAFile
	XMLFileException
		formatSignal: 'Not a file: {1}'
		with: self path! !
!XMLFileHandle methodsFor: 'testing'!
exists
	"returns true if the file exists"

	self subclassResponsibility! !
!XMLFileHandle methodsFor: 'accessing'!
extension
	"Returns the file extension, everything after the first '.' of the
	last path segment:
		'one.two/three.txt' asXMLFileHandle extension = 'txt'.
		'one.two/three.tar.gz' asXMLFileHandle extension = 'tar.gz'.
		'one.two/three.four/' asXMLFileHandle extension = ''.
	"
	| i |

	^ ((i := self path lastIndexOf: $/) > 0
		ifTrue: [self path copyFrom: i + 1 to: self path size]
		ifFalse: [self path]) copyAfter: $.! !
!XMLFileHandle methodsFor: 'resolving'!
get
	^ self
		getUpToLimit: nil
		decoding: true! !
!XMLFileHandle methodsFor: 'resolving'!
getUpToLimit: aMaxSize decoding: aBoolean
	| stream contents |

	"can be safely implemented using streamGetUpToLimit:decoding: rather
	than the other way around like XMLHTTPRequest requires, because files
	are local and can be safely read incrementally, unlike an HTTP response
	which must be read immediately and stored entirely in memory"
	stream :=
		self
			streamGetUpToLimit: aMaxSize
			decoding: aBoolean.
	contents := stream upToEnd.
	stream close.

	^ contents.! !
!XMLFileHandle methodsFor: 'testing'!
isFile
	"returns true if the file exists and is a file (not a directory)"

	self subclassResponsibility! !
!XMLFileHandle methodsFor: 'testing'!
isXMLDocumentFile
	"Returns true if the file has a known extension of an XML document format
	such as .xml, .xhtml, .xul, but not .dtd, .ent, or other XML-related
	formats that aren't proper XML documents."

	^ self class xmlDocumentFileExtensions includes: self extension asLowercase! !
!XMLFileHandle methodsFor: 'instance creation'!
newFileReadStreamOnPath
	^ XMLFileReadStreamFactory onPath: self path! !
!XMLFileHandle methodsFor: 'instance creation'!
newFileWriteStreamOnPath
	^ XMLFileWriteStreamFactory onPath: self path! !
!XMLFileHandle methodsFor: 'accessing'!
path
	^ path ifNil: [path := '']! !
!XMLFileHandle methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		nextPutAll: self path;
		nextPut: $).! !
!XMLFileHandle methodsFor: 'reading'!
rawReadStream
	"returns a raw file read stream with no decoding"

	self exists
		ifFalse: [self errorFileDoesNotExist].
	self isFile
		ifFalse: [self errorNotAFile].
	
	^ [self newFileReadStreamOnPath]
		on: Error
		do: [:error | XMLFileException signalMessageFrom: error].! !
!XMLFileHandle methodsFor: 'writing'!
rawWriteStream
	"returns a raw file write stream with no encoding; truncates existing files"

	^ [self newFileWriteStreamOnPath]
		on: Error
		do: [:error | XMLFileException signalMessageFrom: error]! !
!XMLFileHandle methodsFor: 'reading'!
readStream
	"returns a file read stream with decoding"

	^ (XMLDecodingReadStreamAdapter nonDecodingOn: self rawReadStream)
		detectEncoding! !
!XMLFileHandle methodsFor: 'reading'!
readStreamDo: aBlock
	"evaluates aBlock with a file read stream with decoding and automatically
	closes it after"

	| readStream |

	readStream := self readStream.
	^ [aBlock value: readStream]
		ensure: [readStream close].! !
!XMLFileHandle methodsFor: 'initialization'!
setPath: aPathString
	path := aPathString! !
!XMLFileHandle methodsFor: 'accessing'!
size
	self exists
		ifFalse: [self errorFileDoesNotExist].

	^ self basicFileSize.! !
!XMLFileHandle methodsFor: 'resolving'!
streamGet
	^ self
		streamGetUpToLimit: nil
		decoding: true! !
!XMLFileHandle methodsFor: 'resolving'!
streamGetUpToLimit: aMaxSize decoding: aBoolean
	(aMaxSize notNil
		and: [self size > aMaxSize])
		ifTrue: [self errorFileExceedsMaxSize: aMaxSize].

	^ aBoolean
		ifTrue: [self readStream]
		ifFalse: [self rawReadStream].! !
!XMLFileHandle methodsFor: 'writing'!
writeStream
	"returns a file write stream with encoding; truncates existing files"

	^ XMLEncodingWriteStreamAdapter on: self rawWriteStream! !
!XMLFileHandle methodsFor: 'writing'!
writeStreamDo: aBlock
	"evaluates aBlock with a file write stream with encoding and
	automatically closes it after; truncates existing files"

	| writeStream |

	writeStream := self writeStream.
	^ [aBlock value: writeStream]
		ensure: [writeStream close].! !
!XMLFileSystemFileHandle class methodsFor: 'basic'!
basicCurrentWorkingDirectory
	"avoid the class #workingDirectory message for Pharo1x compatibility"
	^ (XMLClassFinder classNamed: #FileSystem) disk workingDirectory pathString! !
!XMLFileSystemFileHandle class methodsFor: 'instance creation'!
fileReference: aFileReference
	^ self new setFileReference: aFileReference! !
!XMLFileSystemFileHandle class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #FileSystem! !
!XMLFileSystemFileHandle methodsFor: 'basic'!
basicDelete
	self fileReference delete! !
!XMLFileSystemFileHandle methodsFor: 'basic'!
basicFileSize
	^ self fileReference size! !
!XMLFileSystemFileHandle methodsFor: 'testing'!
exists
	^ self fileReference exists! !
!XMLFileSystemFileHandle methodsFor: 'accessing'!
fileReference
	^ fileReference ifNil: [fileReference := self path asFileReference]! !
!XMLFileSystemFileHandle methodsFor: 'testing'!
isFile
	^ self fileReference isFile! !
!XMLFileSystemFileHandle methodsFor: 'instance creation'!
newFileReadStreamOnPath
	"memory file references need special handling"
	self usesMemoryStore
		ifTrue: [^ self fileReference readStream].
	^ super newFileReadStreamOnPath.! !
!XMLFileSystemFileHandle methodsFor: 'instance creation'!
newFileWriteStreamOnPath
	"memory file references need special handling"
	self usesMemoryStore
		ifTrue: [^ self fileReference writeStream].
	^ super newFileWriteStreamOnPath.! !
!XMLFileSystemFileHandle methodsFor: 'initialization'!
setFileReference: aFileReference
	fileReference := aFileReference.
	self setPath: aFileReference fullName.! !
!XMLFileSystemFileHandle methodsFor: 'testing'!
usesMemoryStore
	"Pharo 3.0 has memory stores but lacks #isMemoryFileSystem, so
	this test is used instead for backwards compatibility"
	^ self fileReference fileSystem store class ==
		(XMLClassFinder classNamed: #MemoryStore)! !
!XMLFileReadStreamFactory class methodsFor: 'basic'!
basicOnPath: aPathString
	self subclassResponsibility! !
!XMLFileReadStreamFactory class methodsFor: 'testing'!
canBeImplemented
	^ true! !
!XMLFileReadStreamFactory class methodsFor: 'finding'!
noSupportedImplementationFound
	XMLFileException signal: 'File reading unsupported'! !
!XMLFileReadStreamFactory class methodsFor: 'instance creation'!
onPath: aPathString
	^ self implementation basicOnPath: aPathString! !
!XMLFileReadStreamFactory class methodsFor: 'defaults'!
preferredImplementation
	^ XMLStandardFileStreamReadStreamFactory! !
!XMLStandardFileStreamReadStreamFactory class methodsFor: 'basic'!
basicOnPath: aPathString
	^ ((XMLClassFinder classNamed: #StandardFileStream)
		readOnlyFileNamed: aPathString)
			binary;
			yourself! !
!XMLStandardFileStreamReadStreamFactory class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #StandardFileStream! !
!XMLFileWriteStreamFactory class methodsFor: 'basic'!
basicOnPath: aPathString
	self subclassResponsibility! !
!XMLFileWriteStreamFactory class methodsFor: 'testing'!
canBeImplemented
	^ true! !
!XMLFileWriteStreamFactory class methodsFor: 'finding'!
noSupportedImplementationFound
	XMLFileException signal: 'File writing unsupported'! !
!XMLFileWriteStreamFactory class methodsFor: 'instance creation'!
onPath: aPathString
	^ self implementation basicOnPath: aPathString! !
!XMLFileWriteStreamFactory class methodsFor: 'defaults'!
preferredImplementation
	^ XMLStandardFileStreamWriteStreamFactory! !
!XMLStandardFileStreamWriteStreamFactory class methodsFor: 'basic'!
basicOnPath: aPathString
	"use forceNewFileNamed: to ensure truncation of existing files before writing"
	^ ((XMLClassFinder classNamed: #StandardFileStream)
		forceNewFileNamed: aPathString)
			binary;
			yourself! !
!XMLStandardFileStreamWriteStreamFactory class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #StandardFileStream! !
!XMLHTTPMessage methodsFor: 'adding'!
addHeader: anAssociation
	self
		headerValuesAt: anAssociation key
		add: anAssociation value.
	^ anAssociation.! !
!XMLHTTPMessage methodsFor: 'accessing'!
content
	"Returns the response content as a String or ByteArray"

	"Requests with content aren't supported yet"
	^ content ifNil: [content := '']! !
!XMLHTTPMessage methodsFor: 'accessing'!
content: aStringOrByteArray
	content := aStringOrByteArray! !
!XMLHTTPMessage methodsFor: 'accessing'!
contentCharset
	| contentType charset |

	^ ((contentType := self contentType) isNil
		or: [(charset := contentType charset) isEmpty])
		ifTrue: [self defaultContentCharset]
		ifFalse: [charset]! !
!XMLHTTPMessage methodsFor: 'accessing'!
contentEncoding
	"Returns the non-identity content encoding compression schemes
	in the order they were applied"

	^ self encodingNamesFromHeaderValuesAt: 'Content-Encoding'! !
!XMLHTTPMessage methodsFor: 'accessing'!
contentEncoding: aStringOrCollection
	self
		encodingNamesFromHeaderValuesAt: 'Content-Encoding'
		put: aStringOrCollection! !
!XMLHTTPMessage methodsFor: 'accessing'!
contentLength
	^ XMLIntegerReader
		readFrom:
			(self
				headerAt: 'Content-Length'
				ifAbsent: [^ nil]) readStream
		withBase: 10! !
!XMLHTTPMessage methodsFor: 'accessing'!
contentLength: anInteger
	anInteger
		ifNil: [
			self
				removeHeaderAt: 'Content-Length'
				ifAbsent: []]
		ifNotNil: [
			self
				headerAt: 'Content-Length'
				put: anInteger asString]! !
!XMLHTTPMessage methodsFor: 'accessing'!
contentType
	"Returns an XMLMIMEType object for the Content-Type header value"

	^ XMLHTTPMIMEType fromString:
		(self
			headerAt: 'Content-Type'
			ifAbsent: [^ nil])! !
!XMLHTTPMessage methodsFor: 'accessing'!
contentType: aMIMETypeOrString
	aMIMETypeOrString
		ifNil: [
			self
				removeHeaderAt: 'Content-Type'
				ifAbsent: []]
		ifNotNil: [
			self
				headerAt: 'Content-Type'
				put: aMIMETypeOrString asString]! !
!XMLHTTPMessage methodsFor: 'defaults'!
defaultContentCharset
	^ XMLHTTPMIMEType defaultCharset! !
!XMLHTTPMessage methodsFor: 'private'!
encodingNamesFromHeaderValuesAt: aKey
	"Returns the non-identity encoding compression schemes
	in the order they were applied from the value(s) of the
	specified header"

	| encodingNames |

	encodingNames := OrderedCollection new.
	self
		headerValuesAt: aKey
		do: [:headerValue |
			$,
				xmlSplit: headerValue
				do: [:headerValueField | | encodingName |
					encodingName :=
						headerValueField xmlCopyWithoutWhitespace asLowercase.
					(encodingName isEmpty
						or: [encodingName = 'identity'])
						ifFalse: [encodingNames addLast: encodingName]]].
	^ encodingNames.! !
!XMLHTTPMessage methodsFor: 'private'!
encodingNamesFromHeaderValuesAt: aKey put: aStringOrCollection
	aStringOrCollection isEmpty
		ifTrue: [
			self
				removeHeaderAt: aKey
				ifAbsent: []]
		ifFalse: [
			self
				headerAt: aKey
				put:
					(aStringOrCollection isString
						ifTrue: [aStringOrCollection]
						ifFalse: [
							String streamContents: [:stream |
								aStringOrCollection
									do: [:each | stream nextPutAll: each]
									separatedBy: [stream nextPutAll: ', ']]])]! !
!XMLHTTPMessage methodsFor: 'private'!
errorRemovingAbsentHeader: aKey
	XMLHTTPException
		formatSignal: 'Cannot remove absent HTTP header "{1}" from message'
		with: aKey! !
!XMLHTTPMessage methodsFor: 'testing'!
hasContent
	^ self content notEmpty! !
!XMLHTTPMessage methodsFor: 'testing'!
hasHeaders
	self headerKeysDo: [:key | ^ true].
	^ false.! !
!XMLHTTPMessage methodsFor: 'accessing'!
headerAt: aKey
	^ self
		headerAt: aKey
		ifAbsent: ['']! !
!XMLHTTPMessage methodsFor: 'accessing'!
headerAt: aKey ifAbsent: aBlock
	self subclassResponsibility! !
!XMLHTTPMessage methodsFor: 'accessing'!
headerAt: aKey ifAbsentPut: aBlock
	^ self
		headerAt: aKey
		ifAbsent: [
			self
				headerAt: aKey
				put: aBlock value]! !
!XMLHTTPMessage methodsFor: 'accessing'!
headerAt: aKey put: aValue
	self subclassResponsibility! !
!XMLHTTPMessage methodsFor: 'accessing'!
headerKeys
	| keys |

	keys := OrderedCollection new.
	self headerKeysDo: [:key |
		keys addLast: key].
	^ keys.! !
!XMLHTTPMessage methodsFor: 'enumerating'!
headerKeysAndValuesDo: aTwoArgumentBlock
	self subclassResponsibility! !
!XMLHTTPMessage methodsFor: 'enumerating'!
headerKeysDo: aBlock
	self headerKeysAndValuesDo: [:key :value |
		aBlock value: key]! !
!XMLHTTPMessage methodsFor: 'accessing'!
headerValuesAt: aKey
	| values |

	values := OrderedCollection new.
	self
		headerValuesAt: aKey
		do: [:each | values addLast: each].
	^ values.! !
!XMLHTTPMessage methodsFor: 'adding'!
headerValuesAt: aKey add: aValue
	self subclassResponsibility! !
!XMLHTTPMessage methodsFor: 'enumerating'!
headerValuesAt: aKey do: aBlock
	self subclassResponsibility! !
!XMLHTTPMessage methodsFor: 'accessing'!
headers
	| headers |

	headers := OrderedCollection new.
	self headerKeysAndValuesDo: [:key :value |
		headers addLast: key -> value].
	^ headers.! !
!XMLHTTPMessage methodsFor: 'testing'!
includesHeaderAt: aKey
	self
		headerAt: aKey
		ifAbsent: [^ false].
	^ true.! !
!XMLHTTPMessage methodsFor: 'removing'!
removeHeaderAt: aKey
	^ self
		removeHeaderAt: aKey
		ifAbsent: [self errorRemovingAbsentHeader: aKey]! !
!XMLHTTPMessage methodsFor: 'removing'!
removeHeaderAt: aKey ifAbsent: aBlock
	self subclassResponsibility! !
!XMLHTTPMessage methodsFor: 'removing'!
removeHeaders
	self headerKeys do: [:each |
		self
			removeHeaderAt: each
			ifAbsent: []]! !
!XMLHTTPRequest class methodsFor: 'testing'!
canBeImplemented
	^ true! !
!XMLHTTPRequest class methodsFor: 'instance creation'!
new
	^ self url: ''! !
!XMLHTTPRequest class methodsFor: 'finding'!
noSupportedImplementationFound
	XMLHTTPException signal: 'HTTP unsupported; install Zinc or WebClient'! !
!XMLHTTPRequest class methodsFor: 'defaults'!
preferredImplementation
	^ XMLHTTPZincRequest! !
!XMLHTTPRequest class methodsFor: 'instance creation'!
url: aURLString
	^ self implementationNew setURL: aURLString! !
!XMLHTTPRequest methodsFor: 'accessing'!
acceptEncoding
	^ self encodingNamesFromHeaderValuesAt: 'Accept-Encoding'! !
!XMLHTTPRequest methodsFor: 'accessing'!
acceptEncoding: aStringOrCollection
	"NOTE: only gzip is currently supported"
	self
		encodingNamesFromHeaderValuesAt: 'Accept-Encoding'
		put: aStringOrCollection! !
!XMLHTTPRequest methodsFor: 'converting'!
asXMLHTTPRequest
	^ self! !
!XMLHTTPRequest methodsFor: 'basic'!
basicCleanup
	"can be overridden to handle cleanup after sending the
	request and reading the response"! !
!XMLHTTPRequest methodsFor: 'basic'!
basicSend
	self subclassResponsibility! !
!XMLHTTPRequest methodsFor: 'defaults'!
defaultAcceptEncoding
	^ #()! !
!XMLHTTPRequest methodsFor: 'defaults'!
defaultMethod
	^ 'GET'! !
!XMLHTTPRequest methodsFor: 'defaults'!
defaultTimeout
	^ 30! !
!XMLHTTPRequest methodsFor: 'accessing'!
enableCompression
	"NOTE: only gzip is currently supported"
	self acceptEncoding: 'gzip'! !
!XMLHTTPRequest methodsFor: 'private'!
errorBadResponse: aResponse
	XMLHTTPException
		formatSignal: '{1} ({2})'
		with: aResponse statusDescription
		with: aResponse statusCode! !
!XMLHTTPRequest methodsFor: 'resolving'!
get
	^ self
		getUpToLimit: nil
		decoding: true! !
!XMLHTTPRequest methodsFor: 'resolving'!
getUpToLimit: aMaxSize decoding: aBoolean
	self method: 'GET'.
	^ (self
		resolveUpToLimit: aMaxSize
		decoding: aBoolean) content! !
!XMLHTTPRequest methodsFor: 'accessing'!
method
	self subclassResponsibility! !
!XMLHTTPRequest methodsFor: 'accessing'!
method: aString
	self subclassResponsibility! !
!XMLHTTPRequest methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		nextPutAll: self method;
		space;
		nextPutAll: self url;
		nextPut: $).! !
!XMLHTTPRequest methodsFor: 'resolving - response'!
resolve
	"Sends and retrieves the response as an XMLHTTPResponse object."

	^ self
		resolveUpToLimit: nil
		decoding: true! !
!XMLHTTPRequest methodsFor: 'resolving - response'!
resolveUpToLimit: aMaxSize decoding: aBoolean
	| response |

	[
		[
			(response := self basicSend) isSuccess
				ifFalse: [self errorBadResponse: response].
			response
				readContentUpToLimit: aMaxSize
				decoding: aBoolean]
			on: Error
			do: [:error |
				error isXMLParserException
					ifTrue: [error pass]
					ifFalse: [XMLHTTPException signalMessageFrom: error]]
		] ensure: [self basicCleanup].

	^ response.! !
!XMLHTTPRequest methodsFor: 'defaults'!
responseClass
	self subclassResponsibility! !
!XMLHTTPRequest methodsFor: 'initialization'!
setURL: aURLString
	url := aURLString.
	self
		timeout: self defaultTimeout;
		method: self defaultMethod;
		"even if #defaultAcceptEncoding returns an empty collection,
		#acceptEncoding: must still be sent here to override any default
		setting of the underlying HTTP library that we don't support"
		acceptEncoding: self defaultAcceptEncoding.! !
!XMLHTTPRequest methodsFor: 'resolving'!
streamGet
	^ self
		streamGetUpToLimit: nil
		decoding: true! !
!XMLHTTPRequest methodsFor: 'resolving'!
streamGetUpToLimit: aMaxSize decoding: aBoolean
	"must be implemented using getUpToLimit:decoding: rather than the other
	way around like XMLFileHandle does, because HTTP responses must be read
	immediately and stored entirely in memory, unlike a file stream which
	can safely be left open and read from incrementally"
	^ (self
		getUpToLimit: aMaxSize
		decoding: aBoolean) readStream! !
!XMLHTTPRequest methodsFor: 'accessing'!
timeout
	self subclassResponsibility! !
!XMLHTTPRequest methodsFor: 'accessing'!
timeout: anInteger
	self subclassResponsibility! !
!XMLHTTPRequest methodsFor: 'accessing'!
url
	^ url ifNil: [url := '']! !
!XMLHTTPWebClientRequest class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #WebClient! !
!XMLHTTPWebClientRequest methodsFor: 'basic'!
basicCleanup
	self webClientClient close! !
!XMLHTTPWebClientRequest methodsFor: 'basic'!
basicSend
	^ self responseClass
		request: self
		webClientResponse:
			(self webClientClient
				"#sendRequest: unfortunately requires #initializeFromUrl:
				to be sent first"
				initializeFromUrl: self url;
				sendRequest: self webClientRequest)! !
!XMLHTTPWebClientRequest methodsFor: 'accessing'!
headerAt: aKey ifAbsent: aBlock
	^ self webClientRequest
		headerAt: aKey
		ifAbsent: aBlock! !
!XMLHTTPWebClientRequest methodsFor: 'accessing'!
headerAt: aKey put: aValue
	self webClientRequest
		removeHeader: aKey;
		addHeader: aKey value: aValue.
	^ aValue.! !
!XMLHTTPWebClientRequest methodsFor: 'enumerating'!
headerKeysAndValuesDo: aTwoArgumentBlock
	self webClientRequest headersDo: aTwoArgumentBlock! !
!XMLHTTPWebClientRequest methodsFor: 'adding'!
headerValuesAt: aKey add: aValue
	self webClientRequest
		addHeader: aKey
		value: aValue.
	^ aValue.! !
!XMLHTTPWebClientRequest methodsFor: 'enumerating'!
headerValuesAt: aKey do: aBlock
	self webClientRequest
		headersAt: aKey
		do: aBlock! !
!XMLHTTPWebClientRequest methodsFor: 'accessing'!
method
	^ self webClientRequest method! !
!XMLHTTPWebClientRequest methodsFor: 'accessing'!
method: aString
	self webClientRequest method: aString! !
!XMLHTTPWebClientRequest methodsFor: 'removing'!
removeHeaderAt: aKey ifAbsent: aBlock
	| removedValues |

	removedValues :=
		self webClientRequest
			headersAt: aKey
			ifAbsent: [^ aBlock value].
	self webClientRequest removeHeader: aKey.
	^ removedValues asOrderedCollection.! !
!XMLHTTPWebClientRequest methodsFor: 'defaults'!
responseClass
	^ XMLHTTPWebClientResponse! !
!XMLHTTPWebClientRequest methodsFor: 'accessing'!
timeout
	^ self webClientClient timeout! !
!XMLHTTPWebClientRequest methodsFor: 'accessing'!
timeout: anInteger
	self webClientClient timeout: anInteger! !
!XMLHTTPWebClientRequest methodsFor: 'private'!
webClientClient
	^ webClientClient
		ifNil: [
			webClientClient := (XMLClassFinder classNamed: #WebClient) new]! !
!XMLHTTPWebClientRequest methodsFor: 'private'!
webClientRequest
	^ webClientRequest
		ifNil: [
			webClientRequest :=
				(XMLClassFinder classNamed: #WebRequest) new
					initializeFromUrl: self url;
					yourself]! !
!XMLHTTPZincRequest class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #ZnClient! !
!XMLHTTPZincRequest methodsFor: 'basic'!
basicCleanup
	self zincClient close! !
!XMLHTTPZincRequest methodsFor: 'basic'!
basicSend
	^ self responseClass
		request: self
		zincResponse:
			(self zincClient
				request: self zincRequest;
				execute;
				response)! !
!XMLHTTPZincRequest methodsFor: 'accessing'!
headerAt: aKey ifAbsent: aBlock
	self zincRequest headers
		at: aKey
		ifPresent: [:value |
			^ value isArray
				ifTrue: [value first]
				ifFalse: [value]].
	^ aBlock value.! !
!XMLHTTPZincRequest methodsFor: 'accessing'!
headerAt: aKey put: aValue
	self zincRequest headers
		at: aKey
		put: aValue.
	^ aValue.! !
!XMLHTTPZincRequest methodsFor: 'enumerating'!
headerKeysAndValuesDo: aTwoArgumentBlock
	self zincRequest headersDo: aTwoArgumentBlock! !
!XMLHTTPZincRequest methodsFor: 'adding'!
headerValuesAt: aKey add: aValue
	self zincRequest headers
		at: aKey
		add: aValue.
	^ aValue.! !
!XMLHTTPZincRequest methodsFor: 'enumerating'!
headerValuesAt: aKey do: aBlock
	self zincRequest headers
		at: aKey
		ifPresent: [:value |
			value isArray
				ifTrue: [value do: aBlock]
				ifFalse: [aBlock value: value]]! !
!XMLHTTPZincRequest methodsFor: 'accessing'!
method
	^ self zincRequest method asString! !
!XMLHTTPZincRequest methodsFor: 'accessing'!
method: aString
	self zincRequest method: aString asSymbol! !
!XMLHTTPZincRequest methodsFor: 'removing'!
removeHeaderAt: aKey ifAbsent: aBlock
	| removedValues |

	removedValues :=
		self zincRequest headers
			removeKey: aKey
			ifAbsent: [^ aBlock value].
	^ removedValues isString
		ifTrue: [OrderedCollection with: removedValues]
		ifFalse: [removedValues asOrderedCollection].! !
!XMLHTTPZincRequest methodsFor: 'defaults'!
responseClass
	^ XMLHTTPZincResponse! !
!XMLHTTPZincRequest methodsFor: 'accessing'!
timeout
	^ self zincClient timeout! !
!XMLHTTPZincRequest methodsFor: 'accessing'!
timeout: anInteger
	self zincClient timeout: anInteger! !
!XMLHTTPZincRequest methodsFor: 'private '!
zincClient
	^ zincClient
		ifNil: [
			zincClient :=
				(XMLClassFinder classNamed: #ZnClient) new
					streaming: true;
					yourself]! !
!XMLHTTPZincRequest methodsFor: 'private '!
zincRequest
	^ zincRequest
		ifNil: [
			zincRequest :=
				(XMLClassFinder classNamed: #ZnRequest)
					get: self url]! !
!XMLHTTPResponse class methodsFor: 'testing'!
canBeImplemented
	^ true! !
!XMLHTTPResponse class methodsFor: 'finding'!
noSupportedImplementationFound
	XMLHTTPRequest noSupportedImplementationFound! !
!XMLHTTPResponse class methodsFor: 'defaults'!
preferredImplementation
	^ XMLHTTPZincResponse! !
!XMLHTTPResponse class methodsFor: 'instance creation'!
request: aRequest
	^ self new setRequest: aRequest! !
!XMLHTTPResponse methodsFor: 'defaults'!
contentReaderClass
	self subclassResponsibility! !
!XMLHTTPResponse methodsFor: 'defaults'!
defaultProtocol
	^ 'HTTP/1.1'! !
!XMLHTTPResponse methodsFor: 'defaults'!
defaultStatusCode
	^ 200! !
!XMLHTTPResponse methodsFor: 'testing'!
isChunked
	^ (self
		headerAt: 'Transfer-Encoding'
		ifAbsent: [^ false]) beginsWith: 'chunked'! !
!XMLHTTPResponse methodsFor: 'testing'!
isSuccess
	self subclassResponsibility! !
!XMLHTTPResponse methodsFor: 'instance creation'!
newContentReader
	^ self contentReaderClass response: self! !
!XMLHTTPResponse methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		nextPutAll: self statusLine;
		nextPut: $).! !
!XMLHTTPResponse methodsFor: 'accessing'!
protocol
	self subclassResponsibility! !
!XMLHTTPResponse methodsFor: 'accessing'!
protocol: aString
	self
		setProtocol: aString
		statusCode: self statusCode! !
!XMLHTTPResponse methodsFor: 'reading'!
readContentUpToLimit: aMaxSize decoding: aBoolean
	self content:
		(self newContentReader
			readUpToLimit: aMaxSize
			decoding: aBoolean)! !
!XMLHTTPResponse methodsFor: 'converting'!
readStream
	^ self content readStream! !
!XMLHTTPResponse methodsFor: 'accessing'!
request
	"Returns the XMLHTTPRequest object that created this response"

	^ request! !
!XMLHTTPResponse methodsFor: 'initialization'!
setProtocol: aString statusCode: anInteger
	self subclassResponsibility! !
!XMLHTTPResponse methodsFor: 'initialization'!
setRequest: aRequest
	request := aRequest! !
!XMLHTTPResponse methodsFor: 'accessing'!
statusCode
	"Returns the status code as an integer"

	self subclassResponsibility! !
!XMLHTTPResponse methodsFor: 'accessing'!
statusCode: anInteger
	self
		setProtocol: self protocol
		statusCode: anInteger! !
!XMLHTTPResponse methodsFor: 'accessing'!
statusDescription
	| delimiter |

	delimiter := Character space.
	^ (self statusLine copyAfter: delimiter)
		copyAfter: delimiter! !
!XMLHTTPResponse methodsFor: 'accessing'!
statusLine
	"Returns the status line as a string"

	self subclassResponsibility! !
!XMLHTTPWebClientResponse class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #WebResponse! !
!XMLHTTPWebClientResponse class methodsFor: 'instance creation'!
request: aRequest webClientResponse: aWebClientResponse
	^ (self request: aRequest)
		setWebClientResponse: aWebClientResponse! !
!XMLHTTPWebClientResponse methodsFor: 'defaults'!
contentReaderClass
	^ XMLHTTPWebClientResponseContentReader! !
!XMLHTTPWebClientResponse methodsFor: 'accessing'!
headerAt: aKey ifAbsent: aBlock
	^ self webClientResponse
		headerAt: aKey
		ifAbsent: aBlock! !
!XMLHTTPWebClientResponse methodsFor: 'accessing'!
headerAt: aKey put: aValue
	self webClientResponse
		removeHeader: aKey;
		addHeader: aKey value: aValue.
	^ aValue.! !
!XMLHTTPWebClientResponse methodsFor: 'enumerating'!
headerKeysAndValuesDo: aTwoArgumentBlock
	self webClientResponse headersDo: aTwoArgumentBlock! !
!XMLHTTPWebClientResponse methodsFor: 'adding'!
headerValuesAt: aKey add: aValue
	self webClientResponse
		addHeader: aKey
		value: aValue.
	^ aValue.! !
!XMLHTTPWebClientResponse methodsFor: 'enumerating'!
headerValuesAt: aKey do: aBlock
	self webClientResponse
		headersAt: aKey
		do: aBlock! !
!XMLHTTPWebClientResponse methodsFor: 'testing'!
isSuccess
	^ self webClientResponse isSuccess! !
!XMLHTTPWebClientResponse methodsFor: 'accessing'!
protocol
	^ self webClientResponse protocol! !
!XMLHTTPWebClientResponse methodsFor: 'removing'!
removeHeaderAt: aKey ifAbsent: aBlock
	| removedValues |

	removedValues :=
		self webClientResponse
			headersAt: aKey
			ifAbsent: [^ aBlock value].
	self webClientResponse removeHeader: aKey.
	^ removedValues asOrderedCollection.! !
!XMLHTTPWebClientResponse methodsFor: 'initialization'!
setProtocol: aString statusCode: anInteger
	self webClientResponse
		protocol: aString
		code: anInteger! !
!XMLHTTPWebClientResponse methodsFor: 'initialization'!
setWebClientResponse: aWebClientResponse
	webClientResponse := aWebClientResponse! !
!XMLHTTPWebClientResponse methodsFor: 'accessing'!
statusCode
	^ self webClientResponse code! !
!XMLHTTPWebClientResponse methodsFor: 'accessing'!
statusLine
	^ self webClientResponse status! !
!XMLHTTPWebClientResponse methodsFor: 'private'!
webClientResponse
	^ webClientResponse
		ifNil: [
			webClientResponse :=
				(XMLClassFinder classNamed: #WebResponse)
					protocol: self defaultProtocol
					code: self defaultStatusCode]! !
!XMLHTTPZincResponse class methodsFor: 'testing'!
isSupportedImplementation
	^ XMLClassFinder hasClassNamed: #ZnResponse! !
!XMLHTTPZincResponse class methodsFor: 'instance creation'!
request: aRequest zincResponse: aZincResponse
	^ (self request: aRequest)
		setZincResponse: aZincResponse! !
!XMLHTTPZincResponse methodsFor: 'defaults'!
contentReaderClass
	^ XMLHTTPZincResponseContentReader! !
!XMLHTTPZincResponse methodsFor: 'accessing'!
headerAt: aKey ifAbsent: aBlock
	self zincResponse headers
		at: aKey
		ifPresent: [:value |
			^ value isArray
				ifTrue: [value first]
				ifFalse: [value]].
	^ aBlock value.! !
!XMLHTTPZincResponse methodsFor: 'accessing'!
headerAt: aKey put: aValue
	self zincResponse headers
		at: aKey
		put: aValue.
	^ aValue.! !
!XMLHTTPZincResponse methodsFor: 'enumerating'!
headerKeysAndValuesDo: aTwoArgumentBlock
	self zincResponse headersDo: aTwoArgumentBlock! !
!XMLHTTPZincResponse methodsFor: 'adding'!
headerValuesAt: aKey add: aValue
	self zincResponse headers
		at: aKey
		add: aValue.
	^ aValue.! !
!XMLHTTPZincResponse methodsFor: 'enumerating'!
headerValuesAt: aKey do: aBlock
	self zincResponse headers
		at: aKey
		ifPresent: [:value |
			value isArray
				ifTrue: [value do: aBlock]
				ifFalse: [aBlock value: value]]! !
!XMLHTTPZincResponse methodsFor: 'testing'!
isSuccess
	^ self zincResponse isSuccess! !
!XMLHTTPZincResponse methodsFor: 'accessing'!
protocol
	^ self zincResponse statusLine version! !
!XMLHTTPZincResponse methodsFor: 'removing'!
removeHeaderAt: aKey ifAbsent: aBlock
	| removedValues |

	removedValues :=
		self zincResponse headers
			removeKey: aKey
			ifAbsent: [^ aBlock value].
	^ removedValues isString
		ifTrue: [OrderedCollection with: removedValues]
		ifFalse: [removedValues asOrderedCollection].! !
!XMLHTTPZincResponse methodsFor: 'initialization'!
setProtocol: aString statusCode: anInteger
	self zincResponse statusLine:
		((ZnStatusLine code: anInteger)
			version: aString;
			yourself)! !
!XMLHTTPZincResponse methodsFor: 'initialization'!
setZincResponse: aZincResponse
	zincResponse := aZincResponse! !
!XMLHTTPZincResponse methodsFor: 'accessing'!
statusCode
	^ self zincResponse status! !
!XMLHTTPZincResponse methodsFor: 'accessing'!
statusLine
	| statusLine |
	
	statusLine := self zincResponse statusLine.
	^ String streamContents: [:stream |
		stream
			nextPutAll: statusLine version;
			space.
		statusLine printCodeAndReasonOn: stream].! !
!XMLHTTPZincResponse methodsFor: 'private'!
zincResponse
	^ zincResponse
		ifNil: [
			zincResponse :=
				(XMLClassFinder classNamed: #ZnResponse) new
					statusLine:
						((ZnStatusLine code: self defaultStatusCode)
							version: self defaultProtocol;
							yourself);
					yourself]! !
!XMLKeyValueCache class methodsFor: 'testing'!
canBeImplemented
	^ true! !
!XMLKeyValueCache class methodsFor: 'defaults'!
defaultMaxSize
	^ 32! !
!XMLKeyValueCache class methodsFor: 'instance creation'!
maxSize: anInteger
	^ self implementationNew setMaxSize: anInteger! !
!XMLKeyValueCache class methodsFor: 'instance creation'!
new
	^ self maxSize: self defaultMaxSize! !
!XMLKeyValueCache class methodsFor: 'finding'!
noSupportedImplementationFound
	Error signal: 'No supported key-value cache class available'! !
!XMLKeyValueCache class methodsFor: 'defaults'!
preferredImplementation
	^ XMLStandardKeyValueCache! !
!XMLKeyValueCache methodsFor: 'accessing'!
at: aKey
	^ self
		at: aKey
		ifAbsent: [nil]! !
!XMLKeyValueCache methodsFor: 'accessing'!
at: aKey ifAbsent: aBlock
	^ self critical: [
		self collection
			at: aKey
			ifAbsent: aBlock]! !
!XMLKeyValueCache methodsFor: 'accessing'!
at: aKey ifAbsentPut: aBlock
	^ self
		at: aKey
		ifAbsent: [
			self
				at: aKey
				put: aBlock value]! !
!XMLKeyValueCache methodsFor: 'accessing'!
at: aKey ifPresent: aBlock
	^ self critical: [
		"Gemstone's at:ifAbsentPut: does not use cull:"
		aBlock cull:
			(self collection
				at: aKey
				ifAbsent: [^ nil])]! !
!XMLKeyValueCache methodsFor: 'accessing'!
at: aKey ifPresent: aPresentBlock put: aValueBlock
	"Looks up the value of aKey and if present, evaluates aPresentBlock
	optionally with it, and if aPresentBlock returns true, replaces the old
	value with the result of evaluating aValueBlock."

	^ self
		at: aKey
		ifPresent: [:value |
			(aPresentBlock cull: value)
				ifTrue: [	
					self
						at: aKey
						put: aValueBlock value]
				ifFalse: [value]]! !
!XMLKeyValueCache methodsFor: 'accessing'!
at: aKey put: aValue
	^ self critical: [
		(self collection includesKey: aKey)
			ifFalse: [
				self collection size >= self maxSize
					ifTrue: [self collection removeAll]].
		self collection
			at: aKey
			put: aValue]! !
!XMLKeyValueCache methodsFor: 'accessing'!
capacity
	^ self maxSize! !
!XMLKeyValueCache methodsFor: 'clearing'!
clear
	self removeAll! !
!XMLKeyValueCache methodsFor: 'accessing'!
collection
	self subclassResponsibility! !
!XMLKeyValueCache methodsFor: 'defaults'!
collectionClass
	^ Dictionary! !
!XMLKeyValueCache methodsFor: 'copying'!
copy
	^ self critical: [self shallowCopy postCopy]! !
!XMLKeyValueCache methodsFor: 'mutual exclusion'!
critical: aBlock
	"Can be used to lock the cache during one or more operations in aBlock"

	^ self mutex critical: aBlock! !
!XMLKeyValueCache methodsFor: 'testing'!
includesKey: aKey
	^ self critical: [self collection includesKey: aKey]! !
!XMLKeyValueCache methodsFor: 'testing'!
isEmpty
	^ self size = 0! !
!XMLKeyValueCache methodsFor: 'accessing'!
keys
	^ self critical: [self collection keys]! !
!XMLKeyValueCache methodsFor: 'enumerating'!
keysAndValuesDo: aTwoArgumentBlock
	self critical: [self collection keysAndValuesDo: aTwoArgumentBlock]! !
!XMLKeyValueCache methodsFor: 'enumerating'!
keysDo: aBlock
	self critical: [self collection keysDo: aBlock]! !
!XMLKeyValueCache methodsFor: 'accessing'!
loadFactor
	^ (self size / self maxSize) asFraction! !
!XMLKeyValueCache methodsFor: 'accessing'!
maxSize
	^ maxSize! !
!XMLKeyValueCache methodsFor: 'accessing'!
maxSize: anInteger
	self critical: [| oldMaxSize |
		oldMaxSize := maxSize.
		(maxSize := anInteger) < oldMaxSize
			ifTrue: [self collection removeAll]]! !
!XMLKeyValueCache methodsFor: 'private'!
mutex
	^ mutex! !
!XMLKeyValueCache methodsFor: 'testing'!
notEmpty
	^ self size > 0! !
!XMLKeyValueCache methodsFor: 'copying'!
postCopy
	super postCopy.

	mutex := XMLReentrantMutex new.
	self setCollection: self collection copy.! !
!XMLKeyValueCache methodsFor: 'printing'!
printOn: aStream
	| loadFactor |

	super printOn: aStream.

	loadFactor := self loadFactor.
	aStream
		nextPut: $(;
		print: loadFactor numerator;
		nextPut: $/;
		print: loadFactor denominator;
		nextPut: $).! !
!XMLKeyValueCache methodsFor: 'removing'!
removeAll
	self critical: [self collection removeAll]! !
!XMLKeyValueCache methodsFor: 'removing'!
removeKey: aKey
	"this attempts to remove a key, but to support concurrent removal, it
	does not raise errors if it was already removed"
	^ self critical: [
		self collection
			removeKey: aKey
			ifAbsent: [nil]]! !
!XMLKeyValueCache methodsFor: 'removing'!
removeKey: aKey ifAbsent: aBlock
	^ self critical: [
		self collection
			removeKey: aKey
			ifAbsent: aBlock]! !
!XMLKeyValueCache methodsFor: 'removing'!
removeKey: aKey ifPresent: aBlock
	"Looks up the value of aKey and if present, evaluates aPresentBlock
	optionally with it, and if aPresentBlock returns true, removes the
	key from the cache and returns its old value."
	^ self
		at: aKey
		ifPresent: [:value |
			(aBlock cull: value)
				ifTrue: [self removeKey: aKey]
				ifFalse: [value]]! !
!XMLKeyValueCache methodsFor: 'initialization'!
setCollection: aKeyValueCollection
	self subclassResponsibility! !
!XMLKeyValueCache methodsFor: 'initialization'!
setMaxSize: anInteger
	maxSize := anInteger.
	mutex := XMLReentrantMutex new.
	self setCollection: self collectionClass new.! !
!XMLKeyValueCache methodsFor: 'accessing'!
size
	^ self collection size! !
!XMLKeyValueCache methodsFor: 'accessing'!
values
	^ self critical: [self collection values]! !
!XMLKeyValueCache methodsFor: 'enumerating'!
valuesDo: aBlock
	self critical: [self collection valuesDo: aBlock]! !
!XMLStandardKeyValueCache class methodsFor: 'testing'!
isSupportedImplementation
	"need some type of reentrant mutex"
	XMLReentrantMutex hasSupportedImplementation
		ifFalse: [^ false].

	"MUST use the transient class on GS to avoid persisting and causing
	write conflicts"
	XMLClassFinder
		classNamed: #XMLTransientKeyValueCache
		ifPresent: [:transientKeyValueCacheClass |
			transientKeyValueCacheClass isSupportedImplementation
				ifTrue: [^ false]].

	^ true.! !
!XMLStandardKeyValueCache methodsFor: 'accessing'!
collection
	^ collection! !
!XMLStandardKeyValueCache methodsFor: 'initialization'!
setCollection: aKeyValueCollection
	collection := aKeyValueCollection! !
!XMLReentrantMutex class methodsFor: 'testing'!
canBeImplemented
	^ true! !
!XMLReentrantMutex class methodsFor: 'finding'!
noSupportedImplementationFound
	Error signal: 'No supported reentrant mutex class available'! !
!XMLReentrantMutex class methodsFor: 'defaults'!
preferredImplementation
	"Prefer the Pharo/Squeak Mutex-based implementation"
	^ XMLStandardReentrantMutex! !
!XMLReentrantMutex methodsFor: 'mutual exclusion'!
critical: aBlock
	self subclassResponsibility! !
!XMLStandardReentrantMutex class methodsFor: 'testing'!
isSupportedImplementation
	(XMLClassFinder hasClassNamed: #Mutex)
		ifFalse: [^ false].

	"MUST use the transient class on GS to avoid persisting and causing
	write conflicts"
	XMLClassFinder
		classNamed: #XMLTransientReentrantMutex
		ifPresent: [:transientReentrantMutexClass |
			transientReentrantMutexClass isSupportedImplementation
				ifTrue: [^ false]].

	^ true.! !
!XMLStandardReentrantMutex methodsFor: 'mutual exclusion'!
critical: aBlock
	^ mutex critical: aBlock! !
!XMLStandardReentrantMutex methodsFor: 'initialization'!
initialize
	super initialize.

	mutex := (XMLClassFinder classNamed: #Mutex) new.! !
!XMLAbstractReadStream class methodsFor: 'basic'!
basicOn: anObject
	^ self basicNew initialize on: anObject! !
!XMLAbstractReadStream class methodsFor: 'instance creation'!
new
	self shouldNotImplement! !
!XMLAbstractReadStream class methodsFor: 'instance creation'!
on: anObject
	^ self basicOn: anObject! !
!XMLAbstractReadStream methodsFor: 'testing'!
atEnd
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'closing'!
close! !
!XMLAbstractReadStream methodsFor: 'accessing'!
contents
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'testing'!
isBinary
	^ false! !
!XMLAbstractReadStream methodsFor: 'testing'!
isStream
	^ true! !
!XMLAbstractReadStream methodsFor: 'testing'!
isXMLBinaryOrExternalStream
	^ self isBinary! !
!XMLAbstractReadStream methodsFor: 'instance creation'!
newWriteStream
	^ (self writeStreamCollectionClass new: 128) writeStream! !
!XMLAbstractReadStream methodsFor: 'accessing'!
next
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'accessing'!
next: anInteger
	| writeStream i |

	writeStream := self newWriteStream.
	i := 0.
	[self atEnd
		or: [i >= anInteger]]
		whileFalse: [
			writeStream nextPut: self next.
			i := i + 1].
	^ writeStream contents.! !
!XMLAbstractReadStream methodsFor: 'initialization'!
on: anObject
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'accessing'!
peek
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'accessing'!
peekFor: anObject
	(self atEnd not
		and: [self peek = anObject])
		ifTrue: [
			self next.
			^ true]
		ifFalse: [^ false]! !
!XMLAbstractReadStream methodsFor: 'positioning'!
position
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'positioning'!
position: anInteger
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'positioning'!
reset
	self subclassResponsibility! !
!XMLAbstractReadStream methodsFor: 'positioning'!
skip: anInteger
	"only supports skipping forwards"
	1 to: anInteger do: [:i |
		self atEnd
			ifTrue: [^ self].
		self next]! !
!XMLAbstractReadStream methodsFor: 'positioning'!
skipSeparators
	"we use #isXMLWhitespace instead of the narrower, XML-specific
	#isXMLSeparator, because this class can be used for non-XML
	streams too"
	[self atEnd not
		and: [self peek isXMLWhitespace]]
		whileTrue: [self next]! !
!XMLAbstractReadStream methodsFor: 'positioning'!
skipTo: anObject
	[self atEnd]
		whileFalse: [
			self next = anObject
				ifTrue: [^ true]].
	^ false.! !
!XMLAbstractReadStream methodsFor: 'accessing'!
upTo: anObject
	| writeStream next |

	writeStream := self newWriteStream.
	[self atEnd
		or: [(next := self next) = anObject]]
		whileFalse: [writeStream nextPut: next].
	^ writeStream contents.! !
!XMLAbstractReadStream methodsFor: 'accessing'!
upToEnd
	| writeStream |

	writeStream := self newWriteStream.
	[self atEnd]
		whileFalse: [writeStream nextPut: self next].
	^ writeStream contents.! !
!XMLAbstractReadStream methodsFor: 'writing'!
writeStreamCollectionClass
	self isBinary
		ifTrue: [^ ByteArray]
		ifFalse: [^ String]! !
!XMLNullReadStream class methodsFor: 'class initialization'!
initialize
	"self initialize"

	instance := self basicOn: nil! !
!XMLNullReadStream class methodsFor: 'instance creation'!
new
	^ instance! !
!XMLNullReadStream class methodsFor: 'instance creation'!
on: anObject
	^ instance! !
!XMLNullReadStream methodsFor: 'testing'!
atEnd
	^ true! !
!XMLNullReadStream methodsFor: 'accessing'!
contents
	^ String new! !
!XMLNullReadStream methodsFor: 'accessing'!
next
	^ nil! !
!XMLNullReadStream methodsFor: 'initialization'!
on: anObject! !
!XMLNullReadStream methodsFor: 'accessing'!
peek
	^ nil! !
!XMLNullReadStream methodsFor: 'positioning'!
position
	^ 0! !
!XMLNullReadStream methodsFor: 'positioning'!
position: anInteger! !
!XMLNullReadStream methodsFor: 'positioning'!
reset! !
!XMLSingleCharacterReadStream methodsFor: 'testing'!
atEnd
	^ atEnd! !
!XMLSingleCharacterReadStream methodsFor: 'closing'!
close
	atEnd := true! !
!XMLSingleCharacterReadStream methodsFor: 'accessing'!
contents
	^ String with: character! !
!XMLSingleCharacterReadStream methodsFor: 'accessing'!
next
	atEnd
		ifTrue: [^ nil]
		ifFalse: [
			atEnd := true.
			^ character]! !
!XMLSingleCharacterReadStream methodsFor: 'initialization'!
on: aCharacter
	character := aCharacter.
	atEnd := false.! !
!XMLSingleCharacterReadStream methodsFor: 'accessing'!
peek
	atEnd
		ifTrue: [^ nil]
		ifFalse: [^ character]! !
!XMLSingleCharacterReadStream methodsFor: 'positioning'!
position
	^ atEnd
		ifTrue: [1]
		ifFalse: [0]! !
!XMLSingleCharacterReadStream methodsFor: 'positioning'!
position: anInteger
	atEnd := anInteger > 0! !
!XMLSingleCharacterReadStream methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		print: character;
		nextPut: $).! !
!XMLSingleCharacterReadStream methodsFor: 'positioning'!
reset
	atEnd := false! !
!XMLAbstractReadStreamParser class methodsFor: 'instance creation'!
new
	self shouldNotImplement! !
!XMLAbstractReadStreamParser class methodsFor: 'instance creation'!
on: aStringOrStream
	^ self basicNew initialize on: aStringOrStream! !
!XMLAbstractReadStreamParser methodsFor: 'tokenizing'!
nextDelimitedBy: aCharacter
	writeStream reset.
	[readStream atEnd
		or: [readStream peek = aCharacter]]
		whileFalse: [writeStream nextPut: readStream next].
	^ writeStream contents.! !
!XMLAbstractReadStreamParser methodsFor: 'tokenizing'!
nextDelimitedByAny: aCharacterCollection
	writeStream reset.
	[readStream atEnd
		or: [aCharacterCollection includes: readStream peek]]
		whileFalse: [writeStream nextPut: readStream next].
	^ writeStream contents.! !
!XMLAbstractReadStreamParser methodsFor: 'initialization'!
on: aStringOrStream
	readStream :=
		XMLReadStreamAdapter on:
			(aStringOrStream isStream
				ifTrue: [aStringOrStream]
				ifFalse: [aStringOrStream readStream]).
	writeStream := (String new: 64) writeStream.! !
!XMLHTTPMIMETypeParser class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self initializeTokenDelimiters! !
!XMLHTTPMIMETypeParser class methodsFor: 'class initialization'!
initializeTokenDelimiters
	"String streamContents: [:writeStream | | readStream current previous |
		readStream := self tspecialsTemplate readStream.
		[readStream atEnd]
			whileFalse: [
				previous := current.
				current := readStream next.
				(#('""' '<>') anySatisfy: [:each |
					previous = each first
						and: [readStream peek = each last]])
					ifTrue: [writeStream nextPut: current]]]"

	TokenDelimiters :=
		BitmapCharacterSet newFrom: '()<>@,;:\"/[]?.=', Character xmlWhitespace! !
!XMLHTTPMIMETypeParser class methodsFor: 'private'!
tspecialsTemplate
	^ '	tspecials :=  "(" / ")" / "<" / ">" / "@"  ; Must be in
                       /  "," / ";" / ":" / "\" / <">  ; quoted-string,
                       /  "/" / "[" / "]" / "?" / "."  ; to use within
                       /  "="                        ; parameter values'! !
!XMLHTTPMIMETypeParser methodsFor: 'private'!
nextOptionalQuotedString
	| isEscaping nextChar |

	(readStream
		skipSeparators;
		peekFor: $")
		ifFalse: [^ nil].

	writeStream
		reset;
		nextPut: $".
	isEscaping := false.
	[(nextChar := readStream next) isNil
		or: [isEscaping not
			and: [nextChar == $"]]]
		whileFalse: [
			isEscaping :=
				isEscaping not
					and: [nextChar == $\].
			writeStream nextPut: nextChar].
	^ writeStream
		nextPut: $";
		contents.! !
!XMLHTTPMIMETypeParser methodsFor: 'private'!
nextToken
	readStream skipSeparators.
	^ self nextDelimitedByAny: TokenDelimiters.
! !
!XMLHTTPMIMETypeParser methodsFor: 'private'!
nextTokenOrQuotedString
	^ self nextOptionalQuotedString
		ifNil: [self nextToken]! !
!XMLHTTPMIMETypeParser methodsFor: 'parsing'!
parseMainType
	"main types are case insensitive and are converted to
	lowercase for consistentcy"
	^ self nextToken asLowercase! !
!XMLHTTPMIMETypeParser methodsFor: 'parsing'!
parseParameters
	| parameters attributes totalAttributes |

	parameters := OrderedCollection new.
	totalAttributes := 0.
	[(readStream
		skipSeparators;
		peekFor: $;)
			and: [
				(readStream
					skipSeparators;
					atEnd) not]]
		whileTrue: [| attribute value hasValue |
			"attributes are case insensitive and are converted
			to lowercase for convenience"
			attribute := self nextToken asLowercase.
			(hasValue :=
				readStream
					skipSeparators;
					peekFor: $=)
				ifTrue: [value := self nextTokenOrQuotedString]
				ifFalse: [value := ''].
			(attribute notEmpty
				or: [hasValue])
				ifTrue: [
					"only initialize if needed"
					((attributes ifNil: [attributes := Set new])
						add: attribute;
						size) > totalAttributes
						ifTrue: [
							parameters addLast: attribute -> value.
							totalAttributes := totalAttributes + 1]]].
	^ parameters.! !
!XMLHTTPMIMETypeParser methodsFor: 'parsing'!
parseSubType
	"sub types are case insensitive and are converted to
	lowercase for consistentcy"
	readStream
		skipSeparators;
		peekFor: $/.
	^ self nextToken asLowercase.! !
!XMLURIParser class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self
		initializeSchemeDelimiters;
		initializeUserInfoDelimiters;
		initializeHostDelimiters;
		initializePathDelimiters;
		initializeQueryKeyDelimiters;
		initializeQueryValueDelimiters! !
!XMLURIParser class methodsFor: 'class initialization'!
initializeHostDelimiters
	HostDelimiters := BitmapCharacterSet newFrom: ':/?#'! !
!XMLURIParser class methodsFor: 'class initialization'!
initializePathDelimiters
	PathDelimiters := BitmapCharacterSet newFrom: '/?#'! !
!XMLURIParser class methodsFor: 'class initialization'!
initializeQueryKeyDelimiters
	QueryKeyDelimiters := BitmapCharacterSet newFrom: '=&#'! !
!XMLURIParser class methodsFor: 'class initialization'!
initializeQueryValueDelimiters
	QueryValueDelimiters := BitmapCharacterSet newFrom: '&#'! !
!XMLURIParser class methodsFor: 'class initialization'!
initializeSchemeDelimiters
	"including % disallows percent encoding in schemes"
	SchemeDelimiters := BitmapCharacterSet newFrom: ':@/?#%'! !
!XMLURIParser class methodsFor: 'class initialization'!
initializeUserInfoDelimiters
	UserInfoDelimiters := BitmapCharacterSet newFrom: '@/?#'! !
!XMLURIParser methodsFor: 'parsing'!
parseAuthorityPrefix
	| oldPosition |

	oldPosition := readStream position.
	((readStream peekFor: $/)
		and: [readStream peekFor: $/])
		ifTrue: [^ true]
		ifFalse: [
			readStream position: oldPosition.
			^ false].! !
!XMLURIParser methodsFor: 'parsing'!
parseFragment
	(readStream peekFor: $#)
		ifTrue: [^ readStream upToEnd]
		ifFalse: [^ '']! !
!XMLURIParser methodsFor: 'parsing'!
parseHost
	| host |

	readStream peek == $[
		ifTrue: [
			host := (self nextDelimitedBy: $]) copyWith: $].
			readStream peekFor: $]]
		ifFalse: [host := self nextDelimitedByAny: HostDelimiters].
	^ host.! !
!XMLURIParser methodsFor: 'parsing'!
parsePathSegments
	| pathSegments segment |

	pathSegments := OrderedCollection new.

	segment := self nextDelimitedByAny: PathDelimiters.
	[readStream peekFor: $/]
		whileTrue: [
			pathSegments addLast: segment.
			segment := self nextDelimitedByAny: PathDelimiters].
	(pathSegments isEmpty
		and: [segment isEmpty])
		ifFalse: [pathSegments addLast: segment].

	^ pathSegments.! !
!XMLURIParser methodsFor: 'parsing'!
parsePort
	| port |

	(readStream peekFor: $:)
		ifTrue: [
			"do not limit the number of chars read, because port
			number literals can have an arbitrary number of
			leading zeros"
			port :=
				XMLSmallIntegerReader
					readFrom: readStream
					withBase: 10.
			[readStream atEnd
				or: [PathDelimiters includes: readStream peek]]
				whileFalse: [readStream next]].
	^ port.! !
!XMLURIParser methodsFor: 'parsing'!
parseQuery
	"parse the query as an OrderedCollection of name=value associations
	to handle multiple values for the same key and different encoded keys
	that later percent/plus decode to the same key"

	| query key value |

	(readStream peekFor: $?)
		ifFalse: [^ OrderedCollection new: 0].

	query := OrderedCollection new.
	[readStream atEnd
		or: [(key := self nextDelimitedByAny: QueryKeyDelimiters) isEmpty
			and: [readStream peek == $#]]]
		whileFalse: [| hasValue |
			(hasValue := readStream peekFor: $=)
				ifTrue: [value := self nextDelimitedByAny: QueryValueDelimiters]
				ifFalse: [value := ''].
			(key notEmpty
				or: [hasValue])
				ifTrue: [query addLast: key -> value].
			readStream peekFor: $&].

	^ query.! !
!XMLURIParser methodsFor: 'parsing'!
parseScheme
	| oldPosition scheme |

	oldPosition := readStream position.
	scheme := self nextDelimitedByAny: SchemeDelimiters.
	(readStream peekFor: $:)
		ifTrue: [^ scheme asLowercase]
		ifFalse: [
			readStream position: oldPosition.
			^ ''].! !
!XMLURIParser methodsFor: 'parsing'!
parseUserInfo
	| userInfo oldPosition |

	oldPosition := readStream position.
	userInfo := self nextDelimitedByAny: UserInfoDelimiters.
	(readStream peekFor: $@)
		ifTrue: [^ userInfo]
		ifFalse: [
			readStream position: oldPosition.
			^ ''].! !
!XMLAttributeDefaultValidator class methodsFor: 'instance creation'!
attribute: anAttribute
	^ self
		attribute: anAttribute
		value: ''! !
!XMLAttributeDefaultValidator class methodsFor: 'instance creation'!
attribute: anAttribute value: aDefaultValue
	^ self new
		setAttribute: anAttribute
		value: aDefaultValue! !
!XMLAttributeDefaultValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ self! !
!XMLAttributeDefaultValidator methodsFor: 'accessing'!
attribute
	^ attribute! !
!XMLAttributeDefaultValidator methodsFor: 'testing'!
isFixedValue
	^ false! !
!XMLAttributeDefaultValidator methodsFor: 'testing'!
isImplied
	^ false! !
!XMLAttributeDefaultValidator methodsFor: 'testing'!
isRequired
	^ false! !
!XMLAttributeDefaultValidator methodsFor: 'testing'!
isValue
	^ false! !
!XMLAttributeDefaultValidator methodsFor: 'printing'!
printNameAndValueOn: aStream
	aStream
		nextPutAll: self attribute;
		nextPutAll: '="';
		nextPutAll: self value;
		nextPut: $"! !
!XMLAttributeDefaultValidator methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self printNameAndValueOn: aStream.
	aStream nextPut: $).! !
!XMLAttributeDefaultValidator methodsFor: 'processing'!
processedDefaultForAbsentAttributeValue
	^ nil! !
!XMLAttributeDefaultValidator methodsFor: 'processing'!
processedDefaultForPresentAttributeValue: anAttributeValue
	^ anAttributeValue! !
!XMLAttributeDefaultValidator methodsFor: 'initialization'!
setAttribute: anAttribute value: aDefaultValue
	attribute := anAttribute! !
!XMLAttributeDefaultValidator methodsFor: 'validating'!
validatedDefaultForAbsentAttributeValue
	^ nil! !
!XMLAttributeDefaultValidator methodsFor: 'validating'!
validatedDefaultForPresentAttributeValue: anAttributeValue
	^ anAttributeValue! !
!XMLAttributeDefaultValidator methodsFor: 'accessing'!
value
	^ ''! !
!XMLAttributeImpliedDefaultValidator methodsFor: 'testing'!
isImplied
	^ true! !
!XMLAttributeRequiredDefaultValidator methodsFor: 'private'!
errorRequiredAttributeMissing
	XMLValidationException
		formatSignal: 'Required attribute "{1}" is missing'
		with: self attribute! !
!XMLAttributeRequiredDefaultValidator methodsFor: 'testing'!
isRequired
	^ true! !
!XMLAttributeRequiredDefaultValidator methodsFor: 'validating'!
validatedDefaultForAbsentAttributeValue
	self errorRequiredAttributeMissing! !
!XMLAttributeFixedValueDefaultValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalAttributeFixedValueDefaultValidator! !
!XMLAttributeFixedValueDefaultValidator methodsFor: 'private'!
errorFixedAttributeValueCannotChange
	XMLValidationException
		formatSignal: 'Fixed attribute "{1}" can only have "{2}" as its value'
		with: self attribute
		with: self value! !
!XMLAttributeFixedValueDefaultValidator methodsFor: 'testing'!
isFixedValue
	^ true! !
!XMLAttributeFixedValueDefaultValidator methodsFor: 'processing'!
processedDefaultForPresentAttributeValue: anAttributeValue
	^ self value! !
!XMLAttributeFixedValueDefaultValidator methodsFor: 'validating'!
validatedDefaultForPresentAttributeValue: anAttributeValue
	anAttributeValue = self value
		ifFalse: [self errorFixedAttributeValueCannotChange].
	^ anAttributeValue.! !
!XMLStandaloneExternalAttributeFixedValueDefaultValidator methodsFor: 'private'!
errorStandaloneExternalAttributeDefaultFixedValueUsed
	XMLValidationException
		formatSignal:
			'Externally defined attribute "{1}" fixed default value ',
			'cannot be used by elements when standalone="yes"'
		with: self attribute! !
!XMLStandaloneExternalAttributeFixedValueDefaultValidator methodsFor: 'validating'!
validatedDefaultForAbsentAttributeValue
	self errorStandaloneExternalAttributeDefaultFixedValueUsed! !
!XMLAttributeValueDefaultValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalAttributeValueDefaultValidator! !
!XMLAttributeValueDefaultValidator methodsFor: 'testing'!
isValue
	^ true! !
!XMLAttributeValueDefaultValidator methodsFor: 'processing'!
processedDefaultForAbsentAttributeValue
	^ self value! !
!XMLAttributeValueDefaultValidator methodsFor: 'initialization'!
setAttribute: anAttribute value: aDefaultValue
	attribute := anAttribute.
	value := aDefaultValue.! !
!XMLAttributeValueDefaultValidator methodsFor: 'validating'!
validatedDefaultForAbsentAttributeValue
	^ self value! !
!XMLAttributeValueDefaultValidator methodsFor: 'accessing'!
value
	^ value! !
!XMLAttributeValueDefaultValidator methodsFor: 'accessing'!
value: aDefaultValue
	value := aDefaultValue! !
!XMLStandaloneExternalAttributeValueDefaultValidator methodsFor: 'private'!
errorStandaloneExternalAttributeDefaultValueUsed
	XMLValidationException
		formatSignal:
			'Externally defined attribute "{1}" default value ',
			'cannot be used by elements when standalone="yes"'
		with: self attribute! !
!XMLStandaloneExternalAttributeValueDefaultValidator methodsFor: 'validating'!
validatedDefaultForAbsentAttributeValue
	self errorStandaloneExternalAttributeDefaultValueUsed! !
!XMLAttributeSpec methodsFor: 'converting'!
asXMLAttributeSpec
	^ self! !
!XMLAttributeSpec methodsFor: 'matching'!
matchesAttributes: anAttributeDictionary
	self subclassResponsibility! !
!XMLBasicAttributeSpec class methodsFor: 'instance creation'!
attributes: aDictionaryOrCollectionOfAssociationsAndStrings
	^ self new setAttributes: aDictionaryOrCollectionOfAssociationsAndStrings! !
!XMLBasicAttributeSpec methodsFor: 'adding'!
addAttribute: anAttribute
	^ attributeSpec
		at: anAttribute
		ifAbsentPut: [nil]! !
!XMLBasicAttributeSpec methodsFor: 'adding'!
addAttributeAssociation: anAssociation
	^ self
		addAttributeName: anAssociation key
		value: anAssociation value! !
!XMLBasicAttributeSpec methodsFor: 'adding'!
addAttributeName: aName value: aValue
	^ attributeSpec
		at: aName
		put: aValue! !
!XMLBasicAttributeSpec methodsFor: 'initialization'!
initialize
	super initialize.

	attributeSpec := Dictionary new.! !
!XMLBasicAttributeSpec methodsFor: 'matching'!
matchesAttributes: anAttributeDictionary
	attributeSpec keysAndValuesDo: [:specName :specValue |
		specValue
			ifNil: [
				"nil values mean the attribute has to be present and can have
				any value"
				(anAttributeDictionary includesKey: specName)
					ifFalse: [^ false]]
			ifNotNil: [
				(specValue isBlock
					ifTrue: [
						specValue value:
							(anAttributeDictionary
								at: specName
								ifAbsent: [^ false])]
					ifFalse: [
						specValue =
							(anAttributeDictionary
								at: specName
								ifAbsent: [^ false])])
							ifFalse: [^ false]]].
	^ true.! !
!XMLBasicAttributeSpec methodsFor: 'initialization'!
setAttributes: aDictionaryOrCollectionOfAssociationsAndStrings
	attributeSpec removeAll.

	"associationsDo: works for dictionaries and non-dictionaries, including
	arrays, to support specs like {'one'. 'two'->'three'}"
	aDictionaryOrCollectionOfAssociationsAndStrings associationsDo: [:each |
		each isString
			ifTrue: [self addAttribute: each]
			ifFalse: [self addAttributeAssociation: each]].! !
!XMLPluggableAttributeSpec class methodsFor: 'generated'!
block: aOneArgumentBlock
	^ self new block: aOneArgumentBlock! !
!XMLPluggableAttributeSpec methodsFor: 'accessing'!
block
	^ block! !
!XMLPluggableAttributeSpec methodsFor: 'accessing'!
block: aOneArgumentBlock
	block := aOneArgumentBlock! !
!XMLPluggableAttributeSpec methodsFor: 'matching'!
matchesAttributes: anAttributeDictionary
	"if there's no block, then it automatically matches, similar to an
	XMLBasicAttributeSpec with no attributes"
	block
		ifNil: [^ true]
		ifNotNil: [^ block value: anAttributeDictionary]! !
!XMLAttributeValidator class methodsFor: 'instance creation'!
element: anElement attribute: anAttribute defaultValidator: aDefaultValidator
	^ self new
		setElement: anElement
		attribute: anAttribute
		defaultValidator: aDefaultValidator! !
!XMLAttributeValidator class methodsFor: 'class initialization'!
initialize
	"self initialize"

	"stored in a class var for faster access"
	NormalizedSpace := Character space! !
!XMLAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ self! !
!XMLAttributeValidator methodsFor: 'accessing'!
attribute
	^ attribute! !
!XMLAttributeValidator methodsFor: 'accessing'!
defaultValidator
	^ defaultValidator! !
!XMLAttributeValidator methodsFor: 'accessing'!
element
	^ element! !
!XMLAttributeValidator methodsFor: 'private'!
errorInvalidDefaultAttributeValue: aDefaultValue
	XMLValidationException
		formatSignal:
			'Invalid default value "{1}" in declaration for ',
			'attribute "{2}" of element <3>'
		with: aDefaultValue
		with: self attribute
		with: self element! !
!XMLAttributeValidator methodsFor: 'private'!
errorInvalidXMLIDAttributeDeclaration
	XMLValidationException signal:
		'All "xml:id" attributes must be declared to be of ID type'! !
!XMLAttributeValidator methodsFor: 'private'!
errorInvalidXMLSpaceAttributeDeclaration
	XMLValidationException
		formatSignal:
			'Attribute "xml:space" of element <{1}> must be declared as ',
			'an enumeration type with "default" and/or "preserve" values'
		with: self element! !
!XMLAttributeValidator methodsFor: 'private'!
errorNormalizedStandaloneExternalAttribute
	XMLValidationException
		formatSignal:
			'Externally defined attribute "{1}" of element <{2}> required ',
			'further value normalizaiton in standalone="yes" document'
		with: self attribute
		with: self element! !
!XMLAttributeValidator methodsFor: 'private'!
furtherNormalizeAttributeValue: aSemiNormalizedAttributeValue
	"The tokenizer normalizes all non-char escaped whitespace in attribute
	values to spaces (0x20). This further normalizes them by removing leading
	and trailing spaces and turing multiple spaces to single spaces."
	| writeStream isInWhitespace |

	aSemiNormalizedAttributeValue size > 0 "optimization"
		ifFalse: [^ aSemiNormalizedAttributeValue].

	"must use #writeStream instead of 'WriteStream on:' to get a 0-based stream
	on Gemstone"
	writeStream := (String new: aSemiNormalizedAttributeValue size) writeStream.
	isInWhitespace := false.
	"use #to:do: for speed"
	1 to: aSemiNormalizedAttributeValue size do: [:i | | nextChar |
		(nextChar := aSemiNormalizedAttributeValue at: i) == NormalizedSpace
			ifTrue: [
				isInWhitespace
					ifFalse: [isInWhitespace := true]]
			ifFalse: [
				isInWhitespace
					ifTrue: [
						writeStream position > 0
							ifTrue: [writeStream nextPut: NormalizedSpace].
						isInWhitespace := false].
				writeStream nextPut: nextChar]].
	^ writeStream contents.! !
!XMLAttributeValidator methodsFor: 'initialization'!
initializeWithValidatorsFrom: aValidatorContainer
	(self mustFurtherNormalizeAttributeValue
		and: [self defaultValidator isValue])
		ifTrue: [
			self defaultValidator value:
				(self furtherNormalizeAttributeValue:
					self defaultValidator value)]! !
!XMLAttributeValidator methodsFor: 'testing'!
isCData
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isEntities
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isEntity
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isEnumeration
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isID
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isIDRef
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isIDRefs
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isNmtoken
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isNmtokens
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isNotationEnumeration
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	"this is overridden in each standalone external subclass to return
	true instead of just returning a boolean inst var to save memory"
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
isXMLID
	^ false! !
!XMLAttributeValidator methodsFor: 'testing'!
mustFurtherNormalizeAttributeValue
	^ true! !
!XMLAttributeValidator methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPutAll: '(<';
		nextPutAll: self element;
		space.
	self defaultValidator printNameAndValueOn: aStream.
	aStream nextPutAll: '>)'.! !
!XMLAttributeValidator methodsFor: 'processing'!
processAttributes: aDictionary
	| attributeAssociation normalizedValue |

	attributeAssociation :=
		aDictionary
			associationAt: self attribute
			ifAbsent: [
				self defaultValidator processedDefaultForAbsentAttributeValue
					ifNotNil: [:defaultValue |
						aDictionary
							at: self attribute
							put: defaultValue].
				^ self].

	self mustFurtherNormalizeAttributeValue
		ifTrue: [
			normalizedValue :=
				self furtherNormalizeAttributeValue:
					attributeAssociation value]
		ifFalse: [normalizedValue := attributeAssociation value].
	attributeAssociation value:
		(self defaultValidator processedDefaultForPresentAttributeValue:
			normalizedValue).! !
!XMLAttributeValidator methodsFor: 'initialization'!
setElement: anElement attribute: anAttribute defaultValidator: aDefaultValidator
	element := anElement.
	attribute := anAttribute.
	defaultValidator := aDefaultValidator.! !
!XMLAttributeValidator methodsFor: 'private'!
spaceSeparatedListValuesIn: aSpaceSeparatedList do: aBlock
	NormalizedSpace
		xmlSplit: aSpaceSeparatedList
		do: aBlock! !
!XMLAttributeValidator methodsFor: 'validating'!
validateAttributeDeclaration
	(self attribute at: 1) == $x "optimization"
		ifTrue: [
			(self attribute = 'xml:id')
				ifTrue: [^ self validateXMLIDAttributeDeclaration].
			(self attribute = 'xml:space')
				ifTrue: [^ self validateXMLSpaceAttributeDeclaration]].

	self defaultValidator isValue
		ifTrue: [	
			self validateAttributeDefaultValue:
				self defaultValidator value].! !
!XMLAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	"This is overridden in subclasses to check default values when validating
	the declaration, but CDATA types should not be validated, and ID types
	cannot have default values at all"! !
!XMLAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	"This is overridden in subclasses to check attribute values"! !
!XMLAttributeValidator methodsFor: 'validating'!
validateAttributes: aDictionary
	| attributeAssociation wasAbsent |

	wasAbsent := false.
	attributeAssociation :=
		aDictionary
			associationAt: self attribute
			ifAbsent: [
				wasAbsent := true.
				self defaultValidator validatedDefaultForAbsentAttributeValue
					ifNil: [^ self]
					ifNotNil: [:defaultValue |
						aDictionary add: self attribute -> defaultValue]].

	wasAbsent
		ifFalse: [| normalizedValue |
			self mustFurtherNormalizeAttributeValue
				ifTrue: [
					normalizedValue :=
						self furtherNormalizeAttributeValue:
							attributeAssociation value.
					self isStandaloneExternal
						ifTrue: [
							"since further normalization just condences multiple spaces
							to single spaces and removes trailing and leading spaces,
							comparing the sizes after is enough to detect if it was
							done"
							normalizedValue size = attributeAssociation value size
								ifFalse: [
									self errorNormalizedStandaloneExternalAttribute]]]
				ifFalse: [normalizedValue := attributeAssociation value].
			attributeAssociation value:
				(self defaultValidator validatedDefaultForPresentAttributeValue:
					normalizedValue)].

	self validateAttributeValue: attributeAssociation value.! !
!XMLAttributeValidator methodsFor: 'validating'!
validateXMLIDAttributeDeclaration
	self errorInvalidXMLIDAttributeDeclaration! !
!XMLAttributeValidator methodsFor: 'validating'!
validateXMLSpaceAttributeDeclaration
	self errorInvalidXMLSpaceAttributeDeclaration! !
!XMLCDataAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalCDataAttributeValidator! !
!XMLCDataAttributeValidator methodsFor: 'testing'!
isCData
	^ true! !
!XMLCDataAttributeValidator methodsFor: 'testing'!
mustFurtherNormalizeAttributeValue
	^ false! !
!XMLStandaloneExternalCDataAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLEntitiesAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalEntitiesAttributeValidator! !
!XMLEntitiesAttributeValidator methodsFor: 'testing'!
isEntities
	^ true! !
!XMLEntitiesAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	self
		spaceSeparatedListValuesIn: aDefaultValue
		do: [:each |
			each isXMLName
				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !
!XMLEntitiesAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self
		spaceSeparatedListValuesIn: aValue
		do: [:each |
			self unparsedEntityValidator
				validateEntityReference: each
				inAttribute: self attribute]! !
!XMLStandaloneExternalEntitiesAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLEntityAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalEntityAttributeValidator! !
!XMLEntityAttributeValidator methodsFor: 'initialization'!
initializeWithValidatorsFrom: aValidatorContainer
	super initializeWithValidatorsFrom: aValidatorContainer.

	unparsedEntityValidator := aValidatorContainer unparsedEntityValidator! !
!XMLEntityAttributeValidator methodsFor: 'testing'!
isEntity
	^ true! !
!XMLEntityAttributeValidator methodsFor: 'accessing'!
unparsedEntityValidator
	^ unparsedEntityValidator! !
!XMLEntityAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	aDefaultValue isXMLName
		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !
!XMLEntityAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self unparsedEntityValidator
		validateEntityReference: aValue
		inAttribute: self attribute! !
!XMLStandaloneExternalEntityAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLEnumerationAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalEnumerationAttributeValidator! !
!XMLEnumerationAttributeValidator methodsFor: 'accessing'!
allowedValues
	^ allowedValues ifNil: [allowedValues := Set new]! !
!XMLEnumerationAttributeValidator methodsFor: 'accessing'!
allowedValues: anAllowedValuesCollection
	allowedValues := anAllowedValuesCollection! !
!XMLEnumerationAttributeValidator methodsFor: 'private '!
errorEnumerationContainsDuplicateValues
	XMLValidationException
		formatSignal:
			'Declaration for enumeration attribute "{1}" of element ',
			'<{2}> contains duplicate values'
		with: self attribute
		with: self element! !
!XMLEnumerationAttributeValidator methodsFor: 'private '!
errorInvalidValue: aValue
	XMLValidationException
		formatSignal: 'Invalid value "{1}" for attribute "{2}" of element <{3}>'
		with: aValue
		with: self attribute
		with: self element! !
!XMLEnumerationAttributeValidator methodsFor: 'testing'!
isEnumeration
	^ true! !
!XMLEnumerationAttributeValidator methodsFor: 'validating'!
validateAttributeDeclaration
	| oldAllowedValues |

	oldAllowedValues := self allowedValues.
	self allowedValues: oldAllowedValues asSet.
	(self allowedValues size < oldAllowedValues size)
		ifTrue: [self errorEnumerationContainsDuplicateValues].

	super validateAttributeDeclaration.! !
!XMLEnumerationAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	(self allowedValues includes: aDefaultValue)
		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !
!XMLEnumerationAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	(self allowedValues includes: aValue)
		ifFalse: [self errorInvalidValue: aValue]! !
!XMLEnumerationAttributeValidator methodsFor: 'validating'!
validateXMLSpaceAttributeDeclaration
	self allowedValues size > 2
		ifTrue: [self errorInvalidXMLSpaceAttributeDeclaration].
	self allowedValues do: [:each |
		(each = 'preserve'
			or: [each = 'default'])
			ifFalse: [self errorInvalidXMLSpaceAttributeDeclaration]].! !
!XMLNotationEnumerationAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalNotationEnumerationAttributeValidator! !
!XMLNotationEnumerationAttributeValidator methodsFor: 'initialization'!
initializeWithValidatorsFrom: aValidatorContainer
	super initializeWithValidatorsFrom: aValidatorContainer.

	unparedEntityValidator := aValidatorContainer unparsedEntityValidator.! !
!XMLNotationEnumerationAttributeValidator methodsFor: 'testing'!
isNotationEnumeration
	^ true! !
!XMLNotationEnumerationAttributeValidator methodsFor: 'accessing'!
unparsedEntityValidator
	^ unparedEntityValidator! !
!XMLNotationEnumerationAttributeValidator methodsFor: 'validating'!
validateAttributeDeclaration
	self unparsedEntityValidator validateNotationAttributeDeclaration: self.

	super validateAttributeDeclaration.! !
!XMLNotationEnumerationAttributeValidator methodsFor: 'validating'!
validateXMLSpaceAttributeDeclaration
	self errorInvalidXMLSpaceAttributeDeclaration! !
!XMLStandaloneExternalNotationEnumerationAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLStandaloneExternalEnumerationAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLIDAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalIDAttributeValidator! !
!XMLIDAttributeValidator methodsFor: 'accessing'!
elementIDValidator
	^ elementIDValidator! !
!XMLIDAttributeValidator methodsFor: 'accessing'!
elementIDValidator: anElementIDValidator
	elementIDValidator := anElementIDValidator! !
!XMLIDAttributeValidator methodsFor: 'private'!
errorIDAttributeMustBeRequiredOrImplied
	XMLValidationException
		formatSignal:
			'Attribute "{1}" of element <{2}> is of ID type and must ',
			'be declared #REQUIRED or #IMPLIED'
		with: self attribute
		with: self element! !
!XMLIDAttributeValidator methodsFor: 'initialization'!
initializeWithValidatorsFrom: aValidatorContainer
	super initializeWithValidatorsFrom: aValidatorContainer.

	elementIDValidator := aValidatorContainer elementIDValidator.! !
!XMLIDAttributeValidator methodsFor: 'testing'!
isID
	^ true! !
!XMLIDAttributeValidator methodsFor: 'validating'!
validateAttributeDeclaration
	self elementIDValidator
		validateIDAttribute: self attribute
		forElement: self element.

	super validateAttributeDeclaration.! !
!XMLIDAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	self errorIDAttributeMustBeRequiredOrImplied! !
!XMLIDAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self elementIDValidator
		validateID: aValue
		inAttribute: self attribute! !
!XMLStandaloneExternalIDAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLStandaloneExternalXMLIDAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLXMLIDAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalXMLIDAttributeValidator! !
!XMLXMLIDAttributeValidator methodsFor: 'testing'!
isXMLID
	^ true! !
!XMLXMLIDAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self elementIDValidator validateXMLID: aValue! !
!XMLXMLIDAttributeValidator methodsFor: 'validating'!
validateXMLIDAttributeDeclaration
! !
!XMLIDRefAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalIDRefAttributeValidator! !
!XMLIDRefAttributeValidator methodsFor: 'accessing'!
elementIDValidator
	^ elementIDValidator! !
!XMLIDRefAttributeValidator methodsFor: 'initialization'!
initializeWithValidatorsFrom: aValidatorContainer
	super initializeWithValidatorsFrom: aValidatorContainer.

	elementIDValidator := aValidatorContainer elementIDValidator.! !
!XMLIDRefAttributeValidator methodsFor: 'testing'!
isIDRef
	^ true! !
!XMLIDRefAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	aDefaultValue isXMLName
		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !
!XMLIDRefAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self elementIDValidator
		validateIDReference: aValue
		inAttribute: self attribute! !
!XMLIDRefsAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalIDRefsAttributeValidator! !
!XMLIDRefsAttributeValidator methodsFor: 'testing'!
isIDRefs
	^ true! !
!XMLIDRefsAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	self
		spaceSeparatedListValuesIn: aDefaultValue
		do: [:each |
			each isXMLName
				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !
!XMLIDRefsAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self
		spaceSeparatedListValuesIn: aValue
		do: [:each |
			self elementIDValidator
				validateIDReference: each
				inAttribute: self attribute]! !
!XMLStandaloneExternalIDRefsAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLStandaloneExternalIDRefAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLNmtokenAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalNmtokenAttributeValidator! !
!XMLNmtokenAttributeValidator methodsFor: 'private'!
errorInvalidNmtoken: aName
	XMLValidationException
		formatSignal: 'Invalid Nmtoken name "{1}" in attribute "{2}" of element <{3}>'
		with: aName
		with: self attribute
		with: self element! !
!XMLNmtokenAttributeValidator methodsFor: 'testing'!
isNmtoken
	^ true! !
!XMLNmtokenAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	aDefaultValue isXMLNmtoken
		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !
!XMLNmtokenAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self validateNmtoken: aValue! !
!XMLNmtokenAttributeValidator methodsFor: 'validating'!
validateNmtoken: aName
	aName isXMLNmtoken
		ifFalse: [self errorInvalidNmtoken: aName]! !
!XMLNmtokensAttributeValidator class methodsFor: 'defaults'!
standaloneExternalClass
	^ XMLStandaloneExternalNmtokensAttributeValidator! !
!XMLNmtokensAttributeValidator methodsFor: 'testing'!
isNmtokens
	^ true! !
!XMLNmtokensAttributeValidator methodsFor: 'validating'!
validateAttributeDefaultValue: aDefaultValue
	self
		spaceSeparatedListValuesIn: aDefaultValue
		do: [:each |
			each isXMLNmtoken
				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !
!XMLNmtokensAttributeValidator methodsFor: 'validating'!
validateAttributeValue: aValue
	self
		spaceSeparatedListValuesIn: aValue
		do: [:each | self validateNmtoken: each]! !
!XMLStandaloneExternalNmtokensAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLStandaloneExternalNmtokenAttributeValidator methodsFor: 'testing'!
isStandaloneExternal
	^ true! !
!XMLClassFinder class methodsFor: 'accessing'!
classNamed: aClassName
	^ self
		classNamed: aClassName
		ifAbsent: [nil]! !
!XMLClassFinder class methodsFor: 'accessing'!
classNamed: aClassName ifAbsent: aBlock
	"'self environment at:' is the proper way to get a class that may not
	exist, not 'Smalltalk at:', 'Smalltalk globals at:' or '#ClassName asClass'
	(assuming both this class and aClassName class are in the same environment)"
	^ self environment
		at: aClassName asSymbol
		ifAbsent: aBlock! !
!XMLClassFinder class methodsFor: 'accessing'!
classNamed: aClassName ifPresent: aBlock
	^ aBlock cull:
		(self
			classNamed: aClassName
			ifAbsent: [^ nil])! !
!XMLClassFinder class methodsFor: 'accessing'!
classNamed: aClassName ifPresent: aPresentBlock ifAbsent: anAbsentBlock
	^ aPresentBlock cull:
		(self
			classNamed: aClassName
			ifAbsent: [^ anAbsentBlock value])! !
!XMLClassFinder class methodsFor: 'testing'!
hasClassNamed: aClassName
	self
		classNamed: aClassName
		ifAbsent: [^ false].
	^ true.! !
!XMLConfiguration methodsFor: 'accessing'!
decodesCharacters
	^ decodesCharacters! !
!XMLConfiguration methodsFor: 'accessing'!
decodesCharacters: aBoolean
	decodesCharacters := aBoolean! !
!XMLConfiguration methodsFor: 'defaults'!
defaultParserHandlerClass
	^ SAXHandler! !
!XMLConfiguration methodsFor: 'accessing'!
documentReadLimit
	^ self parserLimits documentReadLimit! !
!XMLConfiguration methodsFor: 'accessing'!
documentReadLimit: anInteger
	self parserLimits documentReadLimit: anInteger! !
!XMLConfiguration methodsFor: 'accessing'!
entityConfiguration
	^ entityConfiguration ifNil: [entityConfiguration := DTDEntityConfiguration new]! !
!XMLConfiguration methodsFor: 'accessing'!
entityConfiguration: anEntityConfiguration
	entityConfiguration := anEntityConfiguration! !
!XMLConfiguration methodsFor: 'accessing'!
externalEntityResolver
	^ self entityConfiguration externalEntityResolver! !
!XMLConfiguration methodsFor: 'accessing'!
externalEntityResolver: anExternalEntityResolver
	self entityConfiguration externalEntityResolver: anExternalEntityResolver! !
!XMLConfiguration methodsFor: 'initialization'!
initialize
	super initialize.

	"always used, so explicitly initialized"
	isValidating := true.
	usesNamespaces := true.
	decodesCharacters := true.
	requiresSchema := false.
	parserLimits := XMLParserLimits new.! !
!XMLConfiguration methodsFor: 'accessing'!
isValidating
	^ isValidating! !
!XMLConfiguration methodsFor: 'accessing'!
isValidating: aBoolean
	(isValidating := aBoolean)
		ifTrue: [self preservesUndeclaredEntityReferences: false]
		ifFalse: [self requiresSchema: false]! !
!XMLConfiguration methodsFor: 'accessing'!
maxEntityReplacementDepth
	^ self parserLimits maxEntityReplacementDepth! !
!XMLConfiguration methodsFor: 'accessing'!
maxEntityReplacementDepth: anInteger
	self parserLimits maxEntityReplacementDepth: anInteger! !
!XMLConfiguration methodsFor: 'accessing'!
parserHandlerClass
	^ parserHandlerClass ifNil: [parserHandlerClass := self defaultParserHandlerClass]! !
!XMLConfiguration methodsFor: 'accessing'!
parserHandlerClass: aClass
	parserHandlerClass := aClass! !
!XMLConfiguration methodsFor: 'accessing'!
parserLimits
	^ parserLimits! !
!XMLConfiguration methodsFor: 'accessing'!
parserLimits: aParserLimits
	parserLimits := aParserLimits! !
!XMLConfiguration methodsFor: 'copying'!
postCopy
	super postCopy.

	parserLimits := parserLimits copy.
	entityConfiguration
		ifNotNil: [entityConfiguration := entityConfiguration copy].! !
!XMLConfiguration methodsFor: 'accessing'!
preservesUndeclaredEntityReferences
	^ self entityConfiguration preservesUndeclaredEntityReferences! !
!XMLConfiguration methodsFor: 'accessing'!
preservesUndeclaredEntityReferences: aBoolean
	self entityConfiguration preservesUndeclaredEntityReferences: aBoolean.
	aBoolean
		ifTrue: [self isValidating: false].! !
!XMLConfiguration methodsFor: 'removing'!
removeLimits
	self parserLimits removeAll.
	self externalEntityResolver removeLimits.! !
!XMLConfiguration methodsFor: 'accessing'!
replacesContentEntityReferences
	^ self entityConfiguration replacesContentEntityReferences! !
!XMLConfiguration methodsFor: 'accessing'!
replacesContentEntityReferences: aBoolean
	self entityConfiguration replacesContentEntityReferences: aBoolean! !
!XMLConfiguration methodsFor: 'deprecated'!
requiresDocumentConstraints
	^ self requiresSchema! !
!XMLConfiguration methodsFor: 'deprecated'!
requiresDocumentConstraints: aBoolean
	"will be deprecated; use #requiresSchema: instead"
	self requiresSchema: aBoolean! !
!XMLConfiguration methodsFor: 'accessing'!
requiresSchema
	^ requiresSchema! !
!XMLConfiguration methodsFor: 'accessing'!
requiresSchema: aBoolean
	(requiresSchema := aBoolean)
		ifTrue: [self isValidating: true]! !
!XMLConfiguration methodsFor: 'accessing'!
resolvesExternalEntities
	^ self entityConfiguration resolvesExternalEntities! !
!XMLConfiguration methodsFor: 'accessing'!
resolvesExternalEntities: aBoolean
	self entityConfiguration resolvesExternalEntities: aBoolean! !
!XMLConfiguration methodsFor: 'accessing'!
usesNamespaces
	^ usesNamespaces! !
!XMLConfiguration methodsFor: 'accessing'!
usesNamespaces: aBoolean
	usesNamespaces := aBoolean! !
!XMLDOMConfiguration methodsFor: 'accessing'!
attributeListClass
	^ self nodeFactory attributeListClass! !
!XMLDOMConfiguration methodsFor: 'accessing'!
attributeListClass: aClass
	self nodeFactory:
		(self nodeFactory asPluggableNodeFactory attributeListClass: aClass)! !
!XMLDOMConfiguration methodsFor: 'defaults'!
defaultNodeFactoryClass
	^ XMLNodeFactory! !
!XMLDOMConfiguration methodsFor: 'defaults'!
defaultParserHandlerClass
	^ XMLDOMParser! !
!XMLDOMConfiguration methodsFor: 'initialization'!
initialize
	super initialize.

	"always used, so explicitly initialized"
	preservesCDataNodes := false.
	preservesCommentNodes := false.
	preservesIgnorableWhitespace := false.
	nodeFactory := self defaultNodeFactoryClass new.! !
!XMLDOMConfiguration methodsFor: 'accessing'!
isValidating: aBoolean
	aBoolean
		ifFalse: [self preservesIgnorableWhitespace: false].
	super isValidating: aBoolean.! !
!XMLDOMConfiguration methodsFor: 'accessing'!
nodeFactory
	^ nodeFactory! !
!XMLDOMConfiguration methodsFor: 'accessing'!
nodeFactory: aFactory
	nodeFactory := aFactory! !
!XMLDOMConfiguration methodsFor: 'accessing'!
nodeListClass
	^ self nodeFactory nodeListClass! !
!XMLDOMConfiguration methodsFor: 'accessing'!
nodeListClass: aClass
	self nodeFactory:
		(self nodeFactory asPluggableNodeFactory nodeListClass: aClass)! !
!XMLDOMConfiguration methodsFor: 'copying'!
postCopy
	super postCopy.

	nodeFactory := nodeFactory copy.! !
!XMLDOMConfiguration methodsFor: 'accessing'!
preservesCDataNodes
	^ preservesCDataNodes! !
!XMLDOMConfiguration methodsFor: 'accessing'!
preservesCDataNodes: aBoolean
	preservesCDataNodes := aBoolean! !
!XMLDOMConfiguration methodsFor: 'accessing'!
preservesCommentNodes
	^ preservesCommentNodes! !
!XMLDOMConfiguration methodsFor: 'accessing'!
preservesCommentNodes: aBoolean
	preservesCommentNodes := aBoolean! !
!XMLDOMConfiguration methodsFor: 'accessing'!
preservesIgnorableWhitespace
	^ preservesIgnorableWhitespace! !
!XMLDOMConfiguration methodsFor: 'accessing'!
preservesIgnorableWhitespace: aBoolean
	(preservesIgnorableWhitespace := aBoolean)
		ifTrue: [self isValidating: true]! !
!XMLDFAState class methodsFor: 'instance creation'!
nfaStates: anNFAStateSet
	^ self
		nfaStates: anNFAStateSet
		dfaStateCache: nil! !
!XMLDFAState class methodsFor: 'instance creation'!
nfaStates: anNFAStateSet dfaStateCache: aDFAStateCache
	^ self new
		setNFAStates: anNFAStateSet
		dfaStateCache: aDFAStateCache! !
!XMLDFAState methodsFor: 'private'!
addDFAStateTransitionMatching: aMatcher
	| matchingNFAStates totalMatched matchingDFAState |

	self dfaStateTransitions size >= self maxDFAStateTransitions
		ifTrue: [self removeDFAStateTransitions].

	matchingNFAStates := XMLNFAStateSet new.
	totalMatched := 0.
	self nfaStatesDo: [:state |
		(state matches: aMatcher)
			ifTrue: [
				state nextState addTo: matchingNFAStates.
				totalMatched := totalMatched + 1]].

	matchingNFAStates size > 0
		ifTrue: [
			matchingDFAState :=
				dfaStateCache dfaStateForNFAStates: matchingNFAStates.
			totalMatched > 1
				ifTrue: [matchingDFAState hasNonDeterminism: true]].

	^ self dfaStateTransitions
		at: aMatcher
		put: matchingDFAState. "nil if no match"! !
!XMLDFAState methodsFor: 'private'!
dfaStateCache
	^ dfaStateCache! !
!XMLDFAState methodsFor: 'private'!
dfaStateTransitions
	^ dfaStateTransitions ifNil: [dfaStateTransitions := Dictionary new]! !
!XMLDFAState methodsFor: 'testing'!
hasNonDeterminism
	^ hasNonDeterminism! !
!XMLDFAState methodsFor: 'accessing'!
hasNonDeterminism: aBoolean
	hasNonDeterminism := aBoolean! !
!XMLDFAState methodsFor: 'testing'!
isAccepting
	^ nfaStates isAccepting! !
!XMLDFAState methodsFor: 'private'!
maxDFAStateTransitions
	^ 64! !
!XMLDFAState methodsFor: 'matching'!
nextDFAStateMatching: aMatcher
	^ self
		nextDFAStateMatching: aMatcher
		ifNone: [nil]! !
!XMLDFAState methodsFor: 'matching'!
nextDFAStateMatching: aMatcher ifNone: aBlock
	^ (self dfaStateTransitions
		at: aMatcher
		ifAbsent: [self addDFAStateTransitionMatching: aMatcher])
			ifNil: [aBlock value]! !
!XMLDFAState methodsFor: 'accessing'!
nfaStates
	^ nfaStates! !
!XMLDFAState methodsFor: 'enumerating'!
nfaStatesDo: aBlock
	nfaStates do: aBlock! !
!XMLDFAState methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		print: self nfaStates;
		nextPut: $).! !
!XMLDFAState methodsFor: 'private'!
removeDFAStateTransitions
	dfaStateTransitions := nil! !
!XMLDFAState methodsFor: 'initialization'!
setNFAStates: anNFAStateSet dfaStateCache: aDFAStateCache
	nfaStates := anNFAStateSet.
	dfaStateCache :=
		aDFAStateCache	
			ifNil: [XMLDFAStateCache firstDFAState: self].
	hasNonDeterminism := false.! !
!XMLDFAStateCache class methodsFor: 'instance creation'!
firstDFAState: aDFAState
	^ self new setFirstDFAState: aDFAState! !
!XMLDFAStateCache methodsFor: 'private'!
addDFAStateForNFAStates: anNFAStateSet
	cachedDFAStates size >= self maxCachedDFAStates
		ifTrue: [self removeDFAStates].
	^ cachedDFAStates
		at: anNFAStateSet
		put: (anNFAStateSet asDFAStateWithStateCache: self).! !
!XMLDFAStateCache methodsFor: 'private'!
cachedDFAStates
	^ cachedDFAStates! !
!XMLDFAStateCache methodsFor: 'accessing'!
dfaStateForNFAStates: anNFAStateSet
	^ cachedDFAStates
		at: anNFAStateSet
		ifAbsent: [self addDFAStateForNFAStates: anNFAStateSet]! !
!XMLDFAStateCache methodsFor: 'accessing'!
firstDFAState
	^ firstDFAState! !
!XMLDFAStateCache methodsFor: 'private'!
maxCachedDFAStates
	^ 64! !
!XMLDFAStateCache methodsFor: 'private'!
removeDFAStates
	cachedDFAStates
		valuesDo: [:each | each removeDFAStateTransitions];
		removeAll.
	cachedDFAStates
		at: firstDFAState nfaStates
		put: firstDFAState.! !
!XMLDFAStateCache methodsFor: 'initialization'!
setFirstDFAState: aDFAState
	firstDFAState := aDFAState.
	(cachedDFAStates := Dictionary new: 5)
		at: firstDFAState nfaStates
		put: firstDFAState.! !
!DTDDocumentValidator class methodsFor: 'instance creation'!
doctypeDefinition: aDoctypeDefinition
	^ self new doctypeDefinition: aDoctypeDefinition! !
!DTDDocumentValidator methodsFor: 'accessing'!
attributeValidatorsFor: anElement ifNone: aBlock
	^ self doctypeDefinition
		attributeValidatorsAt: anElement
		ifAbsent: aBlock! !
!DTDDocumentValidator methodsFor: 'accessing'!
doctypeDefinition
	^ doctypeDefinition! !
!DTDDocumentValidator methodsFor: 'accessing'!
doctypeDefinition: aDoctypeDefinition
	doctypeDefinition := aDoctypeDefinition! !
!DTDDocumentValidator methodsFor: 'accessing'!
elementValidatorFor: anElement ifNone: aBlock
	^ self doctypeDefinition
		elementValidatorsAt: anElement
		ifAbsent: aBlock! !
!DTDDocumentValidator methodsFor: 'private'!
errorInvalidRootElement: anElement
	XMLValidationException
		formatSignal:
			'Root element must be <{1}> according to DOCTYPE declaration, not <{2}>'
		with: self doctypeDefinition root
		with: anElement! !
!DTDDocumentValidator methodsFor: 'testing'!
hasAttributeValidators
	^ self doctypeDefinition hasAttributeValidators! !
!DTDDocumentValidator methodsFor: 'testing'!
hasElementValidators
	^ self doctypeDefinition hasElementValidators! !
!DTDDocumentValidator methodsFor: 'validating'!
unvalidatedAttributes: anAttributeCollection inElement: anElement
	XMLValidationException
		formatSignal: 'Undeclared attribute "{1}" in element <{2}>'
		with: anAttributeCollection anyOne
		with: anElement! !
!DTDDocumentValidator methodsFor: 'validating'!
unvalidatedElement: anElement
	XMLValidationException
		formatSignal: 'Undeclared element <{1}>'
		with: anElement! !
!DTDDocumentValidator methodsFor: 'validating'!
validateIDReferences
	self doctypeDefinition hasElementIDReferences
		ifTrue: [self doctypeDefinition elementIDValidator validateIDReferences]! !
!DTDDocumentValidator methodsFor: 'validating'!
validateRootElement: anElement
	(self doctypeDefinition hasRoot
		and: [self doctypeDefinition root ~= anElement])
		ifTrue: [self errorInvalidRootElement: anElement]! !
!XMLDocumentValidator methodsFor: 'accessing'!
attributeValidatorsFor: anElement
	^ self
		attributeValidatorsFor: anElement
		ifNone: [nil]! !
!XMLDocumentValidator methodsFor: 'accessing'!
attributeValidatorsFor: anElement ifNone: aBlock
	self subclassResponsibility! !
!XMLDocumentValidator methodsFor: 'accessing'!
currentElementValidator
	^ self elementValidatorStack xmlLastOrNil! !
!XMLDocumentValidator methodsFor: 'accessing'!
defaultElementValidatorFor: aName
	^ XMLAnyElementValidator element: aName! !
!XMLDocumentValidator methodsFor: 'private'!
defaultXMLIDValidator
	"used to validate xml:id attributes if there's no DTD or other validators"
	^ defaultXMLIDValidator
		ifNil: [
			defaultXMLIDValidator :=
				XMLXMLIDAttributeValidator
					element: ''
					attribute: 'xml:id'
					defaultValidator:
						(XMLAttributeImpliedDefaultValidator attribute: 'xml:id').
			defaultXMLIDValidator
				elementIDValidator: XMLElementIDValidator new;
				yourself]! !
!XMLDocumentValidator methodsFor: 'accessing'!
elementValidatorFor: anElement
	^ self
		elementValidatorFor: anElement
		ifNone: [nil]! !
!XMLDocumentValidator methodsFor: 'accessing'!
elementValidatorFor: anElement ifNone: aBlock
	self subclassResponsibility! !
!XMLDocumentValidator methodsFor: 'accessing'!
elementValidatorStack
	^ elementValidatorStack ifNil: [elementValidatorStack := OrderedCollection new]! !
!XMLDocumentValidator methodsFor: 'private'!
errorUnexpectEndOfElement: anElement
	XMLValidationException
		formatSignal: 'Element <{1}> terminated prematurely'
		with: anElement! !
!XMLDocumentValidator methodsFor: 'testing'!
hasAttributeValidators
	self subclassResponsibility! !
!XMLDocumentValidator methodsFor: 'testing'!
hasCurrentElementValidator
	"optimized to avoid lazy initialization"
	elementValidatorStack == nil
		ifTrue: [^ false].
	^ elementValidatorStack size > 0.! !
!XMLDocumentValidator methodsFor: 'testing'!
hasElementValidators
	self subclassResponsibility! !
!XMLDocumentValidator methodsFor: 'testing'!
isCurrentElementWhitespaceIgnorable
	^ self hasCurrentElementValidator
		and: [self currentElementValidator ignoresWhitespace]! !
!XMLDocumentValidator methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	self hasCurrentElementValidator
		ifTrue: [
			aStream
				nextPut: $(;
				print: self currentElementValidator;
				nextPut: $)].! !
!XMLDocumentValidator methodsFor: 'validating'!
unvalidatedAttributes: anAttributeCollection inElement: anElement
	"sent when at least one attribute of an element wasn't validated by an
	attribute validator and there are element or attribute validators defined"! !
!XMLDocumentValidator methodsFor: 'validating'!
unvalidatedElement: anElement
	"sent when an element was not validated by an element validator
	and there are element or attribute validators defined"! !
!XMLDocumentValidator methodsFor: 'validating'!
validateAttributes: aDictionary withAttributeValidatorsFor: anElement
	| totalUnvalidatedAttributes validatedAttributes |

	totalUnvalidatedAttributes := aDictionary size.
	(self attributeValidatorsFor: anElement)
		ifNotNil: [:attributeValidators |
			attributeValidators keysAndValuesDo: [:attribute :validator |
				(aDictionary includesKey: attribute)
					ifTrue: [
						"only initialize if needed, and as an OrderedCollection that
						is only converted to a Set later if needed, for permformance"
						(validatedAttributes
							ifNil: [
								validatedAttributes :=
									OrderedCollection new: totalUnvalidatedAttributes])
							addLast: attribute.
						totalUnvalidatedAttributes := totalUnvalidatedAttributes - 1].
				validator validateAttributes: aDictionary]].

	totalUnvalidatedAttributes > 0
		ifTrue: [
			self
				unvalidatedAttributes:
					(validatedAttributes
						ifNil: [aDictionary keys]
						ifNotNil: [| validatedAttributesSet |
							validatedAttributesSet := validatedAttributes asSet.
							aDictionary keys reject: [:each |
								validatedAttributesSet includes: each]])
				inElement: anElement].! !
!XMLDocumentValidator methodsFor: 'validating'!
validateComment: aString
	self hasCurrentElementValidator
		ifTrue: [self currentElementValidator validateComment: aString]! !
!XMLDocumentValidator methodsFor: 'validating'!
validateEndDocument
	self validateIDReferences! !
!XMLDocumentValidator methodsFor: 'validating'!
validateEndTag: anElement
	self hasCurrentElementValidator
		ifTrue: [
			self currentElementValidator atEnd
				ifFalse: [self errorUnexpectEndOfElement: anElement].
			self elementValidatorStack removeLast]! !
!XMLDocumentValidator methodsFor: 'validating'!
validateIDReferences
	self subclassResponsibility! !
!XMLDocumentValidator methodsFor: 'validating'!
validatePCData: aString
	self hasCurrentElementValidator
		ifTrue: [self currentElementValidator validatePCData: aString]! !
!XMLDocumentValidator methodsFor: 'validating'!
validatePI: aTargetString data: aDataString
	self hasCurrentElementValidator
		ifTrue: [
			self currentElementValidator
				validatePI: aTargetString
				data: aDataString]! !
!XMLDocumentValidator methodsFor: 'validating'!
validateRootElement: anElement! !
!XMLDocumentValidator methodsFor: 'validating'!
validateStartTag: anElement
	self currentElementValidator
		ifNotNil: [:elementValidator |
			elementValidator validateStartTag: anElement].

	self elementValidatorStack addLast:
		(self
			elementValidatorFor: anElement
			ifNone: [
				self
					unvalidatedElement: anElement;
					defaultElementValidatorFor: anElement]) asReadyElementValidator.! !
!XMLDocumentValidator methodsFor: 'validating'!
validateStartTag: anElement attributes: aDictionary
	(self hasElementValidators
		or: [self hasAttributeValidators])
		ifTrue: [
			self validateStartTag: anElement.
			self
				validateAttributes: aDictionary
				withAttributeValidatorsFor: anElement]! !
!XMLDocumentValidator methodsFor: 'validating'!
validateXMLIDAttributeIn: aDictionary
	self hasAttributeValidators
		ifFalse: [self defaultXMLIDValidator validateAttributes: aDictionary]! !
!XMLBasicElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName attributes: anAssociationCollection ifNone: aBlock
	^ self
		classForElement: aQualifiedName
		namespaceURI: ''
		attributes: anAssociationCollection
		ifNone: aBlock! !
!XMLBasicElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName ifNone: aBlock
	^ self
		classForElement: aQualifiedName
		namespaceURI: ''
		attributes: XMLLazyAttributeDictionary  new
		ifNone: aBlock! !
!XMLBasicElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection ifNone: aBlock
	| localName attributeDictionary |

	attributeDictionary := anAssociationCollection asXMLAttributeDictionary.
	aURI size > 0 "optimization"
		ifTrue: [
			(self
				elementClassMapAt: aQualifiedName -> aURI
				attributes: attributeDictionary)
				ifNotNil: [:class | ^ class].
			(self
				elementClassMapAt: aQualifiedName
				attributes: attributeDictionary)
				ifNotNil: [:class | ^ class].
			(localName := aQualifiedName xmlLocalNameAfterPrefix) size <
				aQualifiedName size
				ifTrue: [
					(self
						elementClassMapAt: localName -> aURI
						attributes: attributeDictionary)
						ifNotNil: [:class | ^ class].
					(self
						elementClassMapAt: localName
						attributes: attributeDictionary)
						ifNotNil: [:class | ^ class]]]
		ifFalse: [
			(self
				elementClassMapAt: aQualifiedName
				attributes: attributeDictionary)
				ifNotNil: [:class | ^ class].
			(localName := aQualifiedName xmlLocalNameAfterPrefix) size <
				aQualifiedName size
				ifTrue: [
					(self
						elementClassMapAt: localName
						attributes: attributeDictionary)
						ifNotNil: [:class | ^ class]]].

	^ aBlock value.! !
!XMLBasicElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI ifNone: aBlock
	^ self
		classForElement: aQualifiedName
		namespaceURI: aURI
		attributes: XMLLazyAttributeDictionary new
		ifNone: aBlock! !
!XMLBasicElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection ifNone: aBlock
	| attributeDictionary |

	attributeDictionary := anAssociationCollection.
	aURI size > 0 "optimization"
		ifTrue: [
			(self
				elementClassMapAt: aQualifiedName -> aURI
				attributes: attributeDictionary)
				ifNotNil: [:class | ^ class].
			(self
				elementClassMapAt: aQualifiedName
				attributes: attributeDictionary)
				ifNotNil: [:class | ^ class].
			aLocalName size < aQualifiedName size
				ifTrue: [
					(self
						elementClassMapAt: aLocalName -> aURI
						attributes: attributeDictionary)
						ifNotNil: [:class | ^ class].
					(self
						elementClassMapAt: aLocalName
						attributes: attributeDictionary)
						ifNotNil: [:class | ^ class]]]
		ifFalse: [
			(self
				elementClassMapAt: aQualifiedName
				attributes: attributeDictionary)
				ifNotNil: [:class | ^ class].
			aLocalName size < aQualifiedName size
				ifTrue: [
					(self
						elementClassMapAt: aLocalName
						attributes: attributeDictionary)
						ifNotNil: [:class | ^ class]]].

	^ aBlock value.! !
!XMLBasicElementClassMapper methodsFor: 'private'!
elementClassMap
	^ elementClassMap! !
!XMLBasicElementClassMapper methodsFor: 'private'!
elementClassMapAt: aKey attributes: anAttributeDictionary
	| classOrCollection |

	classOrCollection :=
		elementClassMap
			at: aKey
			ifAbsent: [^ nil].

	classOrCollection isCollection
		ifTrue: [
			"to:do: for speed"
			1 to: classOrCollection size - 1 do: [:i |
				((classOrCollection at: i) key
					matchesAttributes: anAttributeDictionary)
					ifTrue: [^ (classOrCollection at: i) value]].
			^ classOrCollection last]
		ifFalse: [^ classOrCollection].! !
!XMLBasicElementClassMapper methodsFor: 'initialization'!
initialize
	super initialize.

	elementClassMap := Dictionary new.! !
!XMLBasicElementClassMapper methodsFor: 'mapping'!
mapElement: anElement attributeSpec: anAttributeSpec toClass: aClass
	| classOrCollection |

	classOrCollection :=
		elementClassMap
			at: anElement
			ifAbsent: [nil].

	classOrCollection isCollection
		ifTrue: [
			"new mappings have precedence over old"
			classOrCollection addFirst: anAttributeSpec -> aClass]
		ifFalse: [
			elementClassMap
				at: anElement
				put:
					(OrderedCollection
						with: anAttributeSpec -> aClass
						with: classOrCollection)].! !
!XMLBasicElementClassMapper methodsFor: 'mapping'!
mapElement: anElement namespaceURI: aURI attributeSpec: anAttributeSpec toClass: aClass
	self
		mapElement:
			(aURI size > 0
				ifTrue: [anElement -> aURI]
				ifFalse: [anElement])
		attributeSpec: anAttributeSpec
		toClass: aClass! !
!XMLBasicElementClassMapper methodsFor: 'mapping'!
mapElement: anElement namespaceURI: aURI toClass: aClass
	self
		mapElement:
			(aURI size > 0
				ifTrue: [anElement -> aURI]
				ifFalse: [anElement])
		toClass: aClass! !
!XMLBasicElementClassMapper methodsFor: 'mapping'!
mapElement: anElement toClass: aClass
	| classOrCollection |

	classOrCollection :=
		elementClassMap
			at: anElement
			ifAbsent: [nil].

	classOrCollection isCollection
		ifTrue: [
			classOrCollection
				at: classOrCollection size
				put: aClass]
		ifFalse: [
			elementClassMap
				at: anElement
				put: aClass].! !
!XMLBasicElementClassMapper methodsFor: 'copying'!
postCopy
	super postCopy.

	elementClassMap := elementClassMap copy.

	"each val is either a class or an OrderedCollection, which needs
	to be copied so new mappings in either the copy or original don't
	effect the other"
	elementClassMap associationsDo: [:each |
		each value isCollection
			ifTrue: [each value: each value copy]].! !
!XMLElementClassMapper methodsFor: 'private'!
camelCasedNameFromClassNameSegments: aNameSegmentCollection
	^ String streamContents: [:stream |
		aNameSegmentCollection withIndexDo: [:each :i |
			stream nextPutAll:
				(i > 1
					ifTrue: [each]
					ifFalse: [each asLowercase])]]! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName
	^ self
		classForElement: aQualifiedName
		ifNone: [nil]! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName attributes: anAssociationCollection
	^ self
		classForElement: aQualifiedName
		attributes: anAssociationCollection
		ifNone: [nil]! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName attributes: anAssociationCollection ifNone: aBlock
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName ifNone: aBlock
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI
	^ self
		classForElement: aQualifiedName
		namespaceURI: aURI
		ifNone: [nil]! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection
	^ self
		classForElement: aQualifiedName
		namespaceURI: aURI
		attributes: anAssociationCollection
		ifNone: [nil]! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection ifNone: aBlock
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI ifNone: aBlock
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection
	^ self
		classForElement: aQualifiedName
		namespaceURI: aURI
		localName: aLocalName
		attributes: anAssociationCollection
		ifNone: [nil]! !
!XMLElementClassMapper methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection ifNone: aBlock
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'private'!
classNameFrom: aClass withoutIgnorableSuffixes: aSuffixCollection
	| className |

	className := aClass name asString.
	aSuffixCollection do: [:each |
		(className endsWith: each)
			ifTrue: [^ className allButLast: each size]].
	^ className.! !
!XMLElementClassMapper methodsFor: 'private'!
classNameSegmentsFrom: aString
	| nameSegments startIndex |

	nameSegments := OrderedCollection new.
	startIndex := 1.
	1 to: aString size do: [:i |
		(((aString at: i) isLowercase
			and: [aString size >= (i + 1)
				and: [(aString at: i + 1) isLowercase not]])
			or: [
				((aString at: i) isUppercase
					and: [aString size >= (i + 2)
						and: [(aString at: i + 1) isUppercase
							and: [(aString at: i + 2) isUppercase not]]])])
			ifTrue: [
				nameSegments addLast:
					(aString
						copyFrom: startIndex
						to: i).
				startIndex := i + 1]].

	startIndex <= aString size
		ifTrue: [
			nameSegments addLast:
				(aString
					copyFrom: startIndex
					to: aString size)].

	^ nameSegments.! !
!XMLElementClassMapper methodsFor: 'private'!
hyphenatedNameFromClassNameSegments: aNameSegmentCollection
	^ String streamContents: [:stream |
		aNameSegmentCollection
			do: [:each | stream nextPutAll: each asLowercase]
			separatedBy: [stream nextPut: $-]]! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapAllMatchingElementsToClass: aClass ignoringSuffixes: aSuffixCollection
	| classNameWithoutSuffixes classNameSegments totalClassNameSegments |

	classNameWithoutSuffixes :=
		self
			classNameFrom: aClass
			withoutIgnorableSuffixes: aSuffixCollection.
	classNameSegments := self classNameSegmentsFrom: classNameWithoutSuffixes.
	(totalClassNameSegments := classNameSegments size) > 0
		ifFalse: [^ self].

	"remove the class prefix if any"
	totalClassNameSegments > 1
		ifTrue: [classNameSegments removeFirst].
	self
		mapElement:
			(self nameFromClassNameSegments: classNameSegments)
		toClass: aClass.
	self
		mapElement:
			(self camelCasedNameFromClassNameSegments: classNameSegments)
		toClass: aClass.
	self
		mapElement:
			(self hyphenatedNameFromClassNameSegments: classNameSegments)
		toClass: aClass.
	self
		mapElement:
			(self underscoredNameFromClassNameSegments: classNameSegments)
		toClass: aClass.! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapAllMatchingElementsToClasses: aClassCollection ignoringSuffixes: aSuffixCollection
	aClassCollection do: [:each |
		self
			mapAllMatchingElementsToClass: each
			ignoringSuffixes: aSuffixCollection]! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapElement: anElement attributeSpec: anAttributeSpec toClass: aClass
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapElement: anElement namespaceURI: aURI attributeSpec: anAttributeSpec toClass: aClass
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapElement: anElement namespaceURI: aURI toClass: aClass
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapElement: anElement toClass: aClass
	self subclassResponsibility! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapElements: anElementCollection namespaceURI: aNamespaceURI toClass: aClass
	anElementCollection do: [:each |
		self
			mapElement: each
			namespaceURI: aNamespaceURI
			toClass: aClass]! !
!XMLElementClassMapper methodsFor: 'mapping'!
mapElements: anElementCollection toClass: aClass
	anElementCollection do: [:each |
		self
			mapElement: each
			toClass: aClass]! !
!XMLElementClassMapper methodsFor: 'private'!
nameFromClassNameSegments: aNameSegmentCollection
	"avoid join: for Squeak/GS portability"
	^ String streamContents: [:stream |
		aNameSegmentCollection do: [:each | stream nextPutAll: each]]! !
!XMLElementClassMapper methodsFor: 'private'!
underscoredNameFromClassNameSegments: aNameSegmentCollection
	^ String streamContents: [:stream |
		aNameSegmentCollection
			do: [:each | stream nextPutAll: each asLowercase]
			separatedBy: [stream nextPut: $_]]! !
!XMLElementIDValidator methodsFor: 'accessing'!
elementsAndIDAttributes
	^ elementsAndIdAttributes ifNil: [elementsAndIdAttributes := Dictionary new]! !
!XMLElementIDValidator methodsFor: 'private'!
errorDuplicateID: anID inAttribute: anAttribute
	XMLValidationException
		formatSignal: 'Duplicate element ID "{1}" used in attribute "{2}"'
		with: anID
		with: anAttribute! !
!XMLElementIDValidator methodsFor: 'private'!
errorInvalidID: anID inAttribute: anAttribute
	XMLValidationException
		formatSignal: 'Invalid element ID value "{1}" in attribute "{2}"'
		with: anID
		with: anAttribute! !
!XMLElementIDValidator methodsFor: 'private'!
errorMultipleIDAttributesForElement: anElement
	XMLValidationException
		formatSignal: 'Element <{1}> has multiple ID attributes'
		with: anElement! !
!XMLElementIDValidator methodsFor: 'private'!
errorUnknownIDReference: anID
	XMLValidationException
		formatSignal: 'Reference to unknown element ID "{1}"'
		with: anID! !
!XMLElementIDValidator methodsFor: 'testing'!
hasIDReferences
	^ idReferences notNil
		and: [idReferences notEmpty]! !
!XMLElementIDValidator methodsFor: 'testing'!
hasIDs
	^ ids notNil
		and: [ids notEmpty]! !
!XMLElementIDValidator methodsFor: 'accessing'!
idReferences
	^ idReferences ifNil: [idReferences := Set new]! !
!XMLElementIDValidator methodsFor: 'accessing'!
ids
	^ ids ifNil: [ids := Set new]! !
!XMLElementIDValidator methodsFor: 'removing'!
removeIDReferences
	"Gemstone's Set does not understand removeAll, so nil reassignment
	is used instead (will be lazy initialized by accessors)"
	idReferences := nil! !
!XMLElementIDValidator methodsFor: 'removing'!
removeIDs
	"Gemstone's Set does not understand removeAll, so nil reassignment
	is used instead (will be lazy initialized by accessors)"
	ids := nil! !
!XMLElementIDValidator methodsFor: 'validating'!
validateID: anID inAttribute: anAttribute
	anID isXMLName
		ifFalse: [
			self
				errorInvalidID: anID
				inAttribute: anAttribute].
	self
		validateUniquenessOfID: anID
		inAttribute: anAttribute.! !
!XMLElementIDValidator methodsFor: 'validating'!
validateIDAttribute: anAttribute forElement: anElement
	| oldSize |

	"checking size after is faster than includes test"
	oldSize := self elementsAndIDAttributes size.
	(self elementsAndIDAttributes
		at: anElement
		put: anAttribute;
		size) > oldSize
		ifFalse: [self errorMultipleIDAttributesForElement: anElement].! !
!XMLElementIDValidator methodsFor: 'validating'!
validateIDReference: anID inAttribute: anAttribute
	anID isXMLName
		ifFalse: [
			self
				errorInvalidID: anID
				inAttribute: anAttribute].
	self idReferences add: anID.! !
!XMLElementIDValidator methodsFor: 'validating'!
validateIDReferences
	self idReferences do: [:each |
		(self ids includes: each)
			ifFalse: [self errorUnknownIDReference: each]]! !
!XMLElementIDValidator methodsFor: 'private'!
validateUniquenessOfID: anID inAttribute: anAttribute
	| oldSize |

	"checking size after is faster than includes test"
	oldSize := self ids size.
	(self ids
		add: anID;
		size) > oldSize
		ifFalse: [
			self
				errorDuplicateID: anID
				inAttribute: anAttribute].! !
!XMLElementIDValidator methodsFor: 'validating'!
validateXMLID: anID
	anID isXMLNCName
		ifFalse: [
			self
				errorInvalidID: anID
				inAttribute: 'xml:id'].
	self
		validateUniquenessOfID: anID
		inAttribute: 'xml:id'.! !
!XMLElementNester methodsFor: 'private'!
copiedScopedAttributes
	| copiedAttributes |

	copiedAttributes :=
		self hasScopedAttributes
			ifTrue: [self scopedAttributes removeLast copy]
			ifFalse: [Dictionary new].
	self scopedAttributes addLast: copiedAttributes.

	^ copiedAttributes.! !
!XMLElementNester methodsFor: 'accessing'!
currentElement
	^ self openElements xmlLastOrNil! !
!XMLElementNester methodsFor: 'accessing'!
currentElement: anElement
	self hasOpenElements
		ifTrue: [
			self openElements
				at: self totalOpenElements
				put: anElement]
		ifFalse: [self setExternalRootElement: anElement]! !
!XMLElementNester methodsFor: 'accessing'!
currentScopedAttributes
	^ self scopedAttributes xmlLastOrNil! !
!XMLElementNester methodsFor: 'private'!
elementPrintLimit
	^ 5! !
!XMLElementNester methodsFor: 'nesting'!
endCurrentElement
	(self openElements
		removeLast;
		size) > 0
		ifFalse: [
			isInElement := hasExternalRootElement.
			wasRootElementEnded := hasExternalRootElement not].
	self hasScopedAttributes
		ifTrue: [self endScopedAttributes].! !
!XMLElementNester methodsFor: 'private'!
endScopedAttributes
	scopedAttributes removeLast! !
!XMLElementNester methodsFor: 'testing'!
hasExternalRootElement
	^ hasExternalRootElement! !
!XMLElementNester methodsFor: 'testing'!
hasOpenElement: anElement
	^ self openElements includes: anElement! !
!XMLElementNester methodsFor: 'testing'!
hasOpenElements
	^ self openElements size > 0! !
!XMLElementNester methodsFor: 'testing'!
hasScopedAttributes
	"optimized to avoid lazy initialization"
	scopedAttributes == nil
		ifTrue: [^ false].
	^ scopedAttributes size > 0.! !
!XMLElementNester methodsFor: 'initialization'!
initialize
	super initialize.

	openElements := OrderedCollection new: 10.
	hasExternalRootElement := false.
	wasRootElementEnded := false.
	isInElement := false.! !
!XMLElementNester methodsFor: 'testing'!
isInElement
	^ isInElement! !
!XMLElementNester methodsFor: 'accessing'!
openElements
	^ openElements! !
!XMLElementNester methodsFor: 'enumerating'!
openElementsDo: aBlock
	self openElements do: aBlock! !
!XMLElementNester methodsFor: 'enumerating'!
openElementsReverseDo: aBlock
	"implemented for XMLParserHTML so it's always safe to remove at
	the end while scanning backwards"
	self openElements size to: 1 by: -1 do: [:i |
			aBlock value: (self openElements at: i)]! !
!XMLElementNester methodsFor: 'printing'!
printElementsOn: aStream
	self
		printElementsStartingAt: 1
		on: aStream! !
!XMLElementNester methodsFor: 'printing'!
printElementsStartingAt: aStart on: aStream
	self
		printElementsStartingAt: aStart
		stoppingAt: aStart + self elementPrintLimit - 1
		on: aStream! !
!XMLElementNester methodsFor: 'printing'!
printElementsStartingAt: aStart stoppingAt: aStop on: aStream
	aStart
		to: (aStop min: self openElements size)
		do: [:i |
			i > aStart
				ifTrue: [aStream nextPutAll: ', '].

			aStream
				nextPut: $<;
				nextPutAll: (self openElements at: i);
				nextPut: $>].

	(aStop < self openElements size)
		ifTrue: [aStream nextPutAll: '...'].! !
!XMLElementNester methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	self hasOpenElements
		ifTrue: [
			aStream nextPut: $(.
			self
				printElementsStartingAt: 1
				on: aStream.
			aStream nextPut: $)].! !
!XMLElementNester methodsFor: 'printing'!
printedElements
	^ String streamContents: [:stream | self printElementsOn: stream]! !
!XMLElementNester methodsFor: 'printing'!
printedElementsEnclosedBy: anElement
	^ String streamContents: [:stream |
		self
			printElementsStartingAt: (self openElements lastIndexOf: anElement) + 1
			on: stream]! !
!XMLElementNester methodsFor: 'accessing'!
rootElement
	^ rootElement! !
!XMLElementNester methodsFor: 'accessing'!
scopedAttributeAt: anAttribute
	^ self
		scopedAttributeAt: anAttribute
		ifAbsent: ['']! !
!XMLElementNester methodsFor: 'accessing'!
scopedAttributeAt: anAttribute ifAbsent: aBlock
	^ self currentScopedAttributes
		ifNil: [aBlock value]
		ifNotNil: [:attributes |
			attributes
				at: anAttribute
				ifAbsent: aBlock]! !
!XMLElementNester methodsFor: 'private'!
scopedAttributes
	^ scopedAttributes ifNil: [scopedAttributes := OrderedCollection new]! !
!XMLElementNester methodsFor: 'accessing'!
setExternalRootElement: anElement
	rootElement := anElement.
	hasExternalRootElement := true.
	isInElement := true.! !
!XMLElementNester methodsFor: 'accessing'!
setScopedAttributesNamed: anAttributeCollection from: aDictionary
	| attributes |

	anAttributeCollection do: [:each |
		aDictionary
			at: each
			ifPresent: [:value |
				"used to copy only once if needed"
				(attributes ifNil: [attributes := self copiedScopedAttributes])
					at: each
					put: value]]! !
!XMLElementNester methodsFor: 'nesting'!
startElement: anElement
	self openElements addLast: anElement.
	isInElement
		ifFalse: [
			isInElement := true.
			rootElement
				ifNil: [rootElement := anElement]].
	self hasScopedAttributes
		ifTrue: [self startScopedAttributes].! !
!XMLElementNester methodsFor: 'private'!
startScopedAttributes
	scopedAttributes addLast: self currentScopedAttributes! !
!XMLElementNester methodsFor: 'accessing'!
totalOpenElements
	^ self openElements size! !
!XMLElementNester methodsFor: 'testing'!
wasRootElementEnded
	^ wasRootElementEnded! !
!XMLAnyElementValidator methodsFor: 'testing'!
atEnd
	^ true! !
!XMLAnyElementValidator methodsFor: 'testing'!
isAny
	^ true! !
!XMLAnyElementValidator methodsFor: 'defaults'!
typeName
	^ 'ANY'! !
!XMLDFAElementContentElementValidator methodsFor: 'testing'!
ignoresWhitespace
	^ true! !
!XMLDFAElementContentElementValidator methodsFor: 'testing'!
isElementContent
	^ true! !
!XMLDFAElementContentElementValidator methodsFor: 'defaults'!
typeName
	^ 'element content'! !
!XMLDFAElementContentElementValidator methodsFor: 'validating'!
validatePCData: aString
	self errorUnexpectedPCData! !
!XMLStandaloneExternalDFAElementContentElementValidator methodsFor: 'testing'!
ignoresWhitespace
	^ false! !
!XMLDFAElementValidator class methodsFor: 'instance creation'!
element: anElement dfa: aDFA
	^ self new
		setElement: anElement
		dfa: aDFA! !
!XMLDFAElementValidator methodsFor: 'converting'!
asReadyElementValidator
	^ self copy! !
!XMLDFAElementValidator methodsFor: 'testing'!
atEnd
	^ currentState isAccepting! !
!XMLDFAElementValidator methodsFor: 'accessing'!
currentState
	^ currentState! !
!XMLDFAElementValidator methodsFor: 'accessing'!
dfa
	^ dfa! !
!XMLDFAElementValidator methodsFor: 'private'!
errorNonDeterminismInContentModelAfter: anElement
	XMLValidationException
		formatSignal:
			'Content model for <{1}> becomes non-deterministic after <{2}>. ',
			'Rewrite it deterministically; for example "{3}" instead ',
			'of "{4}"'
		with: self element
		with: anElement
		with: '(a,(b|c))'
		with: '((a,b)|(a,c))'! !
!XMLDFAElementValidator methodsFor: 'copying'!
postCopy
	currentState := dfa! !
!XMLDFAElementValidator methodsFor: 'initialization'!
setElement: anElement dfa: aDFA
	element := anElement.
	dfa := aDFA.
	currentState := aDFA.! !
!XMLDFAElementValidator methodsFor: 'validating'!
validateStartTag: anElement
	currentState :=
		currentState
			nextDFAStateMatching: anElement
			ifNone: [self errorUnexpectedElement: anElement].
	currentState hasNonDeterminism
		ifTrue: [self errorNonDeterminismInContentModelAfter: anElement].! !
!XMLElementValidator class methodsFor: 'instance creation'!
element: anElement
	^ self new element: anElement! !
!XMLElementValidator methodsFor: 'converting'!
asReadyElementValidator
	^ self! !
!XMLElementValidator methodsFor: 'testing'!
atEnd
	self subclassResponsibility! !
!XMLElementValidator methodsFor: 'accessing'!
element
	^ element! !
!XMLElementValidator methodsFor: 'accessing'!
element: anElement
	element := anElement! !
!XMLElementValidator methodsFor: 'private'!
errorUnexpected: aDescription
	XMLValidationException
		formatSignal: 'Unexpected {1} in {2} type element <{3}>'
		with: aDescription
		with: self typeName
		with: self element! !
!XMLElementValidator methodsFor: 'private'!
errorUnexpectedComment
	^ self errorUnexpected: 'comment'! !
!XMLElementValidator methodsFor: 'private'!
errorUnexpectedElement: anElement
	XMLValidationException
		formatSignal: 'Unexpected <{1}> element in {2} type element <{3}>'
		with: anElement
		with: self typeName
		with: self element! !
!XMLElementValidator methodsFor: 'private'!
errorUnexpectedPCData
	^ self errorUnexpected: 'PCDATA'! !
!XMLElementValidator methodsFor: 'private'!
errorUnexpectedPI
	^ self errorUnexpected: 'processing instruction'! !
!XMLElementValidator methodsFor: 'testing'!
ignoresWhitespace
	^ false! !
!XMLElementValidator methodsFor: 'testing'!
isAny
	^ false! !
!XMLElementValidator methodsFor: 'testing'!
isElementContent
	^ false! !
!XMLElementValidator methodsFor: 'testing'!
isEmpty
	^ false! !
!XMLElementValidator methodsFor: 'testing'!
isMixedContent
	^ false! !
!XMLElementValidator methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPutAll: '(<';
		nextPutAll: self element;
		nextPutAll: '>)'.! !
!XMLElementValidator methodsFor: 'defaults'!
typeName
	self subclassResponsibility! !
!XMLElementValidator methodsFor: 'validating'!
validateComment: aString! !
!XMLElementValidator methodsFor: 'validating'!
validateElementDeclaration! !
!XMLElementValidator methodsFor: 'validating'!
validatePCData: aString! !
!XMLElementValidator methodsFor: 'validating'!
validatePI: aTargetString data: aDataString! !
!XMLElementValidator methodsFor: 'validating'!
validateStartTag: anElement! !
!XMLEmptyElementValidator methodsFor: 'testing'!
atEnd
	^ true! !
!XMLEmptyElementValidator methodsFor: 'testing'!
isEmpty
	^ true! !
!XMLEmptyElementValidator methodsFor: 'defaults'!
typeName
	^ 'EMPTY'! !
!XMLEmptyElementValidator methodsFor: 'validating'!
validateComment: aString
	self errorUnexpectedComment! !
!XMLEmptyElementValidator methodsFor: 'validating'!
validatePCData: aString
	self errorUnexpectedPCData! !
!XMLEmptyElementValidator methodsFor: 'validating'!
validatePI: aTargetString data: aDataString
	self errorUnexpectedPI! !
!XMLEmptyElementValidator methodsFor: 'validating'!
validateStartTag: anElement
	self errorUnexpectedElement: anElement! !
!XMLMixedContentElementValidator class methodsFor: 'instance creation'!
element: anElement allowedContent: anAllowedContentCollection
	^ self new
		setElement: anElement
		allowedContent: anAllowedContentCollection! !
!XMLMixedContentElementValidator methodsFor: 'accessing'!
allowedContent
	^ allowedContent! !
!XMLMixedContentElementValidator methodsFor: 'accessing'!
allowedContent: anAllowedContentCollection
	allowedContent := anAllowedContentCollection! !
!XMLMixedContentElementValidator methodsFor: 'testing'!
atEnd
	^ true! !
!XMLMixedContentElementValidator methodsFor: 'private'!
errorContentContainsDuplicates
	XMLValidationException
		formatSignal:
			'Declaration for mixed content element <{1}> contains duplicate names'
		with: self element! !
!XMLMixedContentElementValidator methodsFor: 'testing'!
isMixedContent
	^ true! !
!XMLMixedContentElementValidator methodsFor: 'initialization'!
setElement: anElement allowedContent: anAllowedContentCollection
	element := anElement.
	allowedContent := anAllowedContentCollection.! !
!XMLMixedContentElementValidator methodsFor: 'defaults'!
typeName
	^ 'mixed content'! !
!XMLMixedContentElementValidator methodsFor: 'validating'!
validateElementDeclaration
	| oldAllowedContentCollection |

	oldAllowedContentCollection := self allowedContent.
	self allowedContent: oldAllowedContentCollection asSet.
	(self allowedContent size < oldAllowedContentCollection size)
		ifTrue: [self errorContentContainsDuplicates].! !
!XMLMixedContentElementValidator methodsFor: 'validating'!
validateStartTag: anElement
	(self allowedContent includes: anElement)
		ifFalse: [self errorUnexpectedElement: anElement]
	! !
!XMLEncodingDetector class methodsFor: 'class initialization'!
initialize
	"self initialize"

	"stored in class vars for faster access"
	UTF8BOMBytes :=
		XMLUTF8StreamConverter byteOrderMarkBytes.
	UTF16BigEndianBOMBytes :=
		XMLUTF16BigEndianStreamConverter byteOrderMarkBytes.
	UTF32BigEndianBOMBytes :=
		XMLUTF32BigEndianStreamConverter byteOrderMarkBytes.
	UTF32LittleEndianBOMBytes :=
		XMLUTF32LittleEndianStreamConverter byteOrderMarkBytes.! !
!XMLEncodingDetector class methodsFor: 'instance creation'!
on: aStream
	^ self new on: aStream! !
!XMLEncodingDetector methodsFor: 'private'!
atEnd
	^ stream atEnd! !
!XMLEncodingDetector methodsFor: 'private'!
detectBigEndianUTF16BOM
	2 to: UTF16BigEndianBOMBytes size do: [:i |
		self next == (UTF16BigEndianBOMBytes at: i)
			ifFalse: [
				self resetStreamToStartPosition.
				"no legal UTF-8 byte sequence begins with 16rFE, and:
					UTF16BigEndianBOMBytes first = 16rFE
				so it can't be implicit UTF-8"
				^ nil]].
	^ XMLUTF16BigEndianStreamConverter new.! !
!XMLEncodingDetector methodsFor: 'private'!
detectBigEndianUTF32BOMOrImplicitEncoding
	2 to: UTF32BigEndianBOMBytes size do: [:i |
		self peek == (UTF32BigEndianBOMBytes at: i)
			ifTrue: [self next]
			ifFalse: [| implicitConverterClass |
				self detectsImplicitEncodings
					ifTrue: [
						i = 2
							ifTrue: [
								"(UTF32BigEndianBOMBytes at: 1) isZero"
								self peekForASCII
									ifTrue: [
										"null char followed by an ASCII char;
										implicit UTF-16 BE"
										implicitConverterClass :=
											XMLImplicitUTF16BigEndianStreamConverter]]
							ifFalse: [
								i = 3
									ifTrue: [
										"(UTF32BigEndianBOMBytes at: 2) isZero"
										(self peekForNull
											and: [self peekForASCII]) 
											ifTrue: [
												"three null chars followed by an ASCII char;
												implicit UTF-32 BE"
												implicitConverterClass :=
													XMLImplicitUTF32BigEndianStreamConverter]]].
						(implicitConverterClass isNil
							and: [self peekForUTF8LeadingByte])
							ifTrue: [
								"any number of null chars followed by a leading UTF-8
								byte char; implicit UTF-8"
								implicitConverterClass :=
									XMLImplicitUTF8StreamConverter]].
				self resetStreamToStartPosition.
				^ implicitConverterClass
					ifNotNil: [implicitConverterClass new]]].
	^ XMLUTF32BigEndianStreamConverter new.! !
!XMLEncodingDetector methodsFor: 'private'!
detectLittleEndianImplicitEncoding
	| implicitConverterClass |

	self detectsImplicitEncodings
		ifTrue: [
			implicitConverterClass :=
				self peekForNull
					ifTrue: [		
						(self peekForNull
							and: [self peekForNull])
							ifTrue: [
								"a leading ASCII char followed by three nulls;
								implicit little endian UTF-32"
								XMLImplicitUTF32LittleEndianStreamConverter]
							ifFalse: [
								"a leading ASCII char followed by just one null;
								implicit little endian UTF-16"
								XMLImplicitUTF16LittleEndianStreamConverter]]
					ifFalse: [
						"an ASCII char; assume it's UTF-8"
						XMLImplicitUTF8StreamConverter]].

	self resetStreamToStartPosition.
	^ implicitConverterClass
		ifNotNil: [implicitConverterClass new].! !
!XMLEncodingDetector methodsFor: 'private'!
detectLittleEndianUTF32Or16BOM
	2 to: UTF32LittleEndianBOMBytes size do: [:i |
		self peek == (UTF32LittleEndianBOMBytes at: i)
			ifTrue: [self next]
			ifFalse: [
				i > 2
					ifTrue: [
						"the 2 byte UTF-16 BOM begins the 4 byte UTF-32 BOM:
							UTF32LittleEndianBOMBytes beginsWith:
								XMLUTF16LittleEndianStreamConverter byteOrderMarkBytes"
						stream position: startPosition + 2.
						^ XMLUTF16LittleEndianStreamConverter new]
					ifFalse: [
						self resetStreamToStartPosition.
						"no legal UTF-8 byte sequence begins with 16rFF, and:
							UTF32LittleEndianBOMBytes first = 16rFF
						so it can't be implicit UTF-8"
						^ nil]]].
	^ XMLUTF32LittleEndianStreamConverter new.! !
!XMLEncodingDetector methodsFor: 'private'!
detectUTF8BOM
	2 to: UTF8BOMBytes size do: [:i |
		self peek == (UTF8BOMBytes at: i)
			ifTrue: [self next]
			ifFalse: [| implicitConverter |
				(self detectsImplicitEncodings
					and: [self peekForUTF8NonLeadingByte])
					ifTrue: [implicitConverter := XMLImplicitUTF8StreamConverter new].
				self resetStreamToStartPosition.
				^ implicitConverter]].
	^ XMLUTF8StreamConverter new.! !
!XMLEncodingDetector methodsFor: 'testing'!
detectsImplicitEncodings
	^ false! !
!XMLEncodingDetector methodsFor: 'private'!
isUTF8LeadingByte: aByte
	^ aByte < 16r80
		or: [aByte < 16rF8
			and: [(aByte bitAnd: 16rE0) == 16rC0
				or: [(aByte bitAnd: 16rF0) == 16rE0
					or: [(aByte bitAnd: 16rF8) == 16rF0]]]]! !
!XMLEncodingDetector methodsFor: 'private'!
next
	stream atEnd
		ifTrue: [^ nil]
		ifFalse: [^ stream next asInteger]! !
!XMLEncodingDetector methodsFor: 'initialization'!
on: aStream
	stream := aStream.
	startPosition := aStream position.! !
!XMLEncodingDetector methodsFor: 'private'!
peek
	stream atEnd
		ifTrue: [^ nil]
		ifFalse: [^ stream peek asInteger]! !
!XMLEncodingDetector methodsFor: 'private'!
peekForASCII
	| byte |

	((byte := self peek) notNil
		and: [byte < 16r80])
		ifTrue: [
			self next.
			^ true]
		ifFalse: [^ false]! !
!XMLEncodingDetector methodsFor: 'private'!
peekForNull
	self peek == 0
		ifTrue: [
			self next.
			^ true]
		ifFalse: [^ false]! !
!XMLEncodingDetector methodsFor: 'private'!
peekForUTF8LeadingByte
	| byte |

	((byte := self peek) notNil
		and: [self isUTF8LeadingByte: byte])
		ifTrue: [
			self next.
			^ true]
		ifFalse: [^ false]! !
!XMLEncodingDetector methodsFor: 'private'!
peekForUTF8NonLeadingByte
	| byte |

	((byte := self peek) notNil
		and: [byte < 16rC0
			and: [byte > 16r80]])
		ifTrue: [
			self next.
			^ true]
		ifFalse: [^ false]! !
!XMLEncodingDetector methodsFor: 'private'!
resetStreamToStartPosition
	stream position: startPosition! !
!XMLEncodingDetector methodsFor: 'detecting'!
streamConverterForEncoding
	| byte |

	(byte := self next)
		ifNil: [^ nil].

	byte == 0
		ifTrue: [^ self detectBigEndianUTF32BOMOrImplicitEncoding].

	byte < 16r80
		ifTrue: [^ self detectLittleEndianImplicitEncoding].

	"(UTF8BOMBytes at: 1) >= 16r80"
	byte == (UTF8BOMBytes at: 1)
		ifTrue: [^ self detectUTF8BOM].

	"(UTF16BigEndianBOMBytes at: 1) >= 16r80"
	byte == (UTF16BigEndianBOMBytes at: 1)
		ifTrue: [^ self detectBigEndianUTF16BOM].

	"(UTF32LittleEndianBOMBytes at: 1) >= 16r80"
	byte == (UTF32LittleEndianBOMBytes at: 1)
		ifTrue: [^ self detectLittleEndianUTF32Or16BOM].

	self resetStreamToStartPosition.
	^ (self detectsImplicitEncodings
		and: [self isUTF8LeadingByte: byte])
		ifTrue: [XMLImplicitUTF8StreamConverter new]
		ifFalse: [nil].! !
!XMLImplicitEncodingDetector methodsFor: 'testing'!
detectsImplicitEncodings
	^ true! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'basic'!
basicCanDecompressCompression: aCompressionScheme
	^ self compressionScheme = aCompressionScheme
		and: [self isSupportedImplementation]! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'testing'!
canDecompressCompression: aCompressionScheme
	^ self basicCanDecompressCompression: aCompressionScheme asLowercase! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!
classForCompression: aCompressionScheme
	| lowercaseCompressionScheme |

	lowercaseCompressionScheme := aCompressionScheme asLowercase.
	self allSubclassesDo: [:each |
		(each basicCanDecompressCompression: lowercaseCompressionScheme)
			ifTrue: [^ each]].
	^ nil.! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!
compressionScheme
	self subclassResponsibility! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!
decompressingReadStreamAdapterClass
	self subclassResponsibility! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'private '!
errorUnsupportedCompression: aCompressionScheme
	XMLHTTPException
		formatSignal: 'Unsupported compression scheme "{1}" for HTTP content'
		with: aCompressionScheme! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'testing'!
isSupportedImplementation
	^ self decompressingReadStreamAdapterClass notNil! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'instance creation'!
on: aReadStream
	^ self decompressingReadStreamAdapterClass on: aReadStream! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'instance creation'!
on: aReadStream compression: aCompressionScheme
	^ (self classForCompression: aCompressionScheme)
		ifNil: [self errorUnsupportedCompression: aCompressionScheme]
		ifNotNil: [:classForCompression |
			classForCompression on: aReadStream]! !
!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!
supportedCompressionSchemes
	| supportedCompressionSchemes |

	supportedCompressionSchemes := OrderedCollection new.
	self allSubclassesDo: [:each |
		each isSupportedImplementation
			ifTrue: [supportedCompressionSchemes addLast: each compressionScheme]].
	^ supportedCompressionSchemes.! !
!XMLHTTPGZipDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!
compressionScheme
	^ 'gzip'! !
!XMLHTTPGZipDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!
decompressingReadStreamAdapterClass
	^ XMLClassFinder classNamed: #GZipReadStream! !
!XMLHTTPMIMEType class methodsFor: 'defaults'!
defaultCharset
	^ 'ISO-8859-1'! !
!XMLHTTPMIMEType class methodsFor: 'instance creation'!
fromString: aString
	| parser |

	parser := XMLHTTPMIMETypeParser on: aString.
	^ self new
		setMainType: parser parseMainType
		subType: parser parseSubType
		parameters: parser parseParameters.! !
!XMLHTTPMIMEType class methodsFor: 'instance creation'!
mainType: aMainType subType: aSubType
	^ self
		mainType: aMainType
		subType: aSubType
		parameters: #()! !
!XMLHTTPMIMEType class methodsFor: 'instance creation'!
mainType: aMainType subType: aSubType parameters: anAssociationCollection
	| parameters attributes totalAttributes |

	"convert the parameters to an OrderedCollection of attribute=value
	associations, ignoring duplicate attributes"
	parameters := OrderedCollection new: anAssociationCollection size.
	totalAttributes := 0.
	anAssociationCollection associationsDo: [:each | | attribute |
		attribute := each key asLowercase.
		"only initialize if needed"
		((attributes ifNil: [attributes := Set new])
			add: attribute;
			size) > totalAttributes
			ifTrue: [
				parameters addLast: attribute -> each value.
				totalAttributes := totalAttributes + 1]].

	^ self new
		setMainType: aMainType asLowercase
		subType: aSubType asLowercase
		parameters: parameters.! !
!XMLHTTPMIMEType methodsFor: 'comparing'!
= anObject
	self == anObject
		ifTrue: [^ true].

	self species == anObject species
		ifFalse: [^ false].

	^ self mainType = anObject mainType
		and: [self subType = anObject subType
			and: [self parameters size = anObject parameters size
				and: [
					"order is irrelevant according to the spec"
					self parameters asSet = anObject parameters asSet]]].! !
!XMLHTTPMIMEType methodsFor: 'converting'!
asString
	"don't assume Object>>#asString is defined, for portability"
	^ self printString! !
!XMLHTTPMIMEType methodsFor: 'accessing'!
charset
	^ self
		parameterAt: 'charset'
		ifAbsent: [self defaultCharset]! !
!XMLHTTPMIMEType methodsFor: 'defaults'!
defaultCharset
	^ self class defaultCharset! !
!XMLHTTPMIMEType methodsFor: 'comparing'!
hash
	^ self species hash bitXor:
		(self mainType hash bitXor:
			(self subType hash bitXor:
				"OrderedCollection>>#hash depends on order (and even if it
				didn't, assuming it wouldn't in the future is too risky),
				so instead the size is hashed"
				self parameters size hash))! !
!XMLHTTPMIMEType methodsFor: 'accessing'!
mainType
	^ mainType! !
!XMLHTTPMIMEType methodsFor: 'accessing'!
parameterAt: aKey
	^ self
		parameterAt: aKey
		ifAbsent: ['']! !
!XMLHTTPMIMEType methodsFor: 'accessing'!
parameterAt: aKey ifAbsent: aBlock
	self parameterKeysAndValuesDo: [:key :value |
		key = aKey
			ifTrue: [^ value]].
	^ aBlock value.! !
!XMLHTTPMIMEType methodsFor: 'enumerating'!
parameterKeysAndValuesDo: aTwoArgumentBlock
	self parameters do: [:each |
		aTwoArgumentBlock
			value: each key
			value: each value]! !
!XMLHTTPMIMEType methodsFor: 'enumerating'!
parameterKeysDo: aBlock
	self parameters do: [:each |
		aBlock value: each key]! !
!XMLHTTPMIMEType methodsFor: 'private'!
parameters
	^ parameters! !
!XMLHTTPMIMEType methodsFor: 'printing'!
printOn: aStream
	aStream
		nextPutAll: self mainType;
		nextPut: $/;
		nextPutAll: self subType.

	self parameterKeysAndValuesDo: [:key :value |
		aStream
			nextPutAll: '; ';
			nextPutAll: key;
			nextPut: $=;
			nextPutAll: value].! !
!XMLHTTPMIMEType methodsFor: 'initialization'!
setMainType: aMainType subType: aSubType parameters: aParameterCollection
	mainType := aMainType.
	subType := aSubType.
	parameters := aParameterCollection.! !
!XMLHTTPMIMEType methodsFor: 'accessing'!
subType
	^ subType! !
!XMLHTTPResponseContentReader class methodsFor: 'accessing'!
response: aResponse
	^ self new setResponse: aResponse! !
!XMLHTTPResponseContentReader methodsFor: 'private'!
contentReadStreamUpToEnd
	| contentWriteStream |

	contentWriteStream := self newContentWriteStream.
	[contentReadStream atEnd]
		whileFalse: [contentWriteStream nextPut: contentReadStream next].
	^ contentWriteStream contents.! !
!XMLHTTPResponseContentReader methodsFor: 'private'!
decodedContentReadStreamUpToEndWithCharset: aCharset
	| streamConverter |

	(streamConverter := aCharset asXMLStreamConverter) isNull
		ifTrue: [self errorUnrecognizedContentTypeCharset: aCharset].

	contentReadStream :=
		XMLDecodingReadStreamAdapter
			on: contentReadStream
			streamConverter: streamConverter.

	[^ self contentReadStreamUpToEnd]
		on: XMLEncodingException
		do: [:error |
			"might actually be a limit exception"
			self ensureContentReadStreamWasNotLimited.

			error pass].! !
!XMLHTTPResponseContentReader methodsFor: 'private'!
ensureContentReadStreamWasNotLimited
	(limitedContentReadStream notNil
		and: [limitedContentReadStream atLimitedEnd])
		ifTrue: [self errorContentLimitExceeded]! !
!XMLHTTPResponseContentReader methodsFor: 'private'!
errorContentLimitExceeded
	XMLLimitException signal: 'HTTP reponse content limit exceeded'! !
!XMLHTTPResponseContentReader methodsFor: 'private'!
errorUnrecognizedContentTypeCharset: aCharset
	XMLEncodingException
		formatSignal:
			'Unrecognized Content-Type charset "{1}" encoding for HTTP content'
		with: aCharset! !
!XMLHTTPResponseContentReader methodsFor: 'testing'!
handlesDecompression
	^ false! !
!XMLHTTPResponseContentReader methodsFor: 'initialization'!
initializeDecompressionWithSchemes: aCompressionSchemeSequence upToLimit: aMaxSize
	isDecompressing := true.
	aCompressionSchemeSequence reverseDo: [:each |
		contentReadStream :=
			XMLHTTPDecompressingReadStreamAdapterFactory
				on: contentReadStream
				compression: each].
	aMaxSize
		ifNotNil: [self limitContentReadStreamUpToLimit: aMaxSize].! !
!XMLHTTPResponseContentReader methodsFor: 'accessing'!
limitContentReadStreamUpToLimit: aMaxSize
	limitedContentReadStream :=
		XMLLimitedReadStreamAdapter
			on: contentReadStream
			limit: aMaxSize.
	contentReadStream := limitedContentReadStream.! !
!XMLHTTPResponseContentReader methodsFor: 'instance creation'!
newContentWriteStream
	^ (String new: rawContent size) writeStream! !
!XMLHTTPResponseContentReader methodsFor: 'reading'!
rawReadWithLength: aContentLength upToLimit: aMaxSize
	self subclassResponsibility! !
!XMLHTTPResponseContentReader methodsFor: 'reading'!
readUpToLimit: aMaxSize decoding: aBoolean
	| contentLength contentType compressionSchemes charset content |

	contentLength := response contentLength.
	(response isChunked
		or: [contentLength isNil])
		ifTrue: [contentLength := nil]
		ifFalse: [
			contentLength > 0
				ifFalse: [^ ''].
			(aMaxSize notNil
				and: [contentLength > aMaxSize])
				ifTrue: [self errorContentLimitExceeded]].
	rawContent :=
		self
			rawReadWithLength: contentLength
			upToLimit: aMaxSize.
	contentReadStream := rawContent readStream.

	(self handlesDecompression
		and: [(compressionSchemes := response contentEncoding) notEmpty])
		ifTrue: [
			self
				initializeDecompressionWithSchemes: compressionSchemes
				upToLimit: aMaxSize].

	(aBoolean
		and: [(contentType := response contentType) notNil
			and: [(charset := contentType charset) ~= contentType defaultCharset]])
		ifTrue: [
			content := self decodedContentReadStreamUpToEndWithCharset: charset]
		ifFalse: [
			content := self undecodedContentReadStreamUpToEnd].

	self ensureContentReadStreamWasNotLimited.
	^ content.! !
!XMLHTTPResponseContentReader methodsFor: 'initialization'!
setResponse: aResponse
	response := aResponse.
	isDecompressing := false.! !
!XMLHTTPResponseContentReader methodsFor: 'streaming'!
undecodedContentReadStreamUpToEnd
	^ (isDecompressing
		or: [limitedContentReadStream notNil])
		ifTrue: [self contentReadStreamUpToEnd]
		ifFalse: [rawContent]! !
!XMLHTTPWebClientResponseContentReader methodsFor: 'testing'!
handlesDecompression
	"this class needs to handle decompression, since it uses the lower-level
	WebClient #streamFrom:to:size:progress: interface"
	^ true! !
!XMLHTTPWebClientResponseContentReader methodsFor: 'reading'!
rawReadWithLength: aContentLength upToLimit: aMaxSize
	| socketStream rawContentWriteStream |

	(socketStream := response webClientResponse stream) binary.
	rawContentWriteStream :=
		(ByteArray new:
			(aContentLength
				ifNil: [aMaxSize
					ifNil: [4096]])) writeStream.
	response webClientResponse
		streamFrom: socketStream
		to: rawContentWriteStream
		size: aContentLength
		progress:
			((aContentLength isNil
				and: [aMaxSize notNil])
				ifTrue: [
					[:ignored :total |
						total > aMaxSize
							ifTrue: [self errorContentLimitExceeded]]]
				ifFalse: [nil]).
	^ rawContentWriteStream contents.! !
!XMLHTTPZincResponseContentReader methodsFor: 'reading'!
rawReadWithLength: aContentLength upToLimit: aMaxSize
	^ [| entityStream |
		(entityStream := response zincResponse entity stream) binary.
		ZnUtils
			readUpToEnd: entityStream
			limit: aMaxSize]
		on: ZnEntityTooLarge
		do: [:error | self errorContentLimitExceeded]! !
!XMLIntegerReader class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self initializeCharacterDigitValues! !
!XMLIntegerReader class methodsFor: 'class initialization'!
initializeCharacterDigitValues
	| temp |

	"use an array instead of a dictionary for speed, and use a temp
	to fully initialize it before assignment to avoid possible race
	conditions during class reinitialization"
	temp := Array new: 255.
	#(#($0 $9 0) #($a $f 10) #($A $Z 10)) do: [:each |
		| firstDigitValue lastDigitValue baseValue |
		firstDigitValue := each first asciiValue.
		lastDigitValue := each second asciiValue.
		baseValue := each third.
		firstDigitValue
			to: lastDigitValue
			do: [:i |
				temp
					at: i
					put: i - firstDigitValue + baseValue]].
	CharacterDigitValues := temp.! !
!XMLIntegerReader class methodsFor: 'defaults'!
maxBase
	^ 16! !
!XMLIntegerReader class methodsFor: 'defaults'!
maxIntegerValue
	^ nil! !
!XMLIntegerReader class methodsFor: 'instance creation'!
on: aStringOrStream
	^ self new on: aStringOrStream! !
!XMLIntegerReader class methodsFor: 'instance creation'!
readFrom: aStream
	^ (self on: aStream) nextInteger! !
!XMLIntegerReader class methodsFor: 'reading'!
readFrom: aStream withBase: aBase
	^ (self on: aStream) nextIntegerWithBase: aBase! !
!XMLIntegerReader class methodsFor: 'reading'!
readFrom: aStream withBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase
	^ (self on: aStream)
		nextIntegerWithBase: aFirstBase
		andPrefixes: aCharacterCollection
		orBase: aSecondBase! !
!XMLIntegerReader class methodsFor: 'reading'!
readFrom: aStream withBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase upToLimit: aReadLimit
	^ (self on: aStream)
		nextIntegerWithBase: aFirstBase
		andPrefixes: aCharacterCollection
		orBase: aSecondBase
		upToLimit: aReadLimit! !
!XMLIntegerReader class methodsFor: 'reading'!
readFrom: aStream withBase: aBase upToLimit: aReadLimit
	^ (self on: aStream)
		nextIntegerWithBase: aBase
		upToLimit: aReadLimit! !
!XMLIntegerReader methodsFor: 'testing'!
atEnd
	^ readStream atEnd! !
!XMLIntegerReader methodsFor: 'private'!
errorUnsupportedBase: aBase
	Error signal: 'Unsupported base ', aBase printString! !
!XMLIntegerReader methodsFor: 'private'!
next
	| nextChar |

	self atEnd
		ifFalse: [
			nextChar := readStream next.
			printStream
				ifNotNil: [printStream nextPut: nextChar]].
	^ nextChar.! !
!XMLIntegerReader methodsFor: 'private'!
nextDigitWithBase: aBase
	| asciiValue digit |

	((asciiValue := self peek asciiValue) > 0
		and: [asciiValue <= CharacterDigitValues size
			and: [(digit := CharacterDigitValues at: asciiValue) notNil
				and: [digit < aBase]]])
				ifTrue: [
					self next.
					^ digit]
				ifFalse: [^ nil]! !
!XMLIntegerReader methodsFor: 'reading'!
nextInteger
	^ self nextIntegerWithBase: 10! !
!XMLIntegerReader methodsFor: 'reading'!
nextIntegerWithBase: aBase
	^ self
		nextIntegerWithBase: aBase
		upToLimit: nil! !
!XMLIntegerReader methodsFor: 'reading'!
nextIntegerWithBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase
	^ self
		nextIntegerWithBase: aFirstBase
		andPrefixes: aCharacterCollection
		orBase: aSecondBase
		upToLimit: nil! !
!XMLIntegerReader methodsFor: 'reading'!
nextIntegerWithBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase upToLimit: aReadLimit
	^ self
		nextIntegerWithBase:
			((self atEnd not
				and: [aCharacterCollection includes: self peek])
				ifTrue: [
					self next.
					aFirstBase]
				ifFalse: [aSecondBase])
		upToLimit: aReadLimit! !
!XMLIntegerReader methodsFor: 'reading'!
nextIntegerWithBase: aBase upToLimit: aReadLimit
	| integer maxValue maxBaseValue digitValue readLimit |

	(aBase > 1
		and: [aBase <= self class maxBase])
		ifFalse: [self errorUnsupportedBase: aBase].

	self class maxIntegerValue
		ifNotNil: [:maxIntegerValue |
			maxValue := maxIntegerValue.
			maxBaseValue := (maxValue / aBase) floor].
	readLimit := aReadLimit.
	[self atEnd
		or: [(readLimit notNil and: [readLimit <= 0])
			or: [(digitValue := self nextDigitWithBase: aBase) isNil]]]
		whileFalse: [
			integer
				ifNil: [integer := 0].
	
			maxBaseValue
				ifNotNil: [
					integer > maxBaseValue
						ifTrue: [
							self overflowed.
							"handle overflow with saturation"
							^ maxValue]].
			integer := integer * aBase.

			maxValue
				ifNotNil: [
					integer > (maxValue - digitValue)
						ifTrue: [
							self overflowed.
							"handle overflow with saturation"
							^ maxValue]].
			integer := integer + digitValue.
			readLimit
				ifNotNil: [readLimit := readLimit - 1]].
	^ integer.! !
!XMLIntegerReader methodsFor: 'initialization'!
on: aStringOrStream
	readStream :=
		aStringOrStream isStream
			ifTrue: [aStringOrStream]
			ifFalse: [aStringOrStream readStream]! !
!XMLIntegerReader methodsFor: 'private'!
overflowed
	"can override to raise a warning or error"! !
!XMLIntegerReader methodsFor: 'private'!
peek
	self atEnd
		ifTrue: [^ nil]
		ifFalse: [^ readStream peek]! !
!XMLIntegerReader methodsFor: 'accessing'!
printStream: aStream
	printStream := aStream! !
!XMLSmallIntegerReader class methodsFor: 'class initialization'!
initialize
	"self initialize"

	SmallIntegerMaxValue := SmallInteger maxVal! !
!XMLSmallIntegerReader class methodsFor: 'defaults'!
maxIntegerValue
	^ SmallIntegerMaxValue! !
!XMLNFABuilder methodsFor: 'applying'!
applyAccepting
	| totalFragments |

	(totalFragments := self totalFragments) > 0
		ifTrue: [
			1 to: totalFragments - 1 do: [:i |
				self applyConcatenation].
			self topFragment connectToState:
				XMLNFAAcceptingState new]
		ifFalse: [
			self pushFragment:
				(XMLNFAFragment firstState: XMLNFAAcceptingState new)]! !
!XMLNFABuilder methodsFor: 'applying'!
applyBranch
	| leftFragment rightFragment branchState |

	leftFragment := self popFragment.
	rightFragment := self popFragment.
	branchState :=
		XMLNFABranchingState
			leftBranch: leftFragment firstState
			rightBranch: rightFragment firstState.

	self pushFragment:
		(XMLNFAFragment
			firstState: branchState
			terminalStates:
				(leftFragment terminalStatesWithAllFrom: rightFragment)).! !
!XMLNFABuilder methodsFor: 'applying'!
applyConcatenation
	| firstFragment secondFragment |

	secondFragment := self popFragment.
	firstFragment := self popFragment.
	firstFragment connectToFragment: secondFragment.

	self pushFragment: firstFragment.! !
!XMLNFABuilder methodsFor: 'applying'!
applyOptional
	| optionalFragment branchingState |

	optionalFragment := self popFragment.
	branchingState :=
		XMLNFABranchingState branch: optionalFragment firstState.

	self pushFragment:
		(XMLNFAFragment
			firstState: branchingState
			terminalStates:
				(optionalFragment terminalStatesWith: branchingState))! !
!XMLNFABuilder methodsFor: 'applying'!
applyPlus
	| plusFragment |

	plusFragment := self topFragment.
	plusFragment connectToState:
		(XMLNFABranchingState branch: plusFragment firstState).! !
!XMLNFABuilder methodsFor: 'applying'!
applyStar
	| branchState starFragment |

	starFragment := self popFragment.
	branchState := XMLNFABranchingState branch: starFragment firstState.
	starFragment connectToState: branchState.

	self pushFragment:
		(XMLNFAFragment
			firstState: branchState
			terminalState: branchState).! !
!XMLNFABuilder methodsFor: 'converting'!
asAcceptingNFA
	^ (self
		applyAccepting;
		popFragment) firstState! !
!XMLNFABuilder methodsFor: 'private'!
fragmentStack
	^ fragmentStack! !
!XMLNFABuilder methodsFor: 'testing'!
hasFragments
	^ self totalFragments > 0! !
!XMLNFABuilder methodsFor: 'initialization'!
initialize
	super initialize.

	fragmentStack := OrderedCollection new.! !
!XMLNFABuilder methodsFor: 'accessing'!
popFragment
	^ self fragmentStack removeLast! !
!XMLNFABuilder methodsFor: 'accessing'!
pushFragment: aFragment
	^ self fragmentStack addLast: aFragment! !
!XMLNFABuilder methodsFor: 'accessing'!
pushFragmentMatching: aMatcher
	^ self pushFragment:
		(XMLNFAFragment firstState:
			(XMLNFAMatchingState matcher: aMatcher))! !
!XMLNFABuilder methodsFor: 'accessing'!
topFragment
	^ self fragmentStack last! !
!XMLNFABuilder methodsFor: 'accessing'!
totalFragments
	^ self fragmentStack size! !
!XMLNFAFragment class methodsFor: 'instance creation'!
firstState: aFirstState
	^ self new
		setFirstState: aFirstState
		terminalStateOrStates: aFirstState! !
!XMLNFAFragment class methodsFor: 'instance creation'!
firstState: aFirstState terminalState: aTerminalState
	^ self new
		setFirstState: aFirstState
		terminalStateOrStates: aTerminalState! !
!XMLNFAFragment class methodsFor: 'instance creation'!
firstState: aFirstState terminalStates: aTerminalStateCollection
	^ self new
		setFirstState: aFirstState
		terminalStateOrStates: aTerminalStateCollection! !
!XMLNFAFragment methodsFor: 'private'!
connectTerminalStatesToState: aState
	terminalStateOrStates isCollection
		ifTrue: [
			"use #to:do: for speed"
			1 to: terminalStateOrStates size do: [:i |
				(terminalStateOrStates at: i) connectToState: aState]]
		ifFalse: [terminalStateOrStates connectToState: aState]! !
!XMLNFAFragment methodsFor: 'connecting'!
connectToFragment: aFragment
	self connectTerminalStatesToState: aFragment firstState.
	terminalStateOrStates := aFragment terminalStateOrStates.! !
!XMLNFAFragment methodsFor: 'connecting'!
connectToState: aState
	self connectTerminalStatesToState: aState.
	terminalStateOrStates := aState.! !
!XMLNFAFragment methodsFor: 'accessing'!
firstState
	^ firstState! !
!XMLNFAFragment methodsFor: 'accessing'!
firstState: aFirstState
	firstState := aFirstState! !
!XMLNFAFragment methodsFor: 'private'!
newTerminalStatesWith: aFirstTerminalState and: aSecondTerminalState
	"avoid #with:with: to control the capacity"
	^ (OrderedCollection new: 4)
		addLast: aFirstTerminalState;
		addLast: aSecondTerminalState;
		yourself! !
!XMLNFAFragment methodsFor: 'initialization'!
setFirstState: aFirstState terminalStateOrStates: aTerminalStateOrStateCollection
	firstState := aFirstState.
	terminalStateOrStates := aTerminalStateOrStateCollection.! !
!XMLNFAFragment methodsFor: 'accessing'!
terminalState: aTerminalState
	terminalStateOrStates := aTerminalState! !
!XMLNFAFragment methodsFor: 'private'!
terminalStateOrStates
	^ terminalStateOrStates! !
!XMLNFAFragment methodsFor: 'accessing'!
terminalStates
	^ terminalStateOrStates isCollection
		ifTrue: [terminalStateOrStates]
		ifFalse: [OrderedCollection with: terminalStateOrStates]! !
!XMLNFAFragment methodsFor: 'accessing'!
terminalStates: aTerminalStateCollection
	terminalStateOrStates := aTerminalStateCollection! !
!XMLNFAFragment methodsFor: 'private'!
terminalStatesAddedTo: aTerminalStateCollection
	terminalStateOrStates isCollection
		ifTrue: [
			"#to:do: for speed"
			1 to: terminalStateOrStates size do: [:i |
				aTerminalStateCollection addLast: (terminalStateOrStates at: i)]]
		ifFalse: [aTerminalStateCollection addLast: terminalStateOrStates].
	^ aTerminalStateCollection.! !
!XMLNFAFragment methodsFor: 'converting'!
terminalStatesWith: aTerminalState
	terminalStateOrStates isCollection
		ifTrue: [
			terminalStateOrStates addLast: aTerminalState.
			^ terminalStateOrStates]
		ifFalse: [
			^ self
				newTerminalStatesWith: terminalStateOrStates
				and: aTerminalState]! !
!XMLNFAFragment methodsFor: 'converting'!
terminalStatesWithAllFrom: aFragment
	terminalStateOrStates isCollection
		ifTrue: [^ aFragment terminalStatesAddedTo: terminalStateOrStates].
	aFragment terminalStateOrStates isCollection
		ifTrue: [^ self terminalStatesAddedTo: aFragment terminalStateOrStates].
	^ self
		newTerminalStatesWith: terminalStateOrStates
		and: aFragment terminalStateOrStates.! !
!XMLNFAAcceptingState methodsFor: 'testing'!
isAccepting
	^ true! !
!XMLNFAAcceptingState methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self printLabelOn: aStream.
	aStream nextPut: $).! !
!XMLNFABranchingState class methodsFor: 'instance creation'!
branch: aLeftBranch
	^ self new
		setLeftBranch: aLeftBranch
		rightBranch: nil! !
!XMLNFABranchingState class methodsFor: 'instance creation'!
leftBranch: aLeftBranch rightBranch: aRightBranch
	^ self new
		setLeftBranch: aLeftBranch
		rightBranch: aRightBranch! !
!XMLNFABranchingState methodsFor: 'adding'!
addTo: aStateSet
	lastAddedTo == aStateSet
		ifFalse: [
			"to detect and handle cycles"
			lastAddedTo := aStateSet.

			"this is effectively a non-matching, non-accepting state
			with epsilon transitions, so it can be skipped and its
			branches can be followed (in other words, the epsilon
			closure of this state, minus this state)"
			leftBranch
				ifNotNil: [leftBranch addTo: aStateSet].
			rightBranch
				ifNotNil: [rightBranch addTo: aStateSet]]! !
!XMLNFABranchingState methodsFor: 'connecting'!
connectToState: aState
	leftBranch
		ifNil: [leftBranch := aState].
	rightBranch
		ifNil: [rightBranch := aState].! !
!XMLNFABranchingState methodsFor: 'accessing'!
leftBranch
	^ leftBranch! !
!XMLNFABranchingState methodsFor: 'enumerating'!
nextStatesDo: aBlock
	leftBranch
		ifNotNil: [aBlock value: leftBranch].
	rightBranch
		ifNotNil: [aBlock value: rightBranch].! !
!XMLNFABranchingState methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self printLabelOn: aStream.
	aStream nextPut: $(.
	leftBranch
		ifNotNil: [
			leftBranch printLabelOn: aStream].
	aStream nextPut: $|.
	rightBranch
		ifNotNil: [
			rightBranch printLabelOn: aStream].
	aStream nextPutAll: '))'.! !
!XMLNFABranchingState methodsFor: 'accessing'!
rightBranch
	^ rightBranch! !
!XMLNFABranchingState methodsFor: 'initialization'!
setLeftBranch: aLeftBranch rightBranch: aRightBranch
	leftBranch := aLeftBranch.
	rightBranch := aRightBranch.! !
!XMLNFAMatchingState class methodsFor: 'instance creation'!
matcher: aMatcher
	^ self new matcher: aMatcher! !
!XMLNFAMatchingState methodsFor: 'connecting'!
connectToState: aState
	nextState
		ifNil: [nextState := aState]! !
!XMLNFAMatchingState methodsFor: 'accessing'!
matcher
	^ matcher! !
!XMLNFAMatchingState methodsFor: 'accessing'!
matcher: aMatcher
	matcher := aMatcher! !
!XMLNFAMatchingState methodsFor: 'testing'!
matches: anObject
	^ matcher = anObject! !
!XMLNFAMatchingState methodsFor: 'accessing'!
nextState
	^ nextState! !
!XMLNFAMatchingState methodsFor: 'enumerating'!
nextStatesDo: aBlock
	nextState
		ifNotNil: [aBlock value: nextState]! !
!XMLNFAMatchingState methodsFor: 'printing'!
printLabelOn: aStream
	aStream
		print: self identityHash;
		nextPut: $(;
		print: matcher;
		nextPut: $)! !
!XMLNFAMatchingState methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self printLabelOn: aStream.
	aStream nextPutAll: '->'.
	nextState
		ifNotNil: [
			nextState printLabelOn: aStream].
	aStream nextPut: $).! !
!XMLNFAState methodsFor: 'adding'!
addTo: aStateSet
	lastAddedTo == aStateSet
		ifFalse: [
			"to detect and handle cycles"
			lastAddedTo := aStateSet.

			aStateSet add: self]! !
!XMLNFAState methodsFor: 'converting'!
asDFAState
	| nfaStates |

	nfaStates := XMLNFAStateSet new.
	self addTo: nfaStates.
	^ nfaStates asDFAState.! !
!XMLNFAState methodsFor: 'connecting'!
connectToState: aState! !
!XMLNFAState methodsFor: 'testing'!
isAccepting
	^ false! !
!XMLNFAState methodsFor: 'testing'!
matches: anObject
	^ false! !
!XMLNFAState methodsFor: 'enumerating'!
nextStatesDo: aBlock! !
!XMLNFAState methodsFor: 'printing'!
printLabelOn: aStream
	aStream print: self identityHash! !
!XMLNamespaceScope class methodsFor: 'defaults'!
xmlNamespaceURI
	^ 'http://www.w3.org/XML/1998/namespace'! !
!XMLNamespaceScope class methodsFor: 'defaults'!
xmlnsNamespaceURI
	^ 'http://www.w3.org/2000/xmlns/'! !
!XMLNamespaceScope methodsFor: 'comparing'!
= anObject
	self == anObject
		ifTrue: [^ true].

	self species == anObject species
		ifFalse: [^ false].

	self hasNamespaces
		ifFalse: [^ anObject hasNamespaces not].

	"use #hasNamespaces first to avoid initializing anObject's prefixMappings"
	anObject hasNamespaces
		ifFalse: [^ false].

	^ prefixMappings = anObject prefixMappings.! !
!XMLNamespaceScope methodsFor: 'private'!
copiedPrefixMappings
	"replaces current mappings with copy for copy-on-write"
	prefixMappings
		ifNil: [^ self prefixMappings]
		ifNotNil: [^ prefixMappings := prefixMappings copy]! !
!XMLNamespaceScope methodsFor: 'copying'!
copy
	"copy-on-write allows copies to share state so no postCopy is needed"
	^ self shallowCopy! !
!XMLNamespaceScope methodsFor: 'accessing'!
defaultNamespace
	^ prefixMappings
		ifNil: ['']
		ifNotNil: [
			prefixMappings
				at: ''
				ifAbsent: ['']]! !
!XMLNamespaceScope methodsFor: 'accessing'!
defaultNamespace: aURI
	self
		validatePrefix: ''
		beforeMappingTo: aURI.

	"copy-on-write"
	self copiedPrefixMappings
		at: ''
		put: aURI.! !
!XMLNamespaceScope methodsFor: 'private'!
errorAttribute: anAttribute aliasesURI: aURI
	XMLNamespaceException
		formatSignal: 'Attribute "{1}" has alias for namespace URI "{2}"'
		with: anAttribute
		with: aURI! !
!XMLNamespaceScope methodsFor: 'private'!
errorCannotAliasPrefix: aFirstPrefix with: aSecondPrefix
	aSecondPrefix isEmpty
		ifTrue: [
			XMLNamespaceException
				formatSignal:
					'Cannot use the "{1}" namespace URI as a ',
					'default namespace URI'
				with: aFirstPrefix]
		ifFalse: [
			XMLNamespaceException
				formatSignal:
					'Cannot alias the "{1}" namespace URI ',
					'with the "{2}" prefix'
				with: aFirstPrefix
				with: aSecondPrefix]! !
!XMLNamespaceScope methodsFor: 'private'!
errorCannotAliasXMLNSPrefixWith: aPrefix
	self
		errorCannotAliasPrefix: 'xmlns'
		with: aPrefix! !
!XMLNamespaceScope methodsFor: 'private'!
errorCannotAliasXMLPrefixWith: aPrefix
	self
		errorCannotAliasPrefix: 'xml'
		with: aPrefix! !
!XMLNamespaceScope methodsFor: 'private'!
errorCannotMapPrefixToEmptyURI
	XMLNamespaceException signal: 'Cannot map namespace prefixes to empty URIs'! !
!XMLNamespaceScope methodsFor: 'private'!
errorCannotMapXMLNSPrefix
	XMLNamespaceException signal:
		'Cannot map "xmlns" prefix to any namespace, even the current "xmlns" namespace'! !
!XMLNamespaceScope methodsFor: 'private'!
errorCannotRemapXMLPrefix
	XMLNamespaceException signal: 'Cannot map the "xml" prefix to a new namespace URI'! !
!XMLNamespaceScope methodsFor: 'private'!
errorCannotUnmapPrefix: aPrefix
	XMLNamespaceException
		formatSignal: 'Prefix "{1}" was not mapped and cannot be unmapped'
		with: aPrefix! !
!XMLNamespaceScope methodsFor: 'private'!
errorInvalidPrefix: aPrefix	
	XMLNamespaceException
		formatSignal: 'Prefix "{1}" contains ":" character'
		with: aPrefix! !
!XMLNamespaceScope methodsFor: 'private'!
errorInvalidUnprefixedAttribute: anAttribute
	XMLNamespaceException
		formatSignal: 'Unprefixed attribute "{1}" contains ":" character'
		with: anAttribute! !
!XMLNamespaceScope methodsFor: 'private'!
errorInvalidUnprefixedElement: anElement
	XMLNamespaceException
		formatSignal: 'Unprefixed element <{1}> contains ":" character'
		with: anElement! !
!XMLNamespaceScope methodsFor: 'private'!
errorUnmappedPrefix: aPrefix inAttribute: anAttribute
	XMLNamespaceException
		formatSignal: 'Unmapped namespace prefix "{1}" in "{2}" attribute'
		with: aPrefix
		with: anAttribute! !
!XMLNamespaceScope methodsFor: 'private'!
errorUnmappedPrefix: aPrefix inElement: anElement
	XMLNamespaceException
		formatSignal: 'Unmapped namespace prefix "{1}" in <{2}> element'
		with: aPrefix
		with: anElement! !
!XMLNamespaceScope methodsFor: 'private'!
errorXMLNSPrefixInAttribute: anAttribute
	XMLNamespaceException
		formatSignal: 'Attribute "{1}" uses reserved "xmlns" namespace prefix'
		with: anAttribute! !
!XMLNamespaceScope methodsFor: 'private'!
errorXMLNSPrefixInElement: anElement
	XMLNamespaceException
		formatSignal: 'Element <{1}> uses reserved "xmlns" namespace prefix'
		with: anElement! !
!XMLNamespaceScope methodsFor: 'testing'!
hasDefaultNamespace
	^ self includesPrefix: ''! !
!XMLNamespaceScope methodsFor: 'testing'!
hasNamespaces
	"optimized to avoid lazy initialization"
	prefixMappings == nil
		ifTrue: [^ false].
	^ prefixMappings size > 0.! !
!XMLNamespaceScope methodsFor: 'comparing'!
hash
	self hasNamespaces
		ifTrue: [^ self species hash bitXor: self prefixMappings hash]
		ifFalse: [^ self species hash]! !
!XMLNamespaceScope methodsFor: 'testing'!
includesPrefix: aPrefix
	self
		prefixMappingAt: aPrefix
		ifAbsent: [^ false].
	^ true.! !
!XMLNamespaceScope methodsFor: 'testing'!
includesPrefix: aPrefix mappedTo: aURI
	^ (self
		prefixMappingAt: aPrefix
		ifAbsent: [^ false]) = aURI! !
!XMLNamespaceScope methodsFor: 'accessing'!
inheritMappingsFrom: anEnclosingScope
	anEnclosingScope hasNamespaces
		ifFalse: [^ self].
	self hasNamespaces
		ifTrue: [| copiedPrefixMappings |
			anEnclosingScope prefixesAndURIsDo: [:prefix :uri |
				(self includesPrefix: prefix)
					ifFalse: [
						"nil test ensures we only copy the first time when needed"
						(copiedPrefixMappings
							ifNil: [copiedPrefixMappings := self copiedPrefixMappings])
							at: prefix
							put: uri]]]
		ifFalse: [
			"can safely share anEnclosingScope's prefixMappings because of
			copy-on-write behavior"
			prefixMappings := anEnclosingScope prefixMappings].! !
!XMLNamespaceScope methodsFor: 'accessing'!
mapPrefix: aPrefix to: aURI
	self
		validatePrefix: aPrefix
		beforeMappingTo: aURI.

	"copy-on-write"
	self copiedPrefixMappings
		at: aPrefix
		put: aURI.! !
!XMLNamespaceScope methodsFor: 'accessing'!
mapPrefixesAndURIs: anAssociationCollection
	| copiedPrefixMappings |

	anAssociationCollection associationsDo: [:each |
		self
			validatePrefix: each key
			beforeMappingTo: each value.
		"nil test ensures we only copy the first time when needed"
		(copiedPrefixMappings
			ifNil: [copiedPrefixMappings := self copiedPrefixMappings])
			at: each key
			put: each value]! !
!XMLNamespaceScope methodsFor: 'accessing'!
mappedPrefixes
	^ prefixMappings
		ifNil: [#()]
		ifNotNil: [prefixMappings keys]! !
!XMLNamespaceScope methodsFor: 'accessing'!
prefixMappingAt: aPrefix
	^ self
		prefixMappingAt: aPrefix
		ifAbsent: ['']! !
!XMLNamespaceScope methodsFor: 'accessing'!
prefixMappingAt: aPrefix ifAbsent: aBlock
	^ prefixMappings
		ifNil: [aBlock value]
		ifNotNil: [
			prefixMappings
				at: aPrefix
				ifAbsent: aBlock]! !
!XMLNamespaceScope methodsFor: 'private'!
prefixMappings
	^ prefixMappings
		ifNil: [prefixMappings := OrderPreservingStringDictionary new: 5]! !
!XMLNamespaceScope methodsFor: 'enumerating'!
prefixesAndURIsDo: aTwoArgumentBlock
	prefixMappings
		ifNotNil: [prefixMappings keysAndValuesDo: aTwoArgumentBlock]! !
!XMLNamespaceScope methodsFor: 'printing'!
printDeclarationsOn: aStream
	| isFirst |

	isFirst := true.
	self prefixesAndURIsDo: [:prefix :uri |
		isFirst 
			ifTrue: [isFirst := false]
			ifFalse: [aStream space].
		aStream nextPutAll: 'xmlns'.
		prefix
			ifNotEmpty: [
				aStream
					nextPut: $:;
					nextPutAll: prefix].
		aStream
			nextPut: $=;
			nextPut: $";
			nextPutAll: uri;
			nextPut: $"].! !
!XMLNamespaceScope methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self printDeclarationsOn: aStream.
	aStream nextPut: $).! !
!XMLNamespaceScope methodsFor: 'resolving'!
resolvePrefix: aPrefix
	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix
	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns an
	empty string if aPrefix is unresolvable."

	^ self
		resolvePrefix: aPrefix
		ifUnresolvable: ''! !
!XMLNamespaceScope methodsFor: 'resolving'!
resolvePrefix: aPrefix ifUnresolvable: aBlock
	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix
	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns the
	value of aBlock if aPrefix is unresolvable."

	aPrefix size > 0 "optimization"
		ifTrue: [
			(aPrefix at: 1) == $x "optimization"
				ifTrue: [
					aPrefix = 'xml'
						ifTrue: [^ self xmlNamespaceURI].
					aPrefix = 'xmlns'
						ifTrue: [^ self xmlnsNamespaceURI]]].

	^ self
		prefixMappingAt: aPrefix
		ifAbsent: aBlock.! !
!XMLNamespaceScope methodsFor: 'resolving'!
resolvePrefixesOfNamespaceURI: aURI
	| prefixes |

	"the 'xml' and 'xmlns' namespaces URIs can't be aliased"
	aURI = self xmlNamespaceURI
		ifTrue: [^ Set with: 'xml'].
	aURI = self xmlnsNamespaceURI
		ifTrue: [^ Set with: 'xmlns'].

	prefixes := Set new.
	self prefixesAndURIsDo: [:prefix :uri |
		uri = aURI
			ifTrue: [prefixes add: prefix]].
	^ prefixes.! !
!XMLNamespaceScope methodsFor: 'accessing'!
size
	^ prefixMappings
		ifNil: [0]
		ifNotNil: [prefixMappings size]! !
!XMLNamespaceScope methodsFor: 'unmapping'!
unmapPrefix: aPrefix
	^ self
		unmapPrefix: aPrefix
		ifAbsent: [self errorCannotUnmapPrefix: aPrefix]! !
!XMLNamespaceScope methodsFor: 'unmapping'!
unmapPrefix: aPrefix ifAbsent: aBlock
	prefixMappings
		ifNil: [^ aBlock value]
		ifNotNil: [
			"copy-on-write"
			^ self copiedPrefixMappings 
				removeKey: aPrefix
				ifAbsent: aBlock]! !
!XMLNamespaceScope methodsFor: 'unmapping'!
unmapPrefixes
	self hasNamespaces
		ifTrue: [
			"copy-on-write"
			self copiedPrefixMappings removeAll]! !
!XMLNamespaceScope methodsFor: 'validating'!
validateAndResolvePrefix: aPrefix ofAttribute: anAttribute
	"performance critical method"
	aPrefix size > 0 "optimization"
		ifTrue: [
			^ self
				prefixMappingAt: aPrefix
				ifAbsent: [
					aPrefix = 'xml'
						ifTrue: [self xmlNamespaceURI]
						ifFalse: [					
							aPrefix = 'xmlns'
								ifTrue: [
									"this can't happen during parsing, because
									'xmlns' attributes are treated as namespace
									declarations, but it can happen through DOM tree
									manipulation, for example:
										attributeNode prefix: 'xmlns'
									"
									self errorXMLNSPrefixInAttribute: anAttribute]
								ifFalse: [
									self
										errorUnmappedPrefix: aPrefix
										inAttribute: anAttribute]]]]
		ifFalse: [
			"catch names like ':name' with an empty prefix"
			(anAttribute size > 0
				and: [(anAttribute at: 1) == $:])
				ifTrue: [self errorInvalidUnprefixedAttribute: anAttribute].
			^ '']! !
!XMLNamespaceScope methodsFor: 'validating'!
validateAndResolvePrefix: aPrefix ofElement: anElement
	aPrefix size > 0 "optimization"
		ifTrue: [
			^ self
				prefixMappingAt: aPrefix
				ifAbsent: [
					aPrefix = 'xml'
						ifTrue: [self xmlNamespaceURI]
						ifFalse: [					
							aPrefix = 'xmlns'
								ifTrue: [self errorXMLNSPrefixInElement: anElement]
								ifFalse: [
									self
										errorUnmappedPrefix: aPrefix
										inElement: anElement]]]]
		ifFalse: [
			"catch names like ':name' with an empty prefix"
			(anElement size > 0
				and: [(anElement at: 1) == $:])
				ifTrue: [self errorInvalidUnprefixedElement: anElement].
			^ self defaultNamespace]! !
!XMLNamespaceScope methodsFor: 'private'!
validatePrefix: aPrefix beforeMappingTo: aURI
	aPrefix size > 0 "optimization"
		ifTrue: ["non-default namespace"
			aPrefix = 'xml' "cannot be remapped"
				ifTrue: [
					aURI = self xmlNamespaceURI
						ifFalse: [self errorCannotRemapXMLPrefix].
					^ self].
			aPrefix = 'xmlns' "cannot be mapped, even to the same URI"
				ifTrue: [self errorCannotMapXMLNSPrefix].
			(aPrefix indexOf: $:) > 0 
				ifTrue: [self errorInvalidPrefix: aPrefix].
			"non-default namespaces cannot be mapped to empty uris, even
			to shadow an inherited namesapce"
			aURI size > 0
				ifFalse: [self errorCannotMapPrefixToEmptyURI]].

	"these URIs cannot be aliased, even by the default namespace"
	aURI = self xmlNamespaceURI
		ifTrue: [self errorCannotAliasXMLPrefixWith: aPrefix].
	aURI = self xmlnsNamespaceURI
		ifTrue: [self errorCannotAliasXMLNSPrefixWith: aPrefix].! !
!XMLNamespaceScope methodsFor: 'validating'!
validatePrefixesOfAttributes: anAttributeCollection
	^ self
		validatePrefixesOfAttributes: anAttributeCollection asArray
		from: 1
		to: anAttributeCollection size! !
!XMLNamespaceScope methodsFor: 'validating'!
validatePrefixesOfAttributes: anAttributeCollection from: aStart to: aStop
	"performance critical method"
	| attributeLocalNamesAndURIs |

	"#to:do: for speed"
	aStart to: aStop do: [:i | | attribute prefix uri |
		attribute := anAttributeCollection at: i.
		prefix := attribute xmlPrefixBeforeLocalName.
		(uri :=
			self
				validateAndResolvePrefix: prefix
				ofAttribute: attribute) size > 0 "optimization"
			ifTrue: [| oldSize |
				oldSize :=
					(attributeLocalNamesAndURIs
						ifNil: [
							"not initialized unless needed"
							attributeLocalNamesAndURIs := Set new]) size.
				(attributeLocalNamesAndURIs
					add: (attribute xmlLocalNameAfterPrefix: prefix) -> uri;
					size) > oldSize
					ifFalse: [
						self
							errorAttribute: attribute xmlLocalNameAfterPrefix
							aliasesURI: uri]]]! !
!XMLNamespaceScope methodsFor: 'defaults'!
xmlNamespaceURI
	^ self class xmlNamespaceURI! !
!XMLNamespaceScope methodsFor: 'defaults'!
xmlnsNamespaceURI
	^ self class xmlnsNamespaceURI! !
!XMLNamespaceScopeAllocator methodsFor: 'accessing'!
currentScope
	| totalScopes |

	^ (totalScopes := scopes size) > 0
		ifTrue: [scopes at: totalScopes]
		ifFalse: [self newEmptyScope]! !
!XMLNamespaceScopeAllocator methodsFor: 'accessing'!
currentScope: aScope
	scopes size > 0
		ifTrue: [
			scopes
				at: scopes size
				put: aScope]
		ifFalse: [scopes addLast: aScope]! !
!XMLNamespaceScopeAllocator methodsFor: 'allocating'!
enterScope
	^ scopes addLast: self currentScope copy! !
!XMLNamespaceScopeAllocator methodsFor: 'allocating'!
exitScope
	^ scopes removeLast! !
!XMLNamespaceScopeAllocator methodsFor: 'testing'!
hasCurentScope
	^ scopes notEmpty! !
!XMLNamespaceScopeAllocator methodsFor: 'initialization'!
initialize
	super initialize.

	scopes := OrderedCollection new: 10.! !
!XMLNamespaceScopeAllocator methodsFor: 'instance creation'!
newEmptyScope
	^ XMLNamespaceScope new! !
!XMLNamespaceScopeAllocator methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	self hasCurentScope
		ifTrue: [
			aStream
				nextPut: $(;
				print: self currentScope;
				nextPut: $)].! !
!XMLNamespaceScopeAllocator methodsFor: 'accessing'!
scopes
	^ scopes! !
!XMLNestedStreamReader class methodsFor: 'class initialization'!
initialize
	"self initialize"

	"stored in class vars for faster access"
	CRCharacter := Character cr.
	LFCharacter := Character lf.

	"a null stream that is already #atEnd and can safely be sent
	#close repeatedly and #atEnd after"
	NullReadStream := XMLNullReadStream new.! !
!XMLNestedStreamReader class methodsFor: 'instance creation'!
on: aStream
	^ self
		on: aStream
		readLimit: nil! !
!XMLNestedStreamReader class methodsFor: 'instance creation'!
on: aStream readLimit: anInteger
	^ self new
		setStream: aStream
		readLimit: anInteger! !
!XMLNestedStreamReader methodsFor: 'testing'!
atEnd
	peekChar
		ifNotNil: [^ false].
	stream atEnd
		ifFalse: [^ false].
	"use #to:do: for speed"
	1 to: nestedStreams size do: [:i |
		(nestedStreams at: i) stream atEnd
			ifFalse: [^ false]].
	^ true.! !
!XMLNestedStreamReader methodsFor: 'testing'!
atQuote
	^ self peek == $"
		or: [peekChar == $']! !
!XMLNestedStreamReader methodsFor: 'private'!
closeStream: aStream
	"must use respondsTo: to support streams only implementing the basic protocol"
	(aStream respondsTo: #close)
		ifTrue: [aStream close].! !
!XMLNestedStreamReader methodsFor: 'closing'!
closeStreams
	"close the streams but do not evaluate their callbacks and
	set the current stream to the null stream sending #closeStreams
	again won't raise an error"
	self
		closeStream: stream;
		setStreamToNull.
	[nestedStreams size > 0]
		whileTrue: [self closeStream: nestedStreams removeLast stream].! !
!XMLNestedStreamReader methodsFor: 'decoding'!
convertFromEncoding: anEncodingName
	"Encoding attributes are ignored unless the stream is a converting adapter
	that has a null/implicit converter.
	
	This is the safest approach, because the encoding of a file can be easily
	changed by a text editor or utility without automatically updating the
	<?xml ...?> encoding attribute.
	
	The BOM and out-of-band info (like HTTP headers) should be given precedence."

	(stream isXMLConvertingStreamAdapter
		and: [stream hasNullStreamConverter
			or: [stream hasImplicitStreamConverter]])
		ifTrue: [| streamConverter |
			(streamConverter := anEncodingName asXMLStreamConverter) isNull
				ifTrue: [self errorUnsupportedEncoding: anEncodingName].
			self decodeStreamWithConverter: streamConverter]! !
!XMLNestedStreamReader methodsFor: 'accessing'!
currentColumnNumber
	"recording the start pos. of the line and subtracting it from the current
	pos. is faster than an explicit column var that would need to be incremented
	each time through #next/#skipSeparators"
	^ currentLineStartPosition
		ifNotNil: [currentPosition - currentLineStartPosition]! !
!XMLNestedStreamReader methodsFor: 'accessing'!
currentLineNumber
	^ currentLineNumber! !
!XMLNestedStreamReader methodsFor: 'accessing'!
currentPosition
	^ currentPosition! !
!XMLNestedStreamReader methodsFor: 'decoding'!
decodeStreamWithConverter: aStreamConverter
	stream isXMLConvertingStreamAdapter
		ifTrue: [stream streamConverter: aStreamConverter]
		ifFalse: [
			stream :=
				XMLDecodingReadStreamAdapter
					on: stream
					streamConverter: aStreamConverter]! !
!XMLNestedStreamReader methodsFor: 'decoding'!
detectEncoding
	stream isXMLConvertingStreamAdapter
		ifTrue: [stream detectEncoding]
		ifFalse: [
			"if it's not already an XMLDecodingReadStreamAdapter, just look
			for an obvious leading byte-order mark and convert it if found,
			and otherwise just leave it alone"
			(XMLEncodingDetector on: stream) streamConverterForEncoding
				ifNotNil: [:converter |
					self decodeStreamWithConverter: converter]]! !
!XMLNestedStreamReader methodsFor: 'private'!
errorNestingLimitExceeded
	XMLLimitException signal: 'Cannot further nest input streams'! !
!XMLNestedStreamReader methodsFor: 'private'!
errorReadLimitExceeded
	XMLLimitException signal:
		'Security input read limit exceeded; ',
		'use #documentReadLimit: and #externalSubsetReadLimit: ',
		'to change/disable it, or #defaultReadLimit: ',
		'to persistently change/disable it'! !
!XMLNestedStreamReader methodsFor: 'private'!
errorUnsupportedEncoding: anEncodingName
	XMLEncodingException
		formatSignal: 'Encoding "{1}" is unsupported'
		with: anEncodingName! !
!XMLNestedStreamReader methodsFor: 'private'!
hasNextAfterPoppingStreamsAtEnd
	"always pop at least one stream, which makes the new current stream
	the null stream if there aren't any nested streams"
	self popCurrentStream.
	[stream atEnd]
		whileTrue: [
			nestedStreams size > 0
				ifFalse: [^ false].
			self popCurrentStream].
	^ true.! !
!XMLNestedStreamReader methodsFor: 'testing'!
hasPushedBackStreams
	^ nestedStreams size > 0! !
!XMLNestedStreamReader methodsFor: 'testing'!
isBinary
	^ false! !
!XMLNestedStreamReader methodsFor: 'testing'!
isStream
	^ true! !
!XMLNestedStreamReader methodsFor: 'testing'!
isXMLBinaryOrExternalStream
	^ self isBinary! !
!XMLNestedStreamReader methodsFor: 'private'!
maxNestedStreams
	^ 32! !
!XMLNestedStreamReader methodsFor: 'private'!
nestedStreamsAddLast: aPushedBackStream
	nestedStreams size >= self maxNestedStreams
		ifTrue: [self errorNestingLimitExceeded].
	nestedStreams addLast: aPushedBackStream.! !
!XMLNestedStreamReader methodsFor: 'private'!
newWriteStream
	^ (self writeStreamCollectionClass new: 128) writeStream! !
!XMLNestedStreamReader methodsFor: 'accessing'!
next
	| nextChar |

	peekChar
		ifNil: [
			stream atEnd
				ifTrue: [
					self hasNextAfterPoppingStreamsAtEnd
						ifFalse: [^ nil]].
			nextChar := stream next.
			isExternal
				ifTrue: [
					currentPosition := currentPosition + 1.
					nextChar == LFCharacter
						ifTrue: [
							nextChar := normalizedLineEndingChar.
							currentLineNumber := currentLineNumber + 1.
							currentLineStartPosition := currentPosition]
						ifFalse: [
							nextChar == CRCharacter
								ifTrue: [
									stream atEnd
										ifFalse: [
											stream peek == LFCharacter
												ifTrue: [stream next]].
									nextChar := normalizedLineEndingChar.
									currentLineNumber := currentLineNumber + 1.
									currentLineStartPosition := currentPosition]]]]
		ifNotNil: [
			nextChar := peekChar.
			peekChar := nil.
			isExternal
				ifTrue: [
					currentPosition := currentPosition + 1.
					nextChar == normalizedLineEndingChar
						ifTrue: [
							currentLineNumber := currentLineNumber + 1.
							currentLineStartPosition := currentPosition]]].

	readLimit
		ifNotNil: [
			(readLimit := readLimit - 1) >= 0
				ifFalse: [self errorReadLimitExceeded]].

	^ nextChar.! !
!XMLNestedStreamReader methodsFor: 'accessing'!
next: anInteger
	| writeStream i |

	writeStream := self newWriteStream.
	i := 0.
	[self atEnd
		or: [i >= anInteger]]
		whileFalse: [
			writeStream nextPut: self next.
			i := i + 1].
	^ writeStream contents.! !
!XMLNestedStreamReader methodsFor: 'accessing'!
normalizedLineEndingChar
	^ normalizedLineEndingChar! !
!XMLNestedStreamReader methodsFor: 'accessing'!
normalizedLineEndingChar: aCharacter
	normalizedLineEndingChar := aCharacter! !
!XMLNestedStreamReader methodsFor: 'accessing'!
peek
	peekChar
		ifNotNil: [^ peekChar].

	stream atEnd
		ifTrue: [
			self hasNextAfterPoppingStreamsAtEnd
				ifFalse: [^ nil]].
	peekChar := stream next.
	isExternal
		ifTrue: [
			peekChar == LFCharacter
				ifTrue: [^ peekChar := normalizedLineEndingChar].
			peekChar == CRCharacter
				ifTrue: [
					stream atEnd
						ifFalse: [
							stream peek == LFCharacter
								ifTrue: [stream next]].
					^ peekChar := normalizedLineEndingChar]].
	^ peekChar.! !
!XMLNestedStreamReader methodsFor: 'accessing'!
peekFor: aCharacter
	(self atEnd not
		and: [self peek = aCharacter])
		ifTrue: [
			self next.
			^ true]
		ifFalse: [^ false]! !
!XMLNestedStreamReader methodsFor: 'private'!
popCurrentStream
	| callbackOfPoppedStream |

	"close the stream first and pop it before evaluating the callback so any
	exception it raises won't cause us to leak file streams or double close a
	stream when XMLParser>>#handleParserError: sends #closeStreams"
	self closeStream: stream.
	callbackOfPoppedStream := whenPoppedDo.
	nestedStreams size > 0
		ifTrue: [| pushedBackStream |
			pushedBackStream := nestedStreams removeLast.
			stream := pushedBackStream stream.
			whenPoppedDo := pushedBackStream whenPoppedDo.
			isExternal := pushedBackStream isExternal.
			currentPosition := pushedBackStream currentPosition.
			currentLineNumber := pushedBackStream currentLineNumber.
			currentLineStartPosition := pushedBackStream currentLineStartPosition]
		ifFalse: [self setStreamToNull].

	"now it's safe to evaluate the callback"
	callbackOfPoppedStream
		ifNotNil: [callbackOfPoppedStream value].! !
!XMLNestedStreamReader methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		print: peekChar; "can be nil"
		nextPutAll: '; ';
		print: stream;
		space;
		print: nestedStreams;
		nextPut: $).! !
!XMLNestedStreamReader methodsFor: 'positioning'!
pushBack: aString
	aString size > 1
		ifTrue: [^ self pushBackStream: aString readStream].
	aString size = 1
		ifTrue: [self pushBackCharacter: (aString at: 1)]! !
!XMLNestedStreamReader methodsFor: 'positioning'!
pushBackCharacter: aCharacter
	self
		pushBackStream: (XMLSingleCharacterReadStream on: aCharacter)
		whenPoppedDo: nil
		isExternal: false! !
!XMLNestedStreamReader methodsFor: 'positioning'!
pushBackStream: aStream
	self
		pushBackStream: aStream
		whenPoppedDo: nil
		isExternal: false! !
!XMLNestedStreamReader methodsFor: 'positioning'!
pushBackStream: aStream whenPoppedDo: aBlock isExternal: aBoolean
	self nestedStreamsAddLast:
		((isExternal
			ifTrue: [XMLPushedBackExternalStream]
			ifFalse: [XMLPushedBackInternalStream])
				stream: stream
				whenPoppedDo: whenPoppedDo
				currentPosition: currentPosition
				currentLineNumber: currentLineNumber
				currentLineStartPosition: currentLineStartPosition).

	peekChar
		ifNotNil: [
			self nestedStreamsAddLast:
				(XMLPushedBackInternalStream
					stream: (XMLSingleCharacterReadStream on: peekChar)
					whenPoppedDo: nil
					currentPosition: currentPosition
					currentLineNumber: currentLineNumber
					currentLineStartPosition: currentLineStartPosition).
			peekChar := nil].

	self stream: aStream.
	whenPoppedDo := aBlock.
	(isExternal := aBoolean)
		ifTrue: [
			currentPosition := 0.
			currentLineNumber := 1.
			currentLineStartPosition := 0].! !
!XMLNestedStreamReader methodsFor: 'accessing'!
readLimit
	^ readLimit! !
!XMLNestedStreamReader methodsFor: 'initialization'!
setStream: aStream readLimit: anInteger
	self stream: aStream.
	isExternal := true.
	currentPosition := 0.
	currentLineNumber := 1.
	currentLineStartPosition := 0.
	nestedStreams := OrderedCollection new: 5.
	readLimit := anInteger.
	normalizedLineEndingChar := LFCharacter.! !
!XMLNestedStreamReader methodsFor: 'private'!
setStreamToNull
	stream := NullReadStream.
	whenPoppedDo := nil.
	"do not reset the other stream properties, including position
	and line number, so error messages will be accurate"! !
!XMLNestedStreamReader methodsFor: 'positioning'!
skip: anInteger
	1 to: anInteger do: [:i |
		self atEnd
			ifTrue: [^ self].
		self next]! !
!XMLNestedStreamReader methodsFor: 'positioning'!
skipSeparators
	"This code is heavily optimized."

	| isExternalNormalizedLineEnding |

	[peekChar
		ifNil: [
			stream atEnd
				ifTrue: [
					self hasNextAfterPoppingStreamsAtEnd
						ifFalse: [^ self]].
			peekChar := stream next.
			isExternal
				ifTrue: [
					peekChar == LFCharacter
						ifTrue: [isExternalNormalizedLineEnding := true]
						ifFalse: [
							peekChar == CRCharacter
								ifTrue: [
									stream atEnd
										ifFalse: [
											stream peek == LFCharacter
												ifTrue: [stream next]].
									isExternalNormalizedLineEnding := true]
								ifFalse: [
									isExternalNormalizedLineEnding := false.
									"nil understands #isXMLSeparator, so it
									isn't tested for first"
									peekChar isXMLSeparator]]]
				ifFalse: [
					"nil understands #isXMLSeparator, so it isn't tested for first"
					peekChar isXMLSeparator]]
			ifNotNil: [
				isExternal
					ifTrue: [
						isExternalNormalizedLineEnding :=
							peekChar == normalizedLineEndingChar].
				peekChar isXMLSeparator]]
		whileTrue: [
			"inlined from #next"
			peekChar := nil.
			isExternal
				ifTrue: [
					currentPosition := currentPosition + 1.
					isExternalNormalizedLineEnding
						ifTrue: [
							currentLineNumber := currentLineNumber + 1.
							currentLineStartPosition := currentPosition].
			readLimit
				ifNotNil: [
					(readLimit := readLimit - 1) >= 0
						ifFalse: [self errorReadLimitExceeded]]]]! !
!XMLNestedStreamReader methodsFor: 'positioning'!
skipTo: aCharacter
	[self atEnd]
		whileFalse: [
			self next = aCharacter
				ifTrue: [^ true]].
	^ false.! !
!XMLNestedStreamReader methodsFor: 'accessing'!
stream
	^ stream! !
!XMLNestedStreamReader methodsFor: 'accessing'!
stream: aStream
	"if the stream is not already a decoding adapter,
	then only assume it needs one if it's binary"
	stream := 
		aStream isXMLConvertingStreamAdapter
			ifTrue: [aStream]
			ifFalse: [
				(XMLDecodingReadStreamAdapter nonDecodingOnIfBinaryOrExternal: aStream)
					ifNil: [aStream]]! !
!XMLNestedStreamReader methodsFor: 'accessing'!
upTo: aCharacter
	| writeStream nextChar |

	writeStream := self newWriteStream.
	[self atEnd
		or: [(nextChar := self next) = aCharacter]]
		whileFalse: [writeStream nextPut: nextChar].
	^ writeStream contents.! !
!XMLNestedStreamReader methodsFor: 'accessing'!
upToEnd
	| writeStream |

	writeStream := self newWriteStream.
	[self atEnd]
		whileFalse: [writeStream nextPut: self next].
	^ writeStream contents.! !
!XMLNestedStreamReader methodsFor: 'defaults'!
writeStreamCollectionClass
	^ String! !
!XMLAttribute class methodsFor: 'instance creation'!
name: aName
	^ self named: aName! !
!XMLAttribute class methodsFor: 'instance creation'!
name: aName value: aValue
	^ self new	
		setName: aName
		value: aValue
		element: nil! !
!XMLAttribute class methodsFor: 'instance creation'!
named: aName
	^ self
		name: aName
		value: ''! !
!XMLAttribute methodsFor: 'accessing'!
element
	"reuse an inst var to save memory"
	^ parent! !
!XMLAttribute methodsFor: 'accessing'!
element: anElement
	"reuse an inst var to save memory"
	parent := anElement! !
!XMLAttribute methodsFor: 'accessing'!
expandedName
	"Returns the expanded name of the attribute as a string in the form of
	'{namespaceURI}localName' if there's a namespace URI or 'localName' if there
	isn't"

	^ self localName expandWithXMLNamespaceURI: self namespaceURI! !
!XMLAttribute methodsFor: 'testing'!
hasNamespaceURI
	^ self namespaceURI notEmpty! !
!XMLAttribute methodsFor: 'testing'!
hasPrefix
	^ (self name
		indexOf: $:
		startingAt: 2) > 0! !
!XMLAttribute methodsFor: 'testing'!
isAttribute
	^ true! !
!XMLAttribute methodsFor: 'testing'!
isInLanguage: aLanguageTag
	"Returns true if the receiver is an xml:lang attribute or if its element
	or an ancestor element has an xml:lang attribute, and if the value is an IETF
	language tag, like 'en-US', that matches aLanguageTag. Matching is
	case-insensitive, and aLanguageTag can be partial, like 'en', and use
	wildcards, like 'en-*'"

	self name = 'xml:lang'
		ifTrue: [^ self matchesLanguage: aLanguageTag]
		ifFalse: [^ super isInLanguage: aLanguageTag]! !
!XMLAttribute methodsFor: 'testing'!
isNamed: aName
	"Does the receiver's qualified or local name match the argument?"

	^ self name isXMLQualifiedOrLocalName: aName! !
!XMLAttribute methodsFor: 'testing'!
isNamedAny: aNameCollection
	"Does the receiver's qualified or local name match any of the names
	in aNameCollection?"

	^ aNameCollection includesXMLName: self name! !
!XMLAttribute methodsFor: 'accessing'!
localName
	"Returns the local name of the receiver, the name minus any leading
	prefix and colon like 'local' in 'prefix:local'"

	"this is recomputed from the name to save memory instead of
	being stored in an inst var like it is for XMLElement"
	^ self name xmlLocalNameAfterPrefix! !
!XMLAttribute methodsFor: 'testing'!
matchesLanguage: aLanguageTag
	"Returns true if the value is an IETF language tag that matches aLanguageTag.
	Matching is case-insensitive, and aLanguageTag can be partial, like 'en',
	and use wildcards, like 'en-*'"

	| sourceLanguageTag targetLanguageTag i |

	((sourceLanguageTag := self value asLowercase) isEmpty
		or: [(targetLanguageTag := aLanguageTag asLowercase) isEmpty])
		ifTrue: [^ false].

	sourceLanguageTag = targetLanguageTag
		ifTrue: [^ true].

	sourceLanguageTag := $- xmlSplit: sourceLanguageTag.
	i := 0.
	$-
		xmlSplit: targetLanguageTag
		do: [:each | | sourceLanguageSubTag |
			sourceLanguageSubTag :=
				sourceLanguageTag
					at: (i := i + 1)
					ifAbsent: [^ false].
			(sourceLanguageSubTag = each
				or: [each = '*'])
				ifFalse: [^ false]].

	^ true.! !
!XMLAttribute methodsFor: 'accessing'!
name
	^ name ifNil: [name := '']! !
!XMLAttribute methodsFor: 'accessing'!
name: aName
	self renameWith: [name := aName]! !
!XMLAttribute methodsFor: 'accessing'!
namespaceURI
	^ self resolvePrefix: self prefix! !
!XMLAttribute methodsFor: 'accessing'!
prefix
	"Returns the prefix of the receiver's name or an empty string if there
	isn't one."

	"this is recomputed from the qualified name instead of being stored
	in an inst var to save memory."
	^ self name xmlPrefixBeforeLocalName! !
!XMLAttribute methodsFor: 'accessing'!
prefix: aPrefix
	self renameWith: [name := self localName qualifyWithXMLPrefix:  aPrefix]! !
!XMLAttribute methodsFor: 'private'!
renameWith: aBlock
	| oldName |

	oldName := self name.
	aBlock value.
	(self name ~= oldName
		and: [self hasParent])
			ifTrue: [
				self parent
					renamedAttribute: self
					from: oldName
					to: self name].! !
!XMLAttribute methodsFor: 'namespacing'!
resolvePrefix: aPrefix
	"This resolves the attribute prefix aPrefix or returns an empty string
	if aPrefix is empty (attributes must be prefixed to have a namespace) or
	undeclared"

	^ self
		resolvePrefix: aPrefix
		ifUnresolvable: ''! !
!XMLAttribute methodsFor: 'namespacing'!
resolvePrefix: aPrefix ifUnresolvable: aBlock
	"This resolves the attribute prefix aPrefix or returns the result of
	evaluated aBlock if aPrefix is empty (attributes must be prefixed to have
	a namespace) or undeclared"

	^ (self hasParent
		and: [aPrefix size > 0]) "no default namespace for attributes"
		ifTrue: [
			self parent
				resolvePrefix: aPrefix
				ifUnresolvable: aBlock]
		ifFalse: [aBlock value]! !
!XMLAttribute methodsFor: 'initialization'!
setName: aName value: aValue element: anElement
	name := aName.
	value := aValue.
	parent := anElement.! !
!XMLAttribute methodsFor: 'accessing'!
sortKey
	^ self name! !
!XMLAttribute methodsFor: 'accessing'!
value
	^ value ifNil: [value := '']! !
!XMLAttribute methodsFor: 'accessing'!
value: aString
	value := aString! !
!XMLAttribute methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter
		writeStringName: self name;
		nextPut: $=;
		writeEscapedContentString: self value! !
!XMLComment class methodsFor: 'instance creation'!
string: aString
	^ self new string: aString! !
!XMLComment methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ aNodeVisitor visitComment: self! !
!XMLComment methodsFor: 'testing'!
isComment
	^ true! !
!XMLComment methodsFor: 'accessing'!
sortKey
	^ self string! !
!XMLComment methodsFor: 'accessing'!
string
	^ string ifNil: [string := '']! !
!XMLComment methodsFor: 'accessing'!
string: aString
	string := aString! !
!XMLComment methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter comment: self string! !
!XMLAttributeDeclaration class methodsFor: 'instance creation'!
element: anElementName attribute: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	^ self new
		element: anElementName;
		attribute: anAttributeName;
		type: aType;
		defaultPragma: aDefaultPragma;
		defaultValue: aDefaultValue! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
attribute
	^ attribute ifNil: [attribute := '']! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
attribute: anAttributeName
	attribute := anAttributeName! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
defaultPragma
	^ defaultPragma ifNil: [defaultPragma := '']! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
defaultPragma: aDefaultPragma
	defaultPragma := aDefaultPragma! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
defaultValue
	^ defaultValue ifNil: [defaultValue := '']! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
defaultValue: aDefaultValue
	defaultValue := aDefaultValue! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
element
	^ element ifNil: [element := '']! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
element: anElementName
	element := anElementName! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
type
	^ type ifNil: [type := '']! !
!XMLAttributeDeclaration methodsFor: 'accessing'!
type: aType 
	type := aType! !
!XMLAttributeDeclaration methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter attributeDeclaration
		element: self element;
		attribute: self attribute;
		type: self type;
		defaultPragma: self defaultPragma;
		defaultValue: self defaultValue;
		write! !
!XMLDeclarationNode methodsFor: 'testing'!
isDeclaration
	^ true! !
!XMLElementDeclaration class methodsFor: 'instance creation'!
element: anElementName contentModel: aContentModel
	^ self new
		element: anElementName;
		contentModel: aContentModel! !
!XMLElementDeclaration methodsFor: 'accessing'!
contentModel
	^ contentModel ifNil: [contentModel := '']! !
!XMLElementDeclaration methodsFor: 'accessing'!
contentModel: aContentModel
	contentModel := aContentModel! !
!XMLElementDeclaration methodsFor: 'accessing'!
element
	^ element ifNil: [element := '']! !
!XMLElementDeclaration methodsFor: 'accessing'!
element: anElementName
	element := anElementName! !
!XMLElementDeclaration methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter elementDeclaration
		element: self element;
		contentModel: self contentModel;
		write! !
!XMLEntityDeclaration class methodsFor: 'instance creation'!
name: aName publicID: aPublicID systemID: aSystemID
	^ self new
		name: aName;
		publicID: aPublicID;
		systemID: aSystemID! !
!XMLEntityDeclaration class methodsFor: 'instance creation'!
name: aName replacement: aReplacement
	^ self new
		name: aName;
		replacement: aReplacement! !
!XMLEntityDeclaration methodsFor: 'testing'!
isExternal
	^ self systemID notEmpty
		or: [self publicID notEmpty]! !
!XMLEntityDeclaration methodsFor: 'testing'!
isParameter
	^ false! !
!XMLEntityDeclaration methodsFor: 'testing'!
isUnparsed
	^ false! !
!XMLEntityDeclaration methodsFor: 'accessing'!
name
	^ name ifNil: [name := '']! !
!XMLEntityDeclaration methodsFor: 'accessing'!
name: aName
	name := aName! !
!XMLEntityDeclaration methodsFor: 'accessing'!
publicID
	^ publicID ifNil: [publicID := '']! !
!XMLEntityDeclaration methodsFor: 'accessing'!
publicID: aPublicID
	publicID := aPublicID! !
!XMLEntityDeclaration methodsFor: 'accessing'!
replacement
	^ replacement ifNil: [replacement := '']! !
!XMLEntityDeclaration methodsFor: 'accessing'!
replacement: aReplacement
	replacement := aReplacement! !
!XMLEntityDeclaration methodsFor: 'accessing'!
systemID
	^ systemID ifNil: [systemID := '']! !
!XMLEntityDeclaration methodsFor: 'accessing'!
systemID: aSystemID
	systemID := aSystemID! !
!XMLGeneralEntityDeclaration class methodsFor: 'instance creation'!
name: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName
	^ self new
		name: aName;
		publicID: aPublicID;
		systemID: aSystemID;
		ndata: aNotationName! !
!XMLGeneralEntityDeclaration methodsFor: 'testing'!
isUnparsed
	^ self ndata notEmpty! !
!XMLGeneralEntityDeclaration methodsFor: 'accessing'!
ndata
	^ ndata ifNil: [ndata := '']! !
!XMLGeneralEntityDeclaration methodsFor: 'accessing'!
ndata: aNotationName
	ndata := aNotationName! !
!XMLGeneralEntityDeclaration methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter entityDeclaration
		name: self name;
		isParameter: false;
		replacement: self replacement;
		publicID: self publicID;
		systemID: self systemID;
		ndata: self ndata;
		write! !
!XMLParameterEntityDeclaration methodsFor: 'testing'!
isParameter
	^ true! !
!XMLParameterEntityDeclaration methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter entityDeclaration
		name: self name;
		isParameter: true;
		replacement: self replacement;
		publicID: self publicID;
		systemID: self systemID;
		write! !
!XMLNotationDeclaration class methodsFor: 'instance creation'!
name: aName publicID: aPublicID systemID: aSystemID
	^ self new
		name: aName;
		publicID: aPublicID;
		systemID: aSystemID! !
!XMLNotationDeclaration methodsFor: 'accessing'!
name
	^ name ifNil: [name := '']! !
!XMLNotationDeclaration methodsFor: 'accessing'!
name: aName
	name := aName! !
!XMLNotationDeclaration methodsFor: 'accessing'!
publicID
	^ publicID ifNil: [publicID := '']! !
!XMLNotationDeclaration methodsFor: 'accessing'!
publicID: aPublicID
	publicID := aPublicID! !
!XMLNotationDeclaration methodsFor: 'accessing'!
systemID
	^ systemID ifNil: [systemID := '']! !
!XMLNotationDeclaration methodsFor: 'accessing'!
systemID: aSystemID
	systemID := aSystemID! !
!XMLNotationDeclaration methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter notationDeclaration
		name: self name;
		publicID: self publicID;
		systemID: self systemID;
		write! !
!XMLNode methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ self! !
!XMLNode methodsFor: 'deprecated'!
addContent: aStringOrStringNode
	"will be deprecated"

	XMLDOMException signal: 'Node cannot contain string content'! !
!XMLNode methodsFor: 'enumerating'!
allNodesDo: aBlock
	"evaluates aBlock for the receiver and all of its descendant nodes"

	aBlock value: self! !
!XMLNode methodsFor: 'accessing'!
ancestorElements
	"returns a node list with all ancestor elements of the receiver"
	| ancestorElements |

	ancestorElements := self newListForSelect.
	self ancestorElementsDo: [:each | ancestorElements addLast: each].
	^ ancestorElements.! !
!XMLNode methodsFor: 'enumerating'!
ancestorElementsDo: aBlock
	| ancestor |

	ancestor := self parent.
	[ancestor notNil
		and: [ancestor isElement]]
		whileTrue: [
			aBlock value: ancestor.
			ancestor := ancestor parent].! !
!XMLNode methodsFor: 'accessing'!
ancestorNodes
	"returns a node list with all ancestor nodes of the receiver"
	| ancestors |

	ancestors := self newListForSelect.
	self ancestorNodesDo: [:each | ancestors addLast: each].
	^ ancestors.! !
!XMLNode methodsFor: 'enumerating'!
ancestorNodesDo: aBlock
	| ancestor |

	ancestor := self parent.
	[ancestor notNil]
		whileTrue: [
			aBlock value: ancestor.
			ancestor := ancestor parent].! !
!XMLNode methodsFor: 'converting'!
asString
	"Returns the full, untruncated XML source string, unlike #printString,
	which may truncate long printed representations"
	
	^ String streamContents: [:stream | self printOn: stream]! !
!XMLNode methodsFor: 'testing'!
canHaveChildren
	"returns true if the receiver is a type of node that can have child nodes"

	^ false! !
!XMLNode methodsFor: 'testing'!
canonicallyEquals: aNode
	"returns true if the receiver and aNode have the same canonical
	representation (http://www.w3.org/TR/xml-c14n)"

	^ self canonicallyPrinted = aNode canonicallyPrinted! !
!XMLNode methodsFor: 'printing'!
canonicallyPrintOn: aStream
 	"Prints on aStream as canonical XML (http://www.w3.org/TR/xml-c14n)"

	self
		printOn: aStream
		beforeWritingDo: [:writer | writer isCanonical: true]! !
!XMLNode methodsFor: 'printing'!
canonicallyPrintToFileNamed: aFileName
 	"Prints to the file aFileName as canonical XML (http://www.w3.org/TR/xml-c14n)"

	self
		printToFileNamed: aFileName
		beforeWritingDo: [:writer | writer isCanonical: true]! !
!XMLNode methodsFor: 'printing'!
canonicallyPrinted
 	"Prints as canonical XML (http://www.w3.org/TR/xml-c14n)"

	^ String streamContents: [:stream | self canonicallyPrintOn: stream]! !
!XMLNode methodsFor: 'accessing'!
configuration
	^ self parent ifNotNil: [:node | node configuration]! !
!XMLNode methodsFor: 'accessing'!
contentString
 	"Returns a combined string of all descendant string values with spaces inserted
	for readability when one string has no trailing space and the next has no
	leading space.

	See also #rawContentString."

	^ String streamContents: [:stream | self printContentOn: stream]! !
!XMLNode methodsFor: 'copying'!
copy
	"returns a deep copy of the receiver, including copies of any descendant nodes,
	and copies the config"

	^ self shallowCopy postCopy postCopyConfiguration! !
!XMLNode methodsFor: 'copying'!
copySharingConfiguration	
	"returns a deep copy of the receiver, including copies of any descendant nodes,
	but does not copy the config"

	^ self shallowCopy postCopy! !
!XMLNode methodsFor: 'enumerating'!
descendantNodesDo: aBlock! !
!XMLNode methodsFor: 'deprecated'!
descendentNodesDo: aBlock
	self deprecated: 'use #descendantNodesDo: instead'.
	^ self descendantNodesDo: aBlock.! !
!XMLNode methodsFor: 'accessing'!
document
	"returns the document node that the receiver belongs to (the receiver if it's a
	document) or nil if there isn't one"

	^ self parent ifNotNil: [:node | node document]! !
!XMLNode methodsFor: 'accessing'!
documentRoot
	"returns the root of the DOM tree, a document node if there is one or the
	last ancestor or self otherwise"
	| documentRoot |

	documentRoot := self.
	self ancestorNodesDo: [:each | documentRoot := each].
	^ documentRoot.! !
!XMLNode methodsFor: 'private'!
errorXMLWritingUnsupported
	XMLDOMException signal: 'The XMLWriter package is required for writng DOM objects'! !
!XMLNode methodsFor: 'private'!
escapesContentEntitiesWhenWriting
	self hasParent
		ifTrue: [^ self parent escapesContentEntitiesWhenWriting]
		ifFalse: [^ true] "default to escaping"! !
!XMLNode methodsFor: 'testing'!
hasChildren
	"returns true if the receiver has child nodes"

	^ false! !
!XMLNode methodsFor: 'private'!
hasNodeList: aNodeList
	^ false! !
!XMLNode methodsFor: 'testing'!
hasParent
	"returns true if the receiver has a parent node"

	^ parent notNil! !
!XMLNode methodsFor: 'private'!
hasParentWithNodeList: aNodeList
	"optimized"
	parent == nil
		ifTrue: [^ false].
	^ parent hasNodeList: aNodeList.! !
!XMLNode methodsFor: 'private'!
initializeFileWriteStream: aWriteStream
	"This sets a stream converter on aWriteStream based on the document's encoding
	attribute and writes the encoding's byte order mark."

	| document |

	aWriteStream
		streamConverter:
			(((document := self document) notNil
				and: [document hasEncoding])
				ifTrue: [document encoding asXMLStreamConverter]
				ifFalse: [XMLStreamConverter default]);
		nextPutByteOrderMark! !
!XMLNode methodsFor: 'testing'!
isAttribute
	^ false! !
!XMLNode methodsFor: 'testing'!
isCData
	^ false! !
!XMLNode methodsFor: 'private'!
isCoalescingStringNode
	^ false! !
!XMLNode methodsFor: 'testing'!
isComment
	^ false! !
!XMLNode methodsFor: 'testing'!
isContentNode
	"returns true if the receiver is a content node (an element or string node)"

	^ false! !
!XMLNode methodsFor: 'testing'!
isDeclaration
	^ false! !
!XMLNode methodsFor: 'testing'!
isDocument
	^ false! !
!XMLNode methodsFor: 'testing'!
isElement
	^ false! !
!XMLNode methodsFor: 'testing'!
isElementNamed: aName
	"returns true if the receiver is an element whose qualified name or local
	name matches aName"

	^ false! !
!XMLNode methodsFor: 'testing'!
isElementNamedAny: aNameCollection
	"returns true if the receiver is an element whose qualified name or local
	name matches any name in aNameCollection"

	^ false! !
!XMLNode methodsFor: 'testing'!
isInLanguage: aLanguageTag
	"Returns true if one of the ancestor elements of the receiver has an xml:lang
	attribute, and if the value is an IETF language tag, like 'en-US', that matches
	aLanguageTag. Matching is case-insensitive, and aLanguageTag can be partial,
	like 'en', and use wildcards, like 'en-*'"

	^ self hasParent
		and: [self parent isInLanguage: aLanguageTag]! !
!XMLNode methodsFor: 'testing'!
isPI
	"returns true if the receiver is a processing instruction node"

	^ false! !
!XMLNode methodsFor: 'testing'!
isStringNode
	^ false! !
!XMLNode methodsFor: 'testing'!
isStringNode: aStringOrStringNode
	^ false! !
!XMLNode methodsFor: 'instance creation'!
newCData: aString
	^ self nodeFactory newCData: aString! !
!XMLNode methodsFor: 'instance creation'!
newComment: aString
	^ self nodeFactory newComment: aString! !
!XMLNode methodsFor: 'instance creation'!
newDocument
	^ self nodeFactory newDocument
		configuration: self configuration! !
!XMLNode methodsFor: 'instance creation'!
newElement
	^ self nodeFactory newElement
		configuration: self configuration! !
!XMLNode methodsFor: 'instance creation'!
newElementNamed: aName
	^ (self nodeFactory classForElement: aName) new
		configuration: self configuration;
		name: aName! !
!XMLNode methodsFor: 'instance creation'!
newElementNamed: aName attributes: anAssociationCollection
	^ (self nodeFactory
		classForElement: aName
		attributes: anAssociationCollection) new
			configuration: self configuration;
			name: aName;
			setAttributes: anAssociationCollection! !
!XMLNode methodsFor: 'instance creation'!
newElementNamed: aName namespaceURI: aURI
	^ (self nodeFactory
		classForElement: aName
		namespaceURI: aURI) new
			configuration: self configuration;
			name: aName namespaceURI: aURI! !
!XMLNode methodsFor: 'instance creation'!
newElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection
	^ (self nodeFactory
		classForElement: aName
		namespaceURI: aURI
		attributes: anAssociationCollection) new
			configuration: self configuration;
			name: aName namespaceURI: aURI;
			setAttributes: anAssociationCollection! !
!XMLNode methodsFor: 'instance creation'!
newListForCollect
	"collect can return non-nodes, so a basic ordered list is used"
	^ XMLOrderedList new: 10! !
!XMLNode methodsFor: 'instance creation'!
newListForSelect
	"select returns only nodes, so a node list is used"
	^ XMLNodeList new: 10! !
!XMLNode methodsFor: 'instance creation'!
newPI
	^ self nodeFactory newPI! !
!XMLNode methodsFor: 'instance creation'!
newPITarget: aTargetString data: aDataString
	^ self nodeFactory
		newPITarget: aTargetString
		data: aDataString! !
!XMLNode methodsFor: 'instance creation'!
newStringNode: aString
	^ self nodeFactory newStringNode: aString! !
!XMLNode methodsFor: 'accessing'!
nextNode
	"returns the first node after this one that is a child of the same parent (the next
	sibling) or nil if there isn't one"

	^ self parent ifNotNil: [:node | node nodeAfter: self]! !
!XMLNode methodsFor: 'accessing'!
nodeFactory
	^ self configuration
		ifNil: [XMLNodeFactory new]
		ifNotNil: [:config | config nodeFactory]! !
!XMLNode methodsFor: 'accessing'!
parent
	"returns the parent node of this node or nil if there isn't one"

	^ parent! !
!XMLNode methodsFor: 'private'!
parent: aNode
	parent := aNode! !
!XMLNode methodsFor: 'defaults'!
parserHandlerClass
	^ self configuration
		ifNil: [XMLDOMParser]
		ifNotNil: [:config | config parserHandlerClass]! !
!XMLNode methodsFor: 'copying'!
postCopy
	super postCopy.

	parent := nil.! !
!XMLNode methodsFor: 'copying'!
postCopyConfiguration! !
!XMLNode methodsFor: 'printing'!
prettyPrintOn: aStream
 	"Prints XML on aStream with whitespace formatting for readability"

	self
		printOn: aStream
		beforeWritingDo: [:writer | writer enablePrettyPrinting]! !
!XMLNode methodsFor: 'printing'!
prettyPrintToFileNamed: aFileName
 	"Prints XML to the file aFileName with whitespace formatting for readability"

	self
		printToFileNamed: aFileName
		beforeWritingDo: [:writer | writer enablePrettyPrinting]! !
!XMLNode methodsFor: 'printing'!
prettyPrinted
 	"Prints XML with whitespace formatting for readability"

	^ String streamContents: [:stream | self prettyPrintOn: stream]! !
!XMLNode methodsFor: 'accessing'!
previousNode
	"returns the first node before this one that is a child of the same parent
	(the preivous sibling) or nil if there isn't one"

	^ self parent ifNotNil: [:node | node nodeBefore: self]! !
!XMLNode methodsFor: 'printing'!
printContentOn: aStream
 	"Prints on aStream the combined content strings of all descendants with
	space inserted when one string has no trailing space and the next has
	no leading space.

	See also #printRawContentOn:"

	self printRawContentOn: (XMLNodeContentWriteStreamAdapter on: aStream)! !
!XMLNode methodsFor: 'printing'!
printOn: aStream
	"Uses XMLWriter if supported to print XML on aStream, uses the
	basic Object>>printOn: otherwise"

	self
		withNewXMLWriterOn: aStream
		do: [:writer |
			self writeXMLOn: writer.
			writer write]
		whenAbsent: [super printOn: aStream]! !
!XMLNode methodsFor: 'printing'!
printOn: aStream beforeWritingDo: aBlock
	"Prints XML on aStream using an XMLWriter object it creates but first
	evaluates aBlock with the XMLWriter so it can be configured before writing.

	Raises an error without XMLWriter support."

	self
		withNewXMLWriterOn: aStream
		do: [:writer |
			aBlock value: writer.
			self writeXMLOn: writer.
			writer write]! !
!XMLNode methodsFor: 'printing'!
printRawContentOn: aStream 
 	"Prints on aStream the content strings of all descendants
	without spaces inserted.

	See also #printContentOn:"! !
!XMLNode methodsFor: 'printing'!
printToFileNamed: aFileName
	"Prints XML to the file aFileName. Uses the encoding specified in the
	document's encoding attribute if supported or UTF-8 otherwise."

	self
		withNewWriteStreamOnFileNamed: aFileName
		do: [:writeStream |
			self
				printOn: writeStream
				beforeWritingDo: [:writer |
					"use the platform's line break because we're writing to a file"
					writer enablePlatformSpecificLineBreak]]! !
!XMLNode methodsFor: 'printing'!
printToFileNamed: aFileName beforeWritingDo: aBlock
	"Prints XML to the file aFileName after evaluating aBlock with the XMLWriter.
	Uses the encoding specified in the document's encoding attribute if
	supported or UTF-8 otherwise."

	self
		withNewWriteStreamOnFileNamed: aFileName
		do: [:writeStream |
			self
				printOn: writeStream
				beforeWritingDo: [:writer |
					"use the platform's line break because we're writing to a file"
					writer enablePlatformSpecificLineBreak.
					aBlock value: writer]]! !
!XMLNode methodsFor: 'printing'!
printWithoutSelfClosingTagsOn: aStream
	"Prints XML on aStream with empty elements rendered as '<empty></empty>'
	instead of self-closing '<empty/>' tags"

	self
		printOn: aStream
		beforeWritingDo: [:writer | writer outputsSelfClosingTags: false]! !
!XMLNode methodsFor: 'printing'!
printWithoutSelfClosingTagsToFileNamed: aFileName
	"Prints XML to the file aFileName with empty elements rendered
	as '<empty></empty>' instead of self-closing '<empty/>' tags"

	self
		printToFileNamed: aFileName
		beforeWritingDo: [:writer | writer outputsSelfClosingTags: false]! !
!XMLNode methodsFor: 'printing'!
printedWithoutSelfClosingTags
	"Prints XML with empty elements rendered as '<empty></empty>' instead
	of self-closing '<empty/>' tags"

	^ String streamContents: [:stream | self printWithoutSelfClosingTagsOn: stream]! !
!XMLNode methodsFor: 'accessing'!
rawContentString
 	"Returns a combined string of all descendant string values without any spaces
	inserted for readability.
	
	See also #contentString"

	^ String streamContents: [:stream | self printRawContentOn: stream]! !
!XMLNode methodsFor: 'accessing'!
sortKey
	"used to compare nodes when sorting"

	^ self class name asString! !
!XMLNode methodsFor: 'validating'!
validate
	"revalidate against the DTD it was parsed with (if any)"

	self document ifNotNil: [:document | document validate]! !
!XMLNode methodsFor: 'validating'!
validateWith: aValidator
	"revalidate against a custom DTD or other validator"

	self document ifNotNil: [:document | document validateWith: aValidator]! !
!XMLNode methodsFor: 'private'!
withNewWriteStreamOnFileNamed: aFileName do: aBlock
	aFileName asXMLFileHandle writeStreamDo: [:writeStream |
		self initializeFileWriteStream: writeStream.
		aBlock value: writeStream]! !
!XMLNode methodsFor: 'private'!
withNewXMLWriterOn: aStream do: aOneArgBlock
	^ self
		withNewXMLWriterOn: aStream
		do: aOneArgBlock
		whenAbsent: [self errorXMLWritingUnsupported]! !
!XMLNode methodsFor: 'private'!
withNewXMLWriterOn: aStream do: aOneArgBlock whenAbsent: aZeroArgBlock
	| writer |

	writer :=
		(self xmlWriterClassOrNil
			ifNil: [^ aZeroArgBlock value]) on: aStream.
	self escapesContentEntitiesWhenWriting
		ifFalse: [writer escapesContentEntityReferences: false].
	^ aOneArgBlock value: writer.! !
!XMLNode methodsFor: 'printing'!
writeXMLOn: aWriter
	"Template method used by nodes to write themselves on XMLWriters.

	Sending with a customized XMLWriter instance as the argument can be used
	to customize printing, but #printOn:beforeWritingDo: should be preferred."! !
!XMLNode methodsFor: 'defaults'!
xmlWriterClassOrNil
	"can be overridden to return a custom XMLWriter subclass"

	^ XMLClassFinder classNamed: #XMLWriter! !
!XMLDoctypeDeclaration class methodsFor: 'instance creation'!
root: aRootElementName publicID: aPublicID systemID: aSystemID
	^ self new
		root: aRootElementName;
		publicID: aPublicID;
		systemID: aSystemID! !
!XMLDoctypeDeclaration methodsFor: 'instance creation'!
newListForSelect
	^ XMLInternalSubsetList new: 10! !
!XMLDoctypeDeclaration methodsFor: 'defaults'!
nodeListClass
	^ XMLInternalSubsetList! !
!XMLDoctypeDeclaration methodsFor: 'accessing'!
publicID
	^ publicID ifNil: [publicID := '']! !
!XMLDoctypeDeclaration methodsFor: 'accessing'!
publicID: aPublicID
	publicID := aPublicID! !
!XMLDoctypeDeclaration methodsFor: 'accessing'!
root
	^ root ifNil: [root := '']! !
!XMLDoctypeDeclaration methodsFor: 'accessing'!
root: aRootElementName
	root := aRootElementName! !
!XMLDoctypeDeclaration methodsFor: 'accessing'!
systemID
	^ systemID ifNil: [systemID := '']! !
!XMLDoctypeDeclaration methodsFor: 'accessing'!
systemID: aSystemID
	systemID := aSystemID! !
!XMLDoctypeDeclaration methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter doctype
		root: self root;
		publicID: self publicID;
		systemID: self systemID;
		with: [self writeInnerXMLOn: aWriter]! !
!XMLNodeWithChildren methodsFor: 'adding'!
addComment: aString
	^ self addNode: (self newComment: aString)! !
!XMLNodeWithChildren methodsFor: 'adding'!
addNode: aNode
	"Adds aNode to the end of the receiver's node list. Can be used for elements,
	comments, and other types of nodes."

	^ self nodes addLast: aNode! !
!XMLNodeWithChildren methodsFor: 'adding'!
addNode: aNode after: aPreviousNode
	"Adds aNode to the receiver's node list after aPreviousNode raising an
	error if aPreviousNode is absent"

	^ self nodes
		add: aNode
		after: aPreviousNode! !
!XMLNodeWithChildren methodsFor: 'adding'!
addNode: aNode before: aNextNode
	"Adds aNode to the receiver's node list before aNextNode raising an
	error if aNextNode is absent"

	^ self nodes
		add: aNode
		before: aNextNode! !
!XMLNodeWithChildren methodsFor: 'adding'!
addNodeFirst: aNode
	"Adds aNode to the begining of the receiver's node list. Can be used for
	elements, comments, and other types of nodes."

	^ self nodes addFirst: aNode! !
!XMLNodeWithChildren methodsFor: 'adding'!
addNodes: aNodeCollection
	^ self nodes addAll: aNodeCollection! !
!XMLNodeWithChildren methodsFor: 'adding'!
addPITarget: aTargetString data: aDataString
	^ self addNode:
		(self
			newPITarget: aTargetString
			data: aDataString)! !
!XMLNodeWithChildren methodsFor: 'notifying'!
addedNode: aNode
	aNode parent
		ifNotNil: [:nodeParent |
			nodeParent == self
				ifFalse: [nodeParent removeNode: aNode]].
	aNode parent: self.! !
!XMLNodeWithChildren methodsFor: 'accessing'!
allNodes
	"returns a node list with the receiver and all of its descendant nodes"
	| allNodes |

	allNodes := self newListForSelect.
	self allNodesDo: [:each | allNodes addLast: each].
	^ allNodes.! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
allNodesCollect: aBlock
	"returns an ordered list of the receiver and all of its descendant nodes
	evaluated with aBlock"
	| collectedObjects |

	collectedObjects := self newListForCollect.
	self allNodesDo: [:each | collectedObjects addLast: (aBlock value: each)].
	^ collectedObjects.! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
allNodesDetect: aBlock
	^ self allNodesDetect: aBlock ifNone: [nil]! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
allNodesDetect: aBlock ifNone: anExceptionBlock
	self allNodesDo: [:each |
		(aBlock value: each)
			ifTrue: [^ each]].
	^ anExceptionBlock value.! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
allNodesDo: aBlock
	"evaluates aBlock for the receiver and all of its descendant nodes"

	aBlock value: self.
	self hasChildren
		ifTrue: [self nodesDo: [:each | each allNodesDo: aBlock]]! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
allNodesSelect: aBlock
	| selectedNodes |

	selectedNodes := self newListForSelect.
	self allNodesDo: [:each |
		(aBlock value: each)
			ifTrue: [selectedNodes addLast: each]].
	^ selectedNodes.! !
!XMLNodeWithChildren methodsFor: 'testing'!
canHaveChildren
	^ true! !
!XMLNodeWithChildren methodsFor: 'accessing'!
descendantNodes
	"returns a node list with all descendant nodes of the receiver"
	| descendentNodes |

	descendentNodes := self newListForSelect.
	self descendantNodesDo: [:each | descendentNodes addLast: each].
	^ descendentNodes.! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
descendantNodesCollect: aBlock
	"returns an ordered list of the values of all descendant nodes of the
	receiver evaluated with aBlock"
	| collectedObjects |

	collectedObjects := self newListForCollect.
	self descendantNodesDo: [:each |
		collectedObjects addLast: (aBlock value: each)].
	^ collectedObjects.! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
descendantNodesDetect: aBlock
	"returns the first descendant node of the receiver that aBlock evaluates
	true for or nil if there isn't one"

	^ self
		descendantNodesDetect: aBlock
		ifNone: [nil]! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
descendantNodesDetect: aBlock ifNone: anExceptionBlock
	"returns the first descendant node of the receiver that aBlock evaluates
	true for or the value of anExceptionBlock if there isn't one"

	self descendantNodesDo: [:each |
		(aBlock value: each)
			ifTrue: [^ each]].
	^ anExceptionBlock value.! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
descendantNodesDo: aBlock
	"evaluates aBlock for all descendant nodes of the receiver"

	self hasChildren
		ifTrue: [self nodesDo: [:each | each allNodesDo: aBlock]]! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
descendantNodesSelect: aBlock
	"returns a node list of all descendant nodes of the receiver that aBlock
	evaluates true for"
	| selectedNodes |

	selectedNodes := self newListForSelect.
	self descendantNodesDo: [:each |
		(aBlock value: each)
			ifTrue: [selectedNodes addLast: each]].
	^ selectedNodes.! !
!XMLNodeWithChildren methodsFor: 'deprecated'!
descendentNodes
	self deprecated: 'use #descendantNodes instead'.
	^ self descendantNodes.! !
!XMLNodeWithChildren methodsFor: 'deprecated'!
descendentNodesCollect: aBlock
	self deprecated: 'use #descendantNodesCollect: instead'.
	^ self descendantNodesCollect: aBlock.! !
!XMLNodeWithChildren methodsFor: 'deprecated'!
descendentNodesDetect: aBlock
	self deprecated: 'use #descendantNodesDetect: instead'.
	^ self descendantNodesDetect: aBlock.! !
!XMLNodeWithChildren methodsFor: 'deprecated'!
descendentNodesDetect: aBlock ifNone: anExceptionBlock
	self deprecated: 'use #descendantNodesDetect:ifNone: instead'.
	^ self
		descendantNodesDetect: aBlock
		ifNone: anExceptionBlock.! !
!XMLNodeWithChildren methodsFor: 'deprecated'!
descendentNodesSelect: aBlock
	self deprecated: 'use #descendantNodesSelect: instead'.
	^ self descendantNodesSelect: aBlock.! !
!XMLNodeWithChildren methodsFor: 'accessing'!
firstNode
	"returns the first child node of the receiver if it has one, nil otherwise"

	^ self nodes first! !
!XMLNodeWithChildren methodsFor: 'testing'!
hasChildren
	"optimized with nil test and size check to avoid lazy initializing"
	nodes == nil
		ifTrue: [^ false].
	^ nodes size > 0.! !
!XMLNodeWithChildren methodsFor: 'private'!
hasNodeList: aNodeList
	^ nodes == aNodeList! !
!XMLNodeWithChildren methodsFor: 'testing'!
includesNode: aNode
	^ self nodes includes: aNode! !
!XMLNodeWithChildren methodsFor: 'accessing'!
innerXML
	"Returns a string containing the XML source of all descendent nodes.
	
	See #innerXML:"

	^ String streamContents: [:stream | self printInnerXMLOn: stream]! !
!XMLNodeWithChildren methodsFor: 'accessing'!
innerXMLPrettyPrinted
	"Pretty print version of #innerXML.
	
	See #innerXML:"

	^ String streamContents: [:stream |
		self
			printInnerXMLOn: stream
			beforeWritingDo: [:writer | writer enablePrettyPrinting]]! !
!XMLNodeWithChildren methodsFor: 'accessing'!
lastNode
	"returns the last child node of the receiver if it has one, nil otherwise"

	^ self nodes last! !
!XMLNodeWithChildren methodsFor: 'accessing'!
nodeAfter: aNode
	"returns the first child node of the receiver after aNode or nil if there
	isn't one"

	^ self nodes after: aNode! !
!XMLNodeWithChildren methodsFor: 'accessing'!
nodeAt: anIndex
	"returns the child node at position anIndex or nil if there isn't one"

	^ self nodes at: anIndex! !
!XMLNodeWithChildren methodsFor: 'accessing'!
nodeAt: anIndex ifAbsent: aBlock
	"returns the child node at position anIndex or the value of aBlock
	if there isn't one"

	^ self nodes
		at: anIndex
		ifAbsent: aBlock! !
!XMLNodeWithChildren methodsFor: 'accessing'!
nodeAt: anIndex put: aNode
	"replaces the child node at anIndex with aNode, raising an error if
	anIndex is outside the current range of the node list"

	^ self nodes
		at: anIndex
		put: aNode! !
!XMLNodeWithChildren methodsFor: 'accessing'!
nodeBefore: aNode
	"returns the first child node of the receiver before aNode or nil if there
	isn't one"

	^ self nodes before: aNode! !
!XMLNodeWithChildren methodsFor: 'defaults'!
nodeListClass
	^ XMLNodeList! !
!XMLNodeWithChildren methodsFor: 'accessing'!
nodes
	"returns the internal node list; safe to modify, but adding or removing nodes
	from it will have the effect of adding or removing them from the receiver"

	^ nodes ifNil: [nodes := self nodeListClass observer: self]! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
nodesCollect: aBlock
	"returns an ordered list of the values of all node children of the
	receiver evaluated with aBlock"

	^ self nodes collect: aBlock! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
nodesDetect: aBlock
	^ self nodes detect: aBlock! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
nodesDetect: aBlock ifNone: anExceptionBlock
	^ self nodes detect: aBlock ifNone: anExceptionBlock! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
nodesDo: aBlock
	"evaluates aBlock for all child nodes of the receiver"

	self nodes do: aBlock! !
!XMLNodeWithChildren methodsFor: 'enumerating'!
nodesSelect: aBlock
	"returns a node list of all node children of the receiver that aBlock
	evaluates true for"

	^ self nodes select: aBlock! !
!XMLNodeWithChildren methodsFor: 'copying'!
postCopy
	super postCopy.

	nodes
		ifNotNil: [| copiedNodes |
			copiedNodes := nodes copyEmpty observer: self.
			nodes do: [:each |
				"copySharingConfiguration is used so the config is only ever copied
				once when an element or doc is sent #copy and is done after all of the
				descendants have been copied"
				copiedNodes addLast: each copySharingConfiguration].
			nodes := copiedNodes].! !
!XMLNodeWithChildren methodsFor: 'printing'!
printInnerXMLOn: aStream
	self hasChildren
		ifTrue: [
			self
				withNewXMLWriterOn: aStream
				do: [:writer |
					self writeInnerXMLOn: writer]]! !
!XMLNodeWithChildren methodsFor: 'printing'!
printInnerXMLOn: aStream beforeWritingDo: aBlock
	self hasChildren
		ifTrue: [
			self
				withNewXMLWriterOn: aStream
				do: [:writer |
					aBlock value: writer.
					self writeInnerXMLOn: writer.
					writer write]]! !
!XMLNodeWithChildren methodsFor: 'removing'!
removeNode: aNode
	^ self nodes remove: aNode! !
!XMLNodeWithChildren methodsFor: 'removing'!
removeNode: aNode ifAbsent: aBlock
	^ self nodes remove: aNode ifAbsent: aBlock! !
!XMLNodeWithChildren methodsFor: 'removing'!
removeNodes
	self nodes removeAll! !
!XMLNodeWithChildren methodsFor: 'removing'!
removeNodes: aNodeCollection
	^ self nodes removeAll: aNodeCollection! !
!XMLNodeWithChildren methodsFor: 'notifying'!
removedNode: aNode
	aNode parent: nil! !
!XMLNodeWithChildren methodsFor: 'accessing'!
replaceNode: aNode with: aReplacementNode
	"replaces aNode in the receiver with aReplacementNode, or if aReplacementNode
	is already a child of the receiver, just swaps their locations"

	| firstIndex secondIndex |

	firstIndex := self nodes indexOf: aNode.
	(secondIndex := self nodes indexOf: aReplacementNode) > 0
		ifTrue: [
			self nodes
				swap: firstIndex
				with: secondIndex]
		ifFalse: [
			self nodes
				at: firstIndex
				put: aReplacementNode].
	^ aReplacementNode.! !
!XMLNodeWithChildren methodsFor: 'printing'!
writeInnerXMLOn: aWriter
	self nodesDo: [:each | each writeXMLOn: aWriter]! !
!XMLNodeWithChildren methodsFor: 'printing'!
writeXMLOn: aWriter
	self writeInnerXMLOn: aWriter! !
!XMLDocument class methodsFor: 'instance creation'!
root: aRoot
	^ self new root: aRoot! !
!XMLDocument methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ aNodeVisitor visitDocument: self! !
!XMLDocument methodsFor: 'accessing'!
doctypeDeclaration
	^ doctypeDeclaration! !
!XMLDocument methodsFor: 'accessing'!
doctypeDeclaration: aDoctypeDeclaration
	doctypeDeclaration
		ifNotNil: [doctypeDeclaration parent: nil].

	aDoctypeDeclaration
		ifNotNil: [
			aDoctypeDeclaration hasParent
				ifTrue: [
					"remove it from its current parent"
					aDoctypeDeclaration parent doctypeDeclaration: nil].
			aDoctypeDeclaration parent: self].

	doctypeDeclaration := aDoctypeDeclaration.! !
!XMLDocument methodsFor: 'accessing'!
doctypeDefinition
	^ doctypeDefinition! !
!XMLDocument methodsFor: 'accessing'!
doctypeDefinition: aDoctypeDefinition
	doctypeDefinition := aDoctypeDefinition! !
!XMLDocument methodsFor: 'accessing'!
document
	^ self! !
!XMLDocument methodsFor: 'accessing'!
documentRoot
	"returns the root of the DOM tree"
	^ self! !
!XMLDocument methodsFor: 'accessing'!
encoding	
	^ encoding ifNil: [encoding := '']! !
!XMLDocument methodsFor: 'accessing'!
encoding: aString	
	encoding := aString! !
!XMLDocument methodsFor: 'private'!
errorCannotHaveNonElementRoot
	XMLDOMException signal: 'Cannot have non-element root'! !
!XMLDocument methodsFor: 'testing'!
hasDoctypeDeclaration
	^ self doctypeDeclaration notNil! !
!XMLDocument methodsFor: 'testing'!
hasDoctypeDefinition
	^ self doctypeDefinition notNil! !
!XMLDocument methodsFor: 'testing'!
hasEncoding
	^ self encoding notEmpty! !
!XMLDocument methodsFor: 'testing'!
hasRoot
	^ self root notNil! !
!XMLDocument methodsFor: 'private'!
innerXMLStateClass
	^ XMLPostDoctypeDeclarationState! !
!XMLDocument methodsFor: 'testing'!
isDocument
	^ true! !
!XMLDocument methodsFor: 'testing'!
isStandalone
	^ isStandalone ifNil: [isStandalone := false]! !
!XMLDocument methodsFor: 'accessing'!
isStandalone: aBoolean
	isStandalone := aBoolean! !
!XMLDocument methodsFor: 'copying'!
postCopy
	super postCopy.

	doctypeDeclaration
		ifNotNil: [doctypeDeclaration := doctypeDeclaration copy].! !
!XMLDocument methodsFor: 'accessing'!
root
	"Returns the current root element or nil if there isn't one"

	^ self firstElement! !
!XMLDocument methodsFor: 'accessing'!
root: anElement
	"Replaces the current root element (if any) with anElement,
	leaving all other nodes in place"

	anElement isElement
		ifFalse: [self errorCannotHaveNonElementRoot].

	self firstElement
		ifNil: [self addNode: anElement]
		ifNotNil: [:firstElement |
			self
				replaceNode: firstElement
				with: anElement].! !
!XMLDocument methodsFor: 'validating'!
validate
	"revalidate against the DTD it was parsed with (if any)"

	self hasDoctypeDefinition
		ifTrue: [
			self doctypeDefinition
				removeElementIDReferences;
				removeElementIDs.
			self validateWith: self doctypeDefinition newValidator]! !
!XMLDocument methodsFor: 'validating'!
validateWith: aValidator
	"revalidate against a custom DTD or other validator"

	(XMLValidatingNodeVisitor validator: aValidator) visitDocument: self! !
!XMLDocument methodsFor: 'accessing'!
version	
	^ version! !
!XMLDocument methodsFor: 'accessing'!
version: aVersionFloat
	version := aVersionFloat! !
!XMLDocument methodsFor: 'printing'!
writeDoctypeDeclarationOn: aWriter
	self hasDoctypeDeclaration
		ifTrue: [self doctypeDeclaration writeXMLOn: aWriter]! !
!XMLDocument methodsFor: 'printing'!
writeXMLDeclarationOn: aWriter
	self version
		ifNotNil: [
			aWriter xml
				version: self version;
				encoding: self encoding;
				standalone: self isStandalone;
				write]! !
!XMLDocument methodsFor: 'printing'!
writeXMLOn: aWriter
	self
		writeXMLDeclarationOn: aWriter;
		writeDoctypeDeclarationOn: aWriter;
		writeInnerXMLOn: aWriter! !
!XMLElement class methodsFor: 'instance creation'!
name: aLocalName
	^ self named: aLocalName! !
!XMLElement class methodsFor: 'instance creation'!
name: aLocalName attributes: anAssociationCollection
	"Returns a new element with the specified name and attributes.

	Both aLocalName and the attributes must not be prefixed or a namespace
	exception will be thrown.

	The anAssociationCollection argument can be a dictionary or any collection
	of associations."

	^ (self named: aLocalName)
		setAttributes: anAssociationCollection! !
!XMLElement class methodsFor: 'instance creation'!
name: aQualifiedName namespaceURI: aURI
	"Returns a new element with the specified name and namespace URI.

	If aQualifiedName has a prefix, then aURI must be non-empty and the prefix
	will be bound to it. Otherwise aURI will be declared as the default namespace."

	^ self new
		name: aQualifiedName
		namespaceURI: aURI! !
!XMLElement class methodsFor: 'instance creation'!
name: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection
	"Returns a new element with the specified name, namespace URI, and attributes.

	If aQualifiedName has a prefix, then aURI must be non-empty and the prefix
	will be bound to it. Otherwise aURI will be declared as the default namespace.
	If the attributes are prefixed, then aQualifiedName must have the same prefix
	or a namespace exception will be thrown.

	The anAssociationCollection argument can be a dictionary or any collection
	of associations."

	^ (self
		name: aQualifiedName
		namespaceURI: aURI)
			setAttributes: anAssociationCollection! !
!XMLElement class methodsFor: 'instance creation'!
name: aQualifiedName namespaces: anAssociationCollection
	"Returns a new element with the specified name and namespaces.

	If aQualifiedName has a prefix, then anAssociationCollection must contain
	an association for it or a namespace exception will be thrown.

	The anAssociationCollection argument can be a dictionary or any collection
	of associations. An association with an empty string key sets the default
	namespace."

	^ self new
		declareNamespaces: anAssociationCollection;
		name: aQualifiedName! !
!XMLElement class methodsFor: 'instance creation'!
name: aQualifiedName namespaces: aNamespaceAssociationCollection attributes: anAttributeAssociationCollection
	"Returns a new element with the specified name, namespaces, and attributes.

	If aQualifiedName or one of the attributes has a prefix, then
	aNamespaceAssociationCollection must contain an association for it or a
	namespace exception will be thrown.

	The aNamespaceAssociationCollection and anAttributeAssociationCollection
	arguments can be dictionaries or any collection of associations. An
	association with an empty string key sets the default namespace."

	^ (self
		name: aQualifiedName
		namespaces: aNamespaceAssociationCollection)
			setAttributes: anAttributeAssociationCollection! !
!XMLElement class methodsFor: 'instance creation'!
named: aLocalName
	"Returns a new element with the specified name.

	The argument must not be prefixed or a namespace exception will be thrown."

	^ self new name: aLocalName! !
!XMLElement methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ aNodeVisitor visitElement: self! !
!XMLElement methodsFor: 'notifying'!
addedAttribute: anAttribute
	anAttribute element
		ifNotNil: [:element |
			element == self
				ifFalse: [element removeAttributeNode: anAttribute]].
	anAttribute element: self.
	self validateNamespacePrefixOfAttribute: anAttribute.! !
!XMLElement methodsFor: 'private'!
addedElement: anElement
	(self hasNamespaces
		and: [self namespaceScope ~= anElement namespaceScope])
		ifTrue: [
			anElement allElementsDo: [:each |
				each namespaceScope inheritMappingsFrom: self namespaceScope]]! !
!XMLElement methodsFor: 'enumerating'!
allElementsDo: aBlock
	"evaluates aBlock for the receiver and all descendant elements"

	aBlock value: self.
	self hasChildren
		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]].! !
!XMLElement methodsFor: 'private'!
allNamespaceScopesRemapPrefix: aPrefix from: anOldURIOrNil to: aNewURI
	(self namespaceScope
		prefixMappingAt: aPrefix
		ifAbsent: [anOldURIOrNil]) = anOldURIOrNil
		ifTrue: [
			self namespaceScope
				mapPrefix: aPrefix
				to: aNewURI.
			"we only need to check the attributes if we've remapped an
			existing, non-default namespace"
			(anOldURIOrNil notNil
				and: [aPrefix size > 0])
				ifTrue: [self validateNamespacePrefixesOfAttributes].
			self elementsDo: [:each |
				each
					allNamespaceScopesRemapPrefix: aPrefix
					from: anOldURIOrNil
					to: aNewURI]]! !
!XMLElement methodsFor: 'private'!
allNamespaceScopesUnmapPrefix: aPrefix mappedTo: aURI
	(self namespaceScope
		includesPrefix: aPrefix
		mappedTo: aURI)
		ifTrue: [
			self namespaceScope unmapPrefix: aPrefix.
			self
				validateNamespacePrefix;
				validateNamespacePrefixesOfAttributes.
			self elementsDo: [:each |
				each
					allNamespaceScopesUnmapPrefix: aPrefix
					mappedTo: aURI]]! !
!XMLElement methodsFor: 'accessing'!
attributeAssociations
	"returns attribute name->value associations"

	^ self attributeNodes attributeAssociations! !
!XMLElement methodsFor: 'accessing'!
attributeAt: aName
	"returns the value of the attribute whose full name matches aName or an
	empty string if there isn't any"

	^ self attributeNodes attributeValueAt: aName! !
!XMLElement methodsFor: 'accessing'!
attributeAt: aName ifAbsent: aBlock
	"returns the value of the attribute whose full name matches aName or the
	value of aBlock if there isn't any"

	^ self attributeNodes
		attributeValueAt: aName
		ifAbsent: aBlock! !
!XMLElement methodsFor: 'accessing'!
attributeAt: aName ifAbsentPut: aBlock
	"sets the value of the attribute whose full name matches aName to the value
	of aBlock if there isn't one already"

	^ self attributeNodes
		attributeValueAt: aName
		ifAbsentPut: aBlock! !
!XMLElement methodsFor: 'accessing'!
attributeAt: aName put: aValue
	"sets the value of the attribute whose full name matches aName to the value
	aValue"

	^ self attributeNodes
		attributeValueAt: aName
		put: aValue! !
!XMLElement methodsFor: 'defaults'!
attributeListClass
	^ self configuration nodeFactory attributeListClass! !
!XMLElement methodsFor: 'accessing'!
attributeNames
	^ self attributeNodes attributeNames! !
!XMLElement methodsFor: 'enumerating'!
attributeNamesAndValuesDo: aTwoArgumentBlock
	self attributeNodes attributeNamesAndValuesDo: aTwoArgumentBlock! !
!XMLElement methodsFor: 'enumerating'!
attributeNamesDo: aBlock
	self attributeNodes attributeNamesDo: aBlock! !
!XMLElement methodsFor: 'accessing'!
attributeNodeAt: aName
	"returns the attribute node whose qualified or local name matches aName
	(unlike attributeAt:, which matches the full name exactly), or nil if there
	isn't any"

	^ self attributeNodes attributeNodeAt: aName! !
!XMLElement methodsFor: 'accessing'!
attributeNodeAt: aName ifAbsent: aBlock
	"returns the attribute node whose qualified or local name matches aName
	(unlike attributeAt:ifAbsent:, which matches the full name exactly), or
	the value of aBlock if there isn't any"

	^ self attributeNodes
		attributeNodeAt: aName
		ifAbsent: aBlock! !
!XMLElement methodsFor: 'accessing'!
attributeNodeAt: aName namespaceURI: aURI
	"returns the attribute node whose qualified or local name matches aName
	(unlike attributeAt:, which matches the full name exactly) and whose
	namespace URI matches aURI, or nil if there isn't any"

	^ self attributeNodes
		attributeNodeAt: aName
		namespaceURI: aURI! !
!XMLElement methodsFor: 'accessing'!
attributeNodeAt: aName namespaceURI: aURI ifAbsent: aBlock
	"returns the attribute node whose qualified or local name matches aName
	(unlike attributeAt:ifAbsent:, which matches the full name exactly) and
	whose namespace URI matches aURI, or the value of aBlock if there isn't any"

	^ self attributeNodes
		attributeNodeAt: aName
		namespaceURI: aURI
		ifAbsent: aBlock! !
!XMLElement methodsFor: 'accessing'!
attributeNodes
	"Returns the attribute node list. Can be modified, but adding or removing
	attributes also adds or removes them from the element. Copy before
	modifying if you don't want that."

	^ attributes ifNil: [attributes := self attributeListClass observer: self]! !
!XMLElement methodsFor: 'enumerating'!
attributeNodesDo: aBlock
	self attributeNodes do: aBlock! !
!XMLElement methodsFor: 'accessing'!
attributes
	"returns a new order preserving dictionary of attribute names and values"

	^ self attributeNodes attributes! !
!XMLElement methodsFor: 'namespacing'!
declareNamespaces: anAssociationCollection
	self ensureUsesNamespaces.
	anAssociationCollection associationsDo: [:each |
		self
			declarePrefix: each key
			uri: each value]! !
!XMLElement methodsFor: 'namespacing'!
declarePrefix: aPrefix uri: aURI
	self ensureUsesNamespaces.
	self
		allNamespaceScopesRemapPrefix: aPrefix
		from:
			(self namespaceScope
				prefixMappingAt: aPrefix
				ifAbsent: [nil])
		to: aURI.! !
!XMLElement methodsFor: 'namespacing'!
declaredPrefixes
	^ self usesNamespaces "avoid lazy initializing the scope"
		ifTrue: [self namespaceScope mappedPrefixes]
		ifFalse: [#()]! !
!XMLElement methodsFor: 'testing'!
declaresDefaultNamespace
	"Did the receiver declare a new default namespace rather than inheriting one?"

	^ self namespaceScope hasDefaultNamespace
		and: [self isRoot
			or: [self defaultNamespace ~= self parent defaultNamespace]]! !
!XMLElement methodsFor: 'testing'!
declaresPrefix: aPrefix uri: aURI
	"Did the receiver declare a new prefix/uri pair rather than inheriting it?"

	^ (self isDeclaredPrefix: aPrefix uri: aURI)
		and: [self isRoot
			or: [(self parent isDeclaredPrefix: aPrefix uri: aURI) not]]! !
!XMLElement methodsFor: 'namespacing'!
defaultNamespace
	^ self usesNamespaces "avoid lazy initializing the scope"
		ifTrue: [self namespaceScope defaultNamespace]
		ifFalse: ['']! !
!XMLElement methodsFor: 'namespacing'!
defaultNamespace: aURI
	self
		declarePrefix: ''
		uri: aURI! !
!XMLElement methodsFor: 'accessing'!
expandedName
	"Returns the expanded name of the element as a string in the form of
	'{namespaceURI}localName' if there's a namespace URI or 'localName' if there
	isn't"

	^ self localName expandWithXMLNamespaceURI: self namespaceURI! !
!XMLElement methodsFor: 'testing'!
hasAttributes
	"returns true if this element has attribute"

	"optimized to avoid lazy initialization"
	attributes == nil
		ifTrue: [^ false].
	^ attributes size > 0.! !
!XMLElement methodsFor: 'testing'!
hasID: anID
	| document doctypeDefinition attributeValidators |

	self hasAttributes
		ifFalse: [^ false].

	((document := self document) notNil
		and: [(doctypeDefinition := document doctypeDefinition) notNil
			and: [doctypeDefinition hasAttributeValidators
				and: [
					(attributeValidators :=
						doctypeDefinition attributeValidatorsAt: self name) notNil]]])
		ifTrue: [
			^ self
				hasUndeclaredOrDeclaredID: anID
				declaredWith: attributeValidators]
		ifFalse: [^ self hasUndeclaredID: anID].! !
!XMLElement methodsFor: 'testing'!
hasNamespaceURI
	^ self namespaceURI notEmpty! !
!XMLElement methodsFor: 'testing'!
hasNamespaces
	"returns true if the receiver declared or inherited namespace declarations"

	"optimized to avoid lazy initialization"
	namespaceScope == nil
		ifTrue: [^ false].
	^ namespaceScope hasNamespaces.! !
!XMLElement methodsFor: 'testing'!
hasPrefix
	"returns true if the receiver's name is a qualified name with a prefix"

	^ self name size > self localName size! !
!XMLElement methodsFor: 'private'!
hasUndeclaredID: anID
	"just look for an 'xml:id' attribute if there were no declarations"
	^ (self
		attributeAt: 'xml:id'
		ifAbsent: [^ false]) = anID! !
!XMLElement methodsFor: 'private'!
hasUndeclaredOrDeclaredID: anID declaredWith: anAttributeValidatorDictionary
	self attributeNamesAndValuesDo: [:attributeName :attributeValue |
		"only check its value if it's been declared as an ID attribute
		or if it's named 'xml:id'"
		((anAttributeValidatorDictionary
			at: attributeName
			ifAbsent: [nil])
				ifNil: [attributeName = 'xml:id']
				ifNotNil: [:attributeValidator | attributeValidator isID])
			ifTrue: [
				attributeValue = anID
					ifTrue: [^ true]]].
	^ false.! !
!XMLElement methodsFor: 'testing'!
includesAttribute: aName
	^ self attributeNodes includesAttribute: aName! !
!XMLElement methodsFor: 'testing'!
includesAttributeNode: aName
	^ self attributeNodes includesAttributeNode: aName! !
!XMLElement methodsFor: 'testing'!
includesAttributeNode: aName namespaceURI: aURI
	^ self attributeNodes
		includesAttributeNode: aName
		namespaceURI: aURI! !
!XMLElement methodsFor: 'testing'!
isDeclaredPrefix: aPrefix
	"is the namespace prefix aPrefix declared for the receiver and its descendants?"

	^ self usesNamespaces
		and: [self namespaceScope includesPrefix: aPrefix]! !
!XMLElement methodsFor: 'testing'!
isDeclaredPrefix: aPrefix uri: aURI
	"is the namespace prefix aPrefix mapped to aURI for the receiver and
	its descendants?"

	^ self usesNamespaces
		and: [
			self namespaceScope
				includesPrefix: aPrefix
				mappedTo: aURI]! !
!XMLElement methodsFor: 'testing'!
isElement
	^ true! !
!XMLElement methodsFor: 'testing'!
isElementNamed: aName
	"returns true if the receiver's qualified name or local name matches aName"

	^ self isNamed: aName! !
!XMLElement methodsFor: 'testing'!
isElementNamedAny: aNameCollection
	"returns true if the receiver's qualified name or local name matches any
	name in aNameCollection"

	^ self isNamedAny: aNameCollection! !
!XMLElement methodsFor: 'testing'!
isInLanguage: aLanguageTag
	"Returns true if the receiver or one of its ancestors has an xml:lang
	attribute, and if the value is an IETF language tag, like 'En-US', that matches
	aLanguageTag. Matching is case-insensitive, and aLanguageTag can be partial,
	like 'En', and use wildcards, like 'En-*'"

	^ (self
		attributeNodeAt: 'xml:lang'
		ifAbsent: [
			^ self hasParent
				and: [self parent isInLanguage: aLanguageTag]])
			matchesLanguage: aLanguageTag! !
!XMLElement methodsFor: 'testing'!
isNamed: aName
	"Does the receiver's qualified or local name match aName?"

	^ self name isXMLQualifiedOrLocalName: aName! !
!XMLElement methodsFor: 'testing'!
isNamedAny: aNameCollection
	"Does the receiver's qualified or local name match any of the names
	in aNameCollection?"

	^ aNameCollection includesXMLName: self name! !
!XMLElement methodsFor: 'testing'!
isRoot
	"Is the receiver the root element of a DOM tree?"

	^ (self hasParent and: [self parent isElement]) not! !
!XMLElement methodsFor: 'accessing'!
localName
	"Returns the local name of the receiver, the name minus any leading
	prefix and colon like 'local' in 'prefix:local'"

	^ localName ifNil: [localName := self name xmlLocalNameAfterPrefix]! !
!XMLElement methodsFor: 'accessing'!
name
	"returns the full name of the element, either a qualified name if it has a
	prefix or just a local name if it doesn't"

	^ name ifNil: [name := '']! !
!XMLElement methodsFor: 'accessing'!
name: aName
	"Renames the element. If aName is a qualified name and namespace checking is
	enabled (default), then the prefix must already have been declared. This can
	be done while renaming using name:namespaceURI."

	self renameWith: [
		name := aName.
		localName := aName xmlLocalNameAfterPrefix]! !
!XMLElement methodsFor: 'accessing'!
name: aName namespaceURI: aURI
	"Renames the element and also declares a namespace URI in one step. If aName
	is qualified, then it declares the prefix to be mapped to aURI. If aName has
	no prefix, then aURI is declared as the default namespace URI."

	self
		declarePrefix: (aName xmlPrefixBeforeLocalName) uri: aURI;
		name: aName! !
!XMLElement methodsFor: 'private'!
namespaceScope
	^ namespaceScope ifNil: [namespaceScope := XMLNamespaceScope new]! !
!XMLElement methodsFor: 'accessing'!
namespaceURI
	^ self resolvePrefix: self prefix! !
!XMLElement methodsFor: 'private'!
newNamespaceScopeForAddedElement
	^ self usesNamespaces
		ifTrue: [self namespaceScope copy]
		ifFalse: [nil]! !
!XMLElement methodsFor: 'accessing'!
nextElement
	"returns the first element after the receiver that is a child of the same
	parent if there is one, nil otherwise"

	^ self parent ifNotNil: [:node | node elementAfter: self]! !
!XMLElement methodsFor: 'copying'!
postCopy
	super postCopy.

	namespaceScope
		ifNotNil: [namespaceScope := namespaceScope copy].
	attributes
		ifNotNil: [| copiedAttributes |
			copiedAttributes := attributes copyEmpty observer: self.
			attributes do: [:each | copiedAttributes addLast: each copy].
			attributes := copiedAttributes].! !
!XMLElement methodsFor: 'accessing'!
prefix
	"Returns the prefix of the receiver's name or an empty string if there
	isn't one."

	"this is recomputed from the qualified and local name instead of being
	stored in an inst var to save memory."
	^ self name xmlPrefixBeforeLocalName: self localName! !
!XMLElement methodsFor: 'accessing'!
prefix: aPrefix
	"Changes the prefix of the name of the receiver to aPrefix. If namespace
	checking is enabled (default) and aPrefix is non-empty, then aPrefix must
	have been declared."

	self renameWith: [name := self localName qualifyWithXMLPrefix:  aPrefix]! !
!XMLElement methodsFor: 'accessing'!
previousElement
	"returns the first element before the receiver that is a child of the same
	parent if there is one, nil otherwise"

	^ self parent ifNotNil: [:node | node elementBefore: self]! !
!XMLElement methodsFor: 'removing'!
removeAttribute: aName
	"Removes and returns the value of the attribute whose full name matches
	aName or raises an error if it's absent."

	^ (self attributeNodes removeAttribute: aName) value.! !
!XMLElement methodsFor: 'removing'!
removeAttribute: aName ifAbsent: aBlock
	"Removes and returns the value of the attribute whose full name matches
	aName or returns the value of aBlock if it's absent."

	^ self attributeNodes
		removeAttribute: aName
		ifAbsent: aBlock! !
!XMLElement methodsFor: 'removing'!
removeAttributeNode: aNode
	"Removes and returns the attribute node aNode or raises an error if
	it's absent."

	^ self attributeNodes remove: aNode! !
!XMLElement methodsFor: 'removing'!
removeAttributeNode: aNode ifAbsent: aBlock
	"Removes and returns the attribute node aNode or returns the value
	of aBlock if it's absent."

	^ self attributeNodes
		remove: aNode
		ifAbsent: aBlock! !
!XMLElement methodsFor: 'removing'!
removeAttributes
	self attributeNodes removeAll! !
!XMLElement methodsFor: 'notifying'!
removedAttribute: anAttribute
	anAttribute element: nil! !
!XMLElement methodsFor: 'private'!
renameWith: aBlock
	| oldName |

	oldName := self name.
	aBlock value.
	self name = oldName
		ifFalse: [
			self validateNamespacePrefix.
			self hasParent
				ifTrue: [
					self parent
						renamedElement: self
						from: oldName
						to: self name]].! !
!XMLElement methodsFor: 'notifying'!
renamedAttribute: anAttribute from: anOldName to: aNewName
	self attributeNodes	
		renamedAttribute: anAttribute
		from: anOldName
		to: aNewName.
	self validateNamespacePrefixOfAttribute: anAttribute.! !
!XMLElement methodsFor: 'namespacing'!
resolvePrefix: aPrefix
	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix
	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns an
	empty string if aPrefix is unresolvable."

	^ self
		resolvePrefix: aPrefix
		ifUnresolvable: ''! !
!XMLElement methodsFor: 'namespacing'!
resolvePrefix: aPrefix ifUnresolvable: aBlock
	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix
	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns the
	value of aBlock if aPrefix is unresolvable."

	^ self hasNamespaces "avoid lazy initializing the scope"
		ifTrue: [
			self namespaceScope
				resolvePrefix: aPrefix
				ifUnresolvable: aBlock]
		ifFalse: [aBlock value]! !
!XMLElement methodsFor: 'namespacing'!
resolvePrefixesOfNamespaceURI: aURI
	"returns a set of all the namespace prefixes of aURI"
	^ self usesNamespaces
		ifTrue: [self namespaceScope resolvePrefixesOfNamespaceURI: aURI]
		ifFalse: [Set new]! !
!XMLElement methodsFor: 'initialization'!
setAttributes: anAssociationCollection
	self attributeNodes setAttributes: anAssociationCollection! !
!XMLElement methodsFor: 'private'!
setConfiguration: aConfiguration name: aName localName: aLocalName attributes: anAttributeDictionary namespaceScope: aNamespaceScope
	"This should only be sent by DOM parsers/builders, not public API users"

	configuration := aConfiguration.
	name := aName.
	localName := aLocalName.
	anAttributeDictionary size > 0 "optimization"
		ifTrue: [
			"This consumes anAttributeDictionary, so it can never be used
			again safely"
			(attributes :=
				self attributeListClass new: anAttributeDictionary size)
				observer: self;
				setAttributesFromOrderPreservingDictionary: 
					anAttributeDictionary].
	namespaceScope := aNamespaceScope.! !
!XMLElement methodsFor: 'private'!
setNamespaceScope: aNamespaceScope
	namespaceScope := aNamespaceScope! !
!XMLElement methodsFor: 'accessing'!
sortKey
	^ self name! !
!XMLElement methodsFor: 'namespacing'!
undeclareDefaultNamespace
	self undeclarePrefix: ''! !
!XMLElement methodsFor: 'namespacing'!
undeclarePrefix: aPrefix
	self ensureUsesNamespaces.
	self
		allNamespaceScopesUnmapPrefix: aPrefix
		mappedTo:
			(self namespaceScope
				prefixMappingAt: aPrefix
				ifAbsent: [^ self]).! !
!XMLElement methodsFor: 'namespacing'!
undeclarePrefixes
	self ensureUsesNamespaces.
	self declaredPrefixes do: [:each |
		self undeclarePrefix: each].! !
!XMLElement methodsFor: 'private'!
validateNamespacePrefix
	(self usesNamespaces
		and: [self hasPrefix])
		ifTrue: [
			self namespaceScope
				validateAndResolvePrefix: self prefix
				ofElement: self name]! !
!XMLElement methodsFor: 'private'!
validateNamespacePrefixOfAttribute: anAttribute
	| attributePrefix attributeLocalName attributeNamespaceURI |

	self usesNamespaces
		ifFalse: [^ self].

	attributePrefix := anAttribute prefix.
	"send #validateAndResolvePrefix:ofAttribute: even if attributePrefix is
	empty, to catch names like ':name', and return if the resolved URI is empty,
	since non-default namespace URIs can't be empty, and attribute namespaces
	are always non-default"
	(attributeNamespaceURI :=
		self namespaceScope
			validateAndResolvePrefix: attributePrefix
			ofAttribute: anAttribute name) size > 0
		ifFalse: [^ self].
	attributeLocalName :=
		anAttribute name xmlLocalNameAfterPrefix: attributePrefix.
	self attributeNodesDo: [:each | | eachLocalName |
		(each ~= anAttribute
			and: [(eachLocalName := each localName) = attributeLocalName])
			ifTrue: [
				(self namespaceScope resolvePrefix:
					(each name xmlPrefixBeforeLocalName: eachLocalName)) =
						attributeNamespaceURI
					ifTrue: [
						self namespaceScope
							errorAttribute: each
							aliasesURI: attributeNamespaceURI]]].! !
!XMLElement methodsFor: 'private'!
validateNamespacePrefixesOfAttributes
	(self usesNamespaces
		and: [self hasAttributes])
		ifTrue: [
			self namespaceScope validatePrefixesOfAttributes:
				self attributeNames]! !
!XMLElement methodsFor: 'printing'!
writeXMLOn: aWriter
	| tagWriter |

	tagWriter := aWriter tag: self name.
	self hasNamespaces
		ifTrue: [
			"non-standard setXMLNSDeclarations: use for performance"
			tagWriter setXMLNSDeclarations: self namespaceScope prefixMappings].
	self hasAttributes
		ifTrue: [
			"non-standard setAttributes: use for performance"
			tagWriter setAttributes: self attributeNodes].
	self hasChildren
		ifTrue: [tagWriter with: [self writeInnerXMLOn: aWriter]]
		ifFalse: [tagWriter write].! !
!XMLNodeWithElements methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ aNodeVisitor visitNodeWithElements: self! !
!XMLNodeWithElements methodsFor: 'adding'!
addCData: aString
	^ self addNode: (self newCData: aString)! !
!XMLNodeWithElements methodsFor: 'deprecated'!
addContent: aStringOrStringNode
	"will be deprecated; use #addString: instead"

	(self hasChildren
		and: [self lastNode isCoalescingStringNode])
		ifTrue: [self lastNode append: aStringOrStringNode]
		ifFalse: [self addNode:
			(aStringOrStringNode isString
				ifTrue: [self nodeFactory newStringNode: aStringOrStringNode]
				ifFalse: [aStringOrStringNode])].
	"returns self for backwards compatibility"! !
!XMLNodeWithElements methodsFor: 'deprecated'!
addElement: anElement
	self deprecated:
		'Use #addNode: with an element argument or #addElementNamed: instead'.

	self addNode: anElement.
	"returns self for backwards compatibility"! !
!XMLNodeWithElements methodsFor: 'adding'!
addElementNamed: aName
	"adds and returns a new element with the specified name"

	| addedElementNamespaceScope addedElementNamespaceURI addedElement |

	addedElementNamespaceScope := self newNamespaceScopeForAddedElement.
	addedElementNamespaceURI :=
		self
			namespaceURIOfAddedElementNamed: aName
			withScope: addedElementNamespaceScope.
	"added first to inherit the config before setting the name"
	addedElement :=
		self addNode:
			((self nodeFactory
				classForElement: aName
				namespaceURI: addedElementNamespaceURI) new
				setNamespaceScope: addedElementNamespaceScope).
	^ addedElement name: aName.! !
!XMLNodeWithElements methodsFor: 'adding'!
addElementNamed: aName attributes: anAssociationCollection
	"adds and returns a new element with the specified name and attributes"

	| addedElementNamespaceScope addedElementNamespaceURI addedElementAttributeDictionary addedElement |

	addedElementNamespaceScope := self newNamespaceScopeForAddedElement.
	addedElementNamespaceURI :=
		self
			namespaceURIOfAddedElementNamed: aName
			withScope: addedElementNamespaceScope.
	addedElementAttributeDictionary :=
		self
			newAttributeDictionaryFrom: anAssociationCollection
			forAddedElementWithScope: addedElementNamespaceScope.
	"added first to inherit the config before setting the name and attributes"
	addedElement :=
		self addNode:
			((self nodeFactory
				classForElement: aName
				namespaceURI: addedElementNamespaceURI
				attributes: addedElementAttributeDictionary) new
				setNamespaceScope: addedElementNamespaceScope).
	^ addedElement
		name: aName;
		setAttributes: addedElementAttributeDictionary.! !
!XMLNodeWithElements methodsFor: 'adding'!
addElementNamed: aName namespaceURI: aURI
	"adds and returns a new element with the specified name and namespace
	URI"

	| addedElementNamespaceScope addedElement |

	addedElementNamespaceScope :=
		self
			newNamespaceScopeForAddedElementNamed: aName
			namespaceURI: aURI.
	"added first to inherit the config before setting the name"
	addedElement :=
		self addNode:
			((self nodeFactory
				classForElement: aName
				namespaceURI: aURI) new
				setNamespaceScope: addedElementNamespaceScope).
	^ addedElement name: aName.! !
!XMLNodeWithElements methodsFor: 'adding'!
addElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection
	"adds and returns a new element with the specified name, namespace URI,
	and attributes"

	| addedElementNamespaceScope addedElementAttributeDictionary addedElement |

	addedElementNamespaceScope :=
		self
			newNamespaceScopeForAddedElementNamed: aName
			namespaceURI: aURI.
	addedElementAttributeDictionary :=
		self
			newAttributeDictionaryFrom: anAssociationCollection
			forAddedElementWithScope: addedElementNamespaceScope.
	"added first to inherit the config before setting the name and attributes"
	addedElement :=
		self addNode:
			((self nodeFactory
				classForElement: aName
				namespaceURI: aURI
				attributes: addedElementAttributeDictionary) new
				setNamespaceScope: addedElementNamespaceScope).
	^ addedElement
		name: aName;
		setAttributes: addedElementAttributeDictionary.! !
!XMLNodeWithElements methodsFor: 'adding'!
addString: aString
	"Adds a new string node for aString or just appends aString to the
	last node if it's a coalescing string node (not CDATA).

	Returns the new string node or the string node appeneded to."

	| lastNode |

	(self hasChildren
		and: [(lastNode := self lastNode) isCoalescingStringNode])
		ifTrue: [^ lastNode append: aString]
		ifFalse: [^ self addNode: (self nodeFactory newStringNode: aString)]! !
!XMLNodeWithElements methodsFor: 'private'!
addedElement: anElement! !
!XMLNodeWithElements methodsFor: 'notifying'!
addedNode: aNode
	super addedNode: aNode.
	aNode isElement
		ifTrue: [
			aNode configuration: self configuration.
			self addedElement: aNode].! !
!XMLNodeWithElements methodsFor: 'accessing'!
allElements
	"returns a node list with all descendant elements (and the receiver if
	it's an element)"
	| allElements |

	allElements := self newListForSelect.
	self allElementsDo: [:each | allElements addLast: each].
	^ allElements.! !
!XMLNodeWithElements methodsFor: 'enumerating'!
allElementsCollect: aBlock
	"returns an ordered list of the values of evaluating all descendant
	elements (and the receiver if it's an element) with aBlock"
	| collectedObjects |

	collectedObjects := self newListForCollect.
	self allElementsDo: [:each | collectedObjects addLast: (aBlock value: each)].
	^ collectedObjects.! !
!XMLNodeWithElements methodsFor: 'enumerating'!
allElementsDetect: aBlock
	"Descend depth-first visiting each element with aBlock until one such evaluation
	of aBlock with an element is true, then return that element. If no evaluation is
	true, then return nil."

	^ self allElementsDetect: aBlock ifNone: [nil]! !
!XMLNodeWithElements methodsFor: 'enumerating'!
allElementsDetect: aBlock ifNone: anExceptionBlock
	"Descend depth-first visiting each element with aBlock until one such evaluation
	of aBlock with an element is true, then return that element. If no evaluation is
	true, then return the value of anExceptionBlock."

	self allElementsDo: [:each |
		(aBlock value: each)
			ifTrue: [^ each]].
	^ anExceptionBlock value.! !
!XMLNodeWithElements methodsFor: 'enumerating'!
allElementsDo: aBlock
	"evaluates all descendant elements (and the receiver if it's an
	element) with aBlock"

	self hasChildren
		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]]! !
!XMLNodeWithElements methodsFor: 'accessing'!
allElementsNamed: aName
	"returns a node list with all descendant elements (and the receiver if
	it's an element) whose qualified or local names match aName"

	^ self allElementsSelect: [:each | each isNamed: aName]! !
!XMLNodeWithElements methodsFor: 'enumerating'!
allElementsNamed: aName do: aBlock
	"evaluates all descendant elements (and the receiver if it's an
	element) whose qualified or local names match aName with aBlock"

	self allElementsDo: [:each |
		(each isNamed: aName)
			ifTrue: [aBlock value: each]]! !
!XMLNodeWithElements methodsFor: 'accessing'!
allElementsNamed: aName namespaceURI: aURI
	"returns a node list with all descendant elements (and the receiver if
	it's an element) whose qualified or local names match aName and whose
	namespace URIs matches aURI"

	^ self allElementsSelect: [:each |
		(each isNamed: aName)
			and: [each namespaceURI = aURI]]! !
!XMLNodeWithElements methodsFor: 'enumerating'!
allElementsSelect: aBlock
	"returns a new node list with all descendant elements (and the receiver
	if it's an element) that aBlock evaluates true for"

	| selectedElements |

	selectedElements := self newListForSelect.
	self allElementsDo: [:each |
		(aBlock value: each)
			ifTrue: [selectedElements addLast: each]].
	^ selectedElements.! !
!XMLNodeWithElements methodsFor: 'accessing'!
configuration
	^ configuration ifNil: [
		self configuration: self configurationClass new.
		configuration]! !
!XMLNodeWithElements methodsFor: 'accessing'!
configuration: aConfiguration
	configuration := aConfiguration.
	self hasChildren
		ifTrue: [
			self elementsDo: [:each |
				each configuration: aConfiguration]].! !
!XMLNodeWithElements methodsFor: 'defaults'!
configurationClass
	^ XMLDOMConfiguration! !
!XMLNodeWithElements methodsFor: 'accessing'!
contentNodes
	"returns a node list of the receiver's element and string node children"

	^ self nodes contentNodes! !
!XMLNodeWithElements methodsFor: 'enumerating'!
contentNodesDo: aBlock
	"evaluates aBlock for all element and string node children of the receiver"

	self nodes contentNodesDo: aBlock! !
!XMLNodeWithElements methodsFor: 'deprecated'!
contentString: aString
	"will be deprecated; use #removeNodes and #addString: instead"

	self
		removeNodes;
		addString: aString! !
!XMLNodeWithElements methodsFor: 'accessing'!
contentStringAt: aName
	"Returns the content string of the first element child of the receiver
	whose qualified or local name matches aName or an empty string if there
	isn't one.

	See also #rawContentStringAt:"

	^ self nodes contentStringAt: aName! !
!XMLNodeWithElements methodsFor: 'accessing'!
descendantElements
	"returns a node list of all descendant elements"
	| descendentElements |

	descendentElements := self newListForSelect.
	self descendantElementsDo: [:each | descendentElements addLast: each].
	^ descendentElements.! !
!XMLNodeWithElements methodsFor: 'enumerating'!
descendantElementsCollect: aBlock
	"returns an ordered list of the values of evaluating all descendant
	elements with aBlock"
	| collectedObjects |

	collectedObjects := self newListForCollect.
	self descendantElementsDo: [:each |
		collectedObjects addLast: (aBlock value: each)].
	^ collectedObjects.! !
!XMLNodeWithElements methodsFor: 'enumerating'!
descendantElementsDetect: aBlock
	"returns the first descendant element that aBlock evaluates true for or
	nil if there isn't one"

	^ self
		descendantElementsDetect: aBlock
		ifNone: [nil]! !
!XMLNodeWithElements methodsFor: 'enumerating'!
descendantElementsDetect: aBlock ifNone: anExceptionBlock
	"returns the first descendant element that aBlock evaluates true for or
	the value of anExceptionBlock if there isn't one"

	self descendantElementsDo: [:each |
		(aBlock value: each)
			ifTrue: [^ each]].
	^ anExceptionBlock value.! !
!XMLNodeWithElements methodsFor: 'enumerating'!
descendantElementsDo: aBlock
	"evaluates all descendant elements with aBlock"

	self hasChildren
		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]]! !
!XMLNodeWithElements methodsFor: 'accessing'!
descendantElementsNamed: aName
	"returns a node list of all descendant elements whose qualified
	or local names match aName"

	^ self descendantElementsSelect: [:each | each isNamed: aName]! !
!XMLNodeWithElements methodsFor: 'enumerating'!
descendantElementsNamed: aName do: aBlock
	"evaluates all descendant elements whose qualified or local names
	match aName with aBlock"

	self descendantElementsDo: [:each |
		(each isNamed: aName)
			ifTrue: [aBlock value: each]]! !
!XMLNodeWithElements methodsFor: 'accessing'!
descendantElementsNamed: aName namespaceURI: aURI
	"returns a node list of all descendant elements whose qualified
	or local names match aName and whose namespace URIs match aURI"

	^ self descendantElementsSelect: [:each |
		(each isNamed: aName)
			and: [each namespaceURI = aURI]]! !
!XMLNodeWithElements methodsFor: 'enumerating'!
descendantElementsSelect: aBlock
	"returns a new node list with all descendant elements that aBlock
	evaluates true for"
	| selectedElements |

	selectedElements := self newListForSelect.
	self descendantElementsDo: [:each |
		(aBlock value: each)
			ifTrue: [selectedElements addLast: each]].
	^ selectedElements.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElements
	self deprecated: 'use #descendantElements instead'.
	^ self descendantElements.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsCollect: aBlock
	self deprecated: 'use #descendantElementsCollect: instead'.
	^ self descendantElementsCollect: aBlock.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsDetect: aBlock
	self deprecated: 'use #descendantElementsDetect: instead'.
	^ self descendantElementsDetect: aBlock.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsDetect: aBlock ifNone: anExceptionBlock
	self deprecated: 'use #descendantElementsDetect:ifNone: instead'.
	^ self
		descendantElementsDetect: aBlock
		ifNone: anExceptionBlock.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsDo: aBlock
	self deprecated: 'use #descendantElementsDo: instead'.
	^ self descendantElementsDo: aBlock.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsNamed: aName
	self deprecated: 'use #descendantElementsNamed: instead"'.
	^ self descendantElementsNamed: aName.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsNamed: aName do: aBlock
	self deprecated: 'use #descendantElementsNamed:do: instead'.
	^ self
		descendantElementsNamed: aName
		do: aBlock.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsNamed: aName namespaceURI: aURI
	self deprecated: 'use #descendantElementsNamed:namespaceURI: instead'.
	^ self
		descendantElementsNamed: aName
		namespaceURI: aURI.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
descendentElementsSelect: aBlock
	self deprecated: 'use #descendantElementsSelect: instead'.
	^ self descendantElementsSelect: aBlock.! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementAfter: anElement
	"returns the first element child of the receiver after anElement or nil if
	there isn't one"

	^ self nodes elementAfter: anElement! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementAt: aName
	"returns the first element child of the receiver whose qualified or
	local name matches aName or nil if there isn't one"

	^ self nodes elementAt: aName! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementAt: aName ifAbsent: aBlock
	"returns the first element child of the receiver whose qualified or
	local name matches aName or the value of aBlock if there isn't one"

	^ self nodes
		elementAt: aName
		ifAbsent: aBlock! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementAt: aName namespaceURI: aURI
	"returns the first element child of the receiver whose qualified or
	local name matches aName and whose namespace URI matches aURI or nil
	if there isn't one"

	^ self nodes
		elementAt: aName
		namespaceURI: aURI! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementAt: aName namespaceURI: aURI ifAbsent: aBlock
	"returns the first element child of the receiver whose qualified or
	local name matches aName and whose namespace URI matches aURI or the
	value of aBlock if there isn't one"

	^ self nodes
		elementAt: aName
		namespaceURI: aURI
		ifAbsent: aBlock! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementBefore: anElement
	"returns the first element child of the receiver before anElement or
	nil if there isn't one"

	^ self nodes elementBefore: anElement! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementNames
	^ self nodes elementNames! !
!XMLNodeWithElements methodsFor: 'accessing'!
elements
	"returns a new node list of all of the receiver's elements"

	^ self nodes elements! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementsAt: aName
	"returns a node list of all the receiver's elements whose qualified
	or local names match aName"

	^ self nodes elementsAt: aName! !
!XMLNodeWithElements methodsFor: 'enumerating'!
elementsAt: aName do: aBlock
	"evaluates aBlock for all element children of the receiver whose
	qualified or local names match aName"

	self nodes
		elementsAt: aName
		do: aBlock! !
!XMLNodeWithElements methodsFor: 'accessing'!
elementsAt: aName namespaceURI: aURI
	"returns a node list of all the receiver's elements whose qualified
	or local names match aName and whose namespace URIs match aURI"

	^ self nodes
		elementsAt: aName
		namespaceURI: aURI! !
!XMLNodeWithElements methodsFor: 'enumerating'!
elementsCollect: aBlock
	"returns an ordered list of the values of evaluating the element
	children of the receiver with aBlock"

	^ self nodes elementsCollect: aBlock! !
!XMLNodeWithElements methodsFor: 'enumerating'!
elementsDetect: aBlock
	"returns the first element child of the receiver that aBlock evaluates
	true for or nil if there isn't one"

	^ self nodes elementsDetect: aBlock! !
!XMLNodeWithElements methodsFor: 'enumerating'!
elementsDetect: aBlock ifNone: anExceptionBlock
	"returns the first element child of the receiver that aBlock evaluates
	true for or the value of anExceptionBlock if there isn't one"

	^ self nodes
		elementsDetect: aBlock
		ifNone: anExceptionBlock! !
!XMLNodeWithElements methodsFor: 'enumerating'!
elementsDo: aBlock
	"evaluates aBlock for all element children of the receiver"

	self nodes elementsDo: aBlock! !
!XMLNodeWithElements methodsFor: 'enumerating'!
elementsSelect: aBlock
	"returns a node list of all element children of the receiver that
	aBlock evaluates true for"

	^ self nodes elementsSelect: aBlock! !
!XMLNodeWithElements methodsFor: 'private'!
ensureUsesNamespaces
	self usesNamespaces: true! !
!XMLNodeWithElements methodsFor: 'private'!
errorOuterXMLForAbsentNode
	XMLDOMException signal: 'Cannot change outer XML for absent node'! !
!XMLNodeWithElements methodsFor: 'private'!
escapesContentEntitiesWhenWriting
	"avoid initializing config; defualt to true"
	^ configuration isNil
		or: [configuration replacesContentEntityReferences]! !
!XMLNodeWithElements methodsFor: 'searching'!
findElementNamed: aName
	"searches the receiver and all descendants for the first element whose
	qualified or local name matches aName"

	^ self allElementsDetect: [:each | each isNamed: aName]! !
!XMLNodeWithElements methodsFor: 'searching'!
findElementNamed: aName namespaceURI: aURI
	"searches the receiver and all descendants for the first element whose
	qualified or local name matches aName and whose namespace URI matches aURI"

	^ self allElementsDetect: [:each |
		(each isNamed: aName)
			and: [each namespaceURI = aURI]]! !
!XMLNodeWithElements methodsFor: 'searching'!
findElementNamed: aName namespaceURI: aURI with: aBlock
	"searches the receiver and all descendants for the first element whose
	qualified or local name matches aName and whose namespace URI matches
	aURI and that aBlock evaluates true for"

	^ self allElementsDetect: [:each |
		(each isNamed: aName)
			and: [each namespaceURI = aURI
				and: [aBlock value: each]]]! !
!XMLNodeWithElements methodsFor: 'searching'!
findElementNamed: aName with: aBlock
	"searches the receiver and all descendants for the first element whose
	qualified or local name matches aName and aBlock evaluates true for"

	^ self allElementsDetect: [:each |
		(each isNamed: aName)
			and: [aBlock value: each]]! !
!XMLNodeWithElements methodsFor: 'searching'!
findElementWithID: anID
	"Works like XML DOM Level 2's getElementByID(). It will scan attributes
	identified as IDs by a DTD with '<!!ATTLIST ...>' declarations or any
	attribute named 'xml:id'."

	| document doctypeDefinition |
	
	((document := self document) notNil
		and: [(doctypeDefinition := document doctypeDefinition) notNil
			and: [doctypeDefinition hasAttributeValidators]])
		ifTrue: [
			self allElementsDo: [:each |
				each hasAttributes
					ifTrue: [
						(doctypeDefinition attributeValidatorsAt: each name)
							ifNil: [
								(each hasUndeclaredID: anID)
									ifTrue: [^ each]]
							ifNotNil: [:attributeValidators |
								(each
									hasUndeclaredOrDeclaredID: anID
									declaredWith: attributeValidators)
									ifTrue: [^ each]]]]]
		ifFalse: [
			self allElementsDo: [:each |
				(each hasAttributes
					and: [each hasUndeclaredID: anID])
					ifTrue: [^ each]]].
	^ nil.! !
!XMLNodeWithElements methodsFor: 'accessing'!
firstElement
	"returns the first child element of the receiver or nil if there
	isn't one"

	^ self nodes firstElement! !
!XMLNodeWithElements methodsFor: 'testing'!
hasContentNodes
	^ self nodes hasContentNodes! !
!XMLNodeWithElements methodsFor: 'testing'!
hasElements
	"returns true if the receiver has element children"

	"optimized with a nil test to avoid lazy initializing nodes"
	nodes == nil
		ifTrue: [^ false].
	^ nodes hasElements.! !
!XMLNodeWithElements methodsFor: 'testing'!
hasStringNodes
	^ self nodes hasStringNodes! !
!XMLNodeWithElements methodsFor: 'testing'!
includesElement: aName
	"returns true if the receiver has a child element whose qualified or local name
	matches aName"

	^ self nodes includesElement: aName! !
!XMLNodeWithElements methodsFor: 'testing'!
includesElement: aName namespaceURI: aURI
	"returns true if the receiver has a child element whose qualified or local name
	matches aName and whose namespace URI matches aURI"

	^ self nodes
		includesElement: aName
		namespaceURI: aURI! !
!XMLNodeWithElements methodsFor: 'parsing'!
innerXML: aStringOrStream
	"Replaces the node children by parsing new inner XML from a string or stream
	argument. By default the same parser configuration will be used to parse the
	new inner XML."

	self innerXMLParsedWith: (self parserHandlerClass on: aStringOrStream)! !
!XMLNodeWithElements methodsFor: 'parsing'!
innerXMLParsedWith: aParser
	| removedNodes |

	removedNodes := self nodes asArray.
	self removeNodes.
	[aParser
		innerXMLRootNode: self;
		parseDocument]
		on: Error
		do: [:error |
			self
				removeNodes;
				addNodes: removedNodes.
			error pass].! !
!XMLNodeWithElements methodsFor: 'private'!
innerXMLStateClass
	^ XMLContentState! !
!XMLNodeWithElements methodsFor: 'testing'!
isContentNode
	^ true! !
!XMLNodeWithElements methodsFor: 'accessing'!
lastElement
	"returns the last child element of the receiver or nil if there
	isn't one"

	^ self nodes lastElement! !
!XMLNodeWithElements methodsFor: 'private'!
namespaceURIOfAddedElementNamed: aName withScope: aNamespaceScope
	^ self usesNamespaces
		ifTrue: [aNamespaceScope resolvePrefix: aName xmlPrefixBeforeLocalName]
		ifFalse: ['']! !
!XMLNodeWithElements methodsFor: 'private'!
newAttributeDictionaryFrom: anAssociationCollection forAddedElementWithScope: aNamespaceScope
	^ self usesNamespaces
		ifTrue: [
			(XMLNamespacedAttributeDictionary newFrom: anAssociationCollection)
				setNamespaceScope: aNamespaceScope]
		ifFalse: [XMLAttributeDictionary newFrom: anAssociationCollection]! !
!XMLNodeWithElements methodsFor: 'private'!
newInnerXMLState
	^ self innerXMLStateClass new! !
!XMLNodeWithElements methodsFor: 'private'!
newNamespaceScopeForAddedElement
	^ self usesNamespaces
		ifTrue: [XMLNamespaceScope new]
		ifFalse: [nil]! !
!XMLNodeWithElements methodsFor: 'private'!
newNamespaceScopeForAddedElementNamed: aName namespaceURI: aURI
	self ensureUsesNamespaces.

	^ self newNamespaceScopeForAddedElement
		mapPrefix: aName xmlPrefixBeforeLocalName to: aURI;
		yourself.! !
!XMLNodeWithElements methodsFor: 'deprecated'!
newString: aString
	"will be deprecated; use #newStringNode: instead"

	^ self newStringNode: aString! !
!XMLNodeWithElements methodsFor: 'accessing'!
nodeFactory
	^ self configuration nodeFactory! !
!XMLNodeWithElements methodsFor: 'accessing'!
nodeFactory: aNodeFactory
	self configuration nodeFactory: aNodeFactory! !
!XMLNodeWithElements methodsFor: 'defaults'!
nodeListClass
	^ self configuration nodeFactory nodeListClass! !
!XMLNodeWithElements methodsFor: 'parsing'!
outerXML: aStringOrStream forNode: aNode
	self
		outerXMLForNode: aNode
		parsedWith: (self parserHandlerClass on: aStringOrStream)! !
!XMLNodeWithElements methodsFor: 'parsing'!
outerXMLForNode: aNode parsedWith: aParser
	| indexOfNode removedNodes |

	indexOfNode :=
		self nodes
			indexOf: aNode
			ifAbsent: [self errorOuterXMLForAbsentNode].
	removedNodes :=
		self nodes
			copyFrom: indexOfNode
			to: self nodes size.
	self removeNodes: removedNodes.
	[aParser
		innerXMLRootNode: self;
		parseDocument]
		on: Error
		do: [:error |
			[self nodes size >= indexOfNode]
				whileTrue: [self nodes removeLast].
			self addNodes: removedNodes.
			error pass].
	2 to: removedNodes size do: [:i |
		self addNode: (removedNodes at: i)].! !
!XMLNodeWithElements methodsFor: 'defaults'!
parserHandlerClass
	^ self configuration parserHandlerClass! !
!XMLNodeWithElements methodsFor: 'copying'!
postCopyConfiguration
	configuration
		ifNotNil: [self configuration: configuration copy]! !
!XMLNodeWithElements methodsFor: 'printing'!
printRawContentOn: aStream
	self contentNodesDo: [:each | each printRawContentOn: aStream]! !
!XMLNodeWithElements methodsFor: 'accessing'!
rawContentStringAt: aName
	"Returns the raw content string (without space inserted) of the first
	element child of the receiver whose qualified or local name matches aName
	or an empty string if there isn't one.

	See also #contentStringAt:"

	^ self nodes rawContentStringAt: aName! !
!XMLNodeWithElements methodsFor: 'removing'!
removeAllFormattingNodes
	"This is a convenience method to remove formatting string nodes from the
	receiver and descendant elements. Empty/whitespace string nodes with
	element siblings are assumed to be formatting, unless they have at least
	one non-empty/non-whitespace sibling string node.

	WARNING: 'mixed content' elements that can have both string and element
	children, like this:
		<row>one<sep/> <sep/>three</row>
	aren't properly recognized when all of the string nodes are whitespace,
	so this:
		<row> <sep/> <sep/> </row>
	will become this:
		<row><sep/><sep/></row>
	which might not be acceptable."

	| hasFormattingStringNodes hasElements |

	hasFormattingStringNodes := false.
	hasElements := false.
	self nodesDo: [:each |
		each isStringNode
			ifTrue: [
				(hasFormattingStringNodes :=
					each isWhitespace
						or: [each isEmpty])
					ifFalse: [^ self]]
			ifFalse: [
				hasElements
					ifFalse: [hasElements := each isElement]]].

	(hasFormattingStringNodes
		and: [hasElements])
		ifTrue: [| nodeList |
			nodeList := self nodes.
			nodeList size to: 1 by: -1 do: [:i | | node |
				((node := nodeList at: i) isStringNode
					and: [node isWhitespace
						or: [node isEmpty]])
					ifTrue: [nodeList removeAt: i]]].
	hasElements
		ifTrue: [
			self elementsDo: [:each |
				each removeAllFormattingNodes]].! !
!XMLNodeWithElements methodsFor: 'notifying'!
renamedElement: anElement from: anOldName to: aNewName
	self nodes
		renamedElement: anElement
		from: anOldName
		to: aNewName! !
!XMLNodeWithElements methodsFor: 'accessing'!
stringNodes
	"returns a new node list of all string node children of the receiver"

	^ self nodes stringNodes! !
!XMLNodeWithElements methodsFor: 'enumerating'!
stringNodesDo: aBlock
	"evaluates each string node child of the receiver with aBlock"

	self nodes stringNodesDo: aBlock! !
!XMLNodeWithElements methodsFor: 'accessing'!
strings
	"returns an ordered list of the strings of the string nodes of the receiver"

	^ self nodes strings! !
!XMLNodeWithElements methodsFor: 'enumerating'!
stringsDo: aBlock
	"evaluates each string of each string node child of the receiver with
	aBlock"

	self nodes stringsDo: aBlock! !
!XMLNodeWithElements methodsFor: 'testing'!
usesNamespaces
	"returns true if namespace checking is enabled (default)"

	"optimized to avoid lazy initializing the config"
	configuration == nil
		ifTrue: [^ true].
	^ configuration usesNamespaces.! !
!XMLNodeWithElements methodsFor: 'accessing'!
usesNamespaces: aBoolean
	"can be used to disable namespace checking, which is enabled by default"

	self configuration usesNamespaces: aBoolean! !
!XMLPI class methodsFor: 'instance creation'!
target: aTargetString data: aDataString
	^ self new
		target: aTargetString;
		data: aDataString! !
!XMLPI methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ aNodeVisitor visitPI: self! !
!XMLPI methodsFor: 'accessing'!
data
	^ data ifNil: [data := '']! !
!XMLPI methodsFor: 'accessing'!
data: aString
	data := aString! !
!XMLPI methodsFor: 'testing'!
hasData
	^ self data notEmpty! !
!XMLPI methodsFor: 'testing'!
isPI
	^ true! !
!XMLPI methodsFor: 'accessing'!
sortKey
	^ self target! !
!XMLPI methodsFor: 'accessing'!
target
	^ target ifNil: [target := '']! !
!XMLPI methodsFor: 'accessing'!
target: aString
	target := aString! !
!XMLPI methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter pi
		target: self target;
		data: self data;
		write! !
!XMLCData methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ aNodeVisitor visitCData: self! !
!XMLCData methodsFor: 'testing'!
isCData
	^ true! !
!XMLCData methodsFor: 'private'!
isCoalescingStringNode
	"this returns false to stop preserved CDATA nodes from coalescing
	together or with ordinary string nodes"

	^ false! !
!XMLCData methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter cdata: self string! !
!XMLString class methodsFor: 'instance creation'!
string: aString
	^ self new string: aString! !
!XMLString methodsFor: 'visiting'!
acceptNodeVisitor: aNodeVisitor
	^ aNodeVisitor visitStringNode: self! !
!XMLString methodsFor: 'deprecated'!
addContent: aStringOrStringNode
	"will be deprecated"

	self append: aStringOrStringNode! !
!XMLString methodsFor: 'appending/prepending'!
append: aStringOrStringNode
	string :=
		string
			ifNil: [aStringOrStringNode asString]
			ifNotNil: [string, aStringOrStringNode asString]! !
!XMLString methodsFor: 'converting'!
asString
	^ self string! !
!XMLString methodsFor: 'converting'!
asXMLEscapedString
	^ self string asXMLEscapedString! !
!XMLString methodsFor: 'deprecated'!
asXMLString
	"will be deprecated; use #asXMLStringNode instead"

	^ self asXMLStringNode! !
!XMLString methodsFor: 'converting'!
asXMLStringNode
	^ self! !
!XMLString methodsFor: 'testing'!
beginsWith: aStringOrStringNode
	^ self string beginsWith: aStringOrStringNode asString! !
!XMLString methodsFor: 'deprecated'!
contentString: aString
	"will be deprecated; use #string: instead"

	self string: aString! !
!XMLString methodsFor: 'replacing'!
deleteFrom: aStart to: anEnd
	self replaceFrom: aStart to: anEnd with: ''! !
!XMLString methodsFor: 'testing'!
endsWith: aStringOrStringNode
	^ self string endsWith: aStringOrStringNode asString! !
!XMLString methodsFor: 'testing'!
includesSubstring: aStringOrStringNode
	"avoid String>>includesSubstring: for backwards compatibility"
	^ aStringOrStringNode isEmpty
		or: [(self indexOfSubstring: aStringOrStringNode) > 0]! !
!XMLString methodsFor: 'accessing'!
indexOfSubstring: aStringOrStringNode
	^ self string
		findString: aStringOrStringNode asString
		startingAt: 1! !
!XMLString methodsFor: 'private'!
isCoalescingStringNode
	^ true! !
!XMLString methodsFor: 'testing'!
isContentNode
	^ true! !
!XMLString methodsFor: 'testing'!
isEmpty
	^ self string isEmpty! !
!XMLString methodsFor: 'deprecated'!
isString: aStringOrStringNode
	"will be deprecated; use #isStringNode: instead"

	^ self isStringNode: aStringOrStringNode! !
!XMLString methodsFor: 'testing'!
isStringNode
	^ true! !
!XMLString methodsFor: 'testing'!
isStringNode: aStringOrStringNode
	^ self string = aStringOrStringNode asString! !
!XMLString methodsFor: 'testing'!
isWhitespace
	^ self string isXMLWhitespace! !
!XMLString methodsFor: 'splitting/merging'!
mergeAdjacent
	"merges a string node with adjacent string nodes in parent"
	| siblingNodes selfIndex adjacentNode |

	self hasParent
		ifFalse: [^ self].

	siblingNodes := self parent nodes.
	selfIndex := siblingNodes indexOf: self.
	[(adjacentNode := siblingNodes at: selfIndex + 1) notNil
		and: [adjacentNode isStringNode]]
		whileTrue: [
			self append: adjacentNode.
			siblingNodes removeAt: selfIndex + 1].

	[(adjacentNode := siblingNodes at: selfIndex - 1) notNil
		and: [adjacentNode isStringNode]]
		whileTrue: [
			self prepend: adjacentNode.
			siblingNodes removeAt: selfIndex - 1.
			selfIndex := selfIndex - 1].! !
!XMLString methodsFor: 'testing'!
notEmpty
	^ self string notEmpty! !
!XMLString methodsFor: 'appending/prepending'!
prepend: aStringOrStringNode
	string :=
		string
			ifNil: [aStringOrStringNode asString]
			ifNotNil: [aStringOrStringNode asString, string]! !
!XMLString methodsFor: 'printing'!
printRawContentOn: aStream
	aStream nextPutAll: self string! !
!XMLString methodsFor: 'replacing'!
replaceAll: aSource with: aReplacement
	"works like copyReplaceAll:with:"
	self string:
		(self string
			copyReplaceAll: aSource asString
			with: aReplacement asString)! !
!XMLString methodsFor: 'replacing'!
replaceFrom: aStart to: aStop with: aReplacement
	"works like copyReplaceFrom:to:with: and
	can be used to insert, delete, and replace"
	| start stop |

	start := (aStart max: 1) min: self size + 1.
	stop := (aStop max: start - 1) min: self size.
	self string:
		(self string
			copyReplaceFrom: start
			to: stop
			with: aReplacement asString)! !
!XMLString methodsFor: 'accessing'!
size
	^ self string size! !
!XMLString methodsFor: 'accessing'!
sortKey
	^ self string! !
!XMLString methodsFor: 'splitting/merging'!
splitAt: anOffset
	| newNode |

	newNode := self copy.
	self replaceFrom: anOffset to: self size with: ''.
	newNode replaceFrom: 1 to: anOffset - 1 with: ''.

	self hasParent
		ifTrue: [self parent addNode: newNode after: self].

	^ newNode.! !
!XMLString methodsFor: 'accessing'!
string
	^ string ifNil: [string := '']! !
!XMLString methodsFor: 'accessing'!
string: aString
	string := aString asString! !
!XMLString methodsFor: 'printing'!
writeXMLOn: aWriter
	aWriter string: self string! !
!XMLNodeFactory methodsFor: 'converting'!
asPluggableNodeFactory
	^ XMLPluggableNodeFactory new! !
!XMLNodeFactory methodsFor: 'accessing'!
attributeDeclarationClass
	^ XMLAttributeDeclaration! !
!XMLNodeFactory methodsFor: 'accessing'!
attributeListClass
	^ XMLCachingAttributeList! !
!XMLNodeFactory methodsFor: 'accessing'!
cdataClass
	"Can be overridden to return a custom XMLCData subclass."

	^ XMLCData! !
!XMLNodeFactory methodsFor: 'accessing'!
classForElement: aQualifiedName
	^ self elementClass! !
!XMLNodeFactory methodsFor: 'accessing'!
classForElement: aQualifiedName attributes: anAssociationCollection
	^ self elementClass! !
!XMLNodeFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI
	^ self elementClass! !
!XMLNodeFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection
	^ self elementClass! !
!XMLNodeFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection
	^ self elementClass! !
!XMLNodeFactory methodsFor: 'accessing'!
commentClass
	"Can be overridden to return a custom XMLComment subclass."

	^ XMLComment! !
!XMLNodeFactory methodsFor: 'accessing'!
doctypeDeclarationClass
	^ XMLDoctypeDeclaration! !
!XMLNodeFactory methodsFor: 'accessing'!
documentClass
	"Can be overridden to return a custom XMLDocument subclass."

	^ XMLDocument! !
!XMLNodeFactory methodsFor: 'accessing'!
elementClass
	"Can be overridden to return a custom XMLElement subclass."

	^ XMLElement! !
!XMLNodeFactory methodsFor: 'accessing'!
elementDeclarationClass
	^ XMLElementDeclaration! !
!XMLNodeFactory methodsFor: 'accessing'!
generalEntityDeclarationClass
	^ XMLGeneralEntityDeclaration! !
!XMLNodeFactory methodsFor: 'instance creation'!
newCData: aString
	^ self cdataClass string: aString! !
!XMLNodeFactory methodsFor: 'instance creation'!
newComment: aString
	^ self commentClass string: aString! !
!XMLNodeFactory methodsFor: 'instance creation'!
newDocument
	^ self documentClass new! !
!XMLNodeFactory methodsFor: 'instance creation'!
newElement
	^ self elementClass new! !
!XMLNodeFactory methodsFor: 'instance creation'!
newElementNamed: aName
	^ (self classForElement: aName)
		named: aName! !
!XMLNodeFactory methodsFor: 'instance creation'!
newElementNamed: aName attributes: anAssociationCollection
	^ (self
		classForElement: aName
		attributes: anAssociationCollection)
			name: aName
			attributes: anAssociationCollection! !
!XMLNodeFactory methodsFor: 'instance creation'!
newElementNamed: aName namespaceURI: aURI
	^ (self
		classForElement: aName
		namespaceURI: aURI)
			name: aName
			namespaceURI: aURI! !
!XMLNodeFactory methodsFor: 'instance creation'!
newElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection
	^ (self
		classForElement: aName
		namespaceURI: aURI
		attributes: anAssociationCollection)
			name: aName
			namespaceURI: aURI
			attributes: anAssociationCollection! !
!XMLNodeFactory methodsFor: 'instance creation'!
newPI
	^ self piClass new! !
!XMLNodeFactory methodsFor: 'instance creation'!
newPITarget: aTargetString data: aDataString
	^ self newPI
		target: aTargetString;
		data: aDataString! !
!XMLNodeFactory methodsFor: 'deprecated'!
newString: aString
	"will be deprecated; use #newStringNode: instead"

	^ self newStringNode: aString! !
!XMLNodeFactory methodsFor: 'instance creation'!
newStringNode: aString
	^ self stringNodeClass new string: aString! !
!XMLNodeFactory methodsFor: 'accessing'!
nodeListClass
	^ XMLNodeList! !
!XMLNodeFactory methodsFor: 'accessing'!
notationDeclarationClass
	^ XMLNotationDeclaration! !
!XMLNodeFactory methodsFor: 'accessing'!
parameterEntityDeclarationClass
	^ XMLParameterEntityDeclaration! !
!XMLNodeFactory methodsFor: 'accessing'!
piClass
	"Can be overridden to return a custom XMLPI subclass."

	^ XMLPI! !
!XMLNodeFactory methodsFor: 'deprecated'!
stringClass
	"will be deprecated; use #stringNodeClass instead"

	^ XMLString! !
!XMLNodeFactory methodsFor: 'accessing'!
stringNodeClass
	"Can be overridden to return a custom XMLString subclass."

	"for now this delegates to the soft-deprecated #stringClass to not
	break custom subclasses that override it expecting it to be sent"
	^ self stringClass! !
!XMLPluggableElementFactory methodsFor: 'accessing'!
classForElement: aQualifiedName
	^ elementClassMapper
		classForElement: aQualifiedName
		ifNone: [self elementClass]! !
!XMLPluggableElementFactory methodsFor: 'accessing'!
classForElement: aQualifiedName attributes: anAssociationCollection
	^ elementClassMapper
		classForElement: aQualifiedName
		attributes: anAssociationCollection
		ifNone: [self elementClass]! !
!XMLPluggableElementFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI
	^ elementClassMapper
		classForElement: aQualifiedName
		namespaceURI: aURI
		ifNone: [self elementClass]! !
!XMLPluggableElementFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection
	^ elementClassMapper
		classForElement: aQualifiedName
		namespaceURI: aURI
		attributes: anAssociationCollection
		ifNone: [self elementClass]! !
!XMLPluggableElementFactory methodsFor: 'accessing'!
classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection
	^ elementClassMapper
		classForElement: aQualifiedName
		namespaceURI: aURI
		localName: aLocalName
		attributes: anAssociationCollection
		ifNone: [self elementClass]! !
!XMLPluggableElementFactory methodsFor: 'private'!
elementClassMapper
	^ elementClassMapper! !
!XMLPluggableElementFactory methodsFor: 'private'!
elementClassMapper: anElementClassMapper
	elementClassMapper := anElementClassMapper! !
!XMLPluggableElementFactory methodsFor: 'defaults'!
elementClassMapperClass
	^ XMLBasicElementClassMapper! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElement: anElementName attributes: aCollectionOrAttributeSpec withClass: aClass
	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a
	collection of associations of required attribute names and values, and the
	required values can be strings, blocks, or nil meaning the attribute is
	required but can take any value"

	elementClassMapper
		mapElement: anElementName
		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec
		toClass: aClass! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElement: anElementName namespaceURI: aURI attributes: aCollectionOrAttributeSpec withClass: aClass
	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a
	collection of associations of required attribute names and values, and the
	required values can be strings, blocks, or nil meaning the attribute is
	required but can take any value"

	elementClassMapper
		mapElement: anElementName
		namespaceURI: aURI
		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec
		toClass: aClass! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElement: anElementName namespaceURI: aURI withClass: aClass
	elementClassMapper
		mapElement: anElementName
		namespaceURI: aURI
		toClass: aClass! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElement: anElementName withClass: aClass
	elementClassMapper
		mapElement: anElementName
		toClass: aClass! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElements: anElementNameCollection namespaceURI: aNamespaceURI withClass: aClass
	elementClassMapper
		mapElements: anElementNameCollection
		namespaceURI: aNamespaceURI
		toClass: aClass! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElements: anElementNameCollection withClass: aClass
	elementClassMapper
		mapElements: anElementNameCollection
		toClass: aClass! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElementsMatchingClass: aClass
	"This will handle all elements matching the name of a class with that
	class, but igoring the class's prefix and any 'Element' suffix.

	For example, it will match MyUserDefinedElement to:
		<UserDefined>
		<userDefined>
		<user-defined>
		<user_defined>"

	elementClassMapper
		mapAllMatchingElementsToClass: aClass
		ignoringSuffixes: self ignorableClassNameSuffixes! !
!XMLPluggableElementFactory methodsFor: 'handling'!
handleElementsMatchingClasses: aClassCollection
	"See the comment in #handleElementsMatchingClass:"

	elementClassMapper
		mapAllMatchingElementsToClasses: aClassCollection
		ignoringSuffixes: self ignorableClassNameSuffixes! !
!XMLPluggableElementFactory methodsFor: 'defaults'!
ignorableClassNameSuffixes
	^ #('Element')! !
!XMLPluggableElementFactory methodsFor: 'initialization'!
initialize
	super initialize.

	elementClassMapper := self elementClassMapperClass new.! !
!XMLPluggableElementFactory methodsFor: 'copying'!
postCopy
	super postCopy.

	elementClassMapper := elementClassMapper copy.! !
!XMLPluggableNodeFactory methodsFor: 'converting'!
asPluggableNodeFactory
	^ self! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
attributeListClass
	^ attributeListClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
attributeListClass: aClass
	attributeListClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
cdataClass
	^ cdataClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
cdataClass: aClass
	cdataClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
commentClass
	^ commentClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
commentClass: aClass
	commentClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
documentClass
	^ documentClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
documentClass: aClass
	documentClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
elementClass
	^ elementClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
elementClass: aClass
	elementClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'initialization'!
initialize
	super initialize.

	documentClass := XMLDocument.
	elementClass := XMLElement.
	stringNodeClass := XMLString.
	cdataClass := XMLCData.
	commentClass := XMLComment.
	piClass := XMLPI.
	nodeListClass := XMLNodeList.
	attributeListClass := XMLCachingAttributeList.! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
nodeListClass
	^ nodeListClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
nodeListClass: aClass
	nodeListClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
piClass
	^ piClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
piClass: aClass
	piClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'deprecated'!
stringClass
	"will be deprecated; use #stringNodeClass instead"

	^ stringNodeClass! !
!XMLPluggableNodeFactory methodsFor: 'deprecated'!
stringClass: aClass
	"will be deprecated; use #stringNodeClass: instead"

	stringNodeClass := aClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
stringNodeClass
	^ stringNodeClass! !
!XMLPluggableNodeFactory methodsFor: 'accessing'!
stringNodeClass: aClass
	stringNodeClass := aClass! !
!XMLMutatingNodeVisitor methodsFor: 'visiting'!
visitNodeWithElements: aNodeWithElements
	aNodeWithElements hasChildren
		ifTrue: [| oldNodes nodeIndexesToRemove |
			oldNodes := aNodeWithElements nodes.
			1 to: oldNodes size do: [:i | | oldNode newNode |
				oldNode := oldNodes at: i.
				(newNode := oldNode acceptNodeVisitor: self) = oldNode
					ifFalse: [
						newNode
							ifNil: [
								"only initialize if needed"
								(nodeIndexesToRemove
									ifNil: [nodeIndexesToRemove := OrderedCollection new])
									addLast: i]
							ifNotNil: [
								"replace it"
								oldNodes
									at: i
									put: newNode]]].
			nodeIndexesToRemove
				ifNotNil: [
					nodeIndexesToRemove reverseDo: [:i |
						oldNodes removeAt: i]]].
	^ aNodeWithElements.! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitCData: aCData
	^ self visitStringNode: aCData! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitComment: aComment
	^ aComment! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitDocument: aDocument
	^ self visitNodeWithElements: aDocument! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitElement: anElement
	^ self visitNodeWithElements: anElement! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitNode: aNode
	^ aNode acceptNodeVisitor: self! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitNodeWithElements: aNodeWithElements
	aNodeWithElements hasChildren
		ifTrue: [
			aNodeWithElements nodesDo: [:each |
				each acceptNodeVisitor: self]].
	^ aNodeWithElements.! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitPI: aPI
	^ aPI! !
!XMLNodeVisitor methodsFor: 'visiting'!
visitStringNode: aStringNode
	^ aStringNode! !
!XMLValidatingNodeVisitor class methodsFor: 'instance creation'!
validator: aValidator
	^ self new validator: aValidator! !
!XMLValidatingNodeVisitor methodsFor: 'accessing'!
validator
	^ validator! !
!XMLValidatingNodeVisitor methodsFor: 'accessing'!
validator: aValidator
	validator := aValidator! !
!XMLValidatingNodeVisitor methodsFor: 'visiting'!
visitComment: aComment
	self validator validateComment: aComment.
	^ aComment.! !
!XMLValidatingNodeVisitor methodsFor: 'visiting'!
visitDocument: aDocument
	aDocument root
		ifNotNil: [:rootElement |
			self validator validateRootElement: rootElement name].
	super visitDocument: aDocument.
	self validator validateEndDocument.
	^ aDocument.! !
!XMLValidatingNodeVisitor methodsFor: 'visiting'!
visitElement: anElement
	| attributeDictionary |

	attributeDictionary := 
		anElement hasAttributes
			ifTrue: [anElement attributeNodes asDictionary]
			ifFalse: [Dictionary new].

	self validator
		validateStartTag: anElement name
		attributes: attributeDictionary.
	"validation can change/add attribute values"
	anElement setAttributes: attributeDictionary.

	super visitElement: anElement.

	self validator validateEndTag: anElement name.
	^ anElement.! !
!XMLValidatingNodeVisitor methodsFor: 'visiting'!
visitPI: aPI
	self validator
		validatePI: aPI target
		data: aPI data.
	^ aPI.! !
!XMLValidatingNodeVisitor methodsFor: 'visiting'!
visitStringNode: aStringNode
	self validator validatePCData: aStringNode string.
	^ aStringNode.! !
!XMLParser class methodsFor: 'instance creation'!
driver: aDriver on: aStringOrStream
	^ self new
		setDriver: aDriver
		tokenizer: (aDriver newTokenizerOn: aStringOrStream)! !
!XMLParser methodsFor: 'testing'!
atEnd
	^ self tokenizer atEnd! !
!XMLParser methodsFor: 'accessing'!
baseURI
	^ self driver baseURI! !
!XMLParser methodsFor: 'accessing'!
currentColumnNumber
	^ self tokenizer currentColumnNumber! !
!XMLParser methodsFor: 'accessing'!
currentLineNumber
	^ self tokenizer currentLineNumber! !
!XMLParser methodsFor: 'accessing'!
currentPosition
	^ self tokenizer currentPosition! !
!XMLParser methodsFor: 'accessing'!
driver
	^ driver! !
!XMLParser methodsFor: 'private'!
handleParserError: anError
	self tokenizer closeStreams.

	anError isXMLParserException
		ifFalse: [anError pass].

	(anError hasLineNumber
		or: [self currentLineNumber isNil])
		ifFalse: [anError lineNumber: self currentLineNumber].
	(anError hasColumnNumber
		or: [self currentColumnNumber isNil])
		ifFalse: [anError columnNumber: self currentColumnNumber].
	(anError hasBaseURI
		or: [self baseURI isEmpty])
		ifFalse: [anError baseURI: self baseURI].

	anError shouldPassOnWhenCaught
		ifTrue: [anError pass].! !
!XMLParser methodsFor: 'parsing'!
parseDocument
	[[self tokenizer atEnd]
		whileFalse: [self tokenizer nextToken]]
		on: Error
		do: [:error | self handleParserError: error]! !
!XMLParser methodsFor: 'parsing'!
parseDocumentUntil: aBlock
	[[self tokenizer atEnd or: [aBlock value]]
		whileFalse: [self tokenizer nextToken]]
		on: Error
		do: [:error | self handleParserError: error]! !
!XMLParser methodsFor: 'parsing'!
parseDocumentWhile: aBlock
	[[self tokenizer atEnd not and: [aBlock value]]
		whileTrue: [self tokenizer nextToken]]
		on: Error
		do: [:error | self handleParserError: error]! !
!XMLParser methodsFor: 'parsing'!
parseToken
	^ [self tokenizer nextToken]
		on: Error
		do: [:error | self handleParserError: error]! !
!XMLParser methodsFor: 'initialization'!
setDriver: aDriver tokenizer: aTokenizer
	driver := aDriver.
	tokenizer := aTokenizer.! !
!XMLParser methodsFor: 'accessing'!
state
	^ self tokenizer state! !
!XMLParser methodsFor: 'accessing'!
state: aTokenState
	self tokenizer state: aTokenState! !
!XMLParser methodsFor: 'accessing'!
tokenizer
	^ tokenizer! !
!DTDExternalSubsetParserDriver class methodsFor: 'instance creation'!
saxDriver: aSAXDriver documentURI: anExternalSubsetURIString
	^ self new
		setSAXDriver: aSAXDriver
		documentURI: anExternalSubsetURIString! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
decodesCharacters
	^ self saxDriver decodesCharacters! !
!DTDExternalSubsetParserDriver methodsFor: 'accessing'!
documentURI
	^ documentURI! !
!DTDExternalSubsetParserDriver methodsFor: 'accessing'!
externalEntityResolver
	^ self saxDriver externalEntityResolver! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
hasExternalSubset
	^ true! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
hasParameterEntityReferences
	^ self saxDriver hasParameterEntityReferences! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
hasSkippedParameterEntityReferences
	^ self saxDriver hasSkippedParameterEntityReferences! !
!DTDExternalSubsetParserDriver methodsFor: 'accessing'!
haveParameterEntityReferences
	self saxDriver haveParameterEntityReferences! !
!DTDExternalSubsetParserDriver methodsFor: 'accessing'!
haveSkippedParameterEntityReferences
	self saxDriver haveSkippedParameterEntityReferences! !
!DTDExternalSubsetParserDriver methodsFor: 'defaults'!
initialStateClass
	^ XMLExternalSubsetTextDeclarationState! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
isExternal
	"Definition: An external markup declaration is defined as a markup
	declaration occurring in the external subset or in a parameter entity
	(external or internal, the latter being included because non-validating
	processors are not required to read them)"

	^ true! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
isStandalone
	^ self saxDriver isStandalone! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
isValidating
	^ self saxDriver isValidating! !
!DTDExternalSubsetParserDriver methodsFor: 'accessing'!
maxEntityReplacementDepth
	^ self saxDriver maxEntityReplacementDepth! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
preservesUndeclaredEntityReferences
	^ self saxDriver preservesUndeclaredEntityReferences! !
!DTDExternalSubsetParserDriver methodsFor: 'accessing'!
readLimit
	^ self externalEntityResolver externalSubsetReadLimit! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
replacesContentEntityReferences
	^ self saxDriver replacesContentEntityReferences! !
!DTDExternalSubsetParserDriver methodsFor: 'testing'!
resolvesExternalEntities
	^ true! !
!DTDExternalSubsetParserDriver methodsFor: 'accessing'!
saxDriver
	^ saxDriver! !
!DTDExternalSubsetParserDriver methodsFor: 'initialization'!
setSAXDriver: aSAXDriver documentURI: anExternalSubsetURIString
	saxDriver := aSAXDriver.
	documentURI := anExternalSubsetURIString.
	doctypeDefinition := aSAXDriver doctypeDefinition.! !
!DTDSubsetParserDriver methodsFor: 'accessing'!
doctypeDefinition
	^ doctypeDefinition! !
!DTDSubsetParserDriver methodsFor: 'private'!
errorImproperParameterEntityNesting
	XMLValidationException signal:
		'Improper nesting of parameter entity replacement within DTD subset'! !
!DTDSubsetParserDriver methodsFor: 'private'!
errorInvalidUndeclaredGeneralEntityReference: aName
	XMLValidationException
		formatSignal: 'Undeclared general entity reference &{1};'
		with: aName! !
!DTDSubsetParserDriver methodsFor: 'private'!
errorInvalidUndeclaredParameterEntityReference: aName
	XMLValidationException
		formatSignal: 'Undeclared parameter entity reference %{1};'
		with: aName! !
!DTDSubsetParserDriver methodsFor: 'private'!
errorMultipleDeclarationsForElement: aName
	XMLValidationException
		formatSignal: 'Multiple declarations for <{1}> element'
		with: aName! !
!DTDSubsetParserDriver methodsFor: 'private'!
errorMultipleDeclarationsForNotation: aName
	"Unlike redundant entity declarations which are just ignored,
	redundant notation declarations are invalid"
	XMLValidationException
		formatSignal: 'Multiple declarations for notation "{1}"'
		with: aName! !
!DTDSubsetParserDriver methodsFor: 'private'!
errorReferenceToStandaloneExternalEntity: anEntity
	XMLValidationException
		formatSignal:
			'Internal reference to externally defined ',
			'entity {1} in standalone="yes" document'
		with: anEntity asReference! !
!DTDSubsetParserDriver methodsFor: 'private'!
errorUndeclaredGeneralEntityReference: aName
	XMLWellFormednessException
		formatSignal: 'Undeclared general entity reference &{1};'
		with: aName! !
!DTDSubsetParserDriver methodsFor: 'accessing'!
externalEntityResolver
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	| newAttributeValidator |

	self mustSkipEntityAndAttributeDeclarations
		ifTrue: [^ self].

	newAttributeValidator :=
		self isStandaloneExternal
			ifTrue: [
				self doctypeDefinition
					addStandaloneExternalValidatorForAttributeIn: anElement
					named: anAttribute
					type: aType
					defaultPragma: aDefaultPragma
					defaultValue: aDefaultValue]
			ifFalse: [
				self doctypeDefinition
					addValidatorForAttributeIn: anElement
					named: anAttribute
					type: aType
					defaultPragma: aDefaultPragma
					defaultValue: aDefaultValue].

	(self isValidating
		and: [newAttributeValidator notNil])
		ifTrue: [newAttributeValidator validateAttributeDeclaration].! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleElementDeclaration: aName contentModel: aContentModel
	| newElementValidator |

	newElementValidator :=
		self isStandaloneExternal
			ifTrue: [
				self doctypeDefinition
					addStandaloneExternalValidatorForElement: aName
					contentModel: aContentModel]
			ifFalse: [
				self doctypeDefinition
					addValidatorForElement: aName
					contentModel: aContentModel].

	self isValidating
		ifTrue: [
			newElementValidator
				ifNil: [self errorMultipleDeclarationsForElement: aName].
			newElementValidator validateElementDeclaration].! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation
	self mustSkipEntityAndAttributeDeclarations
		ifTrue: [^ self].

	aNotation isEmpty
		ifTrue: [
			self resolvesExternalEntities
				ifTrue: [
					self isStandaloneExternal
						ifTrue: [
							self doctypeDefinition
								addStandaloneExternalExternalGeneralEntity: aName
								resolver: self externalEntityResolver
								publicID: aPublicID
								systemID: aSystemID
								baseURI: self baseURI]
						ifFalse: [
							self doctypeDefinition
								addExternalGeneralEntity: aName
								resolver: self externalEntityResolver
								publicID: aPublicID
								systemID: aSystemID
								baseURI: self baseURI]]
				ifFalse: [
					self isValidating
						ifTrue: [
							self doctypeDefinition
								addUnresolvableExternalGeneralEntity: aName]]]
		ifFalse: [
			self doctypeDefinition
				addUnparsedEntity: aName
				publicID: aPublicID
				systemID: aSystemID
				ndata: aNotation].! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleGeneralEntityDeclaration: aName replacement: aReplacement
	self mustSkipEntityAndAttributeDeclarations
		ifTrue: [^ self].

	self isStandaloneExternal
		ifTrue: [
			self doctypeDefinition
				addStandaloneExternalInternalGeneralEntity: aName
				replacement: aReplacement
				baseURI: self baseURI]
		ifFalse: [
			self doctypeDefinition
				addInternalGeneralEntity: aName
				replacement: aReplacement
				baseURI: self baseURI].! !
!DTDSubsetParserDriver methodsFor: 'handling'!
handleGeneralEntityReference: aName
	| entity |

	entity :=
		self doctypeDefinition
			generalEntityAt: aName
			ifAbsent: [
				"WFC: In a document without any DTD, a document with only an
				internal DTD subset which contains no parameter entity references,
				or a document with ''standalone='yes''', for an entity reference
				(general) that does not occur within the external subset or a
				parameter entity (meaning DTD 'external')"
				self isExternal
					ifFalse: [
						((self hasExternalSubset not
							and: [self hasParameterEntityReferences not])
								or: [self isStandalone])
							ifTrue: [self errorUndeclaredGeneralEntityReference: aName]].
				"all general entity refs must be declared when validating"
				self isValidating
					ifTrue: [self errorInvalidUndeclaredGeneralEntityReference: aName].
				^ nil].

	"'VC: Standalone Document Declaration
		The standalone document declaration MUST have the value 'no' if any
		external markup declarations contain declarations of:
			...
		entities ... if references to those entities appear in the document'
	LibXML2 doesn't flag these at all, and Xerces only does for references
	in the content, but the specification says in the 'document', so we
	consider all non-external references, even inside the DTD internal subset"
	(entity isStandaloneExternal
		and: [self isValidating
			and: [self isExternal not]])
		ifTrue: [self errorReferenceToStandaloneExternalEntity: entity].

	^ entity.! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleImproperParameterEntityNesting
	"this is a validity constraint and is only checked when validating"
	self isValidating
		ifTrue: [self errorImproperParameterEntityNesting]! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID
	(self doctypeDefinition
		addNotation: aName
		publicID: aPublicID
		systemID: aSystemID)
		ifNil: [
			self isValidating
				ifTrue: [self errorMultipleDeclarationsForNotation: aName]]! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID
	self mustSkipEntityAndAttributeDeclarations
		ifFalse: [
			self resolvesExternalEntities
				ifTrue: [
					self doctypeDefinition
						addExternalParameterEntity: aName
						resolver: self externalEntityResolver
						publicID: aPublicID
						systemID: aSystemID
						baseURI: self baseURI]
				ifFalse: [
					self isValidating
						ifTrue: [
							self doctypeDefinition
								addUnresolvableExternalParameterEntity: aName]]]! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityDeclaration: aName replacement: aReplacement
	self mustSkipEntityAndAttributeDeclarations
		ifFalse: [
			self doctypeDefinition
				addInternalParameterEntity: aName
				replacement:aReplacement
				baseURI: self baseURI]! !
!DTDSubsetParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityReference: aName
	self haveParameterEntityReferences.
	^ self doctypeDefinition
		parameterEntityAt: aName
		ifAbsent: [
			self isValidating
				ifTrue: [self errorInvalidUndeclaredParameterEntityReference: aName].
			self haveSkippedParameterEntityReferences.
			nil]! !
!DTDSubsetParserDriver methodsFor: 'handling'!
handleParseError: aString
	XMLWellFormednessException signal: aString! !
!DTDSubsetParserDriver methodsFor: 'testing'!
hasExternalSubset
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
hasParameterEntityReferences
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
hasSkippedParameterEntityReferences
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'accessing'!
haveParameterEntityReferences
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'accessing'!
haveSkippedParameterEntityReferences
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
isExternal
	"Definition: An external markup declaration is defined as a markup
	declaration occurring in the external subset or in a parameter entity
	(external or internal, the latter being included because non-validating
	processors are not required to read them)"

	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
isStandalone
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
isStandaloneExternal
	^ self isStandalone
		and: [self isExternal]! !
!DTDSubsetParserDriver methodsFor: 'testing'!
isValidating
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'accessing'!
maxEntityReplacementDepth
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
mustSkipEntityAndAttributeDeclarations
	"'Except when standalone=''yes'', they (non-validating parsers) MUST NOT
	process entity declarations or attribute-list declarations encountered
	after a reference to a parameter entity that is not read...'"
	^ self isValidating not
		and: [self isStandalone not
			and: [self hasSkippedParameterEntityReferences]]! !
!DTDSubsetParserDriver methodsFor: 'testing'!
preservesUndeclaredEntityReferences
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
replacesContentEntityReferences
	self subclassResponsibility! !
!DTDSubsetParserDriver methodsFor: 'testing'!
resolvesExternalEntities
	self subclassResponsibility! !
!SAXParserDriver class methodsFor: 'instance creation'!
saxHandler: aSAXHandler
	^ self new setSAXHandler: aSAXHandler! !
!SAXParserDriver methodsFor: 'accessing'!
baseURI
	"returns a string with the current base URI at this stage of parsing"
	self elementNester hasScopedAttributes
		ifTrue: [
			^ self elementNester
				scopedAttributeAt: 'xml:base'
				ifAbsent: [super baseURI]]
		ifFalse: [^ super baseURI]! !
!SAXParserDriver methodsFor: 'private'!
checkForReservedAttributesIn: anOrderPreservingDictionary afterIndex: anIndex
	"validation may add attributes, so this is used to check if reserved
	attributes were added that need handling when there weren't any before"

	self hasUnhandledReservedAttributes
		ifTrue: [^ self].
	anIndex + 1
		to: anOrderPreservingDictionary size
		do: [:i |
			(anOrderPreservingDictionary keyAtIndex: i) isXMLReservedAttributeName
				ifTrue: [^ self haveUnhandledReservedAttributes]].! !
!SAXParserDriver methodsFor: 'accessing'!
currentElement
	^ self elementNester currentElement! !
!SAXParserDriver methodsFor: 'accessing'!
currentElement: anElement
	self elementNester currentElement: anElement! !
!SAXParserDriver methodsFor: 'accessing'!
currentScope
	^ self scopeAllocator currentScope! !
!SAXParserDriver methodsFor: 'accessing'!
currentScope: aNamespaceScope
	self scopeAllocator currentScope: aNamespaceScope! !
!SAXParserDriver methodsFor: 'private'!
declareNamespaces: aSequenceableCollection inScope: aScope
	1 to: aSequenceableCollection size do: [:i | | association |
		association := aSequenceableCollection at: i.
		(aScope resolvePrefix: association key) = association value
			ifFalse: [
				self saxHandler
					startPrefixMapping: association key
					uri: association value]].
	aScope mapPrefixesAndURIs: aSequenceableCollection.! !
!SAXParserDriver methodsFor: 'testing'!
decodesCharacters
	^ self saxHandler decodesCharacters! !
!SAXParserDriver methodsFor: 'defaults'!
doctypeDefinitionClass
	^ DTDDoctypeDefinition! !
!SAXParserDriver methodsFor: 'accessing'!
documentReadLimit
	^ self saxHandler documentReadLimit! !
!SAXParserDriver methodsFor: 'accessing'!
documentURI
	^ self saxHandler documentURI! !
!SAXParserDriver methodsFor: 'accessing'!
elementNester
	^ elementNester! !
!SAXParserDriver methodsFor: 'private'!
errorDocumentConstraintsRequired
	XMLValidationException signal: 'Document validation constraints required'! !
!SAXParserDriver methodsFor: 'accessing'!
externalEntityResolver
	^ externalEntityResolver
		ifNil: [
			externalEntityResolver :=
				self saxHandler externalEntityResolver
					asLimitingExternalEntityResolver]! !
!SAXParserDriver methodsFor: 'private'!
externalSubsetParserOn: aStringOrStream documentURI: aURIString
	^ self saxHandler parserClass
		driver:
			(DTDExternalSubsetParserDriver
				saxDriver: self
				documentURI: aURIString)
		on: aStringOrStream! !
!SAXParserDriver methodsFor: 'accessing'!
externalSubsetPublicID
	^ externalSubsetPublicID! !
!SAXParserDriver methodsFor: 'accessing'!
externalSubsetSystemID
	^ externalSubsetSystemID! !
!SAXParserDriver methodsFor: 'private'!
extractNamespacesFromAttributes: anOrderPreservingDictionary
	"returns an ordered collection of namespace prefix/uri associations
	removed from the attribute dictionary or nil if there aren't any"
	| namespaces keysToRemove |

	self haveNoUnhandledReservedAttributes.
	anOrderPreservingDictionary keysDo: [:name |
		"optimized comparison ordering"
		(name at: 1) == $x
			ifTrue: [
				name isXMLNSAttributeName
					ifTrue: [
						"only initialize when needed"
						(namespaces ifNil: [namespaces := OrderedCollection new: 5])
							addLast:
								(name size > 6 "'xmlns:' size"
									ifTrue: [name copyFrom: 7 to: name size]
									ifFalse: ['']) ->
										(anOrderPreservingDictionary at: name).
						"only initialize when needed"
						(keysToRemove ifNil: [keysToRemove := OrderedCollection new: 5])
							addLast: name]
					ifFalse: [
						name isXMLReservedAttributeName
							ifTrue: [
								"at least one xml attr is not an xmlns attr, so there
								will still be reserved attrs to handle after extracting
								the namespaces"
								self haveUnhandledReservedAttributes]]]].

	keysToRemove
		ifNotNil: [
			"use removeKeys: for speed"
			anOrderPreservingDictionary removeKeys: keysToRemove].

	^ namespaces.! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue
	super
		handleAttributeDeclaration: anElement
		name: anAttribute
		type: aType
		defaultPragma: aDefaultPragma
		defaultValue: aDefaultValue.

	self saxHandler
		attributeDeclaration: anElement
		name: anAttribute
		type: aType
		defaultPragma: aDefaultPragma
		defaultValue: aDefaultValue.! !
!SAXParserDriver methodsFor: 'handling'!
handleCData: aString
	self isValidating
		ifTrue: [self validator validatePCData: aString].

	self saxHandler
		isInCDataSection: true;
		startCData;
		characters: aString;
		endCData;
		isInCDataSection: false.! !
!SAXParserDriver methodsFor: 'handling'!
handleComment: aString
	(self elementNester isInElement
		and: [self isValidating])
		ifTrue: [self validator validateComment: aString].

	self saxHandler comment: aString.! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleElementDeclaration: aName contentModel: aContentModel
	super
		handleElementDeclaration: aName
		contentModel: aContentModel.

	self saxHandler
		elementDeclaration: aName
		contentModel: aContentModel.! !
!SAXParserDriver methodsFor: 'handling'!
handleEndContentEntityReplacement: aName
	self saxHandler endEntity: aName! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleEndDTD
	(self resolvesExternalEntities
		and: [self hasExternalSubset
			and: [self isValidating
				or: [self isStandalone not]]])
		ifTrue: [self parseExternalSubset].
	self isValidating
		ifTrue: [self doctypeDefinition validateCompletedDefinition].

	self saxHandler
		doctypeDefinition: self doctypeDefinition;
		endDTD.! !
!SAXParserDriver methodsFor: 'handling'!
handleEndDocument
	self isValidating
		ifTrue: [self validator validateEndDocument].

	self saxHandler endDocument.! !
!SAXParserDriver methodsFor: 'handling'!
handleEndTag: anElement
	"performance critical method"
	| prefix currentScope |

	prefix := anElement xmlPrefixBeforeLocalName.
	self saxHandler 
		endElement: anElement
		prefix: prefix
		uri:
			(self usesNamespaces
				ifTrue: [
					(currentScope := self scopeAllocator exitScope)
						resolvePrefix: prefix]
				ifFalse: [''])
		localName: (anElement xmlLocalNameAfterPrefix: prefix).

	self usesNamespaces
		ifTrue: [
			currentScope hasNamespaces
				ifTrue: [self undeclareNamespacesInScope: currentScope]].
	self isValidating
		ifTrue: [self validator validateEndTag: anElement].! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation
	super
		handleGeneralEntityDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID
		ndata: aNotation.

	self saxHandler
		generalEntityDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID
		ndata: aNotation.! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleGeneralEntityDeclaration: aName replacement: aReplacement
	super
		handleGeneralEntityDeclaration: aName
		replacement: aReplacement.

	self saxHandler
		generalEntityDeclaration: aName
		replacement: aReplacement.! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID
	super
		handleNotationDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID.

	self saxHandler
		notationDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID.! !
!SAXParserDriver methodsFor: 'handling'!
handlePCData: aString
	self isValidating
		ifTrue: [self validator validatePCData: aString].

	self saxHandler characters: aString.! !
!SAXParserDriver methodsFor: 'handling'!
handlePI: aTargetString data: aDataString
	(self elementNester isInElement
		and: [self isValidating])
		ifTrue: [
			self validator
				validatePI: aTargetString
				data: aDataString].

	self saxHandler 
		processingInstruction: aTargetString
		data: aDataString.! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID
	super
		handleParameterEntityDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID.

	self saxHandler
		parameterEntityDeclaration: aName
		publicID: aPublicID
		systemID: aSystemID.! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityDeclaration: aName replacement: aReplacement
	super
		handleParameterEntityDeclaration: aName
		replacement: aReplacement.

	self saxHandler
		parameterEntityDeclaration: aName
		replacement: aReplacement.! !
!SAXParserDriver methodsFor: 'private'!
handleReservedAttributes: aDictionary
	aDictionary
		at: 'xml:base'
		ifPresent: [:uri |
			"expand the new base URI using the current"
			aDictionary
				at: 'xml:base'
				put: (self baseURI asXMLURI / uri) asString].
	self isValidating
		ifTrue: [self validator validateXMLIDAttributeIn: aDictionary].

	self elementNester
		setScopedAttributesNamed: self scopedAttributeNames
		from: aDictionary.

	self haveNoUnhandledReservedAttributes.! !
!SAXParserDriver methodsFor: 'handling'!
handleStartContent
	self saxHandler startContent! !
!SAXParserDriver methodsFor: 'handling'!
handleStartContentEntityReplacement: aName
	self saxHandler startEntity: aName! !
!SAXParserDriver methodsFor: 'handling - dtd'!
handleStartDTD: aRoot publicID: aPublicID systemID: aSystemID
	externalSubsetPublicID := aPublicID.
	externalSubsetSystemID := aSystemID.

	self doctypeDefinition root: aRoot.
	self saxHandler
		startDTD: aRoot
		publicID: aPublicID
		systemID: aSystemID.! !
!SAXParserDriver methodsFor: 'handling'!
handleStartDocument
	self saxHandler startDocument! !
!SAXParserDriver methodsFor: 'handling'!
handleStartTag: anElement attributes: anAttributeDictionary
	"performance critical method"
	| prefix totalAttributes namespaceURI currentScope |

	prefix := anElement xmlPrefixBeforeLocalName.
	totalAttributes := anAttributeDictionary size.
	self isValidating
		ifTrue: [
			self elementNester totalOpenElements > 1
				ifFalse: [self validateRootElement: anElement].
			self validator
				validateStartTag: anElement
				attributes: anAttributeDictionary]
		ifFalse: [
			self doctypeDefinition
				processStartTag: anElement
				attributes: anAttributeDictionary].
	"validation and processing can add attributes"
	anAttributeDictionary size > totalAttributes
		ifTrue: [
			self
				checkForReservedAttributesIn: anAttributeDictionary
				afterIndex: totalAttributes.
			totalAttributes := anAttributeDictionary size].
	self usesNamespaces
		ifTrue: [
			anAttributeDictionary setNamespaceScope:
				(currentScope := self scopeAllocator enterScope).
			self hasUnhandledReservedAttributes
				ifTrue: [
					(self extractNamespacesFromAttributes: anAttributeDictionary)
						ifNotNil: [:namespaces |
							self
								declareNamespaces: namespaces
								inScope: currentScope.
							totalAttributes := anAttributeDictionary size]].
			self saxHandler startScope: currentScope.
			namespaceURI :=
				currentScope
					validateAndResolvePrefix: prefix
					ofElement: anElement.
			totalAttributes > 0
				ifTrue: [
					"anAttributeDictionary is an XMLAttributeDictionary, which
					is an OrderPreservingStringDictionary, so use its internal
					#orderedKeys over #keys for speed"
					currentScope
						validatePrefixesOfAttributes: anAttributeDictionary orderedKeys
						from: 1
						to: totalAttributes]].
	self hasUnhandledReservedAttributes
		ifTrue: [self handleReservedAttributes: anAttributeDictionary].

	self saxHandler
		startElement: anElement
		prefix: prefix
		uri: (namespaceURI ifNil: [''])
		localName: (anElement xmlLocalNameAfterPrefix: prefix)
		attributes: anAttributeDictionary.! !
!SAXParserDriver methodsFor: 'handling'!
handleUnreplacedGeneralEntityReference: aName
	self saxHandler skippedEntity: aName! !
!SAXParserDriver methodsFor: 'handling'!
handleWhitespace: aString
	self isValidating
		ifTrue: [
			self validator isCurrentElementWhitespaceIgnorable
				ifTrue: [
					(self elementNester hasScopedAttributes
						and: [
							(self elementNester scopedAttributeAt: 'xml:space') =
								'preserve'])
						ifTrue: [self saxHandler characters: aString]
						ifFalse: [self saxHandler ignorableWhitespace: aString].
					^ self]
				ifFalse: [
					"only validate if it's not ignorable"
					self validator validatePCData: aString]].
	self saxHandler characters: aString.! !
!SAXParserDriver methodsFor: 'handling'!
handleXMLVersion: aVersion encoding: anEncoding standalone: aYesOrNo
	isStandalone := aYesOrNo = 'yes'.

	self saxHandler
		xmlVersion: (self versionFloatFromString: aVersion)
		encoding: anEncoding
		standalone: isStandalone.! !
!SAXParserDriver methodsFor: 'testing'!
hasExternalSubset
	^ self externalSubsetPublicID notEmpty
		or: [self externalSubsetSystemID notEmpty]! !
!SAXParserDriver methodsFor: 'testing'!
hasParameterEntityReferences
	^ hasParameterEntityReferences! !
!SAXParserDriver methodsFor: 'testing'!
hasSkippedParameterEntityReferences
	^ hasSkippedParameterEntityReferences! !
!SAXParserDriver methodsFor: 'testing'!
hasUnhandledReservedAttributes
	^ hasUnhandledReservedAttributes! !
!SAXParserDriver methodsFor: 'accessing'!
haveNoUnhandledReservedAttributes
	hasUnhandledReservedAttributes := false! !
!SAXParserDriver methodsFor: 'accessing'!
haveParameterEntityReferences
	hasParameterEntityReferences := true! !
!SAXParserDriver methodsFor: 'accessing'!
haveSkippedParameterEntityReferences
	hasSkippedParameterEntityReferences := true! !
!SAXParserDriver methodsFor: 'accessing'!
haveUnhandledReservedAttributes
	hasUnhandledReservedAttributes := true! !
!SAXParserDriver methodsFor: 'testing'!
isExternal
	"Definition: An external markup declaration is defined as a markup
	declaration occurring in the external subset or in a parameter entity
	(external or internal, the latter being included because non-validating
	processors are not required to read them)"

	"returning #isParameter instead of 'self currentEntity notNil'
	ensures the correct result when parsing content"
	^ self currentEntity
		ifNil: [false]
		ifNotNil: [:entity | entity isParameter]! !
!SAXParserDriver methodsFor: 'testing'!
isStandalone
	^ isStandalone! !
!SAXParserDriver methodsFor: 'accessing'!
isStandalone: aBoolean
	isStandalone := aBoolean! !
!SAXParserDriver methodsFor: 'testing'!
isValidating
	^ isValidating! !
!SAXParserDriver methodsFor: 'accessing'!
maxEntityReplacementDepth
	^ self saxHandler maxEntityReplacementDepth! !
!SAXParserDriver methodsFor: 'instance creation'!
newAttributeDictionary
	^ (self usesNamespaces
		ifTrue: [XMLNamespacedAttributeDictionary]
		ifFalse: [XMLAttributeDictionary]) new! !
!SAXParserDriver methodsFor: 'instance creation'!
newEmptyAttributeDictionary
	^ (self usesNamespaces
		ifTrue: [XMLLazyNamespacedAttributeDictionary]
		ifFalse: [XMLLazyAttributeDictionary]) new! !
!SAXParserDriver methodsFor: 'private'!
parseExternalSubset
	| externalSubsetURI |

	externalSubsetURI :=
		self externalEntityResolver
			externalEntityURIFromPublicID: self externalSubsetPublicID
			systemID: self externalSubsetSystemID
			baseURI: self baseURI.

	"External subsets are stream-resolved so if they are local (stored on disk),
	they aren't kept entirely in memory during parsing. HTTP entities will be
	kept in memory regardless and this will just return a read stream on them."
	(self
		externalSubsetParserOn:
			(self externalEntityResolver streamResolveExternalEntityURI:
				externalSubsetURI)
		documentURI: externalSubsetURI asString)
		parseDocument.! !
!SAXParserDriver methodsFor: 'testing'!
preservesUndeclaredEntityReferences
	^ self saxHandler preservesUndeclaredEntityReferences! !
!SAXParserDriver methodsFor: 'accessing'!
readLimit
	^ self documentReadLimit! !
!SAXParserDriver methodsFor: 'testing'!
replacesContentEntityReferences
	^ self saxHandler replacesContentEntityReferences! !
!SAXParserDriver methodsFor: 'testing'!
resolvesExternalEntities
	^ self saxHandler resolvesExternalEntities! !
!SAXParserDriver methodsFor: 'accessing'!
saxHandler
	^ saxHandler! !
!SAXParserDriver methodsFor: 'accessing'!
scopeAllocator
	^ scopeAllocator ifNil: [scopeAllocator := XMLNamespaceScopeAllocator new]! !
!SAXParserDriver methodsFor: 'private'!
scopedAttributeNames
	"the scoped attributes tracked by this driver"
	^ #('xml:space' 'xml:base')! !
!SAXParserDriver methodsFor: 'initialization'!
setSAXHandler: aSAXHandler
	saxHandler := aSAXHandler.
	doctypeDefinition := self doctypeDefinitionClass new.
	validator := (aSAXHandler schema ifNil: [doctypeDefinition]) newValidator.
	elementNester := self newElementNester.
	externalSubsetPublicID := ''.
	externalSubsetSystemID := ''.
	"these are copied to inst vars for faster access"
	isValidating := aSAXHandler isValidating.
	usesNamespaces := aSAXHandler usesNamespaces.
	isStandalone := false.
	hasParameterEntityReferences := false.
	hasSkippedParameterEntityReferences := false.
	hasUnhandledReservedAttributes := false.! !
!SAXParserDriver methodsFor: 'private'!
undeclareNamespacesInScope: anExitedScope
	| currentScope |

	currentScope := self scopeAllocator currentScope.
	anExitedScope prefixesAndURIsDo: [:prefix :uri |
		(currentScope resolvePrefix: prefix) = uri
			ifFalse: [self saxHandler endPrefixMapping: prefix]].! !
!SAXParserDriver methodsFor: 'testing'!
usesNamespaces
	^ usesNamespaces! !
!SAXParserDriver methodsFor: 'private'!
validateRootElement: anElement
	self saxHandler requiresSchema
		ifTrue: [
			(self validator hasElementValidators
				or: [self validator hasAttributeValidators])
				ifFalse: [self errorDocumentConstraintsRequired]].

	self validator validateRootElement: anElement.! !
!SAXParserDriver methodsFor: 'accessing'!
validator
	^ validator! !
!SAXParserDriver methodsFor: 'private'!
versionFloatFromString: aString
	aString size = 3
		ifTrue: [
			aString = '1.0'
				ifTrue: [^ 1.0].
			aString = '1.1'
				ifTrue: [^ 1.1]].
	^ Float readFrom: aString readStream.! !
!XMLParserDriver methodsFor: 'accessing'!
baseURI
	"returns a string with the current base URI at this stage of parsing"
	^ baseURI ifNil: [baseURI := self documentURI]! !
!XMLParserDriver methodsFor: 'accessing'!
baseURI: aURI
	baseURI := aURI! !
!XMLParserDriver methodsFor: 'accessing'!
currentEntity
	^ currentEntity! !
!XMLParserDriver methodsFor: 'accessing'!
currentEntity: anEntity
	currentEntity := anEntity! !
!XMLParserDriver methodsFor: 'testing'!
decodesCharacters
	^ true! !
!XMLParserDriver methodsFor: 'accessing'!
documentURI
	^ nil! !
!XMLParserDriver methodsFor: 'accessing'!
elementNester
	^ self newElementNester! !
!XMLParserDriver methodsFor: 'defaults'!
elementNesterClass
	^ XMLElementNester! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !
!XMLParserDriver methodsFor: 'handling'!
handleCData: aString! !
!XMLParserDriver methodsFor: 'handling'!
handleComment: aString! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleElementDeclaration: aName contentModel: aContentModel! !
!XMLParserDriver methodsFor: 'handling'!
handleEndContentEntityReplacement: aName
! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleEndDTD! !
!XMLParserDriver methodsFor: 'handling'!
handleEndDocument! !
!XMLParserDriver methodsFor: 'handling'!
handleEndTag: anElement! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleGeneralEntityDeclaration: aName replacement: aReplacement! !
!XMLParserDriver methodsFor: 'handling'!
handleGeneralEntityReference: aName
	^ nil! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID! !
!XMLParserDriver methodsFor: 'handling'!
handlePCData: aString! !
!XMLParserDriver methodsFor: 'handling'!
handlePI: aTargetString data: aDataString! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityDeclaration: aName replacement: aReplacement! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleParameterEntityReference: aName
	^ nil! !
!XMLParserDriver methodsFor: 'handling'!
handleParseError: aString! !
!XMLParserDriver methodsFor: 'handling'!
handleStartContent! !
!XMLParserDriver methodsFor: 'handling'!
handleStartContentEntityReplacement: aName! !
!XMLParserDriver methodsFor: 'handling - dtd'!
handleStartDTD: aRoot publicID: aPublicID systemID: aSystemID! !
!XMLParserDriver methodsFor: 'handling'!
handleStartDocument! !
!XMLParserDriver methodsFor: 'handling'!
handleStartTag: anElement attributes: anAttributeDictionary! !
!XMLParserDriver methodsFor: 'handling'!
handleUnreplacedGeneralEntityReference: aName! !
!XMLParserDriver methodsFor: 'handling'!
handleWhitespace: aString! !
!XMLParserDriver methodsFor: 'handling'!
handleXMLVersion: aVersion encoding: anEncoding standalone: aYesOrNo! !
!XMLParserDriver methodsFor: 'defaults'!
initialStateClass
	^ XMLXMLDeclarationState! !
!XMLParserDriver methodsFor: 'instance creation'!
newElementNester
	^ self elementNesterClass new! !
!XMLParserDriver methodsFor: 'instance creation'!
newInitialState
	^ self initialStateClass new! !
!XMLParserDriver methodsFor: 'instance creation'!
newTokenizerOn: aStringOrStream
	^ self tokenizerClass
		driver: self
		on: aStringOrStream
		readLimit: self readLimit! !
!XMLParserDriver methodsFor: 'accessing'!
readLimit
	^ nil! !
!XMLParserDriver methodsFor: 'defaults'!
tokenizerClass
	^ XMLWellFormedParserTokenizer! !
!XMLParserLimits class methodsFor: 'defaults'!
defaultDocumentReadLimit
	^ self defaultReadLimit! !
!XMLParserLimits class methodsFor: 'defaults'!
defaultMaxEntityReplacementDepth
	^ 10! !
!XMLParserLimits class methodsFor: 'accessing'!
defaultReadLimit
	^ DefaultReadLimit
		ifNil: [DefaultReadLimit := 10000000]! !
!XMLParserLimits class methodsFor: 'accessing'!
defaultReadLimit: aDefaultLimit
	"can be used to change the default read limit instances start with"
	DefaultReadLimit := aDefaultLimit! !
!XMLParserLimits methodsFor: 'accessing'!
documentReadLimit
	^ documentReadLimit! !
!XMLParserLimits methodsFor: 'accessing'!
documentReadLimit: anInteger
	documentReadLimit := anInteger! !
!XMLParserLimits methodsFor: 'initialization'!
initialize
	super initialize.

	documentReadLimit := self class defaultDocumentReadLimit.
	maxEntityReplacementDepth := self class defaultMaxEntityReplacementDepth.! !
!XMLParserLimits methodsFor: 'accessing'!
maxEntityReplacementDepth
	^ maxEntityReplacementDepth! !
!XMLParserLimits methodsFor: 'accessing'!
maxEntityReplacementDepth: anInteger
	maxEntityReplacementDepth := anInteger! !
!XMLParserLimits methodsFor: 'removing'!
removeAll
	documentReadLimit := nil.
	maxEntityReplacementDepth := nil.! !
!XMLParserTokenizer class methodsFor: 'instance creation'!
driver: aDriver on: aStringOrStream
	^self
		driver: aDriver
		on: aStringOrStream
		readLimit: nil! !
!XMLParserTokenizer class methodsFor: 'instance creation'!
driver: aDriver on: aStringOrStream readLimit: anInteger
	^self new
		setDriver: aDriver
		stream:
			(aStringOrStream isStream
				ifTrue: [aStringOrStream]
				ifFalse: [aStringOrStream readStream])
		readLimit: anInteger! !
!XMLParserTokenizer class methodsFor: 'class initialization'!
initialize
	"self initialize"

	"assign after with #yourself to avoid possible race
	conditions when reinitializing the class"
	PredefinedEntities :=
		Dictionary new
			at: 'lt' put: $<;
			at: 'gt' put: $>;
			at: 'amp' put: $&;
			at: 'apos' put: $';
			at: 'quot' put: $";
			yourself! !
!XMLParserTokenizer class methodsFor: 'accessing'!
predefinedEntities
	^ PredefinedEntities! !
!XMLParserTokenizer methodsFor: 'testing'!
atEnd
	^ state isTerminatedState! !
!XMLParserTokenizer methodsFor: 'decoding'!
characterFromCodePoint: aCodePoint
	(aCodePoint notNil
		and: [aCodePoint > 0
			and: [aCodePoint <= 16r10FFFF]])
		ifTrue: [
			^ [Character value: aCodePoint]
				on: Error
				do: [:error | nil]]
		ifFalse: [^ nil]! !
!XMLParserTokenizer methodsFor: 'closing'!
closeStreams
	streamReader closeStreams! !
!XMLParserTokenizer methodsFor: 'decoding'!
convertFromEncoding: anEncodingName
	driver decodesCharacters
		ifTrue: [streamReader convertFromEncoding: anEncodingName]! !
!XMLParserTokenizer methodsFor: 'accessing'!
currentColumnNumber
	^ streamReader currentColumnNumber! !
!XMLParserTokenizer methodsFor: 'accessing'!
currentLineNumber
	^ streamReader currentLineNumber! !
!XMLParserTokenizer methodsFor: 'accessing'!
currentPosition
	^ streamReader currentPosition! !
!XMLParserTokenizer methodsFor: 'accessing'!
driver
	^ driver! !
!XMLParserTokenizer methodsFor: 'accessing'!
elementNester
	^ elementNester! !
!XMLParserTokenizer methodsFor: 'errors'!
errorExpected: aDescription
	self parseError: 'Expected ', aDescription! !
!XMLParserTokenizer methodsFor: 'errors'!
errorExpected: aDescription butGot: aCharacterOrString
	self
		formatParseError: 'Expected {1} but got "{2}" instead'
		with: aDescription
		with: aCharacterOrString! !
!XMLParserTokenizer methodsFor: 'errors'!
errorExpectedLiteral: aCharacterOrString
	self
		errorExpectedLiteral: aCharacterOrString
		butGot: nil! !
!XMLParserTokenizer methodsFor: 'errors'!
errorExpectedLiteral: anExpectedCharacterOrString butGot: aReceivedCharacterOrString
	self
		formatParseError: 'Expected "{1}" but got "{2}" instead' 
		with: anExpectedCharacterOrString
		with: aReceivedCharacterOrString! !
!XMLParserTokenizer methodsFor: 'tokenizing - expecting'!
expectNext: aCharacter
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing - expecting'!
expectNextAll: aString
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'errors'!
formatParseError: aString with: aFirstValue
	self
		formatParseError: aString
		withArguments: (Array with: aFirstValue)! !
!XMLParserTokenizer methodsFor: 'errors'!
formatParseError: aString with: aFirstValue with: aSecondValue
	self
		formatParseError: aString
		withArguments:
			(Array
				with: aFirstValue
				with: aSecondValue)! !
!XMLParserTokenizer methodsFor: 'errors'!
formatParseError: aString with: aFirstValue with: aSecondValue with: aThirdValue
	self
		formatParseError: aString
		withArguments:
			(Array
				with: aFirstValue
				with: aSecondValue
				with: aThirdValue)! !
!XMLParserTokenizer methodsFor: 'errors'!
formatParseError: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue
	self
		formatParseError: aString
		withArguments:
			(Array
				with: aFirstValue
				with: aSecondValue
				with: aThirdValue
				with: aFourthValue)! !
!XMLParserTokenizer methodsFor: 'errors'!
formatParseError: aString withArguments: aValueCollection
	self parseError:
		(aString format:
			"convert nils to empty strings, so nil values are
			not printed as 'nil' in error messsages"
			(aValueCollection collect: [:each |
				each ifNil: ['']]))! !
!XMLParserTokenizer methodsFor: 'defaults'!
hexCharacterValueLiteralPrefixes
	^ 'x'! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextCDataSection
	self subclassResponsibility
! !
!XMLParserTokenizer methodsFor: 'decoding'!
nextCharacterValueLiteral
	^ self nextCharacterValueLiteralPrintedOn: nil! !
!XMLParserTokenizer methodsFor: 'decoding'!
nextCharacterValueLiteralPrintedOn: aStream
	"do not limit the number of chars read, because char values can
	have an arbitrary number of leading zeros"
	^ (XMLSmallIntegerReader on: streamReader)
		printStream: aStream;
		nextIntegerWithBase: 16
			andPrefixes: self hexCharacterValueLiteralPrefixes
			orBase: 10! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextContentMarkupToken
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextContentToken
	streamReader peek == $<
		ifTrue: [
			streamReader next.
			^ self nextContentMarkupToken].
	elementNester isInElement
		ifTrue: [^ self nextPCDataToken].
	self nextNonElementWhitespace.! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextDoctypeDeclaration
	| root publicID systemID |

	state := state doctypeDeclarationState.
	self
		expectNextAll: 'DOCTYPE';
		nextSeparators.

	root := self nextElementName.
	(streamReader peek == $[
		or: [streamReader peek == $>])
		ifFalse: [
			self nextSeparators.
			streamReader peek == $P
				ifTrue: [
					publicID := self nextPublicID.
					self nextSeparators.
					systemID := self nextSystemIDLiteral]
				ifFalse: [
					streamReader peek == $S
						ifTrue: [systemID := self nextSystemID]]].
	driver
		handleStartDTD: root
		publicID: (publicID ifNil: [''])
		systemID: (systemID ifNil: ['']).

	streamReader skipSeparators.
	streamReader peek == $[
		ifTrue: [self nextStartInternalSubset]
		ifFalse: [self nextEndDoctypeDeclaration].! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextDoctypeDeclarationTerminator
	self expectNext: $>! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextElementName
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextEndDoctypeDeclaration
	self nextDoctypeDeclarationTerminator.
	state := state postDoctypeDeclarationState.

	driver handleEndDTD.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextEndDocument
	state isTerminatedState
		ifFalse: [
			self closeStreams.
			state := state terminatedState.
			driver handleEndDocument]! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextEndInternalSubset
	"skip ]"
	streamReader
		next;
		skipSeparators.
	self nextEndDoctypeDeclaration.! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextInternalSubsetToken
	streamReader skipSeparators.
	streamReader peek == $%
		ifTrue: [
			streamReader next.
			^ self nextParameterEntityReference].
	streamReader peek == $]
		ifTrue: [^ self nextEndInternalSubset].
	self nextSubsetMarkupToken.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextNonElementWhitespace
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextNonPIPrologOrContentMarkupToken
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextPCDataToken
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextPI
	"skip ?"
	streamReader next.
	self nextPIWithTarget: self nextPITarget.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextPIData
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextPITarget
	"should return a PI target string or nil if it's the start of
	an '<?xml ...?>' declaration"
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextPITerminator
	self expectNext: $>! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextPIWithTarget: aTarget
	streamReader peek == $?
		ifTrue: [
			streamReader next.
			self nextPITerminator.
			driver
				handlePI: aTarget
				data: '']
		ifFalse: [
			self nextSeparators.
			driver
				handlePI: aTarget
				data: self nextPIData].! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextParameterEntityReference
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextPrologToken
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextPublicID
	^ self
		expectNextAll: 'PUBLIC';
		nextSeparators;
		nextPublicIDLiteral! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextPublicIDLiteral
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextSeparators
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextStartContent
	state := state contentState.
	elementNester := driver elementNester.
	driver handleStartContent.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextStartDocument
	self state: driver newInitialState.
	driver handleStartDocument.! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextStartInternalSubset
	"skip ["
	streamReader next.
	state := state internalSubsetState.! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSubsetMarkupToken
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSystemID
	^ self
		expectNextAll: 'SYSTEM';
		nextSeparators;
		nextSystemIDLiteral! !
!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSystemIDLiteral
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextToken
	streamReader atEnd
		ifTrue: [
			state isInitializedState
				ifTrue: [^ self nextEndDocument]].
	^ state nextTokenFrom: self.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLAttributeEqualsSeparator
	streamReader skipSeparators.
	self expectNext: $=.
	streamReader skipSeparators.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLAttributeName: aName
	self expectNextAll: aName! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLDeclaration
	| version encoding |

	self nextSeparators.
	version := self nextXMLVersionAttributeRequired: true.
	streamReader peek == $?
		ifFalse: [self nextSeparators].
	(encoding := self nextXMLEncodingAttributeRequired: false) isEmpty
		ifFalse: [
			self convertFromEncoding: encoding.
			streamReader peek == $?
				ifFalse: [self nextSeparators]].
	driver
		handleXMLVersion: version
		encoding: encoding
		standalone: self nextXMLStandaloneAttribute.
	streamReader skipSeparators.
	self nextXMLDeclarationTerminator.

	state := state prologState.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLDeclarationOrPrologToken
	streamReader peek == $<
		ifTrue: [
			streamReader next.
			streamReader peek == $?
				ifTrue: [
					streamReader next.
					self nextPITarget
						ifNil: [^ self nextXMLDeclaration]
						ifNotNil: [:target |
							state := state prologState.
							^ self nextPIWithTarget: target]].
			state := state prologState.
			^ self nextNonPIPrologOrContentMarkupToken].

	"other prolog tokens can have whitespace before them, so the doc
	does not need to start with an '<' for them"
	state := state prologState.
	self nextPrologToken.! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLDeclarationTerminator
	self expectNextAll: '?>'! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLEncodingAttributeRequired: aBoolean
	(aBoolean
		or: [streamReader peek == $e])
		ifTrue: [	
			^ self
				nextXMLAttributeName: 'encoding';
				nextXMLAttributeEqualsSeparator;
				nextXMLEncodingAttributeValue]
		ifFalse: [^ '']! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLEncodingAttributeValue
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLStandaloneAttribute
	"always optional"
	(streamReader peek == $s)
		ifTrue: [
			^ self
				nextXMLAttributeName: 'standalone';
				nextXMLAttributeEqualsSeparator;
				nextXMLStandaloneAttributeValue]
		ifFalse: [^ '']! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLStandaloneAttributeValue
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLVersionAttributeRequired: aBoolean
	(aBoolean
		or: [streamReader peek == $v])
		ifTrue: [
			^ self
				nextXMLAttributeName: 'version';
				nextXMLAttributeEqualsSeparator;
				nextXMLVersionAttributeValue]
		ifFalse: [^ '']! !
!XMLParserTokenizer methodsFor: 'tokenizing'!
nextXMLVersionAttributeValue
	self subclassResponsibility! !
!XMLParserTokenizer methodsFor: 'accessing'!
normalizedLineEndingChar
	^ streamReader normalizedLineEndingChar! !
!XMLParserTokenizer methodsFor: 'accessing'!
normalizedLineEndingChar: aCharacter
	streamReader normalizedLineEndingChar: aCharacter! !
!XMLParserTokenizer methodsFor: 'errors'!
parseError: aString
	driver handleParseError: aString! !
!XMLParserTokenizer methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		print: state;
		nextPutAll: '; ';
		print: streamReader;
		nextPut: $).! !
!XMLParserTokenizer methodsFor: 'initialization'!
setDriver: aDriver stream: aStream readLimit: anInteger
	state := XMLUninitializedState new.
	driver := aDriver.
	streamReader :=
		self streamReaderClass
			on: aStream
			readLimit: anInteger.

	"must use #writeStream instead of 'WriteStream on:' to get 0-based
	streams on Gemstone"
	nameStream := (String new: 16) writeStream.
	"this separate stream is needed because XML text delcarations can occur
	in the replacement of external general entity references in PCDATA and
	external parameter entity references within declarations in the external
	subset or external entities, and characterStream would already be in use
	in both cases"
	xmlDeclarationStream := (String new: 8) writeStream.
	characterStream := (String new: 128) writeStream.! !
!XMLParserTokenizer methodsFor: 'accessing'!
state
	^ state! !
!XMLParserTokenizer methodsFor: 'accessing'!
state: aTokenState
	(state := aTokenState) isContentState
		ifTrue: [elementNester := driver elementNester].
	(driver decodesCharacters
		and: [state supportsEncodingDetection])
		ifTrue: [streamReader detectEncoding].! !
!XMLParserTokenizer methodsFor: 'accessing'!
streamReader
	^ streamReader! !
!XMLParserTokenizer methodsFor: 'defaults'!
streamReaderClass
	^ XMLNestedStreamReader! !
!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self
		initializeNormalizedSpace;
		initializePublicIDChars;
		initializeEncodingNameStartChars;
		initializeEncodingNameChars;
		initializeVersionNumChars! !
!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!
initializeEncodingNameChars
	"EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"

	"assign the fully initialized object with #yourself to avoid
	possible race conditions when reinitialization the class"
	EncodingNameChars :=
		BitmapCharacterSet new
			addRangeFrom: $a to: $z;
			addRangeFrom: $A to: $Z;
			addRangeFrom: $0 to: $9;
			addAll: '-_.';
			yourself! !
!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!
initializeEncodingNameStartChars
	"Character>>isLetter is not used because it may return true for non-ASCII
	letters depending on the locale.
	
	EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"

	"assign the fully initialized object with #yourself to avoid
	possible race conditions when reinitialization the class"
	EncodingNameStartChars :=
		BitmapCharacterSet new
			addRangeFrom: $a to: $z;
			addRangeFrom: $A to: $Z;
			yourself! !
!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!
initializeNormalizedSpace
	"stored in a class var for faster access"
	NormalizedSpace := Character space! !
!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!
initializePublicIDChars
	"PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!!*#@$_%]"

	"assign the fully initialized object with #yourself to avoid
	possible race conditions when reinitialization the class"
	PublicIDChars :=
		BitmapCharacterSet new
			add: 16r20 asCharacter;
			add: 16rD asCharacter;
			add: 16rA asCharacter;
			addRangeFrom: $a to: $z;
			addRangeFrom: $A to: $Z;
			addRangeFrom: $0 to: $9;
			addAll: '-''()+,./:=?;!!*#@$_%';
			yourself! !
!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!
initializeVersionNumChars
	"VersionNum ::= '1.' [0-9]+"

	"assign the fully initialized object with #yourself to avoid
	possible race conditions when reinitialization the class"
	VersionNumChars :=
		BitmapCharacterSet new
			addRangeFrom: $0 to: $9;
			add: $.;
			yourself! !
!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!
addPushedBackEntity: aPushedBackEntity
	(self hasPushedBackEntity: aPushedBackEntity)
		ifTrue: [self errorSelfReferentialEntity: aPushedBackEntity].

	self maxEntityReplacementDepth
		ifNotNil: [:maxDepth |
			self pushedBackEntities size >= maxDepth
				ifTrue: [self errorEntityDepthLimitExceeded]].
	
	self pushedBackEntities addLast: aPushedBackEntity.
	driver currentEntity: aPushedBackEntity entity.
	aPushedBackEntity isExternal
		ifTrue: [driver baseURI: aPushedBackEntity uri].

	^ aPushedBackEntity.! !
!XMLWellFormedParserTokenizer methodsFor: 'decoding'!
characterFromCodePoint: aCodePoint
	| character |

	"nil understands isXMLChar so it does not need to be tested for"
	(character := super characterFromCodePoint: aCodePoint) isXMLChar
		ifTrue: [^ character]
		ifFalse: [^ nil].! !
!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!
constructLiteralReplacementForEntity: anEntity
	| wasIgnoringLiteralValueTerminator |

	wasIgnoringLiteralValueTerminator := isIgnoringLiteralValueTerminator.
	isIgnoringLiteralValueTerminator := true.
	self
		pushBackEntity: anEntity
		whenPoppedDo: [
			isIgnoringLiteralValueTerminator := wasIgnoringLiteralValueTerminator].! !
!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!
constructReplacementForGeneralEntity: anEntity
	isInLiteralValue
		ifTrue: [
			anEntity isExternal
				ifTrue: [self errorLiteralReferenceToExternalGeneralEntity: anEntity].
			self constructLiteralReplacementForEntity: anEntity]
		ifFalse: [
			driver handleStartContentEntityReplacement: anEntity name.
			self
				pushBackEntity: anEntity
				whenPoppedDo: [driver handleEndContentEntityReplacement: anEntity name]]! !
!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!
constructReplacementForParameterEntity: anEntity
	isInLiteralValue
		ifTrue: [self constructLiteralReplacementForEntity: anEntity]
		ifFalse: [
			"the trailing space"
			streamReader pushBackCharacter: NormalizedSpace.
			self
				pushBackEntity: anEntity
				whenPoppedDo: nil.
			"the leading space"
			streamReader pushBackCharacter: NormalizedSpace]! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorDuplicateAttribute: anAttribute
	self
		formatParseError: 'Duplicate attribute "{1}" in start tag'
		with: anAttribute! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorEntityDepthLimitExceeded
	XMLLimitException signal: 
		'Cannot further nest entity replacements; ',
		'use #maxEntityReplacementDepth: to change or disable'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedAttributeEqualsSeparatorFor: anAttributeType butGot: aCharacter
	self
		formatParseError:
			'Expected {1} attribute name-value "=" separator but got "{2}" instead'
		with: anAttributeType
		with: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedAttributeName
	self errorExpected: 'attribute name'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedAttributeValueEnd: aQuote butGot: aCharacter
	aCharacter == $<
		ifTrue: [self parseError: 'Attribute value contains illegal "<" character']
		ifFalse: [
			self
				errorExpectedQuote: aQuote
				ending: 'attribute value'
				butGot: aCharacter]! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedAttributeValueStartButGot: aCharacter
	self
		errorExpectedQuoteStarting: 'attribute value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedCDataSectionTerminator
	self errorExpected: 'end of CDATA section "]]>" terminator'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedCharacterReferenceTerminatorButGot: aCharacter
	self
		errorExpectedReferenceTerminatorFor: 'character'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedCommentStartButGot: aCharacter
	self
		formatParseError:
			'Expected comment starting "<--" sequence but got "<-{1}" instead'
		with: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedCommentTerminator
	self errorExpected: 'comment "-->" terminator'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedCommentTerminatorButGot: aCharacter
	self
		formatParseError:
			'Comments cannot contain "--" sequences',
			(aCharacter
				ifNil: ['']
				ifNotNil: [', like "--{1}",']),
			' and any "--" must be followed by ">" to terminate the comment'
		with: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedDeclarationTerminatorButGot: aCharacter
	self
		errorExpectedMarkupTerminatorFor: 'declaration'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedDoctypeDeclarationTerminatorButGot: aCharacter
	self
		errorExpectedMarkupTerminatorFor: 'doctype declaration'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedElementAttributeEqualsSeparatorButGot: aCharacter
	self
		errorExpectedAttributeEqualsSeparatorFor: 'element'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedElementName
	self errorExpected: 'element name'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedEncodingName
	self errorExpected: 'encoding name in <?xml ...?> encoding attribute'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedEndTag: anExpectedEndTag butGot: aCharacter at: aCharacterPosition
	| receivedEndTag |

	"try to get the entire unexpected name"
	nameStream reset.
	1 to: aCharacterPosition - 1 do: [:i |
		nameStream nextPut: (anExpectedEndTag at: i)].
	"nil understands isXMLNameChar so it is not tested for"
	aCharacter isXMLNameChar
		ifTrue: [
			nameStream nextPut: aCharacter.
			[streamReader peek isXMLNameChar]
				whileTrue: [nameStream nextPut: streamReader next]].

	(receivedEndTag := nameStream contents) size > 0
		ifTrue: [
			(elementNester hasOpenElement: receivedEndTag)
				ifTrue: [self errorUnterminatedElementsInElement: receivedEndTag]
				ifFalse: [self errorTerminatingUnstartedElement: receivedEndTag]]
		ifFalse: [self errorExpectedElementName].! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedEntityName
	self errorExpected: 'entity name'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedEntityReferenceTerminatorButGot: aCharacter
	self
		errorExpectedReferenceTerminatorFor: 'entity'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedEntityValueEnd: aQuote butGot: aCharacter
	self
		errorExpectedQuote: aQuote
		ending: 'entity value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedIncludeSectionTerminatorButGot: aFirstCharacter followedBy: aSecondCharacter
	self
		formatParseError:
			'Expected include section "]]>" terminator ',
			'but got "]{1}{2}" instead'
		with: aFirstCharacter
		with: aSecondCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedIntegerCharacterReference
	self errorExpected:
		'decimal or hex integer after "&#" character reference start'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedLiteral: aString butGot: aCharacter at: aStringPosition
	| receivedString |

	receivedString :=
		(aString
			copyReplaceFrom: aStringPosition
			to: aString size
			with:
				(aCharacter ifNil: ['']) asString,
				(streamReader next: aString size - aStringPosition)).

	self
		errorExpectedLiteral: aString
		butGot: receivedString.! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedMarkupTerminatorFor: aDescription butGot: aCharacter
	self
		formatParseError:
			'Expected ">" {1} terminator but got "{2}" instead'
		with: aDescription
		with: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedNmtoken
	self errorExpected: 'an XML Nmtoken name'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedNotationName
	self errorExpected: 'notation name'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedPITarget
	self errorExpected:
		(state isXMLDeclarationState
			ifTrue: [
				'"xml" to start an <?xml ...?> declaration or a ',
				'processing instruction target']
			ifFalse: ['processing instruction target'])! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedPITerminatorButGot: aCharacter
	self
		errorExpectedMarkupTerminatorFor: 'processing instruction'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedPublicIDLiteralEnd: aQuote butGot: aCharacter
	self
		errorExpectedQuote: aQuote
		ending: 'public ID literal'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedPublicIDLiteralStartButGot: aCharacter
	self
		errorExpectedQuoteStarting: 'public ID literal'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedQuote: aQuote ending: aDescription butGot: aCharacter
	self
		formatParseError:
			'Expected end of {1} ({2}) quoted {3} but got "{4}" instead'
		with:
			(aQuote == $'
				ifTrue: ['single']
				ifFalse: ['double'])
		with: aQuote
		with: aDescription
		with: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedQuoteStarting: aDescription butGot: aCharacter
	self
		formatParseError:
			'Expected start of double (") or single ('') ',
			'quoted {1} but got "{2}" instead'
		with: aDescription
		with: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedReferenceTerminatorFor: aDescription butGot: aCharacter
	self
		formatParseError:
			'Expected {1} reference ";" terminator but got "{2}" instead'
		with: aDescription
		with: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedSeparators
	self errorExpected: 'one or more whitespace characters'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedStartMarkupTokenButGot: aCharacter
	self
		errorExpected: '"<" start of markup'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedSubsetDeclaration
	self errorExpected:
		'DTD subset ELEMENT, ATTLIST, ENTITY, or NOTATION declaration'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedSystemIDLiteralEnd: aQuote butGot: aCharacter
	self
		errorExpectedQuote: aQuote
		ending: 'system ID literal'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedSystemIDLiteralStartButGot: aCharacter
	self
		errorExpectedQuoteStarting: 'system ID literal'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedTagTerminatorButGot: aCharacter
	self
		errorExpectedMarkupTerminatorFor: 'tag'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLAttributeEqualsSeparatorButGot: aCharacter
	self
		errorExpectedAttributeEqualsSeparatorFor: '<?xml ...?>'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLDeclarationTerminatorButGot: aFirstCharacter followedBy: aSecondCharacter
	self
		formatParseError:
			'Expected "<?xml ...?>" declaration "?>" terminator ',
			'but got "{1}{2}" instead'
		with: aFirstCharacter
		with: aSecondCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLEncodingValueEnd: aQuote butGot: aCharacter
	self
		errorExpectedQuote: aQuote
		ending: '<?xml ...?> encoding value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLEncodingValueStartButGot: aCharacter
	self
		errorExpectedQuoteStarting: '<?xml ...?> encoding value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLStandaloneValueEnd: aQuote butGot: aCharacter
	self
		errorExpectedQuote: aQuote
		ending: '<?xml ...?> standalone value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLStandaloneValueStartButGot: aCharacter
	self
		errorExpectedQuoteStarting: '<?xml ...?> standalone value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLVersionNumberButGot: aString
	self
		errorExpected:
			'<?xml ...?> version number "1.x" (where "x" is one or more digits)'
		butGot: aString! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLVersionValueEnd: aQuote butGot: aCharacter
	self
		errorExpectedQuote: aQuote
		ending: '<?xml ...?> version value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorExpectedXMLVersionValueStartButGot: aCharacter
	self
		errorExpectedQuoteStarting: '<?xml ...?> version value'
		butGot: aCharacter! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorImproperGeneralEntityNesting
	self parseError:
		'Markup tokens must start and end in the same general entity replacement'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorInputTerminatedPrematurely
	self parseError: 'Input terminated prematurely'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorInternalDeclarationParameterEntityReference
	self parseError: 'Parameter entity reference within internal subset declaration'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorInternalSubsetConditionalSection
	self parseError:
		'Cannot have <!![INCLUDE[...]> or <!![IGNORE[...]> sections in internal subset'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorInvalidCharacterReferenceCodePoint: aCodePoint
	self
		formatParseError: 'Invalid character reference to U+{1} code point'
		with: aCodePoint printStringHex! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorLiteralReferenceToExternalGeneralEntity: anEntity
	self
		formatParseError:
			'External general entity reference {1} in attribute value'
		with: anEntity asReference! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorMultipleDoctypeDeclarations
	self parseError: 'Multiple <!!DOCTYPE ...> declarations'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorMultipleDocumentRootElements
	self parseError: 'Document cannot have multiple root elements'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonChar: aCharacter in: aDescription
	self
		formatParseError: 'Invalid character U+{1} in {2}'
		with: aCharacter asciiValue printStringHex
		with: aDescription! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonCharInAttributeValue: aCharacter
	self
		errorNonChar: aCharacter
		in: 'attribute value'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonCharInCDataSection: aCharacter
	self
		errorNonChar: aCharacter
		in: '<!![CDATA[...]]> section'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonCharInComment: aCharacter
	self
		errorNonChar: aCharacter
		in: 'comment'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonCharInEntityValue: aCharacter
	self
		errorNonChar: aCharacter
		in: 'entity value'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonCharInPCData: aCharacter
	self
		errorNonChar: aCharacter
		in: 'PCDATA'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonCharInPIValue: aCharacter
	self
		errorNonChar: aCharacter
		in: 'processing instruction value'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonCharInSystemID: aCharacter
	self
		errorNonChar: aCharacter
		in: 'system ID'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonElementGeneralEntityOrCharacterReference
	self parseError:
		'Unexpected "&" starting general entity or character reference after content'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorNonElementPCDataCharacter: aCharacter
	aCharacter == $&
		ifTrue: [self errorNonElementGeneralEntityOrCharacterReference]
		ifFalse: [
			self
				formatParseError: 'Character data "{1}" outside of element'
				with: aCharacter]! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorParameterEntityTerminatingSubset
	self parseError:
		'Parameter entity replacement cannot terminate internal subset'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorReferenceToUnparsedGeneralEntity: anEntity
	self
		formatParseError: 'Illegal unparsed general entity reference {1}'
		with: anEntity asReference! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorReservedPITarget: aTarget
	self
		formatParseError: 'Processing instruction target "{1}" is reserved'
		with: aTarget! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorSelfReferentialEntity: anEntity
	self
		formatParseError: 'Illegal self-referential {1} entity'
		with: anEntity asReference! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorTerminatingUnstartedElement: anElement
	self
		formatParseError: 'End tag </{1}> with no corresponding <{1}> start tag'
		with: anElement! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorURIFragmentInSystemID
	self parseError: 'Illegal "#" URI fragment in system ID'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnexpectedCDataTerminator
	self parseError: 'Unexpected CDATA "]]>" terminator in PCDATA'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnexpectedEndConditionalSection
	self parseError: 'Unexpected "]" end of conditional section in external entity'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnexpectedEndTag: anElement
	self
		formatParseError: 'Unexpected end tag </{1}> before any start tag'
		with: anElement! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnexpectedMarkupDeclarationInContent
	self parseError: 'Unexpected "<!!" markup declaration in content'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnterminatedElements
	self
		formatParseError: 'Unterminated elements: {1}'
		with: elementNester printedElements! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnterminatedElementsInElement: anElement
	self
		formatParseError: '<{1}> element ended before enclosed element(s) {2}'
		with: anElement
		with: (elementNester printedElementsEnclosedBy: anElement)! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnterminatedIgnoreSections
	self parseError: 'Unterminated <!![IGNORE[...]]> section(s) in external entity'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorUnterminatedIncludeSections
	self parseError: 'Unterminated <!![INCLUDE[...]]> section(s) in external entity'! !
!XMLWellFormedParserTokenizer methodsFor: 'errors'!
errorXMLDeclarationNotAtStart
	self parseError: 'XML declaration can only occur at the start of a document'! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!
expectNext: aCharacter
	| nextChar |

	"use #= for pre-SpurVM compatibility where wide chars aren't #=="
	(nextChar := streamReader next) = aCharacter
		ifFalse: [
			self
				errorExpectedLiteral: aCharacter
				butGot: nextChar].
	^ nextChar.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!
expectNextAll: aString
	"uses to:do: and not implemented in terms of #expectNextAll:startingAt:
	for speed"
	1 to: aString size do: [:i | | nextChar |
		"use #= for pre-SpurVM compatibility where wide chars aren't #=="
		(nextChar := streamReader next) = (aString at: i)
			ifFalse: [
				self
					errorExpectedLiteral: aString
					butGot: nextChar
					at: i]].
	^ aString.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!
expectNextAll: aString startingAt: aPosition
	"to:do: for speed"
	aPosition to: aString size do: [:i | | nextChar |
		"use #= for pre-SpurVM compatibility where wide chars aren't #=="
		(nextChar := streamReader next) = (aString at: i)
			ifFalse: [
				self
					errorExpectedLiteral: aString
					butGot: nextChar
					at: i]].
	^ aString.! !
!XMLWellFormedParserTokenizer methodsFor: 'testing'!
hasOpenIncludeSections
	totalOpenIncludeSections == nil
		ifTrue: [^ false].
	^ totalOpenIncludeSections > 0.! !
!XMLWellFormedParserTokenizer methodsFor: 'testing'!
hasPushedBackEntities
	pushedBackEntities == nil
		ifTrue: [^ false].
	^ pushedBackEntities size > 0.! !
!XMLWellFormedParserTokenizer methodsFor: 'testing'!
hasPushedBackEntity: aPushedBackEntity
	self hasPushedBackEntities
		ifFalse: [^ false].

	self pushedBackEntities do: [:each |
		each entity = aPushedBackEntity entity
			ifTrue: [^ true]].

	^ false.! !
!XMLWellFormedParserTokenizer methodsFor: 'testing'!
isInExternalSubsetOrExternalEntity
	"This is used to check for conditional sections and parameter entity
	refs within declarations in the internal subset, which is disallowed.
	
	The way the spec is written and the way Xerces behaves, internal
	entities defined in external entities DO NOT count as 'external'
	for this purpose, even though they were defined externally to
	the document."

	^ state isExternalSubsetState
		or: [self topPushedBackExternalEntity notNil]! !
!XMLWellFormedParserTokenizer methodsFor: 'accessing'!
maxEntityReplacementDepth
	^ driver maxEntityReplacementDepth! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttlistDeclaration
	| element defaultPragma |

	self
		expectNextAll: 'ATTLIST';
		nextSeparatorsInDeclaration.

	element := self nextElementName.
	[streamReader peek == $>
		or: [
			self nextSeparatorsInDeclaration.
			streamReader peek == $>]]
		whileFalse: [
			driver
				handleAttributeDeclaration: element
				name: self nextAttributeName
				type: self nextAttributeType
				defaultPragma:
					(defaultPragma := self nextAttributeDefaultPragma)
				defaultValue:
					(self nextAttributeDefaultValueForPragma: defaultPragma)].

	self nextDeclarationTerminator.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeDefaultPragma
	self nextSeparatorsInDeclaration.
	streamReader peek == $#
		ifFalse: [^ ''].
	streamReader next.

	streamReader peek == $R
		ifTrue: [^ self expectNextAll: 'REQUIRED'].
	streamReader peek == $I
		ifTrue: [^ self expectNextAll: 'IMPLIED'].
	^ self expectNextAll: 'FIXED'.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeDefaultValueForPragma: aPragma
	| previousState attributeValue |

	aPragma isEmpty
		ifFalse: [
			(aPragma first == $F) "FIXED"
				ifFalse: [^ ''].
			self nextSeparatorsInDeclaration].
	previousState := state.
	state := state contentState.
	attributeValue := self nextAttributeValue.
	state := previousState.
	^ attributeValue.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeEntityType
	self expectNextAll: 'ENTIT'.
	streamReader peek == $Y
		ifFalse: [
			^ self
				expectNextAll: 'ENTITIES'
				startingAt: 6 "'ENTIT' size + 1"].
	streamReader next.
	^ 'ENTITY'.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeEnumerationType
	characterStream
		reset;
		nextPut: (self expectNext: $().

	"must have at least one value in the enumeration"
	self
		skipSeparatorsInDeclaration;
		nextNmtokenOnCharacterStream.
	[self skipSeparatorsInDeclaration.
		streamReader peek == $)]
		whileFalse: [
			characterStream nextPut: (self expectNext: $|).
			self
				skipSeparatorsInDeclaration;
				nextNmtokenOnCharacterStream].

	^ characterStream
		nextPut: streamReader next;
		contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeIDOrIDRefType
	self expectNextAll: 'ID'.
	streamReader peek == $R
		ifFalse: [^ 'ID'].	
	self
		expectNextAll: 'IDREF'
		startingAt: 3.
	streamReader peek == $S
		ifFalse: [^ 'IDREF'].
	streamReader next.
	^ 'IDREFS'.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextAttributeName
	| nextChar |

	"nil understands #isXMLNameStartChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameStartChar
		ifFalse: [self errorExpectedAttributeName].
	nameStream
		reset;
		nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [nameStream nextPut: streamReader next].
	^ nameStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeNotationEnumerationOrNmtokenType
	"skip the N"
	streamReader next.
	streamReader peek == $O
		ifTrue: [^ self nextAttributeNotationEnumerationType].
	self
		expectNextAll: 'NMTOKEN'
		startingAt: 2.
	streamReader peek == $S
		ifFalse: [^ 'NMTOKEN'].
	streamReader next.
	^ 'NMTOKENS'.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeNotationEnumerationType
	characterStream
		reset;
		nextPutAll:
			(self
				expectNextAll: 'NOTATION'
				startingAt: 2). "the 'N' was already read"
	self
		nextSeparatorsInDeclaration;
		expectNext: $(.
	characterStream nextPutAll: ' ('.

	"must have at least one declaration name in the enumeration"
	self
		skipSeparatorsInDeclaration;
		nextNotationNameOnCharacterStream.
	[self skipSeparatorsInDeclaration.
		streamReader peek == $)]
		whileFalse: [
			characterStream nextPut: (self expectNext: $|).
			self
				skipSeparatorsInDeclaration;
				nextNotationNameOnCharacterStream].
	
	^ characterStream
		nextPut: streamReader next;
		contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextAttributeType
	| nextChar |

	self nextSeparatorsInDeclaration.
	(nextChar := streamReader peek) == $C
		ifTrue: [^ self expectNextAll: 'CDATA'].
	nextChar == $I
		ifTrue: [^ self nextAttributeIDOrIDRefType].
	nextChar == $E
		ifTrue: [^ self nextAttributeEntityType].
	nextChar == $N
		ifTrue: [^ self nextAttributeNotationEnumerationOrNmtokenType].
	^ self nextAttributeEnumerationType.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextAttributeValue
	| quote nextChar |

	((quote := streamReader next) == $"
		or: [quote == $'])
		ifFalse: [self errorExpectedAttributeValueStartButGot: quote].
	
	isInLiteralValue := true.
	characterStream reset.
	[((nextChar := streamReader next) == quote
		and: [isIgnoringLiteralValueTerminator not])
			or: [nextChar == $<
				or: [nextChar == nil]]]
		whileFalse: [
			nextChar == $&
				ifTrue: [
					"char refs should be ignored by whitespace normalization"
					self nextGeneralEntityOrCharacterReferenceOnCharacterStream]
				ifFalse: [
					nextChar isXMLSeparator
						ifTrue: [nextChar := NormalizedSpace]
						ifFalse: [
							nextChar isXMLChar
								ifFalse: [self errorNonCharInAttributeValue: nextChar]].
					characterStream nextPut: nextChar]].
	isInLiteralValue := false.

	nextChar == quote
		ifFalse: [
			self
				errorExpectedAttributeValueEnd: quote
				butGot: nextChar].

	^ characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextCDataSection
	| closingBracketsRead nextChar |

	self expectNextAll: '[CDATA['.
	characterStream reset.
	closingBracketsRead := 0.
	[(nextChar := streamReader next) == nil
		or: [closingBracketsRead == 2
			and: [nextChar == $>]]]
		whileFalse: [
			nextChar == $]
				ifTrue: [
					closingBracketsRead == 2
						ifTrue: [characterStream nextPut: $]]
						ifFalse: [closingBracketsRead := closingBracketsRead + 1]]
				ifFalse: [
					closingBracketsRead == 0
						ifFalse: [
							characterStream nextPut: $].
							closingBracketsRead == 2
								ifTrue: [characterStream nextPut: $]].
							closingBracketsRead := 0].
					nextChar isXMLChar
						ifFalse: [self errorNonCharInCDataSection: nextChar].
					characterStream nextPut: nextChar]].
	nextChar
		ifNil: [self errorExpectedCDataSectionTerminator].
	driver handleCData: characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextCharacterReferenceOnCharacterStream
	"returns the character written to 'characterStream' or $& if
	it wasn't replaced"
	| codePoint |

	"skip #"
	streamReader next.
	(state isContentState
		and: [driver replacesContentEntityReferences not])
		ifTrue: [
			nameStream reset.
			(codePoint := self nextCharacterValueLiteralPrintedOn: nameStream)
				ifNil: [self errorExpectedIntegerCharacterReference].
			(self characterFromCodePoint: codePoint)
				ifNil: [self errorInvalidCharacterReferenceCodePoint: codePoint].
			self nextCharacterReferenceTerminator.
			characterStream
				nextPutAll: '&#';
				nextPutAll: nameStream contents;
				nextPut: $;.
			^ $&]
		ifFalse: [| character |
			(codePoint := self nextCharacterValueLiteral)
				ifNil: [self errorExpectedIntegerCharacterReference].
			(character := self characterFromCodePoint: codePoint)
				ifNil: [self errorInvalidCharacterReferenceCodePoint: codePoint].
			self nextCharacterReferenceTerminator.
			characterStream nextPut: character.
			^ character].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextCharacterReferenceTerminator
	| nextChar |

	(nextChar := streamReader next) == $;
		ifFalse: [self errorExpectedCharacterReferenceTerminatorButGot: nextChar]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextComment
	| nextChar |

	"Skip first -"
	streamReader next.
	(nextChar := streamReader next) == $-
		ifFalse: [self errorExpectedCommentStartButGot: nextChar].

	"xml comments can't have '--' in them; any '--' must be followed
	by the terminating '>'"
	characterStream reset.
	[(nextChar := streamReader next) == nil
		or: [nextChar == $-
			and: [streamReader peek == $-]]]
		whileFalse: [
			nextChar isXMLChar
				ifFalse: [self errorNonCharInComment: nextChar].
			characterStream nextPut: nextChar].
	nextChar
		ifNil: [self errorExpectedCommentTerminator]
		ifNotNil: [
			streamReader next. "skip second $-"
			(nextChar := streamReader next) == $>
				ifFalse: [self errorExpectedCommentTerminatorButGot: nextChar]].

	driver handleComment: characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextConditionalSectionFromEntity: aPushedBackParameterEntity
	"skip ["
	streamReader next.
	self
		skipSeparatorsInDeclaration;
		expectNext: $I.
	streamReader peek == $N
		ifTrue: [self nextStartIncludeSectionFromEntity: aPushedBackParameterEntity]
		ifFalse: [self nextIgnoreSectionFromEntity: aPushedBackParameterEntity].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextContentMarkupToken
	self topPushedBackEntity
		ifNil: [
			streamReader peek == $?
				ifTrue: [^ self nextPI].
			streamReader peek == $!!
				ifTrue: [
					streamReader next.
					streamReader peek == $-
						ifTrue: [^ self nextComment].
					elementNester isInElement
						ifTrue: [^ self nextCDataSection].
					self errorUnexpectedMarkupDeclarationInContent].
			self nextTag]
		ifNotNil: [:pushedBackGeneralEntity |
			self nextContentMarkupTokenFromEntity: pushedBackGeneralEntity]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextContentMarkupTokenFromEntity: aPushedBackGeneralEntity
	streamReader peek == $?
		ifTrue: [self nextPI]
		ifFalse: [
			streamReader peek == $!!
				ifTrue: [
					streamReader next.
					streamReader peek == $-
						ifTrue: [self nextComment]
						ifFalse: [
							elementNester isInElement
								ifTrue: [self nextCDataSection]
								ifFalse: [
									self errorUnexpectedMarkupDeclarationInContent]]]
				ifFalse: [| oldTotalOpenElements newTotalOpenElements |
					oldTotalOpenElements := elementNester totalOpenElements.
					self nextTag.
					newTotalOpenElements := elementNester totalOpenElements.
					newTotalOpenElements < oldTotalOpenElements
						ifTrue: [
							aPushedBackGeneralEntity endElement.
							aPushedBackGeneralEntity totalOpenElements >= 0
								ifFalse: [self errorImproperGeneralEntityNesting]]
						ifFalse: [
							newTotalOpenElements > oldTotalOpenElements
								ifTrue: [aPushedBackGeneralEntity startElement]]]].

	self topPushedBackEntity == aPushedBackGeneralEntity
		ifFalse: [self errorImproperGeneralEntityNesting].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextContentModel
	| pushedBackParameterEntity |

	self nextSeparatorsInDeclaration.
	streamReader peek == $A
		ifTrue: [^ self expectNextAll: 'ANY'].
	streamReader peek == $E
		ifTrue: [^ self expectNextAll: 'EMPTY'].
	
	characterStream
		reset;
		nextPut: (self expectNext: $().
	pushedBackParameterEntity := self topPushedBackEntity.
	self skipSeparatorsInDeclaration.
	streamReader peek == $#
		ifTrue: [
			self nextMixedContentListOnCharacterStreamFromEntity:
				pushedBackParameterEntity]
		ifFalse: [
			self nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity:
				pushedBackParameterEntity].

	^ characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity: aPushedBackParameterEntity
	self
		nextContentModelParticleOnCharacterStream;
		skipSeparatorsInDeclaration.
	streamReader peek == $|
		ifTrue: [
			characterStream nextPut: streamReader next.
			self nextContentModelParticleOnCharacterStream.
			[self skipSeparatorsInDeclaration.
				streamReader peek == $)]
				whileFalse: [
					characterStream nextPut: (self expectNext: $|).
					self nextContentModelParticleOnCharacterStream].
			characterStream nextPut: streamReader next]
		ifFalse: [
			streamReader peek == $,
				ifTrue: [
					characterStream nextPut: streamReader next.
					self nextContentModelParticleOnCharacterStream.
					[self skipSeparatorsInDeclaration.
						streamReader peek == $)]
						whileFalse: [
							characterStream nextPut: (self expectNext: $,).
							self nextContentModelParticleOnCharacterStream].
					characterStream nextPut: streamReader next]
				ifFalse: [characterStream nextPut: (self expectNext: $))]].

	self topPushedBackEntity == aPushedBackParameterEntity
		ifFalse: [driver handleImproperParameterEntityNesting].
	self nextContentModelUnaryOperatorOnCharacterStream.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextContentModelParticleOnCharacterStream
	self skipSeparatorsInDeclaration.
	streamReader peek == $(
		ifTrue: [
			characterStream nextPut: streamReader next.
			self nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity:
				self topPushedBackEntity]
		ifFalse: [
			self
				nextElementNameOnCharacterStream;
				nextContentModelUnaryOperatorOnCharacterStream]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextContentModelUnaryOperatorOnCharacterStream
	| nextChar |

	((nextChar := streamReader peek) == $?
		or: [nextChar == $*
			or: [nextChar == $+]])
		ifTrue: [characterStream nextPut: streamReader next]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextDeclarationTerminator
	| nextChar |

	(nextChar := streamReader next) == $>
		ifFalse: [self errorExpectedDeclarationTerminatorButGot: nextChar]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextDoctypeDeclarationOrComment
	"skip !!"
	streamReader next.
	streamReader peek == $-
		ifTrue: [^ self nextComment].
	state isPostDoctypeDeclarationState
		ifTrue: [self errorMultipleDoctypeDeclarations].
	self nextDoctypeDeclaration.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextDoctypeDeclarationTerminator
	| nextChar |

	(nextChar := streamReader next) == $>
		ifFalse: [self errorExpectedDoctypeDeclarationTerminatorButGot: nextChar]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextElementDeclaration
	self
		expectNextAll: 'ELEMENT'
		startingAt: 2. "the 'E' was already read"

	self nextSeparatorsInDeclaration.
	driver
		handleElementDeclaration: self nextElementName
		contentModel: self nextContentModel.
	self
		skipSeparatorsInDeclaration;
		nextDeclarationTerminator.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextElementName
	| nextChar |

	"nil understands #isXMLNameStartChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameStartChar
		ifFalse: [self errorExpectedElementName].
	nameStream
		reset;
		nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [nameStream nextPut: streamReader next].
	^ nameStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextElementNameOnCharacterStream
	| nextChar |

	"nil understands #isXMLNameStartChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameStartChar
		ifFalse: [self errorExpectedElementName].
	characterStream nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [characterStream nextPut: streamReader next].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextEndDocument
	state canTerminateInput
		ifFalse: [self errorInputTerminatedPrematurely].
	state isContentState
		ifTrue: [
			elementNester hasOpenElements
				ifTrue: [self errorUnterminatedElements]]
		ifFalse: [
			self hasOpenIncludeSections
				ifTrue: [self errorUnterminatedIncludeSections]].
	super nextEndDocument.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextEndIncludeSection
	| secondChar thirdChar |

	"skip ]"
	streamReader next.
	secondChar := streamReader next.
	thirdChar := streamReader next. 
	(secondChar == $]
		and: [thirdChar == $>])
		ifFalse: [
			self
				errorExpectedIncludeSectionTerminatorButGot: secondChar
				followedBy: thirdChar].

	totalOpenIncludeSections := self totalOpenIncludeSections - 1.
	self topPushedBackEntity
		ifNotNil: [:pushedBackParameterEntity |
			pushedBackParameterEntity endIncludeSection.
			pushedBackParameterEntity totalOpenIncludeSections >= 0
				ifFalse: [driver handleImproperParameterEntityNesting]].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextEndInternalSubset
	self hasOpenIncludeSections
		ifTrue: [^ self nextEndIncludeSection].
	"skip ]"
	streamReader next.
	self hasPushedBackEntities
		ifTrue: [self errorParameterEntityTerminatingSubset].
	streamReader skipSeparators.
	self nextEndDoctypeDeclaration.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextEndTag
	| tagName nextChar |
	"Skip /"
	streamReader next.
	(tagName := elementNester currentElement)
		ifNil: [self errorUnexpectedEndTag: self nextElementName].
	1 to: tagName size do: [:i |
		"can't use #== here because wide chars aren't an immediate type
		in pre-Spur VMs"
		(nextChar := streamReader next) = (tagName at: i)
			ifFalse: [
				self
					errorExpectedEndTag: tagName
					butGot: nextChar
					at: i]].
	elementNester endCurrentElement.
	driver handleEndTag: tagName.
	streamReader skipSeparators.
	(nextChar := streamReader next) == $>
		ifFalse: [self errorExpectedTagTerminatorButGot: nextChar].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextEntityDeclaration
	| isParameterEntity name |

	self
		expectNextAll: 'ENTITY'
		startingAt: 2. "the 'E' was already read"

	self isInExternalSubsetOrExternalEntity
		ifTrue: [
			"this is to distinguish a parameter reference from declaration"
			[isParameterEntity isNil]
				whileTrue: [
					streamReader skipSeparators.
					streamReader peek == $%
						ifTrue: [
							streamReader next.
							"nil understands isXMLSeparator so no nil test is needed"
							streamReader peek isXMLSeparator
								ifTrue: [
									isParameterEntity := true.
									self nextSeparatorsInDeclaration]
								ifFalse: [self nextParameterEntityReference]]
						ifFalse: [isParameterEntity := false]]]
		ifFalse: [
			self nextSeparators.
			(isParameterEntity := (streamReader peek == $%))
				ifTrue: [
					streamReader next.
					self nextSeparators]].

	name := self nextEntityName.
	self nextSeparatorsInDeclaration.
	streamReader atQuote
		ifTrue: [
			self
				nextInternalEntityDeclaration: name
				isParameterEntity: isParameterEntity]
		ifFalse: [
			self
				nextExternalEntityDeclaration: name
				isParameterEntity: isParameterEntity].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextEntityName
	| nextChar |

	"nil understands #isXMLNameStartChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameStartChar
		ifFalse: [self errorExpectedEntityName].
	nameStream
		reset;
		nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [nameStream nextPut: streamReader next].
	^ nameStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextEntityNameOnCharacterStream
	| nextChar |

	"nil understands #isXMLNameStartChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameStartChar
		ifFalse: [self errorExpectedEntityName].
	characterStream nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [characterStream nextPut: streamReader next].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextEntityReferenceTerminator
	| nextChar |

	(nextChar := streamReader next) == $;
		ifFalse: [self errorExpectedEntityReferenceTerminatorButGot: nextChar]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextEntityValue
	| quote nextChar |

	quote := streamReader next.

	isInLiteralValue := true.
	characterStream reset.
	[((nextChar := streamReader next) == quote
		and: [isIgnoringLiteralValueTerminator not])
			or: [nextChar == nil]]
		whileFalse: [
			nextChar == $&
				ifTrue: [
					streamReader peek == $#
						ifTrue: [
							"character refs are replaced in entity values"
							self nextCharacterReferenceOnCharacterStream]
						ifFalse: [
							"general entity refs aren't replaced but must be complete"
							characterStream nextPut: $&.
							self
								nextEntityNameOnCharacterStream;
								nextEntityReferenceTerminator.
							characterStream nextPut: $;]]
				ifFalse: [
					nextChar == $%
						ifTrue: [
							self isInExternalSubsetOrExternalEntity
								ifFalse: [
									self
										errorInternalDeclarationParameterEntityReference].
							self nextParameterEntityReferenceOnCharacterStream]
						ifFalse: [
							nextChar isXMLChar
								ifFalse: [self errorNonCharInEntityValue: nextChar].
							characterStream nextPut: nextChar]]].
	isInLiteralValue := false.

	nextChar == quote
		ifFalse: [
			self
				errorExpectedEntityValueEnd: quote
				butGot: nextChar].

	^ characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextExternalEntityDeclaration: aName isParameterEntity: aBoolean
	| publicID systemID notation |

	streamReader peek == $P
		ifTrue: [
			publicID := self nextPublicIDInDeclaration.
			self nextSeparatorsInDeclaration.
			systemID := self nextSystemIDLiteralWithoutURIFragment]
		ifFalse: [
			publicID := ''.
			systemID := self nextSystemIDInDeclarationWithoutURIFragment].
	aBoolean
		ifTrue: [
			self
				skipSeparatorsInDeclaration;
				nextDeclarationTerminator.
			driver
				handleParameterEntityDeclaration: aName
				publicID: publicID
				systemID: systemID]
		ifFalse: [
			(streamReader peek == $>
				or: [
					self nextSeparatorsInDeclaration.
					streamReader peek == $>])
				ifTrue: [	
					streamReader next.
					notation := '']
				ifFalse: [
					self
						expectNextAll: 'NDATA';
						nextSeparatorsInDeclaration.
					notation := self nextNotationName.
					self
						skipSeparatorsInDeclaration;
						nextDeclarationTerminator].
			driver
				handleGeneralEntityDeclaration: aName
				publicID: publicID
				systemID: systemID
				ndata: notation].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextExternalSubsetToken
	streamReader skipSeparators.
	streamReader atEnd
		ifTrue: [^ self].
	streamReader peek == $%
		ifTrue: [
			streamReader next.
			^ self nextParameterEntityReference].
	streamReader peek == $]
		ifTrue: [
			self hasOpenIncludeSections
				ifFalse: [self errorUnexpectedEndConditionalSection].
			^ self nextEndIncludeSection].
	self nextSubsetMarkupToken.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextGeneralEntityOrCharacterReferenceOnCharacterStream
	"returns the character written to 'characterStream' if any, nil otherwise"
	| pushedBackGeneralEntity result |

	pushedBackGeneralEntity := self topPushedBackEntity.
	result :=
		streamReader peek == $#
			ifTrue: [self nextCharacterReferenceOnCharacterStream]
			ifFalse: [self nextGeneralEntityReferenceOnCharacterStream].
	pushedBackGeneralEntity
		ifNotNil: [
			(self pushedBackEntities includes: pushedBackGeneralEntity)
				ifFalse: [self errorImproperGeneralEntityNesting]].

	^ result.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextGeneralEntityReferenceOnCharacterStream
	"returns the (first) character written to 'characterStream' if any,
	nil otherwise"
	| name |

	name := self nextEntityName.
	self nextEntityReferenceTerminator.
	PredefinedEntities
		at: name
		ifPresent: [:character |
			driver replacesContentEntityReferences
				ifFalse: [
					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].
			characterStream nextPut: character.
			^ character].

	(driver handleGeneralEntityReference: name)
		ifNil: [
			(driver replacesContentEntityReferences not
				or: [driver preservesUndeclaredEntityReferences])
				ifTrue: [
					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].
			driver handleUnreplacedGeneralEntityReference: name]
		ifNotNil: [:entity |
			entity isUnparsed
				ifTrue: [self errorReferenceToUnparsedGeneralEntity: entity].
			driver replacesContentEntityReferences
				ifFalse: [
					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].
			self constructReplacementForGeneralEntity: entity].
	^ nil.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextIgnoreSectionFromEntity: aPushedBackParameterEntity
	| openSections firstChar secondChar nextChar |

	self
		expectNextAll: 'IGNORE'
		startingAt: 2. "the 'I' was already read"
	streamReader skipSeparators.
	self expectNext: $[.

	"the 'IGNORE' can be in the replacement of an entity, like
	in '<!![%entity[...]]>', but after it the entity that started
	the declaration must be current"
	self topPushedBackEntity == aPushedBackParameterEntity
		ifFalse: [driver handleImproperParameterEntityNesting].

	"From the spec:
	The contents of an ignored conditional section MUST be parsed by
	ignoring all characters after the '[' following the keyword, except
	conditional section starts '<!![' and ends ']]>', until the matching
	conditional section end is found. Parameter entity references MUST
	NOT be recognized in this process."
	openSections := 1.
	[openSections == 0
		or: [(nextChar := streamReader next) == nil]]
		whileFalse: [
			nextChar == $>
				ifTrue: [
					(secondChar == $]
						and: [firstChar == $]])
						ifTrue: [openSections := openSections - 1]]
				ifFalse: [
					nextChar == $[
						ifTrue: [
							(secondChar == $!!
								and: [firstChar == $<])
								ifTrue: [openSections := openSections + 1]]].
			firstChar := secondChar.
			secondChar := nextChar].

	openSections == 0
		ifFalse: [self errorUnterminatedIgnoreSections].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextInternalEntityDeclaration: aName isParameterEntity: aBoolean
	| value |

	value := self nextEntityValue.
	self
		skipSeparatorsInDeclaration;
		nextDeclarationTerminator.

	aBoolean
		ifTrue: [
			driver
				handleParameterEntityDeclaration: aName
				replacement: value]
		ifFalse: [
			driver
				handleGeneralEntityDeclaration: aName
				replacement: value].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextMixedContentListOnCharacterStreamFromEntity: aPushedBackParameterEntity
	| hasElements |

	hasElements := false.
	characterStream nextPutAll: (self expectNextAll: '#PCDATA').

	[self skipSeparatorsInDeclaration.
		streamReader peek == $)]
		whileFalse: [
			characterStream nextPut: (self expectNext: $|).
			hasElements := true.
			self
				skipSeparatorsInDeclaration;
				nextElementNameOnCharacterStream].
	characterStream nextPut: streamReader next.
	self topPushedBackEntity == aPushedBackParameterEntity
		ifFalse: [driver handleImproperParameterEntityNesting].

	streamReader peek == $*
		ifTrue: [characterStream nextPut: streamReader next]
		ifFalse: [
			hasElements
				ifTrue: [self errorExpectedLiteral: $*]].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextNmtokenOnCharacterStream
	"matches the Nmtoken production"
	| nextChar |

	"nil understands #isXMLNameChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameChar
		ifFalse: [self errorExpectedNmtoken].
	characterStream nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [characterStream nextPut: streamReader next].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextNonElementWhitespace
	| nextChar |

	"nil understands isXMLSeparator so it is not tested for first"
	[(nextChar := streamReader peek) isXMLSeparator]
		whileTrue: [streamReader next].
	(nextChar == $<
		or: [nextChar == nil])
		ifFalse: [self errorNonElementPCDataCharacter: streamReader next].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextNonPIPrologOrContentMarkupToken
	streamReader peek == $!!
		ifTrue: [^ self nextDoctypeDeclarationOrComment].
	self
		nextStartContent;
		nextTag.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextNotationDeclaration
	| name publicID systemID |

	self
		expectNextAll: 'NOTATION';
		nextSeparatorsInDeclaration.

	name := self nextNotationName.
	self nextSeparatorsInDeclaration.
	streamReader peek == $P
		ifTrue: [
			publicID := self nextPublicIDInDeclaration.
			(streamReader peek == $>
				or: [
					self nextSeparatorsInDeclaration.
					streamReader peek == $>])
				ifFalse: [systemID := self nextSystemIDLiteral]]
		ifFalse: [systemID := self nextSystemIDInDeclaration].
	self
		skipSeparatorsInDeclaration;
		nextDeclarationTerminator.

	driver
		handleNotationDeclaration: name
		publicID: (publicID ifNil: [''])
		systemID: (systemID ifNil: ['']).! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextNotationName
	| nextChar |

	"nil understands #isXMLNameStartChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameStartChar
		ifFalse: [self errorExpectedNotationName].
	nameStream
		reset;
		nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [nameStream nextPut: streamReader next].
	^ nameStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextNotationNameOnCharacterStream
	| nextChar |

	"nil understands #isXMLNameStartChar so it does not need to be tested for"
	(nextChar := streamReader next) isXMLNameStartChar
		ifFalse: [self errorExpectedNotationName].
	characterStream nextPut: nextChar.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [characterStream nextPut: streamReader next].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextPCDataToken
	| isWhitespace nextChar closingBracketsRead |

	isWhitespace := true.
	characterStream reset.
	closingBracketsRead := 0.
	[(nextChar := streamReader peek) == $<
		or: [nextChar == nil]]
		whileFalse: [
			streamReader next == $&
				ifTrue: [
					self nextGeneralEntityOrCharacterReferenceOnCharacterStream
						ifNotNil: [:writtenChar |
							isWhitespace
								ifTrue: [isWhitespace := writtenChar isXMLSeparator]]]
				ifFalse: [
					(isWhitespace
						and: [isWhitespace := nextChar isXMLSeparator])
						ifFalse: [
							nextChar == $]
								ifTrue: [
									isWhitespace := false.
									closingBracketsRead := closingBracketsRead + 1]
								ifFalse: [
									closingBracketsRead == 0
										ifFalse: [
											(closingBracketsRead >= 2
												and: [nextChar == $>])
												ifTrue: [
													self errorUnexpectedCDataTerminator].
											closingBracketsRead := 0].
									nextChar isXMLChar
										ifFalse: [self errorNonCharInPCData: nextChar]]].
					characterStream nextPut: nextChar]].
	isWhitespace
		ifTrue: [
			characterStream position == 0
				ifFalse: [driver handleWhitespace: characterStream contents]]
		ifFalse: [driver handlePCData: characterStream contents].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextPIData
	| nextChar |

	characterStream reset.
	[(nextChar := streamReader next) == nil
		or: [nextChar == $?
			and: [streamReader peek == $>]]]
		whileFalse: [
			nextChar isXMLChar
				ifFalse: [self errorNonCharInPIValue: nextChar].
			characterStream nextPut: nextChar].
	self nextPITerminator.
	^ characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextPITarget
	"PITarget	   ::=   	Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))"
	| nextChar isReservedTarget isLowercaseReservedTarget length |

	nameStream reset.
	(nextChar := streamReader next) == $x
		ifTrue: [
			isReservedTarget := true.
			isLowercaseReservedTarget := true]
		ifFalse:[
			nextChar == $X
				ifTrue: [isReservedTarget := true]
				ifFalse: [
					"nil understands #isXMLNameStartChar so it does
					not need to be tested for"
					nextChar isXMLNameStartChar
						ifFalse: [self errorExpectedPITarget].
					isReservedTarget := false].
			isLowercaseReservedTarget := false].
	nameStream nextPut: nextChar.
	length := 1.

	"nil understands #isXMLNameChar so it does not need to be tested for"
	[streamReader peek isXMLNameChar]
		whileTrue: [
			nextChar := streamReader next.
			length := length + 1.
			isReservedTarget
				ifTrue: [
					(length <= 3
						and: [
							nextChar == ('xml' at: length)
								or: [
									isLowercaseReservedTarget := false.
									nextChar == ('XML' at: length)]])
						ifFalse: [
							isReservedTarget := false.
							isLowercaseReservedTarget := false]].
			nameStream nextPut: nextChar].
	
	(isReservedTarget
		and: [length = 3])
		ifTrue: [
			isLowercaseReservedTarget
				ifTrue: [
					state isXMLDeclarationState
						ifFalse: [self errorXMLDeclarationNotAtStart].
					"return nil to indicate it's an XML declaration, not a PI"
					^ nil].
			"a reserved target other than lowercase 'xml' for XML declarations
			is never allowed"
			self errorReservedPITarget: nameStream contents].
	^ nameStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextPITerminator
	| nextChar |

	(nextChar := streamReader next) == $>
		ifFalse: [self errorExpectedPITerminatorButGot: nextChar]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextParameterEntityReference
	| pushedBackParameterEntity name |

	pushedBackParameterEntity := self topPushedBackEntity.
	name := self nextEntityName.
	self nextEntityReferenceTerminator.
	self topPushedBackEntity == pushedBackParameterEntity
		ifFalse: [driver handleImproperParameterEntityNesting].

	(driver handleParameterEntityReference: name)
		ifNotNil: [:entity | self constructReplacementForParameterEntity: entity].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextParameterEntityReferenceInDeclaration
	self isInExternalSubsetOrExternalEntity
		ifFalse: [self errorInternalDeclarationParameterEntityReference].
	self nextParameterEntityReference.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextParameterEntityReferenceOnCharacterStream
	| pushedBackParameterEntity name |

	pushedBackParameterEntity := self topPushedBackEntity.
	name := self nextEntityName.
	self nextEntityReferenceTerminator.
	self topPushedBackEntity == pushedBackParameterEntity
		ifFalse: [driver handleImproperParameterEntityNesting].
	
	(driver handleParameterEntityReference: name)
		ifNil: [
			driver preservesUndeclaredEntityReferences
				ifTrue: [
					characterStream
						nextPut: $%;
						nextPutAll: name;
						nextPut: $;.
					^ $%]]
		ifNotNil: [:entity |
			self constructReplacementForParameterEntity: entity].
	^ nil.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextPrologToken
	streamReader skipSeparators.
	self nextStartMarkupToken.
	streamReader peek == $?
		ifTrue: [^ self nextPI].
	self nextNonPIPrologOrContentMarkupToken.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextPublicIDInDeclaration
	^ self
		expectNextAll: 'PUBLIC';
		nextSeparatorsInDeclaration;
		nextPublicIDLiteral! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextPublicIDLiteral
	"this returns the pubid with leading and trailing whitespace removed
	and all other whitespace sequences converted to single spaces"
	| quote isInWhitespace nextChar |

	((quote := streamReader next) == $"
		or: [quote == $'])
		ifFalse: [self errorExpectedPublicIDLiteralStartButGot: quote].

	characterStream reset.
	isInWhitespace := false.
	"it's not enough to test for nil and PublicIDChars inclusion because
	(PublicIDChars includes: $') = true (double quoted pubids can contain
	single quotes), so the terminating quote must be tested for first to
	handle single quoted pubids correctly"
	[(nextChar := streamReader next) == nil
		or: [nextChar == quote
			or: [(PublicIDChars includes: nextChar) not]]]
		whileFalse: [
			nextChar isXMLSeparator
				ifTrue: [
					isInWhitespace
						ifFalse: [isInWhitespace := true]]
				ifFalse: [
					isInWhitespace
						ifTrue: [
							characterStream position > 0
								ifTrue: [characterStream nextPut: NormalizedSpace].
							isInWhitespace := false].
					characterStream nextPut: nextChar]].

	nextChar == quote
		ifFalse: [
			self
				errorExpectedPublicIDLiteralEnd: quote
				butGot: nextChar].

	^ characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextSeparators
	"nil understands isXMLSeparator so no nil test is needed"
	streamReader next isXMLSeparator
		ifTrue: [streamReader skipSeparators]
		ifFalse: [self errorExpectedSeparators]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSeparatorsInDeclaration
	"this can be used to replace entity references within declarations"

	[streamReader peek == $%]
		whileTrue: [
			streamReader next.
			self nextParameterEntityReferenceInDeclaration].
	self nextSeparators.
	[streamReader peek == $%]
		whileTrue: [
			streamReader next.
			self nextParameterEntityReferenceInDeclaration.
			streamReader skipSeparators].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextStartExternalEntity
	driver decodesCharacters
		ifTrue: [streamReader detectEncoding].
	self nextXMLTextDeclaration.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextStartExternalSubset
	self nextXMLTextDeclaration.
	state := state externalSubsetState.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextStartIncludeSectionFromEntity: aPushedBackParameterEntity
	self
		expectNextAll: 'INCLUDE'
		startingAt: 2. "the 'I' was already read"
	streamReader skipSeparators.
	self expectNext: $[.

	"the 'INCLUDE' can be in the replacement of an entity, like
	in '<!![%entity[...]]>', but after it the entity that started
	the declaration must be current"
	self topPushedBackEntity == aPushedBackParameterEntity
		ifFalse: [driver handleImproperParameterEntityNesting].

	totalOpenIncludeSections := self totalOpenIncludeSections + 1.
	aPushedBackParameterEntity
		ifNotNil: [aPushedBackParameterEntity startIncludeSection].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextStartMarkupToken
	| nextChar |

	(nextChar := streamReader next) == $<
		ifFalse: [self errorExpectedStartMarkupTokenButGot: nextChar]! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSubsetDeclaration
	streamReader peek == $E
		ifTrue: [
			streamReader next.
			streamReader peek == $N
				ifTrue: [^ self nextEntityDeclaration]
				ifFalse: [^ self nextElementDeclaration]].
	streamReader peek == $A
		ifTrue: [^ self nextAttlistDeclaration].
	streamReader peek == $N
		ifTrue: [^ self nextNotationDeclaration].

	self errorExpectedSubsetDeclaration.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSubsetMarkupToken
	| pushedBackParameterEntity |

	self nextStartMarkupToken.
	pushedBackParameterEntity := self topPushedBackEntity.

	streamReader peek == $?
		ifTrue: [self nextPI]
		ifFalse: [
			self expectNext: $!!.
			streamReader peek == $-
				ifTrue: [self nextComment]
				ifFalse: [
					streamReader peek == $[
						ifTrue: [
							self isInExternalSubsetOrExternalEntity
								ifFalse: [self errorInternalSubsetConditionalSection].
							self nextConditionalSectionFromEntity:
								pushedBackParameterEntity]
						ifFalse: [self nextSubsetDeclaration]]].

	self topPushedBackEntity == pushedBackParameterEntity
		ifFalse: [driver handleImproperParameterEntityNesting].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSystemIDInDeclaration
	^ self
		expectNextAll: 'SYSTEM';
		nextSeparatorsInDeclaration;
		nextSystemIDLiteral! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSystemIDInDeclarationWithoutURIFragment
	^ self
		expectNextAll: 'SYSTEM';
		nextSeparatorsInDeclaration;
		nextSystemIDLiteralWithoutURIFragment! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSystemIDLiteral
	^ self nextSystemIDLiteralWithoutURIFragment: false! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSystemIDLiteralWithoutURIFragment
	^ self nextSystemIDLiteralWithoutURIFragment: true! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
nextSystemIDLiteralWithoutURIFragment: aBoolean
	"Returns the system ID literal.
	If aBoolean is true, it disallows '#' URI fragments."

	| quote nextChar |

	((quote := streamReader next) == $"
		or: [quote == $'])
		ifFalse: [self errorExpectedSystemIDLiteralStartButGot: quote].

	characterStream reset.
	[(nextChar := streamReader next) == nil
		or: [nextChar == quote]]
		whileFalse: [
			nextChar isXMLChar
				ifFalse: [self errorNonCharInSystemID: nextChar].
			aBoolean
				ifTrue: [
					nextChar == $#
						ifTrue: [self errorURIFragmentInSystemID]].
			characterStream nextPut: nextChar].

	nextChar == quote
		ifFalse: [
			self
				errorExpectedSystemIDLiteralEnd: quote
				butGot: nextChar].

	^ characterStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextTag
	"performance critical method"
	| tagName attributes nextChar |

	(streamReader peek == $/)
		ifTrue: [^ self nextEndTag].
	tagName := self nextElementName.

	"nil understands isXMLSeparator so is not tested for"
	[(nextChar := streamReader peek) isXMLSeparator
		and: [
			streamReader
				next;
				skipSeparators.
			((nextChar := streamReader peek) == $>
				or: [nextChar == $/]) not]]
		whileTrue: [| attributeName |
			attributeName := self nextAttributeName.
			streamReader skipSeparators.
			(nextChar := streamReader next) == $=
				ifFalse: [
					self errorExpectedElementAttributeEqualsSeparatorButGot: nextChar].
			streamReader skipSeparators.

			"delay initializing 'attributes' until now to know for sure if it
			needs a non-zero capacity, otherwise use the lazy version"
			((attributes
				ifNil: [attributes := driver newAttributeDictionary])
				at: attributeName
				newPut: self nextAttributeValue)
				ifFalse: [self errorDuplicateAttribute: attributeName].

			"the ordering of these tests is optimized"
			(attributeName at: 1) == $x
				ifTrue: [
					driver hasUnhandledReservedAttributes
						ifFalse: [
							attributeName isXMLReservedAttributeName
								ifTrue: [driver haveUnhandledReservedAttributes]]]].

	elementNester wasRootElementEnded
		ifTrue: [self errorMultipleDocumentRootElements].
	elementNester startElement: tagName.
	driver
		handleStartTag: tagName
		attributes:
			(attributes
				ifNil: [driver newEmptyAttributeDictionary]).

	nextChar == $/
		ifTrue: [
			streamReader next.
			elementNester endCurrentElement.
			driver handleEndTag: tagName].

	(nextChar := streamReader next) == $>
		ifFalse: [self errorExpectedTagTerminatorButGot: nextChar].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextUnreplacedGeneralEntityOnCharacterStreamNamed: aName
	driver handleUnreplacedGeneralEntityReference: aName.
	characterStream
		nextPut: $&;
		nextPutAll: aName;
		nextPut: $;.
	^ $&.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextXMLAttributeEqualsSeparator
	| nextChar |

	streamReader skipSeparators.
	(nextChar := streamReader next) == $=
		ifFalse: [self errorExpectedXMLAttributeEqualsSeparatorButGot: nextChar].
	streamReader skipSeparators.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextXMLDeclarationTerminator
	| firstChar secondChar |

	firstChar := streamReader next.
	secondChar := streamReader next.
	(firstChar == $?
		and: [secondChar == $>])
		ifFalse: [
			self
				errorExpectedXMLDeclarationTerminatorButGot: firstChar
				followedBy: secondChar].! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextXMLEncodingAttributeValue
	| quote nextChar |

	((quote := streamReader next) == $"
		or: [quote == $'])
		ifFalse: [self errorExpectedXMLEncodingValueStartButGot: quote].

	((nextChar := streamReader next) notNil
		and: [EncodingNameStartChars includes: nextChar])
		ifFalse: [self errorExpectedEncodingName].

	xmlDeclarationStream
		reset;
		nextPut: nextChar.
	[(nextChar := streamReader next) == nil
		or: [(EncodingNameChars includes: nextChar) not]]
		whileFalse: [xmlDeclarationStream nextPut: nextChar].

	nextChar == quote
		ifFalse: [
			self
				errorExpectedXMLEncodingValueEnd: quote
				butGot: nextChar].

	^ xmlDeclarationStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextXMLStandaloneAttributeValue
	| quote yesOrNo nextChar |

	((quote := streamReader next) == $"
		or: [quote == $'])
		ifFalse: [self errorExpectedXMLStandaloneValueStartButGot: quote].

	yesOrNo := 
		streamReader peek == $y
			ifTrue: [self expectNextAll: 'yes']
			ifFalse: [self expectNextAll: 'no'].

	(nextChar := streamReader next) == quote
		ifFalse: [
			self
				errorExpectedXMLStandaloneValueEnd: quote
				butGot: nextChar].

	^ yesOrNo.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextXMLTextDeclaration
	| encoding |
	
	1 to: 5 "'<?xml' size" do: [:i |
		streamReader peek == ('<?xml' at: i)
			ifFalse: [
				i > 1
					ifTrue: [
						streamReader pushBack:
							('<?xml'
								copyFrom: 1
								to: i - 1)].
				^ self].
		streamReader next].

	self nextSeparators.
	(self nextXMLVersionAttributeRequired: false) isEmpty
		ifFalse: [self nextSeparators].
	(encoding := self nextXMLEncodingAttributeRequired: true) isEmpty
		ifFalse: [self convertFromEncoding: encoding].

	streamReader skipSeparators.
	self nextXMLDeclarationTerminator.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!
nextXMLVersionAttributeValue
	| quote nextChar length isValid |

	((quote := streamReader next) == $"
		or: [quote == $'])
		ifFalse: [self errorExpectedXMLVersionValueStartButGot: quote].

	length := 0.
	isValid := true.
	xmlDeclarationStream reset.
	[(nextChar := streamReader next) == nil
		or: [(VersionNumChars includes: nextChar) not]]
		whileFalse: [
			xmlDeclarationStream nextPut: nextChar.
			length := length + 1.
			isValid
				ifTrue: [isValid := (length == 2) == (nextChar == $.)]].
	(isValid
		and: [length >= 3])
		ifFalse: [
			self errorExpectedXMLVersionNumberButGot:
				xmlDeclarationStream contents].

	nextChar == quote
		ifFalse: [
			self
				errorExpectedXMLVersionValueEnd: quote
				butGot: nextChar].

	^ xmlDeclarationStream contents.! !
!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!
pushBackEntity: anEntity whenPoppedDo: aBlock
	anEntity hasReplacement
		ifTrue: [| pushedBackEntity |
			pushedBackEntity :=
				self addPushedBackEntity: anEntity asPushedBackEntity.
			streamReader
				pushBackStream: pushedBackEntity replacementStream
				whenPoppedDo: [
					self removePushedBackEntity: pushedBackEntity.
					aBlock
						ifNotNil: [aBlock value]]
				isExternal: pushedBackEntity isExternal.
			pushedBackEntity isExternal
				ifTrue: [self nextStartExternalEntity]]
		ifFalse: [
			aBlock
				ifNotNil: [aBlock value]]! !
!XMLWellFormedParserTokenizer methodsFor: 'accessing'!
pushedBackEntities
	^ pushedBackEntities
		ifNil: [pushedBackEntities := OrderedCollection new: 5]! !
!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!
removePushedBackEntity: aPushedBackEntity
	self pushedBackEntities remove: aPushedBackEntity.
	driver currentEntity: self topPushedBackEntity.
	aPushedBackEntity isExternal
		ifTrue: [
			self topPushedBackExternalEntity
				ifNil: [
					driver baseURI: nil]
				ifNotNil: [:pushedBackExternalEntity |
					driver baseURI: pushedBackExternalEntity uri]].
	^ aPushedBackEntity poppedByTokenizer: self.! !
!XMLWellFormedParserTokenizer methodsFor: 'initialization'!
setDriver: aDriver stream: aStream readLimit: anInteger
	super
		setDriver: aDriver
		stream: aStream
		readLimit: anInteger.

	isInLiteralValue := false.
	isIgnoringLiteralValueTerminator := false.! !
!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!
skipSeparatorsInDeclaration
	"this can be used to replace references within declarations"

	streamReader skipSeparators.
	[streamReader peek == $%]
		whileTrue: [
			streamReader next.
			self nextParameterEntityReferenceInDeclaration.
			streamReader skipSeparators].! !
!XMLWellFormedParserTokenizer methodsFor: 'accessing'!
topPushedBackEntity
	"heavily optimized"
	pushedBackEntities == nil
		ifTrue: [^ nil].
	pushedBackEntities size > 0
		ifFalse: [^ nil].
	^ pushedBackEntities at: pushedBackEntities size.! !
!XMLWellFormedParserTokenizer methodsFor: 'accessing'!
topPushedBackExternalEntity
	self pushedBackEntities reverseDo: [:each |
		each isExternal
			ifTrue: [^ each]].
	^ nil.! !
!XMLWellFormedParserTokenizer methodsFor: 'accessing'!
totalOpenIncludeSections
	^ totalOpenIncludeSections ifNil: [totalOpenIncludeSections := 0]! !
!XMLPushedBackEntity class methodsFor: 'instance creation'!
entity: anEntity
	^ self new entity: anEntity! !
!XMLPushedBackEntity methodsFor: 'converting'!
asPushedBackEntity
	^ self! !
!XMLPushedBackEntity methodsFor: 'converting'!
asReference
	^ entity asReference! !
!XMLPushedBackEntity methodsFor: 'accessing'!
entity
	^ entity! !
!XMLPushedBackEntity methodsFor: 'accessing'!
entity: anEntity
	entity := anEntity! !
!XMLPushedBackEntity methodsFor: 'testing'!
hasReplacement
	^ entity hasReplacement! !
!XMLPushedBackEntity methodsFor: 'testing'!
isExternal
	^ entity isExternal! !
!XMLPushedBackEntity methodsFor: 'testing'!
isParameter
	^ entity isParameter! !
!XMLPushedBackEntity methodsFor: 'testing'!
isStandaloneExternal
	^ entity isStandaloneExternal! !
!XMLPushedBackEntity methodsFor: 'testing'!
isUnparsed
	^ entity isUnparsed! !
!XMLPushedBackEntity methodsFor: 'accessing'!
name
	^ entity name! !
!XMLPushedBackEntity methodsFor: 'nesting'!
poppedByTokenizer: aTokenizer
	self subclassResponsibility! !
!XMLPushedBackEntity methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		print: entity;
		nextPut: $).! !
!XMLPushedBackEntity methodsFor: 'accessing'!
replacement
	^ entity replacement! !
!XMLPushedBackEntity methodsFor: 'accessing'!
replacementStream
	^ entity replacementStream! !
!XMLPushedBackEntity methodsFor: 'accessing'!
uri
	^ entity uri! !
!XMLPushedBackGeneralEntity methodsFor: 'nesting'!
endElement
	totalOpenElements := self totalOpenElements - 1! !
!XMLPushedBackGeneralEntity methodsFor: 'nesting'!
poppedByTokenizer: aTokenizer
	totalOpenElements
		ifNotNil: [
			totalOpenElements = 0
				ifFalse: [aTokenizer errorImproperGeneralEntityNesting]]! !
!XMLPushedBackGeneralEntity methodsFor: 'nesting'!
startElement
	totalOpenElements := self totalOpenElements + 1! !
!XMLPushedBackGeneralEntity methodsFor: 'accessing'!
totalOpenElements
	^ totalOpenElements ifNil: [totalOpenElements := 0]! !
!XMLPushedBackParameterEntity methodsFor: 'nesting'!
endIncludeSection
	totalOpenIncludeSections := self totalOpenIncludeSections - 1! !
!XMLPushedBackParameterEntity methodsFor: 'nesting'!
poppedByTokenizer: aTokenizer
	totalOpenIncludeSections
		ifNotNil: [
			totalOpenIncludeSections = 0
				ifFalse: [aTokenizer driver handleImproperParameterEntityNesting]]! !
!XMLPushedBackParameterEntity methodsFor: 'nesting'!
startIncludeSection
	totalOpenIncludeSections := self totalOpenIncludeSections + 1! !
!XMLPushedBackParameterEntity methodsFor: 'accessing'!
totalOpenIncludeSections
	^ totalOpenIncludeSections ifNil: [totalOpenIncludeSections := 0]! !
!XMLPushedBackExternalStream methodsFor: 'testing'!
isExternal
	^ true! !
!XMLPushedBackStream class methodsFor: 'instance creation'!
stream: aStream whenPoppedDo: aBlock currentPosition: aPosition currentLineNumber: aLineNumber currentLineStartPosition: aStartPosition
	^ self new
		setStream: aStream
		whenPoppedDo: aBlock
		currentPosition: aPosition
		currentLineNumber: aLineNumber
		currentLineStartPosition: aStartPosition! !
!XMLPushedBackStream methodsFor: 'accessing'!
currentLineNumber
	^ currentLineNumber! !
!XMLPushedBackStream methodsFor: 'accessing'!
currentLineStartPosition
	^ currentLineStartPosition! !
!XMLPushedBackStream methodsFor: 'accessing'!
currentPosition
	^ currentPosition! !
!XMLPushedBackStream methodsFor: 'testing'!
isExternal
	^ false! !
!XMLPushedBackStream methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		print: stream;
		nextPut: $).! !
!XMLPushedBackStream methodsFor: 'initialization'!
setStream: aStream whenPoppedDo: aBlock currentPosition: aPosition currentLineNumber: aLineNumber currentLineStartPosition: aStartPosition
	stream := aStream.
	whenPoppedDo := aBlock.
	currentPosition := aPosition.
	currentLineNumber := aLineNumber.
	currentLineStartPosition := aStartPosition.! !
!XMLPushedBackStream methodsFor: 'accessing'!
stream
	^ stream! !
!XMLPushedBackStream methodsFor: 'accessing'!
whenPoppedDo
	^ whenPoppedDo! !
!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!
nonDecodingOn: aStream
	^ self
		on: aStream
		streamConverter: XMLStreamConverter null! !
!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!
nonDecodingOnIfBinaryOrExternal: aStream
	^ aStream isXMLBinaryOrExternalStream
		ifTrue: [
			self
				on: aStream
				streamConverter: XMLStreamConverter null]
		ifFalse: [nil]! !
!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!
on: aStream
	^ self
		on: aStream
		streamConverter: XMLStreamConverter default! !
!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!
on: aStream streamConverter: aStreamConverter
	^ (self basicOn: aStream)
		streamConverter: aStreamConverter! !
!XMLDecodingReadStreamAdapter methodsFor: 'testing'!
atEnd
	^ peekChar == nil
		and: [stream atEnd]! !
!XMLDecodingReadStreamAdapter methodsFor: 'decoding'!
detectEncoding
	prePeekStreamPosition := nil.
	peekChar := nil.
	stream reset.

	(((self hasNullStreamConverter
		or: [self hasImplicitStreamConverter])
		ifTrue: [XMLImplicitEncodingDetector]
		ifFalse: [XMLEncodingDetector])
			on: stream) streamConverterForEncoding
				ifNotNil: [:converter |
					self streamConverter: converter].! !
!XMLDecodingReadStreamAdapter methodsFor: 'testing'!
hasDefaultStreamConverter
	^ streamConverter isDefault! !
!XMLDecodingReadStreamAdapter methodsFor: 'testing'!
hasImplicitStreamConverter
	^ streamConverter isImplicit! !
!XMLDecodingReadStreamAdapter methodsFor: 'testing'!
hasNullStreamConverter
	^ streamConverter isNull! !
!XMLDecodingReadStreamAdapter methodsFor: 'testing'!
isXMLConvertingStreamAdapter
	^ true! !
!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!
next
	peekChar
		ifNil: [^ streamConverter nextFromStream: stream]
		ifNotNil: [:nextChar |
			prePeekStreamPosition := nil.
			peekChar := nil.
			^ nextChar]! !
!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!
peek
	^ peekChar
		ifNil: [
			prePeekStreamPosition := stream position.
			peekChar := streamConverter nextFromStream: stream]! !
!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!
position
	^ prePeekStreamPosition ifNil: [stream position]! !
!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!
position: anInteger
	prePeekStreamPosition := nil.
	peekChar := nil.
	stream position: anInteger.! !
!XMLDecodingReadStreamAdapter methodsFor: 'printing'!
printStreamOn: aStream
	streamConverter
		printWithConvertableStream: stream
		on: aStream! !
!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!
reset
	prePeekStreamPosition := nil.
	peekChar := nil.
	stream reset.! !
!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!
streamConverter
	^ streamConverter! !
!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!
streamConverter: aStreamConverter
	streamConverter :=
		aStreamConverter ifNil: [XMLStreamConverter null].
	peekChar
		ifNotNil: [
			stream position: prePeekStreamPosition.
			prePeekStreamPosition := nil.
			peekChar := nil].! !
!XMLLimitedReadStreamAdapter class methodsFor: 'accessing'!
defaultLimit
	^ 1014! !
!XMLLimitedReadStreamAdapter class methodsFor: 'instance creation'!
on: aStream
	^ self
		on: aStream
		limit: self defaultLimit! !
!XMLLimitedReadStreamAdapter class methodsFor: 'instance creation'!
on: aStream limit: aLimit
	^ (self basicOn: aStream)
		limit: aLimit! !
!XMLLimitedReadStreamAdapter methodsFor: 'testing'!
atEnd
	^ stream atEnd
		or: [limit <= 0]! !
!XMLLimitedReadStreamAdapter methodsFor: 'testing'!
atLimitedEnd
	^ limit <= 0
		and: [stream atEnd not]! !
!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!
limit
	^ limit! !
!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!
limit: anInteger
	limit := anInteger! !
!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!
next
	(stream atEnd
		or: [limit <= 0])
		ifTrue: [^ nil]
		ifFalse: [
			limit := limit - 1.
			^ stream next]! !
!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!
peek
	(stream atEnd
		or: [limit <= 0])
		ifTrue: [^ nil]
		ifFalse: [^ stream peek]! !
!XMLLimitedReadStreamAdapter methodsFor: 'positioning'!
position: anInteger
	| netPosition |

	(netPosition := anInteger - stream position) > limit
		ifTrue: [
			"skip as far ahead as allowed"
			self skip: limit]
		ifFalse: [
			limit := (limit - netPosition) max: 0.
			stream position: anInteger]! !
!XMLLimitedReadStreamAdapter methodsFor: 'positioning'!
reset
	| oldPosition |

	oldPosition := stream position.
	stream reset.
	limit := limit + (oldPosition - stream position).! !
!XMLPercentDecodingReadStreamAdapter methodsFor: 'testing'!
atEnd
	^ stream atEnd
		or: [stream peek ~~ $%]! !
!XMLPercentDecodingReadStreamAdapter methodsFor: 'testing'!
isBinary
	"this stream is binary, because it reads percent-encoded octets
	character sequences like '%HH' and returns the octet values as
	SmallIntegers"
	^ true! !
!XMLPercentDecodingReadStreamAdapter methodsFor: 'accessing'!
next
	| byte |

	(stream atEnd not
		and: [stream peek == $%])
		ifTrue: [
			stream next.
			byte :=
				(XMLSmallIntegerReader
					readFrom: stream
					withBase: 16
					upToLimit: 2)
						ifNil: [37] "$% asciiValue"].
	^ byte.! !
!XMLPercentDecodingReadStreamAdapter methodsFor: 'accessing'!
peek
	| byte |

	stream atEnd
		ifFalse: [| oldPosition |
			oldPosition := stream position.
			byte := self next.
			stream position: oldPosition].
	^ byte.! !
!XMLReadStreamAdapter class methodsFor: 'instance creation'!
onIfBinaryOrExternal: aStream
	^ aStream isXMLBinaryOrExternalStream
		ifTrue: [self on: aStream]
		ifFalse: [nil]! !
!XMLReadStreamAdapter methodsFor: 'testing'!
atEnd
	^ stream atEnd! !
!XMLReadStreamAdapter methodsFor: 'accessing'!
contents
	| oldPosition contents |

	oldPosition := self position.
	self reset.
	contents := self upToEnd.
	self position: oldPosition.
	^ contents.! !
!XMLReadStreamAdapter methodsFor: 'private'!
newWriteStream
	^ (self writeStreamCollectionClass new: 128) writeStream! !
!XMLReadStreamAdapter methodsFor: 'accessing'!
next
	stream atEnd
		ifTrue: [^ nil]
		ifFalse: [^ stream next]! !
!XMLReadStreamAdapter methodsFor: 'accessing'!
next: anInteger
	| writeStream i |

	writeStream := self newWriteStream.
	i := 0.
	[self atEnd
		or: [i >= anInteger]]
		whileFalse: [
			writeStream nextPut: self next.
			i := i + 1].
	^ writeStream contents.! !
!XMLReadStreamAdapter methodsFor: 'accessing'!
peek
	stream atEnd
		ifTrue: [^ nil]
		ifFalse: [^ stream peek]! !
!XMLReadStreamAdapter methodsFor: 'accessing'!
peekFor: anObject
	(self atEnd not
		and: [self peek = anObject])
		ifTrue: [
			self next.
			^ true]
		ifFalse: [^ false]! !
!XMLReadStreamAdapter methodsFor: 'positioning'!
position
	^ stream position! !
!XMLReadStreamAdapter methodsFor: 'positioning'!
position: anInteger
	stream position: anInteger! !
!XMLReadStreamAdapter methodsFor: 'positioning'!
reset
	stream reset! !
!XMLReadStreamAdapter methodsFor: 'positioning'!
skip: anInteger
	"only supports skipping forwards"
	1 to: anInteger do: [:i |
		self atEnd
			ifTrue: [^ self].
		self next]! !
!XMLReadStreamAdapter methodsFor: 'positioning'!
skipSeparators
	"we use #isXMLWhitespace instead of the narrower, XML-specific
	#isXMLSeparator, because this class supports non-XML input too"
	[self atEnd not
		and: [self peek isXMLWhitespace]]
		whileTrue: [self next]! !
!XMLReadStreamAdapter methodsFor: 'positioning'!
skipTo: anObject
	[self atEnd]
		whileFalse: [
			self next = anObject
				ifTrue: [^ true]].
	^ false.! !
!XMLReadStreamAdapter methodsFor: 'accessing'!
upTo: anObject
	| writeStream next |

	writeStream := self newWriteStream.
	[self atEnd
		or: [(next := self next) = anObject]]
		whileFalse: [writeStream nextPut: next].
	^ writeStream contents.! !
!XMLReadStreamAdapter methodsFor: 'accessing'!
upToEnd
	| writeStream |

	writeStream := self newWriteStream.
	[self atEnd]
		whileFalse: [writeStream nextPut: self next].
	^ writeStream contents.! !
!XMLReadStreamAdapter methodsFor: 'defaults'!
writeStreamCollectionClass
	self isBinary
		ifTrue: [^ ByteArray]
		ifFalse: [^ String]! !
!XMLStringReadStreamAdapter methodsFor: 'testing'!
isBinary
	"this stream is binary, because it converts characters to integers"
	^ true! !
!XMLStringReadStreamAdapter methodsFor: 'accessing'!
next
	stream atEnd
		ifTrue: [^ nil]
		ifFalse: [^ stream next asInteger]! !
!XMLStringReadStreamAdapter methodsFor: 'accessing'!
peek
	stream atEnd
		ifTrue: [^ nil]
		ifFalse: [^ stream peek asInteger]! !
!XMLStreamAdapter class methodsFor: 'basic'!
basicOn: aStream
	^ self basicNew initialize on: aStream! !
!XMLStreamAdapter class methodsFor: 'instance creation'!
new
	self shouldNotImplement! !
!XMLStreamAdapter class methodsFor: 'instance creation'!
on: aStream
	^ self basicOn: aStream! !
!XMLStreamAdapter methodsFor: 'closing'!
close
	"must use respondsTo: to support streams only implementing the basic protocol"
	(stream respondsTo: #close)
		ifTrue: [stream close]! !
!XMLStreamAdapter methodsFor: 'accessing'!
contents
	self subclassResponsibility! !
!XMLStreamAdapter methodsFor: 'testing'!
isBinary
	^ false! !
!XMLStreamAdapter methodsFor: 'testing'!
isStream
	^ true! !
!XMLStreamAdapter methodsFor: 'testing'!
isXMLBinaryOrExternalStream
	^ self isBinary! !
!XMLStreamAdapter methodsFor: 'initialization'!
on: aStream
	stream := aStream! !
!XMLStreamAdapter methodsFor: 'positioning'!
position
	self subclassResponsibility! !
!XMLStreamAdapter methodsFor: 'positioning'!
position: anInteger
	self subclassResponsibility! !
!XMLStreamAdapter methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	self printStreamOn: aStream.
	aStream nextPut: $).! !
!XMLStreamAdapter methodsFor: 'printing'!
printStreamOn: aStream
	aStream print: stream! !
!XMLStreamAdapter methodsFor: 'positioning'!
reset
	self subclassResponsibility! !
!XMLStreamAdapter methodsFor: 'accessing'!
stream
	^ stream! !
!XMLEncodingWriteStreamAdapter class methodsFor: 'instance creation'!
on: aStream
	^ self
		on: aStream
		streamConverter: XMLStreamConverter default! !
!XMLEncodingWriteStreamAdapter class methodsFor: 'instance creation'!
on: aStream streamConverter: aStreamConverter
	^ (self basicOn:
		(aStream isXMLBinaryOrExternalStream
			ifTrue: [aStream]
			ifFalse: [XMLStringWriteStreamAdapter on: aStream]))
		streamConverter: aStreamConverter! !
!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!
hasDefaultStreamConverter
	^ streamConverter isDefault! !
!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!
hasImplicitStreamConverter
	^ streamConverter isImplicit! !
!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!
hasNullStreamConverter
	^ streamConverter isNull! !
!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!
isXMLConvertingStreamAdapter
	^ true! !
!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!
nextPut: aCharacter
	streamConverter
		nextPut: aCharacter
		toStream: stream.
	^ aCharacter.! !
!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!
nextPutAll: aCollection
	"can't use #to:do: here because other #nextPutAll: implementations
	support non-sequenceable collection arguments wtih #do:"
	aCollection do: [:each |
		streamConverter
			nextPut: each
			toStream: stream].
	^ aCollection.! !
!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!
nextPutByteOrderMark
	streamConverter nextPutByteOrderMarkToStream: stream! !
!XMLEncodingWriteStreamAdapter methodsFor: 'printing'!
printStreamOn: aStream
	streamConverter
		printWithConvertableStream: stream
		on: aStream! !
!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!
streamConverter
	^ streamConverter! !
!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!
streamConverter: aStreamConverter
	streamConverter :=
		aStreamConverter ifNil: [XMLStreamConverter null]! !
!XMLNodeContentWriteStreamAdapter methodsFor: 'private'!
insertSpaceBefore: aCharacter
	(lastChar == nil
		or: [lastChar isXMLWhitespace
			or: [aCharacter isXMLWhitespace]])
		ifFalse: [stream nextPut: SpaceCharacter]! !
!XMLNodeContentWriteStreamAdapter methodsFor: 'accessing'!
nextPut: aCharacter
	self insertSpaceBefore: aCharacter.
	stream nextPut: aCharacter.
	^ lastChar := aCharacter.! !
!XMLNodeContentWriteStreamAdapter methodsFor: 'accessing'!
nextPutAll: aString
	aString size > 0 "optimization"
		ifTrue: [
			self insertSpaceBefore: aString first.
			stream nextPutAll: aString.
			lastChar := aString last].
	^ aString.! !
!XMLPercentEncodingWriteStreamAdapter methodsFor: 'testing'!
isBinary
	"this stream is binary, because it accepts binary octet values
	and percent-encodes them as '%HH' character sequences"
	^ true! !
!XMLPercentEncodingWriteStreamAdapter methodsFor: 'accessing'!
nextPut: anObject
	| byte |

	stream nextPut: $%.

	"pad it if needed"
	(byte := anObject asInteger) < 16r10
		ifTrue: [stream nextPut: $0].

	"On GS, #printOn:base: shows the radix, so #printOn:base:showRadix:
	is used instead"
	byte
		printOn: stream
		base: 16
		showRadix: false.
	^ anObject.! !
!XMLPercentEncodingWriteStreamAdapter methodsFor: 'accessing'!
nextPutAll: aCollection
	"can't use #to:do: here because other #nextPutAll: implementations
	support non-sequenceable collection arguments wtih #do:"
	aCollection do: [:each |
		self nextPut: each].
	^ aCollection.! !
!XMLStringWriteStreamAdapter methodsFor: 'accessing'!
nextPut: anObject
	stream nextPut: anObject asCharacter! !
!XMLStringWriteStreamAdapter methodsFor: 'accessing'!
nextPutAll: aCollection
	"can't use #to:do: here because other #nextPutAll: implementations
	support non-sequenceable collection arguments wtih #do:"
	aCollection do: [:each |
		stream nextPut: each asCharacter].
	^ aCollection.! !
!XMLWriteStreamAdapter class methodsFor: 'class initialization'!
initialize
	"self initialize"

	"stored in class vars for faster access"
	SpaceCharacter := Character space.
	TabCharacter := Character tab.
	CRCharacter := Character cr.
	LFCharacter := Character lf.! !
!XMLWriteStreamAdapter methodsFor: 'basic'!
basicNextPut: anObject 
	^ self nextPut: anObject! !
!XMLWriteStreamAdapter methodsFor: 'accessing'!
contents
	^ stream contents! !
!XMLWriteStreamAdapter methodsFor: 'character writing'!
cr
	^ self nextPut: CRCharacter! !
!XMLWriteStreamAdapter methodsFor: 'character writing'!
lf
	^ self nextPut: LFCharacter! !
!XMLWriteStreamAdapter methodsFor: 'accessing'!
nextPut: anObject
	stream nextPut: anObject.
	^ anObject.! !
!XMLWriteStreamAdapter methodsFor: 'accessing'!
nextPutAll: aCollection
	stream nextPutAll: aCollection.
	^ aCollection.! !
!XMLWriteStreamAdapter methodsFor: 'positioning'!
position
	^ stream position! !
!XMLWriteStreamAdapter methodsFor: 'positioning'!
position: anInteger
	stream position: anInteger! !
!XMLWriteStreamAdapter methodsFor: 'positioning'!
reset
	stream reset! !
!XMLWriteStreamAdapter methodsFor: 'character writing'!
space
	^ self nextPut: SpaceCharacter! !
!XMLWriteStreamAdapter methodsFor: 'character writing'!
tab
	^ self nextPut: TabCharacter! !
!XMLASCIIStreamConverter class methodsFor: 'basic'!
basicEncodingNames
	^ #('ASCII' 'US-ASCII' 'USASCII')! !
!XMLASCIIStreamConverter methodsFor: 'decoding'!
nextFromStream: aStream
	| byte |

	aStream atEnd
		ifTrue: [^ nil].
	(byte := aStream next asInteger) > 127
		ifTrue: [self errorBadCharacterValue: byte].

	^ byte asCharacter.! !
!XMLASCIIStreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	| codePoint |

	(codePoint := aCharacter asInteger) > 127
		ifTrue: [self errorBadCharacterValue: codePoint].

	aStream nextPut: codePoint.! !
!XMLLatin1StreamConverter class methodsFor: 'basic'!
basicEncodingNames
	^ #('Latin-1' 'Latin1'
			'CP-819' 'CP819'
			'IBM-819' 'IBM819'
			'ISO-8859-1' 'ISO8859-1' 'ISO-88591' 'ISO88591'
			'ISO-IR-100' 'ISOIR-100' 'ISO-IR100' 'ISOIR100'
			'L1'
			'csISOLatin1')! !
!XMLLatin1StreamConverter methodsFor: 'decoding'!
nextFromStream: aStream
	| byte |

	aStream atEnd
		ifTrue: [^ nil].
	(byte := aStream next asInteger) > 255
		ifTrue: [self errorBadCharacterValue: byte].

	^ byte asCharacter.! !
!XMLLatin1StreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	| codePoint |

	(codePoint := aCharacter asInteger) > 255
		ifTrue: [self errorBadCharacterValue: codePoint].

	aStream nextPut: codePoint.! !
!XMLNullStreamConverter methodsFor: 'testing'!
isNull
	^ true! !
!XMLNullStreamConverter methodsFor: 'decoding'!
nextFromStream: aStream
	aStream atEnd
		ifTrue: [^ nil]
		ifFalse: [^ aStream next asCharacter]! !
!XMLNullStreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	aStream nextPut: aCharacter asInteger! !
!XMLStatelessStreamConverter class methodsFor: 'defaults'!
abstractClass
	^ XMLStatelessStreamConverter! !
!XMLStatelessStreamConverter class methodsFor: 'accessing'!
instance
	^ instance ifNil: [instance := self basicNew initialize]! !
!XMLStatelessStreamConverter class methodsFor: 'instance creation'!
new
	"all subclasses are stateless and have a single, immutable, shared instance"
	^ self instance! !
!XMLImplicitUTF16BigEndianStreamConverter class methodsFor: 'testing'!
isImplicit
	^ true! !
!XMLUTF16BigEndianStreamConverter class methodsFor: 'basic'!
basicByteOrderMarkBytes
	^ #[16rFE 16rFF]! !
!XMLUTF16BigEndianStreamConverter class methodsFor: 'basic'!
basicEncodingNames
	^ #('UTF-16' 'UTF16'
			'UTF-16-BE' 'UTF16-BE' 'UTF-16BE' 'UTF16BE')! !
!XMLUTF16BigEndianStreamConverter methodsFor: 'testing'!
isBigEndian
	^ true! !
!XMLUTF16BigEndianStreamConverter methodsFor: 'basic'!
nextPutTwoBytes: anInteger toStream: aStream
	aStream
		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);
		nextPut: (anInteger bitAnd: 16rFF)! !
!XMLUTF16BigEndianStreamConverter methodsFor: 'basic'!
nextTwoBytesFromStream: aStream
	| firstByte |

	firstByte := aStream next asInteger bitShift: 8.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	^ firstByte + aStream next asInteger.! !
!XMLImplicitUTF16LittleEndianStreamConverter class methodsFor: 'testing'!
isImplicit
	^ true! !
!XMLUTF16LittleEndianStreamConverter class methodsFor: 'basic'!
basicByteOrderMarkBytes
	^ #[16rFF 16rFE]! !
!XMLUTF16LittleEndianStreamConverter class methodsFor: 'basic'!
basicEncodingNames
	^ #('UTF-16-LE' 'UTF16-LE' 'UTF-16LE' 'UTF16LE')! !
!XMLUTF16LittleEndianStreamConverter methodsFor: 'testing'!
isBigEndian
	^ false! !
!XMLUTF16LittleEndianStreamConverter methodsFor: 'basic'!
nextPutTwoBytes: anInteger toStream: aStream
	aStream
		nextPut: (anInteger bitAnd: 16rFF);
		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF)! !
!XMLUTF16LittleEndianStreamConverter methodsFor: 'basic'!
nextTwoBytesFromStream: aStream
	| firstByte |

	firstByte := aStream next asInteger.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	^ firstByte + (aStream next asInteger bitShift: 8).! !
!XMLUTF16StreamConverter class methodsFor: 'defaults'!
abstractClass
	^ XMLUTF16StreamConverter! !
!XMLUTF16StreamConverter methodsFor: 'testing'!
isBigEndian
	self subclassResponsibility! !
!XMLUTF16StreamConverter methodsFor: 'basic'!
nextCodePointFromStream: aStream
	| codePoint lowSurrogate |

	aStream atEnd
		ifTrue: [^ nil].

	"code points U+10000 to U+10FFFF are encoded with surrogate pairs,
	while those < U+10000 are encoded directly"
	((codePoint := self nextTwoBytesFromStream: aStream) < 16rD800
		or: [codePoint > 16rDFFF])
		ifTrue: [
			codePoint > 16r10FFFF
				ifTrue: [self errorBadCharacterValue: codePoint].
			^ codePoint].

	codePoint > 16rDBFF "max high surrogate"
		ifTrue: [self errorBadCharacterEncoding].

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	(lowSurrogate := self nextTwoBytesFromStream: aStream)
		ifNil: [self errorBadCharacterEncoding].
	(lowSurrogate < 16rDC00 "min low surrogate"
		or: [lowSurrogate > 16rDFFF]) "max low surrogate"
		ifTrue: [self errorBadCharacterEncoding].

	"A code point > U+10FFFF isn't checked for here because it can't
	be encoded with UTF-16. The maximum surrogate pairs can encode is:
		(16r10000 + (16r3FF bitShift: 10) + 16r3FF) = 16r10FFFF"
	^ ((codePoint bitAnd: 16r3FF) bitShift: 10) +
		(lowSurrogate bitAnd: 16r3FF) +
		16r10000.! !
!XMLUTF16StreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	| codePoint |

	(codePoint := aCharacter asInteger) < 16r10000
		ifTrue: [
			"check for the reserved surrogate pair code points"
			(codePoint >= 16rD800
				and: [codePoint <= 16rDFFF])
				ifTrue: [self errorBadCharacterValue: codePoint].
			self
				nextPutTwoBytes: codePoint
				toStream: aStream]
		ifFalse: [
			codePoint > 16r10FFFF "max code point"
				ifTrue: [self errorBadCharacterValue: codePoint].
			codePoint := codePoint - 16r10000.
			"the 10 high-order bits"
			self
				nextPutTwoBytes: 16rD800 + ((codePoint bitShift: -10) bitAnd: 16r3FF)
				toStream: aStream.
			"the 10 low-order bits"
			self
				nextPutTwoBytes: 16rDC00 + (codePoint bitAnd: 16r3FF)
				toStream: aStream]! !
!XMLUTF16StreamConverter methodsFor: 'basic'!
nextPutTwoBytes: anInteger toStream: aStream
	self subclassResponsibility! !
!XMLUTF16StreamConverter methodsFor: 'basic'!
nextTwoBytesFromStream: aStream
	self subclassResponsibility! !
!XMLImplicitUTF32BigEndianStreamConverter class methodsFor: 'testing'!
isImplicit
	^ true! !
!XMLUTF32BigEndianStreamConverter class methodsFor: 'basic'!
basicByteOrderMarkBytes
	^ #[16r00 16r00 16rFE 16rFF]! !
!XMLUTF32BigEndianStreamConverter class methodsFor: 'basic'!
basicEncodingNames
	^ #('UTF-32' 'UTF32'
			'UTF-32-BE' 'UTF32-BE' 'UTF-32BE' 'UTF32BE')! !
!XMLUTF32BigEndianStreamConverter methodsFor: 'testing'!
isBigEndian
	^ true! !
!XMLUTF32BigEndianStreamConverter methodsFor: 'basic'!
nextFourBytesFromStream: aStream
	| firstByte secondByte thirdByte |

	firstByte := aStream next asInteger bitShift: 24.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	secondByte := aStream next asInteger bitShift: 16.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	thirdByte := aStream next asInteger bitShift: 8.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	^ firstByte + secondByte + thirdByte + aStream next asInteger.! !
!XMLUTF32BigEndianStreamConverter methodsFor: 'basic'!
nextPutFourBytes: anInteger toStream: aStream
	aStream
		nextPut: ((anInteger bitShift: -24) bitAnd: 16rFF);
		nextPut: ((anInteger bitShift: -16) bitAnd: 16rFF);
		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);
		nextPut: (anInteger bitAnd: 16rFF)! !
!XMLImplicitUTF32LittleEndianStreamConverter class methodsFor: 'testing'!
isImplicit
	^ true! !
!XMLUTF32LittleEndianStreamConverter class methodsFor: 'basic'!
basicByteOrderMarkBytes
	^ #[16rFF 16rFE 16r00 16r00]! !
!XMLUTF32LittleEndianStreamConverter class methodsFor: 'basic'!
basicEncodingNames
	^ #('UTF-32-LE' 'UTF32-LE' 'UTF-32LE' 'UTF32LE')! !
!XMLUTF32LittleEndianStreamConverter methodsFor: 'testing'!
isBigEndian
	^ false! !
!XMLUTF32LittleEndianStreamConverter methodsFor: 'basic'!
nextFourBytesFromStream: aStream
	| firstByte secondByte thirdByte |

	firstByte := aStream next asInteger.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	secondByte := aStream next asInteger bitShift: 8.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	thirdByte := aStream next asInteger bitShift: 16.

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	^ firstByte + secondByte + thirdByte + (aStream next asInteger bitShift: 24).! !
!XMLUTF32LittleEndianStreamConverter methodsFor: 'basic'!
nextPutFourBytes: anInteger toStream: aStream
	aStream
		nextPut: (anInteger bitAnd: 16rFF);
		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);
		nextPut: ((anInteger bitShift: -16) bitAnd: 16rFF);
		nextPut: ((anInteger bitShift: -24) bitAnd: 16rFF)! !
!XMLUTF32StreamConverter class methodsFor: 'defaults'!
abstractClass
	^ XMLUTF32StreamConverter! !
!XMLUTF32StreamConverter methodsFor: 'testing'!
isBigEndian
	self subclassResponsibility! !
!XMLUTF32StreamConverter methodsFor: 'basic'!
nextCodePointFromStream: aStream
	| codePoint |

	aStream atEnd
		ifTrue: [^ nil].

	"check for the reserved surrogate pair code points and code points
	greater than the max code point"
	(codePoint := self nextFourBytesFromStream: aStream) >= 16rD800
		ifTrue: [
			(codePoint <= 16rDFFF
				or: [codePoint > 16r10FFFF])
				ifTrue: [self errorBadCharacterValue: codePoint]].

	^ codePoint.! !
!XMLUTF32StreamConverter methodsFor: 'basic'!
nextFourBytesFromStream: aStream
	self subclassResponsibility! !
!XMLUTF32StreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	| codePoint |

	codePoint := aCharacter asInteger.
	"check for the reserved surrogate pair code points and code points
	greater than the max code point"
	(codePoint >= 16rD800
		and: [codePoint <= 16rDFFF
			or: [codePoint > 16r10FFFF]])
		ifTrue: [self errorBadCharacterValue: codePoint].
	self
		nextPutFourBytes: codePoint
		toStream: aStream.! !
!XMLUTF32StreamConverter methodsFor: 'basic'!
nextPutFourBytes: anInteger toStream: aStream
	self subclassResponsibility! !
!XMLImplicitUTF8StreamConverter class methodsFor: 'testing'!
isImplicit
	^ true! !
!XMLUTF8StreamConverter class methodsFor: 'basic'!
basicByteOrderMarkBytes
	^ #[16rEF 16rBB 16rBF]! !
!XMLUTF8StreamConverter class methodsFor: 'basic'!
basicEncodingNames
	^ #('UTF-8' 'UTF8')! !
!XMLUTF8StreamConverter methodsFor: 'private'!
errorOverlongCodePoint: aCodePoint
	XMLEncodingException
		formatSignal: 'Illegal overlong UTF-8 encoding for U+{1} code point'
		with: aCodePoint printStringHex! !
!XMLUTF8StreamConverter methodsFor: 'basic'!
nextCodePointFromStream: aStream
	self shouldNotImplement! !
!XMLUTF8StreamConverter methodsFor: 'decoding'!
nextFromStream: aStream
	"an attempt was made at porting Bjoern Hoehrmann's DFA-based decoder
	(with transitions pre-multiplied by 16), but it was slightly slower
	than this implementation and needed significant modification to report
	errors the same way, so it was scrapped"

	| firstByte codePoint |

	aStream atEnd
		ifTrue: [^ nil].
	(firstByte := aStream next asInteger) < 16r80 "single byte character"
		ifTrue: [^ firstByte asCharacter].

	codePoint :=
		self
			nextMultiByteCodePointStartingWith: firstByte
			fromStream: aStream.
	[codePoint == 16rFEFF] "the BOM code point"
		whileTrue: [
			aStream atEnd
				ifTrue: [^ nil].
			(firstByte := aStream next asInteger) < 16r80 "single byte character"
				ifTrue: [^ firstByte asCharacter].
			codePoint :=
				self
					nextMultiByteCodePointStartingWith: firstByte
					fromStream: aStream].

	^ codePoint asCharacter.! !
!XMLUTF8StreamConverter methodsFor: 'basic'!
nextMultiByteCodePointStartingWith: aFirstByte fromStream: aStream
	| secondByte thirdByte codePoint |

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	secondByte := aStream next asInteger.
	(secondByte bitAnd: 16rC0) == 16r80
		ifFalse: [self errorBadCharacterEncoding].
	(aFirstByte bitAnd: 16rE0) == 16rC0 "two bytes"
		ifTrue: [
			codePoint :=
				((aFirstByte bitAnd: 16r1F) bitShift: 6) +
				(secondByte bitAnd: 16r3F).
			codePoint >= 16r80
				ifFalse: [self errorOverlongCodePoint: codePoint].
			^ codePoint].

	aStream atEnd
		ifTrue: [self errorBadCharacterEncoding].
	thirdByte := aStream next asInteger.
	(thirdByte bitAnd: 16rC0) == 16r80
		ifFalse: [self errorBadCharacterEncoding].
	(aFirstByte bitAnd: 16rF0) == 16rE0 "three bytes"
		ifTrue: [
			codePoint :=
				((aFirstByte bitAnd: 16r0F) bitShift: 12) +
				((secondByte bitAnd: 16r3F) bitShift: 6) +
				(thirdByte bitAnd: 16r3F).
			"check for the reserved surrogate pair code points"
			codePoint >= 16rD800
				ifTrue: [
					codePoint <= 16rDFFF
						ifTrue: [self errorBadCharacterValue: codePoint]]
				ifFalse: [
					codePoint >= 16r800
						ifFalse: [self errorOverlongCodePoint: codePoint]].
			^ codePoint].

	(aFirstByte bitAnd: 16rF8) == 16rF0
		ifTrue: [| fourthByte |
			aStream atEnd
				ifTrue: [self errorBadCharacterEncoding].
			fourthByte := aStream next asInteger.
			(fourthByte bitAnd: 16rC0) == 16r80
				ifFalse: [self errorBadCharacterEncoding].
			codePoint :=
				((aFirstByte bitAnd: 16r07) bitShift: 18) +
				((secondByte bitAnd: 16r3F) bitShift: 12) +
				((thirdByte bitAnd: 16r3F) bitShift: 6) +
				(fourthByte bitAnd: 16r3F).
			codePoint > 16r10FFFF "max code point"
				ifTrue: [self errorBadCharacterValue: codePoint].
			codePoint >= 16r10000
				ifFalse: [self errorOverlongCodePoint: codePoint].
			^ codePoint].

	"the first byte is malformed"
	self errorBadCharacterEncoding.! !
!XMLUTF8StreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	| codePoint |

	(codePoint := aCharacter asInteger) < 16r80
		ifTrue: [
			aStream nextPut: codePoint.
			^ self].

	codePoint < 16r800
		ifTrue: [
			aStream
				nextPut: 16rC0 + (codePoint bitShift: -6);
				nextPut: 16r80 + (codePoint bitAnd: 16r003F).
			^ self].

	codePoint < 16r10000
		ifTrue: [
			"check for the reserved surrogate pair code points"
			(codePoint >= 16rD800
				and: [codePoint <= 16rDFFF])
				ifTrue: [self errorBadCharacterValue: codePoint].
			aStream
				nextPut: 16rE0 + (codePoint bitShift: -12);
				nextPut: 16r80 + ((codePoint bitShift: -6) bitAnd: 16r3F);
				nextPut: 16r80 + (codePoint bitAnd: 16r3F).
			^ self].

	codePoint <= 16r10FFFF  "max code point"
		ifTrue: [
			aStream
				nextPut: 16rF0 + (codePoint bitShift: -18);
				nextPut: 16r80 + ((codePoint bitShift: -12) bitAnd: 16r3F);
				nextPut: 16r80 + ((codePoint bitShift: -6) bitAnd: 16r3F);
				nextPut: 16r80 + (codePoint bitAnd: 16r3F).
			^ self].

	self errorBadCharacterValue: codePoint.! !
!XMLUTFStreamConverter class methodsFor: 'defaults'!
abstractClass
	^ XMLUTFStreamConverter! !
!XMLUTFStreamConverter methodsFor: 'private'!
errorBadCharacterValue: aValue
	XMLEncodingException
		formatSignal: 'Invalid {1} code point U+{1}'
		with: self encoding
		with: aValue printStringHex! !
!XMLUTFStreamConverter methodsFor: 'basic'!
nextCodePointFromStream: aStream
	self subclassResponsibility! !
!XMLUTFStreamConverter methodsFor: 'decoding'!
nextFromStream: aStream
	| codePoint |

	codePoint := self nextCodePointFromStream: aStream.
	[codePoint == 16rFEFF] "the BOM code point"
		whileTrue: [
			aStream atEnd
				ifTrue: [^ nil].
			codePoint := self nextCodePointFromStream: aStream].
	^ codePoint
		ifNotNil: [codePoint asCharacter].! !
!XMLStreamConverter class methodsFor: 'defaults'!
abstractClass
	^ XMLStreamConverter! !
!XMLStreamConverter class methodsFor: 'basic'!
basicByteOrderMarkBytes
	^ #[]! !
!XMLStreamConverter class methodsFor: 'basic'!
basicCanConvertEncoding: anEncodingName
	^ self encodingNames includes: anEncodingName! !
!XMLStreamConverter class methodsFor: 'basic'!
basicEncodingNames
	"encodingNames will have these names + upper/lowercase versions"
	^ #()! !
!XMLStreamConverter class methodsFor: 'accessing'!
byteOrderMark
	"avoid #asString and #newFrom: for GS portability"
	^ String streamContents: [:stream |
		self byteOrderMarkBytes do: [:each |
			stream nextPut: each asCharacter]]! !
!XMLStreamConverter class methodsFor: 'accessing'!
byteOrderMarkBytes
	^ self basicByteOrderMarkBytes asByteArray! !
!XMLStreamConverter class methodsFor: 'testing'!
canConvertEncoding: anEncodingName
	"Returns true if the receiver can decode the encoding anEncodingName.
	Lookup is case-insensitive."

	"we could remove whitespace from anEncodingName too, but the
	production rule for <?xml ...?> 'encoding' attributes disallows
	whitespace, and the HTML parser removes it from <meta> charset
	attributes before converting, so we just convert it to lowercase"
	^ self isAbstractClass not
		and: [self basicCanConvertEncoding: anEncodingName asLowercase]! !
!XMLStreamConverter class methodsFor: 'accessing'!
classForEncoding: anEncodingName
	"avoid #at:ifAbsent: and #at:ifAbsentPut: so the cache isn't locked
	during the class lookup, which could stall other processes"
	self encodingNamesAndClassesCache
		at: anEncodingName
		ifPresent: [:classForEncoding | ^ classForEncoding].

	"this will store the class as nil if it wasn't found to prevent future lookup"
	^ self encodingNamesAndClassesCache
		at: anEncodingName
		put: (self findClassForEncoding: anEncodingName).! !
!XMLStreamConverter class methodsFor: 'convenience'!
decode: aStringOrByteArray
	^ self new decode: aStringOrByteArray! !
!XMLStreamConverter class methodsFor: 'convenience'!
decodingOn: aReadStream
	^ self new decodingOn: aReadStream! !
!XMLStreamConverter class methodsFor: 'instance creation'!
default
	^ self defaultClass new! !
!XMLStreamConverter class methodsFor: 'defaults'!
defaultClass
	^ XMLImplicitUTF8StreamConverter! !
!XMLStreamConverter class methodsFor: 'defaults'!
defaultEncoding
	^ self defaultClass primaryEncodingName! !
!XMLStreamConverter class methodsFor: 'convenience'!
encode: aString
	^ self new encode: aString! !
!XMLStreamConverter class methodsFor: 'accessing'!
encodingNames
	^ encodingNames
		ifNil: [
			"assign the fully initialized object with #yourself to avoid
			possible race conditions when reinitialization the class"
			encodingNames :=
				Set new
					addAll: self basicEncodingNames;
					addAll:
						(self basicEncodingNames collect: [:each | each asLowercase]);
					addAll:
						(self basicEncodingNames collect: [:each | each asUppercase]);
					yourself]! !
!XMLStreamConverter class methodsFor: 'accessing'!
encodingNames: aCollectionOrNil
	encodingNames :=
		aCollectionOrNil
			ifNotNil: [aCollectionOrNil asSet]! !
!XMLStreamConverter class methodsFor: 'private'!
encodingNamesAndClassesCache
	"a class variable so it's shared by all subclasses, but lazy initialized
	so it isn't initialized unless needed"
	^ EncodingNamesAndClassesCache
		ifNil: [EncodingNamesAndClassesCache := XMLKeyValueCache maxSize: 128]! !
!XMLStreamConverter class methodsFor: 'convenience'!
encodingOn: aReadStream
	^ self new encodingOn: aReadStream! !
!XMLStreamConverter class methodsFor: 'private'!
findClassForEncoding: anEncodingName
	"check preferred classes first"
	self preferredClasses do: [:each |
		(each canConvertEncoding: anEncodingName)
			ifTrue: [^ each]].

	"avoid #withAllSubclassesDo: because it does not enumerate the receiver first"
	(self isNonPreferredClassForEncoding: anEncodingName)
		ifTrue: [^ self].
	self allSubclassesDo: [:each |
		(each isNonPreferredClassForEncoding: anEncodingName)
			ifTrue: [^ each]].

	^ nil.! !
!XMLStreamConverter class methodsFor: 'class initialization'!
initialize
	"self initialize"

	PreferredClasses := nil.
	"reset to nil instead of just clearing to get full reinitialization"
	EncodingNamesAndClassesCache := nil.! !
!XMLStreamConverter class methodsFor: 'testing'!
isAbstractClass
	^ self == self abstractClass! !
!XMLStreamConverter class methodsFor: 'testing'!
isDefaultClass
	^ self == self defaultClass! !
!XMLStreamConverter class methodsFor: 'testing'!
isImplicit
	^ false! !
!XMLStreamConverter class methodsFor: 'testing'!
isNonPreferredClassForEncoding: anEncoding
	^ self isPreferredClass not
		and: [self canConvertEncoding: anEncoding]! !
!XMLStreamConverter class methodsFor: 'testing'!
isPreferredClass
	^ self preferredClasses includes: self! !
!XMLStreamConverter class methodsFor: 'instance creation'!
newForEncoding: anEncodingName
	(self classForEncoding: anEncodingName)
		ifNil: [^ self null]
		ifNotNil: [:converterClass |
			^ converterClass new initializeForEncoding: anEncodingName]! !
!XMLStreamConverter class methodsFor: 'instance creation'!
null
	^ self nullClass new! !
!XMLStreamConverter class methodsFor: 'defaults'!
nullClass
	^ XMLNullStreamConverter! !
!XMLStreamConverter class methodsFor: 'accessing'!
preferredClasses
	"A class var because it should be shared by all subclasses.
	Assign the fully initialized object with #yourself to avoid
	possible race conditions when reinitialization the class."
	^ PreferredClasses
		ifNil: [
			PreferredClasses :=
				IdentitySet new
					addAll:
						(XMLUTFStreamConverter allSubclasses reject: [:each |
							each isAbstractClass
								or: [each isImplicit]]);
					add: XMLLatin1StreamConverter;
					add: XMLASCIIStreamConverter;
					yourself]! !
!XMLStreamConverter class methodsFor: 'accessing'!
preferredClasses: aCollectionOrNil
	PreferredClasses :=
		aCollectionOrNil
			ifNotNil: [aCollectionOrNil asSet]! !
!XMLStreamConverter class methodsFor: 'accessing'!
primaryEncodingName
	^ self basicEncodingNames
		at: 1
		ifAbsent: ['']! !
!XMLStreamConverter methodsFor: 'converting'!
asXMLStreamConverter
	^ self! !
!XMLStreamConverter methodsFor: 'convenience'!
decode: aStringOrByteArray
	^ (XMLDecodingReadStreamAdapter
		on: aStringOrByteArray readStream
		streamConverter: self)
			contents! !
!XMLStreamConverter methodsFor: 'convenience'!
decodingOn: aReadStream
	^ XMLDecodingReadStreamAdapter
		on: aReadStream
		streamConverter: self! !
!XMLStreamConverter methodsFor: 'convenience'!
encode: aString
	^ (self encodingOn: (ByteArray new: aString size) writeStream)
		nextPutAll: aString;
		contents! !
!XMLStreamConverter methodsFor: 'accessing'!
encoding
	^ self class primaryEncodingName! !
!XMLStreamConverter methodsFor: 'convenience'!
encodingOn: aWriteStream
	^ (XMLEncodingWriteStreamAdapter
		on: aWriteStream
		streamConverter: self)
			nextPutByteOrderMark;
			yourself! !
!XMLStreamConverter methodsFor: 'private'!
errorBadCharacterEncoding
	XMLEncodingException
		formatSignal: 'Invalid {1} encoding for character'
		with: self encoding! !
!XMLStreamConverter methodsFor: 'private'!
errorBadCharacterValue: aValue
	XMLEncodingException
		formatSignal: 'Invalid character 0x{1} for {2} encoding'
		with: aValue printStringHex
		with: self encoding! !
!XMLStreamConverter methodsFor: 'initialization'!
initializeForEncoding: anEncodingName! !
!XMLStreamConverter methodsFor: 'testing'!
isDefault
	^ self class isDefaultClass! !
!XMLStreamConverter methodsFor: 'testing'!
isImplicit
	^ self class isImplicit! !
!XMLStreamConverter methodsFor: 'testing'!
isNull
	^ false! !
!XMLStreamConverter methodsFor: 'decoding'!
nextFromStream: aStream
	self subclassResponsibility! !
!XMLStreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	self subclassResponsibility! !
!XMLStreamConverter methodsFor: 'encoding'!
nextPutByteOrderMarkToStream: aStream
	self class byteOrderMarkBytes do: [:each |
		aStream nextPut: each]! !
!XMLStreamConverter methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.

	aStream
		nextPut: $(;
		nextPutAll: self encoding;
		nextPut: $).! !
!XMLStreamConverter methodsFor: 'printing'!
printWithConvertableStream: aConvertableStream on: aPrintStream
	aPrintStream
		print: self;
		nextPut: $(;
		print: aConvertableStream;
		nextPut: $)! !
!XMLZincByteEncoderStreamConverter class methodsFor: 'basic'!
basicCanConvertEncoding: anEncodingName
	^ XMLClassFinder
		classNamed: #ZnByteEncoder
		ifPresent: [:zincByteEncoderClass |
			zincByteEncoderClass handlesEncoding: anEncodingName]
		ifAbsent: [false]! !
!XMLZincByteEncoderStreamConverter class methodsFor: 'class initialization'!
initialize
	"self initialize"

	NullReadStream := XMLNullReadStream new! !
!XMLZincByteEncoderStreamConverter methodsFor: 'initialization'!
initializeForEncoding: anEncodingName
	zincByteEncoder :=
		(XMLClassFinder classNamed: #ZnByteEncoder) newForEncoding: anEncodingName.

	"we use an XMLStringReadStreamAdapter to transparently handle non-binary
	character streams for ZnByteEncoder, which exepcts binary streams, and
	since it's only ever set to a non-null stream during #nextFromStream:,
	instances can still be shared by multiple streams, just not re-entrently,
	which is OK since this class is explicitly stateful and so not
	automatically thread-safe."
	stringReadStreamAdapter :=
		XMLStringReadStreamAdapter on: NullReadStream.! !
!XMLZincByteEncoderStreamConverter methodsFor: 'decoding'!
nextFromStream: aStream
	"ZnByteEncoder does not check for #atEnd before sending #next"
	aStream atEnd
		ifTrue: [^ nil]
		ifFalse: [| nextChar |
			nextChar :=
				zincByteEncoder nextFromStream:
					(stringReadStreamAdapter on: aStream).
			stringReadStreamAdapter on: NullReadStream.
			^ nextChar]! !
!XMLZincByteEncoderStreamConverter methodsFor: 'encoding'!
nextPut: aCharacter toStream: aStream
	zincByteEncoder
		nextPut: aCharacter
		toStream: aStream! !
!XMLContentState methodsFor: 'testing'!
isContentState
	^ true! !
!XMLContentState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextContentToken! !
!XMLExternalSubsetState methodsFor: 'testing'!
isExternalSubsetState
	^ true! !
!XMLExternalSubsetState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextExternalSubsetToken! !
!XMLExternalSubsetTextDeclarationState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextStartExternalSubset! !
!XMLExternalSubsetTextDeclarationState methodsFor: 'testing'!
supportsEncodingDetection
	^ true! !
!XMLDoctypeDeclarationState methodsFor: 'testing'!
isDoctypeDeclarationState
	^ true! !
!XMLInternalSubsetState methodsFor: 'testing'!
isInternalSubsetState
	^ true! !
!XMLInternalSubsetState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextInternalSubsetToken! !
!XMLPostDoctypeDeclarationState methodsFor: 'testing'!
isPostDoctypeDeclarationState
	^ true! !
!XMLPrologState methodsFor: 'testing'!
canTerminateInput
	^ false! !
!XMLPrologState methodsFor: 'testing'!
isPrologState
	^ true! !
!XMLPrologState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextPrologToken! !
!XMLXMLDeclarationState methodsFor: 'testing'!
isXMLDeclarationState
	^ true! !
!XMLXMLDeclarationState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextXMLDeclarationOrPrologToken! !
!XMLXMLDeclarationState methodsFor: 'testing'!
supportsEncodingDetection
	^ true! !
!XMLTerminatedState methodsFor: 'testing'!
isTerminatedState
	^ true! !
!XMLTerminatedState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextEndDocument! !
!XMLTokenizerState class methodsFor: 'accessing'!
instance
	^ instance
		ifNil: [instance := self basicNew initialize]! !
!XMLTokenizerState class methodsFor: 'instance creation'!
new
	"all subclasses are stateless and have a single, immutable, shared instance"
	^ self instance! !
!XMLTokenizerState methodsFor: 'testing'!
canTerminateInput
	^ true! !
!XMLTokenizerState methodsFor: 'changing'!
contentState
	^ XMLContentState new! !
!XMLTokenizerState methodsFor: 'changing'!
doctypeDeclarationState
	^ XMLDoctypeDeclarationState new! !
!XMLTokenizerState methodsFor: 'changing'!
externalSubsetState
	^ XMLExternalSubsetState new! !
!XMLTokenizerState methodsFor: 'changing'!
internalSubsetState
	^ XMLInternalSubsetState new! !
!XMLTokenizerState methodsFor: 'testing'!
isContentState
	^ false! !
!XMLTokenizerState methodsFor: 'testing'!
isDoctypeDeclarationState
	^ false! !
!XMLTokenizerState methodsFor: 'testing'!
isExternalSubsetState
	^ false! !
!XMLTokenizerState methodsFor: 'testing'!
isInitializedState
	^ true! !
!XMLTokenizerState methodsFor: 'testing'!
isInternalSubsetState
	^ false! !
!XMLTokenizerState methodsFor: 'testing'!
isPostDoctypeDeclarationState
	^ false! !
!XMLTokenizerState methodsFor: 'testing'!
isPrologState
	^ false! !
!XMLTokenizerState methodsFor: 'testing'!
isTerminatedState
	^ false! !
!XMLTokenizerState methodsFor: 'testing'!
isXMLDeclarationState
	^ false! !
!XMLTokenizerState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	self subclassResponsibility! !
!XMLTokenizerState methodsFor: 'changing'!
postDoctypeDeclarationState
	^ XMLPostDoctypeDeclarationState new! !
!XMLTokenizerState methodsFor: 'changing'!
prologState
	^ XMLPrologState new! !
!XMLTokenizerState methodsFor: 'testing'!
supportsEncodingDetection
	^ false! !
!XMLTokenizerState methodsFor: 'changing'!
terminatedState
	^ XMLTerminatedState new! !
!XMLUninitializedState methodsFor: 'testing'!
isInitializedState
	^ false! !
!XMLUninitializedState methodsFor: 'tokenizing'!
nextTokenFrom: aTokenizer
	^ aTokenizer nextStartDocument! !
!XMLURI class methodsFor: 'instance creation'!
fromStream: aStream
	"streams must be parsed eagerly (because the stream might be read from
	or closed after), unlike strings"
	^ self basicNew initialize parseURIStream: aStream! !
!XMLURI class methodsFor: 'instance creation'!
fromString: aString
	^ self basicNew initialize uriString: aString! !
!XMLURI class methodsFor: 'class initialization'!
initialize
	"self initialize"

	"Assign the fully initialized object with #yourself to avoid
	possible race conditions when reinitialization the class."
	UnreservedCharacters :=
		BitmapCharacterSet new
			addRangeFrom: $a to: $z;
			addRangeFrom: $A to: $Z;
			addRangeFrom: $0 to: $9;
			addAll: '-._~';
			yourself! !
!XMLURI class methodsFor: 'instance creation'!
new
	^ self fromString: ''! !
!XMLURI class methodsFor: 'instance creation'!
readFrom: aStringOrStream
	aStringOrStream isStream
		ifTrue: [^ self fromStream: aStringOrStream]
		ifFalse: [^ self fromString: aStringOrStream]! !
!XMLURI methodsFor: 'combining'!
/ aURIOrURIString
	"Returns the argument URI if it is absolute or the argument resolved in the
	context of the receiver if it is relative, to do relative path resolution
	or replace hosts, query strings, and other components."

	^ self combinedWith: aURIOrURIString! !
!XMLURI methodsFor: 'comparing'!
= anObject
	self == anObject
		ifTrue: [^ true].

	self species == anObject species
		ifFalse: [^ false].

	self scheme = anObject scheme
		ifFalse: [^ false].

	"#has* tests are used as an optimization to skip direclty comparing
	components unless needed when doing so would require additional
	decoding of the raw components"
	self hasUserInfo
		ifTrue: [
			(anObject hasUserInfo
				and: [self userInfo = anObject userInfo])
				ifFalse: [^ false]]
		ifFalse: [
			anObject hasUserInfo
				ifTrue: [^ false]].

	self hasHost
		ifTrue: [
			(anObject hasHost
				and: [self host = anObject host])
				ifFalse: [^ false]]
		ifFalse: [
			anObject hasHost
				ifTrue: [^ false]].

	self port = anObject port
		ifFalse: [^ false].

	self hasPath
		ifTrue: [
			(anObject hasPath
				and: [self pathSegments = anObject pathSegments])
				ifFalse: [^ false]]
		ifFalse: [
			anObject hasPath
				ifTrue: [^ false]].

	self hasQuery
		ifTrue: [
			(anObject hasQuery
				and: [self query = anObject query])
				ifFalse: [^ false]]
		ifFalse: [
			anObject hasQuery
				ifTrue: [^ false]].

	self hasFragment
		ifTrue: [
			(anObject hasFragment
				and: [self fragment = anObject fragment])
				ifFalse: [^ false]]
		ifFalse: [
			anObject hasFragment
				ifTrue: [^ false]].

	^ true.! !
!XMLURI methodsFor: 'private'!
addRawDotPathSegment
	self hasNonDirectoryPath
		ifTrue: [self haveDirectoryPath]! !
!XMLURI methodsFor: 'private'!
addRawDoubleDotPathSegment
	self hasPath
		ifFalse: [^ self].

	self hasRootPath
		ifTrue: [self removeRawPathSegments]
		ifFalse: [| hadAbsolutePath |
			hadAbsolutePath := self hasAbsolutePath.
			self hasDirectoryPath
				ifTrue: [self removeLastRawPathSegment].
			self hasPath
				ifTrue: [
					self removeLastRawPathSegment.
					(self hasPath
						or: [hadAbsolutePath])
						ifTrue: [self haveDirectoryPath]]].! !
!XMLURI methodsFor: 'private'!
addRawPathSegment: aString
	aString = '.'
		ifTrue: [^ self addRawDotPathSegment].
	aString = '..'
		ifTrue: [^ self addRawDoubleDotPathSegment].

	self hasPath
		ifTrue: [
			(self hasDirectoryPath
				and: [self rawPathSegments size > 1])
				ifTrue: [self removeLastRawPathSegment]]
		ifFalse: [
			self hasHost
				ifTrue: [self rawPathSegments addLast: '']].

	self rawPathSegments addLast: aString.! !
!XMLURI methodsFor: 'private'!
addRawPathSegmentsFrom: aURI
	"copy before modifying"
	self rawPathSegments: self rawPathSegments copy.

	aURI hasAbsolutePath
		ifTrue: [self removeRawPathSegments]
		ifFalse: [
			self hasNonDirectoryPath
				ifTrue: [
					self removeLastRawPathSegment.
					self hasPath
						ifTrue: [self haveDirectoryPath]]].

	aURI rawPathSegments do: [:each | self addRawPathSegment: each].! !
!XMLURI methodsFor: 'converting'!
asRetrievableResource
	^ self isLocal
		ifTrue: [self asXMLFileHandle]
		ifFalse: [self asXMLHTTPRequest]! !
!XMLURI methodsFor: 'converting'!
asString
	"Returns the full, untruncated URI string, unlike #printString, which
	may truncate"

	^ self uriString
		ifNil: [| writeStream |
			writeStream := (String new: 64) writeStream.
			self
				printSchemeOn: writeStream;
				printAuthorityPrefixOn: writeStream;
				printAuthorityOn: writeStream;
				printPathPrefixOn: writeStream;
				printPathOn: writeStream;
				printQueryOn: writeStream;
				printFragmentOn: writeStream;
				uriString: writeStream contents;
				uriString]! !
!XMLURI methodsFor: 'converting'!
asXMLFileHandle
	self isLocal
		ifFalse: [self errorCannotConvertURIToFileHandle].
	^ self path asXMLFileHandle.! !
!XMLURI methodsFor: 'converting'!
asXMLHTTPRequest
	(self isHTTP
		or: [self isHTTPS
			or: [self isRelative]])
		ifFalse: [self errorCannotConvertURIToHTTPRequest].
	^ self asString asXMLHTTPRequest.! !
!XMLURI methodsFor: 'converting'!
asXMLURI
	^ self! !
!XMLURI methodsFor: 'combining'!
combinedWith: aURIOrURIString
	"Returns the argument URI if it is absolute or the argument resolved in the
	context of the receiver if it is relative, to do relative path resolution
	or replace hosts, query strings, and other components."

	| uriToCombineWith |

	(uriToCombineWith := aURIOrURIString asXMLURI) isEmpty
		ifFalse: [
			(uriToCombineWith isRelative)
				ifTrue: [^ self combinedWithRelativeURI: uriToCombineWith]
				ifFalse: [^ uriToCombineWith]]! !
!XMLURI methodsFor: 'private'!
combinedWithRelativeURI: aRelativeURI
	| copy |

	copy := self copy.
	aRelativeURI hasUserInfo
		ifTrue: [
			^ copy
				rawUserInfo: aRelativeURI rawUserInfo;
				rawHost: aRelativeURI rawHost;
				port: aRelativeURI port;
				rawPathSegments: aRelativeURI rawPathSegments;
				rawQuery: aRelativeURI rawQuery;
				rawFragment: aRelativeURI rawFragment].
	aRelativeURI hasHost
		ifTrue: [
			^ copy
				rawHost: aRelativeURI rawHost;
				port: aRelativeURI port;
				rawPathSegments: aRelativeURI rawPathSegments;
				rawQuery: aRelativeURI rawQuery;
				rawFragment: aRelativeURI rawFragment].
	aRelativeURI hasPort
		ifTrue: [
			^ copy
				port: aRelativeURI port;
				rawPathSegments: aRelativeURI rawPathSegments;
				rawQuery: aRelativeURI rawQuery;
				rawFragment: aRelativeURI rawFragment].
	aRelativeURI hasPath
		ifTrue: [
			^ copy
				addRawPathSegmentsFrom: aRelativeURI;
				rawQuery: aRelativeURI rawQuery;
				rawFragment: aRelativeURI rawFragment].
	aRelativeURI hasQuery
		ifTrue: [
			^ copy
				rawQuery: aRelativeURI rawQuery;
				rawFragment: aRelativeURI rawFragment].
	aRelativeURI hasFragment
		ifTrue: [^ copy rawFragment: aRelativeURI rawFragment].! !
!XMLURI methodsFor: 'copying'!
copyWithFragment: aString
	^ self copy rawFragment: (self percentEncode: aString)! !
!XMLURI methodsFor: 'copying'!
copyWithHost: aString
	| copy |

	copy := self copy.
	(aString size > 0
		and: [aString first == $[
			and: [aString last == $]]])
		ifTrue: [copy rawHost: aString]
		ifFalse: [copy rawHost: (self percentEncode: aString)].
	^ copy.! !
!XMLURI methodsFor: 'copying'!
copyWithPath: aString
	| newRawPathSegments |

	newRawPathSegments := self rawPathSegments copyEmpty.
	$/
		xmlSplit: aString
		do: [:each |
			newRawPathSegments addLast: (self percentEncode: each)].
	^ self copy rawPathSegments: newRawPathSegments.! !
!XMLURI methodsFor: 'copying'!
copyWithPathSegments: aCollection
	| newRawPathSegments |

	newRawPathSegments := self rawPathSegments copyEmpty.
	aCollection do: [:each |
		newRawPathSegments addLast: (self percentEncode: each)].
	^ self copy rawPathSegments: newRawPathSegments.! !
!XMLURI methodsFor: 'copying'!
copyWithPort: anInteger
	^ self copy port: anInteger! !
!XMLURI methodsFor: 'copying'!
copyWithQuery: anAssociationCollection
	| newRawQuery |

	newRawQuery := OrderedCollection new: anAssociationCollection size.
	anAssociationCollection associationsDo: [:each |
		newRawQuery addLast:
			(self percentAndPlusEncode: each key) ->
				(self percentAndPlusEncode: each value)].
	^ self copy rawQuery: newRawQuery.! !
!XMLURI methodsFor: 'copying'!
copyWithScheme: aString
	^ self copy
		scheme: aString;
		hasAuthorityPrefix:
			(self hasAuthorityPrefix
				or: [self hasScheme not])! !
!XMLURI methodsFor: 'copying'!
copyWithUserInfo: aString
	^ self copy rawUserInfo: (self percentEncode: aString)! !
!XMLURI methodsFor: 'private'!
errorCannotConvertURIToFileHandle
	XMLFileException
		formatSignal: 'Cannot convert non-local URI to file handle: {1}'
		with: self asString! !
!XMLURI methodsFor: 'private'!
errorCannotConvertURIToHTTPRequest
	XMLHTTPException
		formatSignal: 'Cannot convert URI to HTTP request: {1}'
		with: self asString! !
!XMLURI methodsFor: 'accessing'!
fragment
	"Returns the percent-decoded URI fragment (everything after the '#') or
	an empty string if there isn't one"

	^ self percentDecode: self rawFragment! !
!XMLURI methodsFor: 'resolving'!
get
	^ self asRetrievableResource get! !
!XMLURI methodsFor: 'resolving'!
getUpToLimit: aMaxSize decoding: aBoolean
	^ self asRetrievableResource
		getUpToLimit: aMaxSize
		decoding: aBoolean! !
!XMLURI methodsFor: 'testing'!
hasAbsolutePath
	^ self hasPath
		and: [self rawPathSegments first isEmpty]! !
!XMLURI methodsFor: 'testing'!
hasAuthority
	^ self hasUserInfo
		or: [self hasHost
			or: [self hasPort]]! !
!XMLURI methodsFor: 'testing'!
hasAuthorityPrefix
	self parseURIStringIfUnparsed.
	^ hasAuthorityPrefix.! !
!XMLURI methodsFor: 'private'!
hasAuthorityPrefix: aBoolean
	hasAuthorityPrefix := aBoolean! !
!XMLURI methodsFor: 'testing'!
hasDirectoryPath
	^ self hasPath
		and: [self rawPathSegments last isEmpty]! !
!XMLURI methodsFor: 'testing'!
hasFragment
	^ self rawFragment notEmpty! !
!XMLURI methodsFor: 'testing'!
hasHost
	^ self rawHost notEmpty! !
!XMLURI methodsFor: 'testing'!
hasIPv6Host
	^ self hasHost
		and: [self rawHost first == $[
			and: [self rawHost last == $]]]! !
!XMLURI methodsFor: 'testing'!
hasNonDirectoryPath
	^ self hasPath
		and: [self hasDirectoryPath not]! !
!XMLURI methodsFor: 'testing'!
hasPath
	^ self rawPathSegments notEmpty! !
!XMLURI methodsFor: 'testing'!
hasPort
	^ self port notNil! !
!XMLURI methodsFor: 'testing'!
hasQuery
	^ self rawQuery notEmpty! !
!XMLURI methodsFor: 'testing'!
hasRootPath
	^ self rawPathSegments size = 2
		and: [self rawPathSegments allSatisfy: [:each | each isEmpty]]! !
!XMLURI methodsFor: 'testing'!
hasScheme
	^ self scheme notEmpty! !
!XMLURI methodsFor: 'testing'!
hasUserInfo
	^ self rawUserInfo notEmpty! !
!XMLURI methodsFor: 'comparing'!
hash
	"ignores user-info and ports"
	^ ((((self species hash bitXor:
		self scheme hash) bitXor:
			self host hash) bitXor:
				self pathSegments hash) bitXor:
					self query hash) bitXor:
						self fragment hash! !
!XMLURI methodsFor: 'private'!
haveDirectoryPath
	self hasPath
		ifFalse: [self rawPathSegments addLast: ''].
	self rawPathSegments addLast: ''.! !
!XMLURI methodsFor: 'accessing'!
host
	"Returns the percent-decoded host or IPv6-style host or an empty string
	if there isn't one"

	self hasIPv6Host
		ifTrue: [^ self rawHost]
		ifFalse: [^ (self percentDecode: self rawHost) asLowercase]! !
!XMLURI methodsFor: 'testing'!
isEmpty
	self hasScheme
		ifTrue: [^ false].
	self hasAuthority
		ifTrue: [^ false].
	self hasPath
		ifTrue: [^ false].
	self hasQuery
		ifTrue: [^ false].
	self hasFragment
		ifTrue: [^ false].

	^ true.! !
!XMLURI methodsFor: 'testing'!
isFile
	^ self scheme = 'file'! !
!XMLURI methodsFor: 'deprecated'!
isFileURI
	self deprecated: 'use #isFile instead'.
	^ self isFile.! !
!XMLURI methodsFor: 'testing'!
isHTTP
	^ self scheme = 'http'! !
!XMLURI methodsFor: 'testing'!
isHTTPS
	^ self scheme = 'https'! !
!XMLURI methodsFor: 'testing'!
isLocal
	^ self isFile
		or: [self isRelative
			and: [self hasHost not]]! !
!XMLURI methodsFor: 'deprecated'!
isLocalURI
	self deprecated: 'use #isLocal instead'.
	^ self isLocal.! !
!XMLURI methodsFor: 'testing'!
isRelative
	^ self hasScheme not! !
!XMLURI methodsFor: 'testing'!
notEmpty
	^ self isEmpty not! !
!XMLURI methodsFor: 'private'!
parseURIStream: aStream
	| parser |

	parser := XMLURIParser on: aStream.
	self
		scheme: parser parseScheme;
		hasAuthorityPrefix: parser parseAuthorityPrefix.
	(self hasScheme
		or: [self hasAuthorityPrefix])
		ifTrue: [
			self
				rawUserInfo: parser parseUserInfo;
				rawHost: parser parseHost;
				port: parser parsePort]
		ifFalse: [
			self
				rawUserInfo: '';
				rawHost: ''].
	self
		rawPathSegments: parser parsePathSegments;
		rawQuery: parser parseQuery;
		rawFragment: parser parseFragment.! !
!XMLURI methodsFor: 'private'!
parseURIStringIfUnparsed
	scheme
		ifNil: [self parseURIStream: self uriString readStream]! !
!XMLURI methodsFor: 'accessing'!
path
	"Returns the percent-decoded path as a string"

	self hasPath
		ifTrue: [| writeStream |
			writeStream := (String new: self rawPathSegments size * 10) writeStream.
			self rawPathSegments
				do: [:each | writeStream nextPutAll: (self percentDecode: each)]
				separatedBy: [writeStream nextPut: $/].
			^ writeStream contents]
		ifFalse: [^ '']! !
!XMLURI methodsFor: 'accessing'!
pathSegments
	"Returns a temporary OrderedCollection of percent-decoded path segments"

	^ self rawPathSegments collect: [:each | self percentDecode: each]! !
!XMLURI methodsFor: 'enumerating'!
pathSegmentsDo: aBlock
	self rawPathSegments do: [:each |
		aBlock value: (self percentDecode: each)]! !
!XMLURI methodsFor: 'private'!
percentAndPlusDecode: aString
	| readStream writeStream |

	((aString includes: $%)
		or: [aString includes: $+])
		ifFalse: [^ aString].

	readStream := aString readStream.
	writeStream := (String new: aString size) writeStream.
	[readStream atEnd]
		whileFalse: [
			readStream peek == $%
				ifTrue: [
					self
						percentDecodeNextFrom: readStream
						on: writeStream]
				ifFalse: [| nextChar |
					(nextChar := readStream next) == $+
						ifTrue: [writeStream nextPut: Character space]
						ifFalse: [writeStream nextPut: nextChar]]].
	^ writeStream contents.! !
!XMLURI methodsFor: 'private'!
percentAndPlusEncode: aString
	| writeStream |

	writeStream := (String new: aString size) writeStream.
	"use #to:do: for speed"
	1 to: aString size do: [:i | | nextChar |
		(UnreservedCharacters includes: (nextChar := aString at: i))
			ifTrue: [	
				nextChar asciiValue = 32 "Character space asciiValue"
					ifTrue: [writeStream nextPut: $+]
					ifFalse: [writeStream nextPut: nextChar]]
			ifFalse: [
				(XMLEncodingWriteStreamAdapter on:
					(XMLPercentEncodingWriteStreamAdapter on: writeStream))
						nextPut: nextChar]].
	^ writeStream contents.! !
!XMLURI methodsFor: 'private'!
percentDecode: aString
	| readStream writeStream |

	(aString includes: $%)
		ifFalse: [^ aString].

	readStream := aString readStream.
	writeStream := (String new: aString size) writeStream.
	[readStream atEnd]
		whileFalse: [
			readStream peek == $%
				ifTrue: [
					self
						percentDecodeNextFrom: readStream
						on: writeStream]
				ifFalse: [writeStream nextPut: readStream next]].
	^ writeStream contents.! !
!XMLURI methodsFor: 'private'!
percentDecodeNextFrom: aReadStream on: aWriteStream
	| readStreamAdapter |

	readStreamAdapter :=
		XMLDecodingReadStreamAdapter
			on: (XMLPercentDecodingReadStreamAdapter on: aReadStream).
	[readStreamAdapter atEnd]
		whileFalse: [aWriteStream nextPut: readStreamAdapter next].! !
!XMLURI methodsFor: 'private'!
percentEncode: aString
	| writeStream |

	writeStream := (String new: aString size) writeStream.
	"use #to:do: for speed"
	1 to: aString size do: [:i | | nextChar |
		(UnreservedCharacters includes: (nextChar := aString at: i))
			ifTrue: [writeStream nextPut: nextChar]
			ifFalse: [
				(XMLEncodingWriteStreamAdapter on:
					(XMLPercentEncodingWriteStreamAdapter on: writeStream))
					nextPut: nextChar]].
	^ writeStream contents.! !
!XMLURI methodsFor: 'accessing'!
port
	"Returns the integer port or nil if there isn't one"

	self parseURIStringIfUnparsed.
	^ port.! !
!XMLURI methodsFor: 'private'!
port: anInteger
	port := anInteger! !
!XMLURI methodsFor: 'copying'!
postCopy
	"the copyWith* methods modify copies, so any URI string of a copy must be parsed
	if it hasn't been already and then cleared because it will be obsolete after a
	URI component is changed"
	self
		parseURIStringIfUnparsed;
		uriString: nil! !
!XMLURI methodsFor: 'printing'!
printAuthorityOn: aStream
	self hasAuthority
		ifTrue: [
			self
				printUserInfoOn: aStream;
				printHostOn: aStream;
				printPortOn: aStream]! !
!XMLURI methodsFor: 'printing'!
printAuthorityPrefixOn: aStream
	(self hasAuthorityPrefix
		or: [self hasScheme not and: [self hasAuthority]])
		ifTrue: [aStream nextPutAll: '//']! !
!XMLURI methodsFor: 'printing'!
printFragmentOn: aStream
	self hasFragment
		ifTrue: [
			aStream
				nextPut: $#;
				nextPutAll: self rawFragment]! !
!XMLURI methodsFor: 'printing'!
printHostOn: aStream
	self hasHost
		ifTrue: [aStream nextPutAll: self rawHost]! !
!XMLURI methodsFor: 'printing'!
printOn: aStream
	aStream nextPutAll: self asString! !
!XMLURI methodsFor: 'printing'!
printPathOn: aStream
	self rawPathSegments
		do: [:each | aStream nextPutAll: each]
		separatedBy: [aStream nextPut: $/]! !
!XMLURI methodsFor: 'printing'!
printPathPrefixOn: aStream
	(self hasPath
		and: [self hasAbsolutePath not
			and: [self hasScheme or: [self hasAuthority]]])
		ifTrue: [aStream nextPut: $/]! !
!XMLURI methodsFor: 'printing'!
printPortOn: aStream
	self hasPort
		ifTrue: [
			aStream nextPut: $:.
			port printOn: aStream]! !
!XMLURI methodsFor: 'printing'!
printQueryOn: aStream
	| atBeginning |

	self hasQuery
		ifFalse: [^ self].
	
	aStream nextPut: $?.
	atBeginning := true.
	self rawQuery do: [:each |
		atBeginning
			ifTrue: [atBeginning := false]
			ifFalse: [aStream nextPut: $&].
		aStream
			nextPutAll: each key;
			nextPut: $=;
			nextPutAll: each value].! !
!XMLURI methodsFor: 'printing'!
printSchemeOn: aStream
	self hasScheme
		ifTrue: [
			aStream
				nextPutAll: self scheme;
				nextPut: $:]! !
!XMLURI methodsFor: 'printing'!
printUserInfoOn: aStream
	self hasUserInfo
		ifTrue: [
			aStream
				nextPutAll: self rawUserInfo;
				nextPut: $@]! !
!XMLURI methodsFor: 'accessing'!
query
	"Returns a temporary OrderedCollection of percent/plus-decoded
	query string key=value pairs"

	^ self rawQuery collect: [:each |
		(self percentAndPlusDecode: each key) ->
			(self percentAndPlusDecode: each value)]! !
!XMLURI methodsFor: 'accessing'!
queryAt: aKey
	"Returns the last percent/plus-decoded value of the query string
	parameter aKey or an empty string if there isn't one"

	^ self
		queryAt: aKey
		ifAbsent: ['']! !
!XMLURI methodsFor: 'accessing'!
queryAt: aKey ifAbsent: aBlock
	"Returns the first percent/plus-decoded value of the query string
	parameter aKey or the value of aBlock if there isn't one"

	self rawQuery do: [:each |
		(self percentAndPlusDecode: each key) = aKey
			ifTrue: [^ self percentAndPlusDecode: each value]].
	^ aBlock value.! !
!XMLURI methodsFor: 'testing'!
queryIncludesKey: aKey
	self
		queryAt: aKey
		ifAbsent: [^ false].
	^ true.! !
!XMLURI methodsFor: 'accessing'!
queryKeys
	"Returns a SequenceableCollection of the unique percent/plus-decoded
	query string parameter keys"

	| keys |

	keys := OrderedCollection new: self rawQuery size.
	self queryKeysDo: [:each |
		keys addLast: each].
	^ keys.! !
!XMLURI methodsFor: 'enumerating'!
queryKeysAndValuesDo: aTwoArgumentBlock
	self rawQuery do: [:each |
		aTwoArgumentBlock
			value: (self percentAndPlusDecode: each key)
			value: (self percentAndPlusDecode: each value)]! !
!XMLURI methodsFor: 'enumerating'!
queryKeysDo: aBlock
	self rawQuery do: [:each |
		aBlock value: (self percentAndPlusDecode: each key)]! !
!XMLURI methodsFor: 'accessing'!
queryValuesAt: aKey
	"Returns the percent/plus-decoded values of the query string parameter
	aKey or an empty collection if there aren't any"

	^ self
		queryValuesAt: aKey
		ifAbsent: [OrderedCollection new]! !
!XMLURI methodsFor: 'enumerating'!
queryValuesAt: aKey do: aBlock
	self queryKeysAndValuesDo: [:key :value |
		key = aKey
			ifTrue: [aBlock value: value]]! !
!XMLURI methodsFor: 'accessing'!
queryValuesAt: aKey ifAbsent: aBlock
	"Returns the percent/plus-decoded values of the query string parameter
	aKey or the value of aBlock if there aren't any"

	| values |

	self
		queryValuesAt: aKey
		do: [:each |
			"only initialize if needed"
			(values ifNil: [values := OrderedCollection new])
				addLast: each].
	^ values ifNil: [aBlock value].! !
!XMLURI methodsFor: 'accessing'!
rawFragment
	"Returns the raw URI fragment (everything after the '#') without
	percent-decoding or an empty string if there isn't one"

	self parseURIStringIfUnparsed.
	^ rawFragment.! !
!XMLURI methodsFor: 'private'!
rawFragment: aString
	rawFragment := aString! !
!XMLURI methodsFor: 'accessing'!
rawHost
	"Returns the raw host without percent-decoding or the IPv6-style host
	or an empty string if there isn't one"

	self parseURIStringIfUnparsed.
	^ rawHost.! !
!XMLURI methodsFor: 'private'!
rawHost: aString
	rawHost := aString! !
!XMLURI methodsFor: 'accessing'!
rawPathSegments
	"Returns an OrderedCollection of raw path segments without
	percent-decoding"

	self parseURIStringIfUnparsed.
	^ rawPathSegments.! !
!XMLURI methodsFor: 'private'!
rawPathSegments: aPathSegmentCollection
	rawPathSegments := aPathSegmentCollection! !
!XMLURI methodsFor: 'accessing'!
rawQuery
	"Returns an OrderedCollection of raw query string key=value pairs
	without percent/plus-decoding"

	self parseURIStringIfUnparsed.
	^ rawQuery.! !
!XMLURI methodsFor: 'private'!
rawQuery: anOrderedCollection
	rawQuery := anOrderedCollection! !
!XMLURI methodsFor: 'accessing'!
rawUserInfo
	self parseURIStringIfUnparsed.
	^ rawUserInfo.! !
!XMLURI methodsFor: 'private'!
rawUserInfo: aString
	rawUserInfo := aString! !
!XMLURI methodsFor: 'private'!
removeLastRawPathSegment
	^ self rawPathSegments removeLast! !
!XMLURI methodsFor: 'private'!
removeRawPathSegments
	self rawPathSegments removeAll! !
!XMLURI methodsFor: 'accessing'!
scheme
	"Returns the URI scheme or an empty string if there isn't one"

	self parseURIStringIfUnparsed.
	^ scheme.! !
!XMLURI methodsFor: 'private'!
scheme: aString
	scheme := aString! !
!XMLURI methodsFor: 'resolving'!
streamGet
	^ self asRetrievableResource streamGet! !
!XMLURI methodsFor: 'resolving'!
streamGetUpToLimit: aMaxSize decoding: aBoolean
	^ self asRetrievableResource
		streamGetUpToLimit: aMaxSize
		decoding: aBoolean! !
!XMLURI methodsFor: 'private'!
uriString
	^ uriString! !
!XMLURI methodsFor: 'private'!
uriString: aString
	uriString := aString! !
!XMLURI methodsFor: 'accessing'!
userInfo
	^ self percentDecode: self rawUserInfo! !
!XMLUnparsedEntityValidator class methodsFor: 'instance creation'!
unparsedEntities: anUnparsedEntityDictionary notations: aNotationDictionary
	^ self new
		setUnparsedEntities: anUnparsedEntityDictionary
		notations: aNotationDictionary! !
!XMLUnparsedEntityValidator methodsFor: 'private'!
errorMultipleDeclarationsForNotation: aNotation
	XMLValidationException
		formatSignal: 'Multiple declarations for notation "{1}"'
		with: aNotation! !
!XMLUnparsedEntityValidator methodsFor: 'private'!
errorMultipleNotationAttributesForElement: anElement
	XMLValidationException
		formatSignal: 'Element <{1}> has multiple NOTATION list attributes'
		with: anElement! !
!XMLUnparsedEntityValidator methodsFor: 'private'!
errorUndeclaredNotation: aNotation inAttribute: anAttribute
	XMLValidationException
		formatSignal: 'Undeclared notation "{1}" in NOTATION (...) attribute "{2}"'
		with: aNotation
		with: anAttribute! !
!XMLUnparsedEntityValidator methodsFor: 'private'!
errorUndeclaredNotation: aNotation inEntity: anEntity
	XMLValidationException
		formatSignal: 'Undeclared notation "{1}" referenced by <!!ENTITY {2} ...> declaration'
		with: aNotation
		with: anEntity! !
!XMLUnparsedEntityValidator methodsFor: 'private'!
errorUndeclaredUnparsedEntityReference: anEntity inAttribute: anAttriubute
	XMLValidationException
		formatSignal: 'Undeclared unparsed entity "{1}" in "{2}" attribute'
		with: anEntity
		with: anAttriubute! !
!XMLUnparsedEntityValidator methodsFor: 'testing'!
hasNotationAttributeValidators
	"direct access to avoid lazy initialization"
	^ notationAttributeValidators notNil
		and: [notationAttributeValidators notEmpty]! !
!XMLUnparsedEntityValidator methodsFor: 'accessing'!
notationAttributeValidators
	^ notationAttributeValidators ifNil: [notationAttributeValidators := Dictionary new]! !
!XMLUnparsedEntityValidator methodsFor: 'accessing'!
notations
	^ notations ifNil: [notations := Dictionary new]! !
!XMLUnparsedEntityValidator methodsFor: 'initialization'!
setUnparsedEntities: anUnparsedEntityDictionary notations: aNotationDictionary
	unparsedEntities := anUnparsedEntityDictionary.
	notations := aNotationDictionary.! !
!XMLUnparsedEntityValidator methodsFor: 'accessing'!
unparsedEntities
	^ unparsedEntities ifNil: [unparsedEntities := Dictionary new]! !
!XMLUnparsedEntityValidator methodsFor: 'validating'!
validateEntityReference: anEntity inAttribute: anAttribute
	(self unparsedEntities includesKey: anEntity)
		ifFalse: [
			self
				errorUndeclaredUnparsedEntityReference: anEntity
				inAttribute: anAttribute]! !
!XMLUnparsedEntityValidator methodsFor: 'validating'!
validateNotationAttributeDeclaration: aNotationAttributeValidator
	| oldSize |

	"checking size after is faster than includes:"
	oldSize := self notationAttributeValidators size.
	(self notationAttributeValidators
		at: aNotationAttributeValidator element
		put: aNotationAttributeValidator;
		size) > oldSize
		ifFalse: [
			self errorMultipleNotationAttributesForElement:
				aNotationAttributeValidator element].! !
!XMLUnparsedEntityValidator methodsFor: 'validating'!
validateNotationAttributeDeclarationDefaults
	"this validation has to be delayed until the entire DTD
	is processed so notation attributes can be declared before
	the notations referenced in their enumeration list are"
	self notationAttributeValidators valuesDo: [:validator |
		validator allowedValues do: [:each |
			(self notations includesKey: each)
				ifFalse: [
					self
						errorUndeclaredNotation: each
						inAttribute: validator attribute]]]! !
!XMLUnparsedEntityValidator methodsFor: 'validating'!
validateUnparsedEntityDeclarations
	"this validation has to be delayed until the entire DTD
	is processed so unparsed entities can be declared before
	the notation they reference are"
	self unparsedEntities valuesDo: [:each |
		(self notations includesKey: each ndata)
			ifFalse: [
				self
					errorUndeclaredNotation: each ndata
					inEntity: each name]]! !
!XMLAttributeDictionary methodsFor: 'converting'!
asXMLAttributeDictionary
	^ self! !
!XMLAttributeDictionary methodsFor: 'accessing'!
associationAtName: aQualifiedOrLocalName
	^ self
		associationAtName: aQualifiedOrLocalName
		ifAbsent: [nil]! !
!XMLAttributeDictionary methodsFor: 'accessing'!
associationAtName: aQualifiedOrLocalName ifAbsent: aBlock
	^ self
		associationAt: aQualifiedOrLocalName
		ifAbsent: [
			aQualifiedOrLocalName xmlPrefixBeforeLocalName isEmpty
				ifTrue: [
					self keysDo: [:each |
						(each isXMLQualifiedOrLocalName: aQualifiedOrLocalName)
							ifTrue: [^ self associationAt: each]]].
			aBlock value]! !
!XMLAttributeDictionary methodsFor: 'accessing'!
associationAtName: aQualifiedOrLocalName namespaceURI: aURI
	^ self
		associationAtName: aQualifiedOrLocalName
		namespaceURI: aURI
		ifAbsent: [nil]! !
!XMLAttributeDictionary methodsFor: 'accessing'!
associationAtName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock
	| namePrefix |

	(namePrefix := aQualifiedOrLocalName xmlPrefixBeforeLocalName) isEmpty
		ifTrue: [
			"aQualifiedOrLocalName has no prefix, so check for an
			attribute with a matching local name and namespace URI"
			self keysDo: [:each |
				(each isXMLQualifiedOrLocalName: aQualifiedOrLocalName)
					ifTrue: [| keyPrefix |
						(keyPrefix := each xmlPrefixBeforeLocalName) isEmpty
							ifTrue: [
								"unprefixed attribute have no namespace URI"
								aURI isEmpty
									ifTrue: [^ self associationAt: each]]
							ifFalse: [
								(self resolvePrefix: keyPrefix) = aURI
									ifTrue: [^ self associationAt: each]]]]]
		ifFalse: [
			"aQualifiedOrLocalName is a qualified name, look it up exactly"
			(self resolvePrefix: namePrefix) = aURI
				ifTrue: [
					^ self
						associationAt: aQualifiedOrLocalName
						ifAbsent: aBlock]].

	^ aBlock value.! !
!XMLAttributeDictionary methodsFor: 'private'!
at: aKey newPut: aValue
	"should be identical to StandardOrderedDictionary>>#at:put: except
	it returns a boolean to tell if the key is new"
	| oldSize |

	oldSize := dictionary size.
	dictionary
		at: aKey
		put: aValue.
	dictionary size > oldSize
		ifTrue: [
			orderedKeys size > oldSize
				ifFalse: [self growOrderedKeys].
			orderedKeys at: oldSize + 1 put: aKey.
			^ true].
	^ false.! !
!XMLAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName
	^ self
		atName: aQualifiedOrLocalName
		ifAbsent: ['']! !
!XMLAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName ifAbsent: aBlock
	^ (self
		associationAtName: aQualifiedOrLocalName
		ifAbsent: [^ aBlock value])
		ifNil: [aBlock value]
		ifNotNil: [:association | association value]! !
!XMLAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName namespaceURI: aURI
	^ self
		atName: aQualifiedOrLocalName
		namespaceURI: aURI
		ifAbsent: ['']! !
!XMLAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock
	^ (self
		associationAtName: aQualifiedOrLocalName
		namespaceURI: aURI)
		ifNil: [aBlock value]
		ifNotNil: [:association | association value]! !
!XMLAttributeDictionary methodsFor: 'private'!
namespaceScope
	^ nil! !
!XMLAttributeDictionary methodsFor: 'accessing'!
namespaceURIOf: aKey
	"Returns the namespace URI of the attribute name aKey"

	| prefix |

	^ (self usesNamespaces
		and: [(prefix := aKey xmlPrefixBeforeLocalName) notEmpty])
		ifTrue: [self resolvePrefix: prefix]
		ifFalse: ['']! !
!XMLAttributeDictionary methodsFor: 'private'!
resolvePrefix: aPrefix
	^ self
		resolvePrefix: aPrefix
		ifUnresolvable: ''! !
!XMLAttributeDictionary methodsFor: 'private'!
resolvePrefix: aPrefix ifUnresolvable: aBlock
	^ aBlock value! !
!XMLAttributeDictionary methodsFor: 'initialization'!
setNamespaceScope: aNamespaceScope! !
!XMLAttributeDictionary methodsFor: 'testing'!
usesNamespaces
	^ false! !
!XMLNamespacedAttributeDictionary methodsFor: 'private'!
namespaceScope
	^ namespaceScope ifNil: [namespaceScope := XMLNamespaceScope new]! !
!XMLNamespacedAttributeDictionary methodsFor: 'private'!
resolvePrefix: aPrefix ifUnresolvable: aBlock
	^ self namespaceScope
		resolvePrefix: aPrefix
		ifUnresolvable: aBlock! !
!XMLNamespacedAttributeDictionary methodsFor: 'initialization'!
setNamespaceScope: aNamespaceScope
	namespaceScope := aNamespaceScope! !
!XMLNamespacedAttributeDictionary methodsFor: 'testing'!
usesNamespaces
	^ true! !
!String methodsFor: '*XML-Parser'!
asXMLEscapedString
	"returns a copy of self with &, <, and > escaped with &amp;, &lt;, and &gt;"
	| stream |

	stream := (self class new: self size) writeStream.
	"to:do: for performance"
	1 to: self size do: [:i | | nextChar |
		(nextChar := self at: i) == $<
			ifTrue: [stream nextPutAll: '&lt;']
			ifFalse: [
				nextChar == $> "needed to escape ]]> in PCDATA"
					ifTrue: [stream nextPutAll: '&gt;']
					ifFalse: [
						nextChar == $&
							ifTrue: [stream nextPutAll: '&amp;']
							ifFalse: [stream nextPut: nextChar]]]].
	^ stream contents.! !
!String methodsFor: '*XML-Parser'!
asXMLFileHandle
	^ XMLFileHandle path: self! !
!String methodsFor: '*XML-Parser'!
asXMLHTTPRequest
	^ XMLHTTPRequest url: self! !
!String methodsFor: '*XML-Parser'!
asXMLStreamConverter
	^ XMLStreamConverter newForEncoding: self! !
!String methodsFor: '*XML-Parser'!
asXMLString
	"will be deprecated; use #asXMLStringNode instead"

	^ self asXMLStringNode! !
!String methodsFor: '*XML-Parser'!
asXMLStringNode
	^ XMLString string: self! !
!String methodsFor: '*XML-Parser'!
asXMLURI
	^ XMLURI fromString: self! !
!String methodsFor: '*XML-Parser'!
expandWithXMLNamespaceURI: aURI
	"optimized"
	aURI size == 0
		ifTrue: [^ self]
		ifFalse: [^ 'Q{', aURI, '}', self]! !
!String methodsFor: '*XML-Parser'!
isXMLNCName
	"optimized"
	self size == 0
		ifTrue: [^ false].
	(self at: 1) isXMLNCNameStartChar
		ifFalse: [^ false].
	2 to: self size do: [:i |
		(self at: i) isXMLNCNameChar
			ifFalse: [^ false]].
	^ true.! !
!String methodsFor: '*XML-Parser'!
isXMLNSAttributeName
	"optimized"
	self size >= 5
		ifFalse: [^ false].
	(self at: 1) == $x
		ifFalse: [^ false].
	(self at: 2) == $m
		ifFalse: [^ false].
	(self at: 3) == $l
		ifFalse: [^ false].
	(self at: 4) == $n
		ifFalse: [^ false].
	(self at: 5) == $s
		ifFalse: [^ false].
	self size == 5
		ifTrue: [^ true].
	^ (self at: 6) == $:.! !
!String methodsFor: '*XML-Parser'!
isXMLName
	"optimized"
	self size == 0
		ifTrue: [^ false].
	(self at: 1) isXMLNameStartChar
		ifFalse: [^ false].
	2 to: self size do: [:i |
		(self at: i) isXMLNameChar
			ifFalse: [^ false]].
	^ true.! !
!String methodsFor: '*XML-Parser'!
isXMLNmtoken
	"optimized"
	self size == 0
		ifTrue: [^ false].
	1 to: self size do: [:i |
		(self at: i) isXMLNameChar
			ifFalse: [^ false]].
	^ true.! !
!String methodsFor: '*XML-Parser'!
isXMLQualifiedOrLocalName: aQualifiedOrLocalName
	"returns true if self and aQualifiedOrLocalName are the
	same QName or if self is a QName and aQualifiedOrLocalName
	is the local part, or if they are the same NCName."
	| i |

	i := aQualifiedOrLocalName size.
	self size to: 1 by: -1 do: [:j |
		i == 0
			ifTrue: [^ (self at: j) == $:].
		"avoid #== for compatibility with pre-Spur VMs where wide chars
		aren't an immediate type"
		(aQualifiedOrLocalName at: i) = (self at: j)
			ifFalse: [^ false].
		i := i - 1].
	^ i == 0.! !
!String methodsFor: '*XML-Parser'!
isXMLReservedAttributeName
	"optimized"
	self size > 3
		ifFalse: [^ false].
	(self at: 1) == $x
		ifFalse: [^ false].
	(self at: 2) == $m
		ifFalse: [^ false].
	^ (self at: 3) == $l.! !
!String methodsFor: '*XML-Parser'!
isXMLWhitespace
	"optimized"
	self size == 0
		ifTrue: [^ false].
	1 to: self size do: [:i |
		(self at: i) isXMLWhitespace
			ifFalse: [^ false]].
	^ true.! !
!String methodsFor: '*XML-Parser'!
parseXML
	^ XMLDOMParser parse: self! !
!String methodsFor: '*XML-Parser'!
qualifyWithXMLPrefix: aPrefix
	"optimized"
	aPrefix size == 0
		ifTrue: [^ self]
		ifFalse: [^ (aPrefix copyWith: $:), self]! !
!String methodsFor: '*XML-Parser'!
xmlCopyWithoutWhitespace
	^ self reject: [:each | each isXMLWhitespace]! !
!String methodsFor: '*XML-Parser'!
xmlLocalNameAfterPrefix
	^ self xmlLocalNameAfterPrefix: self xmlPrefixBeforeLocalName! !
!String methodsFor: '*XML-Parser'!
xmlLocalNameAfterPrefix: aPrefix
	"optimized"
	| prefixSize |

	(prefixSize := aPrefix size) == 0
		ifTrue: [^ self]
		ifFalse: [^ self copyFrom: prefixSize + 2 to: self size]! !
!String methodsFor: '*XML-Parser'!
xmlPrefixBeforeLocalName
	"optimized"
	| i |

	i := self size.
	[i == 0]
		whileFalse: [
			((self at: i) == $:)
				ifTrue: [^ (self copyFrom: 1 to: i - 1)].
			i := i - 1].
	^ ''.! !
!String methodsFor: '*XML-Parser'!
xmlPrefixBeforeLocalName: aLocalName
	"optimized"
	| prefixSize |

	(prefixSize := self size - aLocalName size - 1) > 0
		ifTrue: [^ self copyFrom: 1 to: prefixSize]
		ifFalse: [^ '']! !
!UndefinedObject methodsFor: '*XML-Parser'!
isXMLChar
	"hack optimization to avoid testing for nil before sending
	this to objects from streams in XMLParser"
	^ false! !
!UndefinedObject methodsFor: '*XML-Parser'!
isXMLNCNameChar
	"hack optimization to avoid testing for nil before sending
	this to objects from streams in XMLParser"
	^ false! !
!UndefinedObject methodsFor: '*XML-Parser'!
isXMLNCNameStartChar
	"hack optimization to avoid testing for nil before sending
	this to objects from streams in XMLParser"
	^ false! !
!UndefinedObject methodsFor: '*XML-Parser'!
isXMLNameChar
	"hack optimization to avoid testing for nil before sending
	this to objects from streams in XMLParser"
	^ false! !
!UndefinedObject methodsFor: '*XML-Parser'!
isXMLNameStartChar
	"hack optimization to avoid testing for nil before sending
	this to objects from streams in XMLParser"
	^ false! !
!UndefinedObject methodsFor: '*XML-Parser'!
isXMLSeparator
	"hack optimization to avoid testing for nil before sending
	this to objects from streams in XMLParser"
	^ false! !
!UndefinedObject methodsFor: '*XML-Parser'!
isXMLWhitespace
	"hack optimization to avoid testing for nil before sending
	this to objects from streams in XMLParser"
	^ false! !
!Character class methodsFor: '*XML-Parser'!
xmlSeparators
	^ String
		with: 32 asCharacter "space"
		with: 10 asCharacter "lf"
		with: 9 asCharacter "tab"
		with: 13 asCharacter "cr"! !
!Character class methodsFor: '*XML-Parser'!
xmlWhitespace
	^ self xmlSeparators copyWith: 12 asCharacter "form feed"! !
!Character methodsFor: '*XML-Parser'!
isXMLChar
	"Range tests are faster and use less memory than a BitmapCharacterSet, and
	a temp is used because Character in newer SpurVM images has no 'value'
	inst var.
	
	Char ::=
		#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]"

	| tempValue |

	(tempValue := self asciiValue) >= 16r20
		ifTrue: [
			"most chars should be in the range 16r20-16rD7FF"
			tempValue <= 16rD7FF
				ifTrue: [^ true].
	
			tempValue <= 16rFFFD
				ifTrue: [^ tempValue >= 16rE000].
			tempValue >= 16r10000
				ifFalse: [^ false].
			^ tempValue <= 16r10FFFF].

	tempValue == 16r9
		ifTrue: [^ true].
	tempValue == 16rA
		ifTrue: [^ true].
	^ tempValue == 16rD.! !
!Character methodsFor: '*XML-Parser'!
isXMLNCNameChar
	"should be the same as isXMLNameChar except without a test for $:"

	| tempValue |

	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"
		ifTrue: [
			tempValue >= 16r61 "$a asciiValue hex"
				ifTrue: [^ true].

			tempValue >= 16r41 "$A asciiValue hex"
				ifTrue: [
					tempValue <= 16r5A "$Z asciiValue hex"
						ifTrue: [^ true].
					^ tempValue == 16r5F]. "$_ asciiValue hex"

			tempValue >= 16r30 "$0 asciiValue hex"
				ifTrue: [^ tempValue <= 16r39]. "$9 asciiValue hex; no $: test"

			tempValue == 16r2D "$- asciiValue hex"
				ifTrue: [^ true].
			^ tempValue == 16r2E]. "$. asciiValue hex"

	tempValue <= 16r2040
		ifTrue: [
			tempValue <= 16r36F
				ifTrue: [	
					tempValue <= 16rF6
						ifTrue: [
							tempValue <= 16rD6
								ifFalse: [^ tempValue >= 16rD8].
							tempValue >= 16rC0
								ifTrue: [^ true].
							^ tempValue == 16rB7]
						ifFalse: [
							tempValue <= 16r2FF
								ifTrue: [^ tempValue >= 16rF8].
							^ tempValue >= 16r300]]
				ifFalse: [
					tempValue <= 16r1FFF
						ifTrue: [	
							tempValue <= 16r37D
								ifFalse: [^ tempValue >= 16r37F].
							^ tempValue >= 16r370]
						ifFalse: [
							tempValue <= 16r200D
								ifTrue: [^ tempValue >= 16r200C].
							^ tempValue >= 16r203F]]]
	ifFalse: [
		tempValue <= 16rD7FF
			ifTrue: [
				tempValue >= 16r2C00
					ifTrue: [
						tempValue >= 16r3001
							ifTrue: [^ true].
						^ tempValue <= 16r2FEF]
					ifFalse: [
						tempValue <= 16r218F
							ifFalse: [^ false].
						^ tempValue >= 16r2070]]
			ifFalse: [
				tempValue <= 16rFFFD
					ifTrue: [
						tempValue <= 16rFDCF
							ifTrue: [^ tempValue >= 16rF900].
						^ tempValue >= 16rFDF0]
					ifFalse: [
						tempValue >= 16r10000
							ifFalse: [^ false].
						^ tempValue <= 16rEFFFF]]].! !
!Character methodsFor: '*XML-Parser'!
isXMLNCNameStartChar
	"should be the same as isXMLNameStartChar except without a test for $:"

	| tempValue |

	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"
		ifTrue: [
			tempValue >= 16r61 "$a asciiValue hex"
				ifTrue: [^ true].

			tempValue <= 16r5A "$Z asciiValue hex"
				ifTrue: [^ tempValue >= 16r41]. "$A asciiValue hex"

			^ tempValue == 16r5F]. "$_ asciiValue hex; no $: test"

	tempValue <= 16r200D
		ifTrue: [
			tempValue <= 16r2FF
				ifTrue: [
					tempValue >= 16rD8
						ifTrue: [
							tempValue >= 16rF8
								ifTrue: [^ true].
							^ tempValue <= 16rF6]
						ifFalse: [
							tempValue >= 16rC0
								ifFalse: [^ false].
							^ tempValue <= 16rD6]]
				ifFalse: [
					tempValue >= 16r37F
						ifTrue: [
							tempValue >= 16r200C
								ifTrue: [^ true].
							^ tempValue <= 16r1FFF]
						ifFalse: [
							tempValue <= 16r37D
								ifFalse: [^ false].
							^ tempValue >= 16r370]]]
	ifFalse: [
		tempValue <= 16rD7FF
			ifTrue: [
				tempValue >= 16r2C00
					ifTrue: [
						tempValue >= 16r3001
							ifTrue: [^ true].
						^ tempValue <= 16r2FEF]
					ifFalse: [
						tempValue <= 16r218F
							ifFalse: [^ false].
						^ tempValue >= 16r2070]]
			ifFalse: [
				tempValue >= 16rFDF0
					ifTrue: [
						tempValue >= 16r10000
							ifTrue: [^ tempValue <= 16rEFFFF].
						^ tempValue <= 16rFFFD]
					ifFalse: [
						tempValue <= 16rFDCF
							ifFalse: [^ false].
						^ tempValue >= 16rF900]]].! !
!Character methodsFor: '*XML-Parser'!
isXMLNameChar
	"Range tests are faster and use less memory than a BitmapCharacterSet, and
	a temp is used because Character in newer SpurVM images has no 'value'
	inst var.
	
	NameStartChar ::=
		':' | [A-Z] | '_' | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
		[#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |
		[#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
		[#x10000-#xEFFFF]
	NameChar ::=
		NameStartChar | '-' | '.' | [0-9] | #xB7 | [#x0300-#x036F] |
		[#x203F-#x2040]"

	| tempValue |

	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"
		ifTrue: [
			tempValue >= 16r61 "$a asciiValue hex"
				ifTrue: [^ true].

			tempValue >= 16r41 "$A asciiValue hex"
				ifTrue: [
					tempValue <= 16r5A "$Z asciiValue hex"
						ifTrue: [^ true].
					^ tempValue == 16r5F]. "$_ asciiValue hex"

			tempValue >= 16r30 "$0 asciiValue hex"
				ifTrue: [
					tempValue <= 16r39 "$9 asciiValue hex"
						ifTrue: [^ true].
					^ tempValue == 16r3A]. "$: asciiValue hex"

			tempValue == 16r2D "$- asciiValue hex"
				ifTrue: [^ true].
			^ tempValue == 16r2E]. "$. asciiValue hex"

	tempValue <= 16r2040
		ifTrue: [
			tempValue <= 16r36F
				ifTrue: [	
					tempValue <= 16rF6
						ifTrue: [
							tempValue <= 16rD6
								ifFalse: [^ tempValue >= 16rD8].
							tempValue >= 16rC0
								ifTrue: [^ true].
							^ tempValue == 16rB7]
						ifFalse: [
							tempValue <= 16r2FF
								ifTrue: [^ tempValue >= 16rF8].
							^ tempValue >= 16r300]]
				ifFalse: [
					tempValue <= 16r1FFF
						ifTrue: [	
							tempValue <= 16r37D
								ifFalse: [^ tempValue >= 16r37F].
							^ tempValue >= 16r370]
						ifFalse: [
							tempValue <= 16r200D
								ifTrue: [^ tempValue >= 16r200C].
							^ tempValue >= 16r203F]]]
	ifFalse: [
		tempValue <= 16rD7FF
			ifTrue: [
				tempValue >= 16r2C00
					ifTrue: [
						tempValue >= 16r3001
							ifTrue: [^ true].
						^ tempValue <= 16r2FEF]
					ifFalse: [
						tempValue <= 16r218F
							ifFalse: [^ false].
						^ tempValue >= 16r2070]]
			ifFalse: [
				tempValue <= 16rFFFD
					ifTrue: [
						tempValue <= 16rFDCF
							ifTrue: [^ tempValue >= 16rF900].
						^ tempValue >= 16rFDF0]
					ifFalse: [
						tempValue >= 16r10000
							ifFalse: [^ false].
						^ tempValue <= 16rEFFFF]]].! !
!Character methodsFor: '*XML-Parser'!
isXMLNameStartChar
	"Range tests are faster and use less memory than a BitmapCharacterSet, and
	a temp is used because Character in newer SpurVM images has no 'value'
	inst var.
	
	NameStartChar ::=
		':' | [A-Z] | '_' | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
		[#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |
		[#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
		[#x10000-#xEFFFF]"

	| tempValue |

	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"
		ifTrue: [
			tempValue >= 16r61 "$a asciiValue hex"
				ifTrue: [^ true].

			tempValue >= 16r41 "$A asciiValue hex"
				ifTrue: [
					tempValue <= 16r5A "$Z asciiValue hex"
						ifTrue: [^ true].
					^ tempValue == 16r5F]. "$_ asciiValue hex"
	
			^ tempValue == 16r3A]. "$: asciiValue hex"

	tempValue <= 16r200D
		ifTrue: [
			tempValue <= 16r2FF
				ifTrue: [
					tempValue >= 16rD8
						ifTrue: [
							tempValue >= 16rF8
								ifTrue: [^ true].
							^ tempValue <= 16rF6]
						ifFalse: [
							tempValue >= 16rC0
								ifFalse: [^ false].
							^ tempValue <= 16rD6]]
				ifFalse: [
					tempValue >= 16r37F
						ifTrue: [
							tempValue >= 16r200C
								ifTrue: [^ true].
							^ tempValue <= 16r1FFF]
						ifFalse: [
							tempValue <= 16r37D
								ifFalse: [^ false].
							^ tempValue >= 16r370]]]
	ifFalse: [
		tempValue <= 16rD7FF
			ifTrue: [
				tempValue >= 16r2C00
					ifTrue: [
						tempValue >= 16r3001
							ifTrue: [^ true].
						^ tempValue <= 16r2FEF]
					ifFalse: [
						tempValue <= 16r218F
							ifFalse: [^ false].
						^ tempValue >= 16r2070]]
			ifFalse: [
				tempValue >= 16rFDF0
					ifTrue: [
						tempValue >= 16r10000
							ifTrue: [^ tempValue <= 16rEFFFF].
						^ tempValue <= 16rFFFD]
					ifFalse: [
						tempValue <= 16rFDCF
							ifFalse: [^ false].
						^ tempValue >= 16rF900]]].! !
!Character methodsFor: '*XML-Parser'!
isXMLSeparator
	"a temp is used because Character in newer SpurVM images
	has no 'value' inst var"
	| tempValue |

	(tempValue := self asciiValue) == 32 "space"
		ifTrue: [^ true].
	tempValue == 10 "line feed"
		ifTrue: [^ true].
	tempValue == 9 "tab"
		ifTrue: [^ true].
	^ tempValue == 13. "carriage return; no form feeds"! !
!Character methodsFor: '*XML-Parser'!
isXMLWhitespace
	"a temp is used because Character in newer SpurVM images
	has no 'value' inst var"
	| tempValue |

	(tempValue := self asciiValue) == 32 "space"
		ifTrue: [^ true].
	tempValue == 10 "line feed"
		ifTrue: [^ true].
	tempValue == 9 "tab"
		ifTrue: [^ true].
	tempValue == 13 "carriage return"
		ifTrue: [^ true].
	^ tempValue == 12. "form feed"! !
!Character methodsFor: '*XML-Parser'!
xmlSplit: aString
	"faster, portable version"
	| parts |

	parts := OrderedCollection new.
	self
		xmlSplit: aString
		do: [:each | parts addLast: each].
	^ parts.! !
!Character methodsFor: '*XML-Parser'!
xmlSplit: aString do: aBlock
	"faster, portable version"
	| start |

	start := 1.
	1 to: aString size do: [:end |
		"avoid #== for compatibility with pre-Spur VMs where wide chars
		aren't an immediate type"
		(aString at: end) = self
			ifTrue: [
				aBlock value: (aString copyFrom: start to: end - 1).
				start := end + 1]].
	start > aString size
		ifTrue: [
			"either aString is empty or it ends with self"
			aBlock value: '']
		ifFalse: [aBlock value: (aString copyFrom: start to: aString size)].! !
!Error methodsFor: '*XML-Parser'!
isXMLParserException
	^ false! !
!XMLException class methodsFor: 'signalling'!
formatSignal: aString with: aFirstValue
	^ self new
		formatSignal: aString
		with: aFirstValue! !
!XMLException class methodsFor: 'signalling'!
formatSignal: aString with: aFirstValue with: aSecondValue
	^ self new
		formatSignal: aString
		with: aFirstValue
		with: aSecondValue! !
!XMLException class methodsFor: 'signalling'!
formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue
	^ self new
		formatSignal: aString
		with: aFirstValue
		with: aSecondValue
		with: aThirdValue! !
!XMLException class methodsFor: 'signalling'!
formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue
	^ self new
		formatSignal: aString
		with: aFirstValue
		with: aSecondValue
		with: aThirdValue
		with: aFourthValue! !
!XMLException class methodsFor: 'signalling'!
formatSignal: aString withArguments: anArray
	^ self new
		formatSignal: aString
		withArguments: anArray! !
!XMLException class methodsFor: 'signalling'!
signalMessageFrom: anException
	^ self new signalMessageFrom: anException! !
!XMLException methodsFor: 'accessing'!
formatMessage: aString with: aFirstValue
	self
		formatMessage: aString
		withArguments: (Array with: aFirstValue)! !
!XMLException methodsFor: 'accessing'!
formatMessage: aString with: aFirstValue with: aSecondValue
	self
		formatMessage: aString
		withArguments:
			(Array
				with: aFirstValue
				with: aSecondValue)! !
!XMLException methodsFor: 'accessing'!
formatMessage: aString with: aFirstValue with: aSecondValue with: aThirdValue
	self
		formatMessage: aString
		withArguments:
			(Array
				with: aFirstValue
				with: aSecondValue
				with: aThirdValue)! !
!XMLException methodsFor: 'accessing'!
formatMessage: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue
	self
		formatMessage: aString
		withArguments:
			(Array
				with: aFirstValue
				with: aSecondValue
				with: aThirdValue
				with: aFourthValue)! !
!XMLException methodsFor: 'accessing'!
formatMessage: aString withArguments: anArray
	self messageText: (aString format: anArray)! !
!XMLException methodsFor: 'signaling'!
formatSignal: aString with: aFirstValue
	self
		formatMessage: aString
		with: aFirstValue.
	^ self signal.! !
!XMLException methodsFor: 'signaling'!
formatSignal: aString with: aFirstValue with: aSecondValue
	self
		formatMessage: aString
		with: aFirstValue
		with: aSecondValue.
	^ self signal.! !
!XMLException methodsFor: 'signaling'!
formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue
	self
		formatMessage: aString
		with: aFirstValue
		with: aSecondValue
		with: aThirdValue.
	^ self signal.! !
!XMLException methodsFor: 'signaling'!
formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue
	self
		formatMessage: aString
		with: aFirstValue
		with: aSecondValue
		with: aThirdValue
		with: aFourthValue.
	^ self signal.! !
!XMLException methodsFor: 'signaling'!
formatSignal: aString withArguments: anArray
	self
		formatMessage: aString
		withArguments: anArray.
	^ self signal.! !
!XMLException methodsFor: 'accessing'!
inheritMessageFrom: anException
	self
		formatMessage: '({1}) {2}'
		with: anException class name
		with: anException messageText! !
!XMLException methodsFor: 'signaling'!
signalMessageFrom: anException
	self inheritMessageFrom: anException.
	^  self signal.! !
!XMLParserException methodsFor: 'accessing'!
baseURI
	^ baseURI ifNil: [baseURI := '']! !
!XMLParserException methodsFor: 'accessing'!
baseURI: aURIString
	baseURI := aURIString! !
!XMLParserException methodsFor: 'accessing'!
columnNumber
	^ columnNumber! !
!XMLParserException methodsFor: 'accessing'!
columnNumber: aColumnNumber
	columnNumber := aColumnNumber! !
!XMLParserException methodsFor: 'testing'!
hasBaseURI
	^ self baseURI notEmpty! !
!XMLParserException methodsFor: 'testing'!
hasColumnNumber
	^ self columnNumber notNil! !
!XMLParserException methodsFor: 'testing'!
hasLineNumber
	^ self lineNumber notNil! !
!XMLParserException methodsFor: 'testing'!
isXMLParserException
	^ true! !
!XMLParserException methodsFor: 'accessing'!
lineNumber
	^ lineNumber! !
!XMLParserException methodsFor: 'accessing'!
lineNumber: aLineNumber
	lineNumber := aLineNumber! !
!XMLParserException methodsFor: 'accessing'!
messageText
	| rawMessageText messageTextStream |

	rawMessageText := super messageText.
	(self hasLineNumber
		or: [self hasBaseURI])
		ifFalse: [^ rawMessageText].

	(messageTextStream := (String new: rawMessageText size * 2) writeStream)
		nextPutAll: rawMessageText;
		nextPutAll: ' ('.
	self hasLineNumber
		ifTrue: [
			messageTextStream
				nextPutAll: 'near line ';
				nextPutAll: self lineNumber asString.
			self hasColumnNumber
				ifTrue: [
					messageTextStream
						nextPutAll: ', column ';
						nextPutAll: self columnNumber asString]].

	self hasBaseURI
		ifTrue: [
			messageTextStream
				nextPutAll:
					(self hasLineNumber
						ifTrue: [' in ']
						ifFalse: ['in ']);
				nextPutAll: self baseURI].
			
	^ messageTextStream
		nextPut: $);
		contents.! !
!XMLParserException methodsFor: 'testing'!
shouldPassOnWhenCaught
	^ true! !
!XMLParsingInterruptException methodsFor: 'testing'!
shouldPassOnWhenCaught
	^ false! !
!Stream methodsFor: '*XML-Parser'!
isXMLBinaryOrExternalStream
	^ self isBinary! !
!Stream methodsFor: '*XML-Parser'!
parseXML
	^ XMLDOMParser parse: self! !
!Collection methodsFor: '*XML-Parser'!
asXMLAttributeDictionary
	^ XMLAttributeDictionary newFrom: self! !
!Collection methodsFor: '*XML-Parser'!
asXMLAttributeSpec
	^ XMLBasicAttributeSpec attributes: self! !
!Collection methodsFor: '*XML-Parser'!
includesXMLName: aName
	"optimized with do: instead of anySatisfy:"
	self do: [:each |
		(aName isXMLQualifiedOrLocalName: each)
			ifTrue: [^ true]].
	^ false.! !
!XMLLazyAttributeDictionary class methodsFor: 'private'!
emptyAttributeDictionary
	^ emptyAttributeDictionary! !
!XMLLazyAttributeDictionary class methodsFor: 'private'!
emptyAttributeDictionaryClass
	^ XMLAttributeDictionary! !
!XMLLazyAttributeDictionary class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self initializeEmptyAttributeDictionary! !
!XMLLazyAttributeDictionary class methodsFor: 'class initialization'!
initializeEmptyAttributeDictionary
	"explictly initialized class inst vars are used for the empty
	dictionaries to simplify class initialization (on GS) and to
	speed up lazy dictionary instance creation"
	emptyAttributeDictionary := self emptyAttributeDictionaryClass new! !
!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!
new
	^ self basicNew setAttributeDictionary: emptyAttributeDictionary! !
!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!
new: aCapacity
	^ self new! !
!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!
newFrom: anAssociationCollection
	^ self basicNew setAttributeDictionary:
		(self emptyAttributeDictionaryClass newFrom:
			anAssociationCollection)! !
!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!
newFromPairs: aSequenceableCollection
	^ self basicNew setAttributeDictionary:
		(self emptyAttributeDictionaryClass newFromPairs:
			aSequenceableCollection)! !
!XMLLazyAttributeDictionary methodsFor: 'comparing'!
= anObject
	^ attributeDictionary = anObject! !
!XMLLazyAttributeDictionary methodsFor: 'adding'!
add: anAssociation
	^ self copiedAttributeDictionary add: anAssociation! !
!XMLLazyAttributeDictionary methodsFor: 'adding'!
addAll: anAssociationCollection
	^ self copiedAttributeDictionary addAll: anAssociationCollection! !
!XMLLazyAttributeDictionary methodsFor: 'converting'!
asXMLAttributeDictionary
	^ self! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associationAt: aKey
	^ attributeDictionary associationAt: aKey! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associationAt: aKey ifAbsent: aBlock
	^ attributeDictionary
		associationAt: aKey
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associationAt: aKey ifPresent: aBlock
	^ attributeDictionary
		associationAt: aKey
		ifPresent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associationAtName: aQualifiedOrLocalName
	^ attributeDictionary associationAtName: aQualifiedOrLocalName! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associationAtName: aKey ifAbsent: aBlock
	^ attributeDictionary
		associationAtName: aKey
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associationAtName: aQualifiedOrLocalName namespaceURI: aURI
	^ attributeDictionary
		associationAtName: aQualifiedOrLocalName
		namespaceURI: aURI! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associationAtName: aKey namespaceURI: aURI ifAbsent: aBlock
	^ attributeDictionary
		associationAtName: aKey
		namespaceURI: aURI
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
associations
	^ attributeDictionary associations! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
associationsDo: aBlock
	attributeDictionary associationsDo: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
associationsSelect: aBlock
	^ self copyEmpty setAttributeDictionary:
		(attributeDictionary associationsSelect: aBlock)! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
at: aKey
	^ attributeDictionary at: aKey! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
at: aKey ifAbsent: aBlock
	^ attributeDictionary
		at: aKey
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
at: aKey ifAbsentPut: aBlock
	^ self copiedAttributeDictionary
		at: aKey
		ifAbsentPut: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
at: aKey ifPresent: aBlock
	^ attributeDictionary
		at: aKey
		ifPresent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock
	^ attributeDictionary
		at: aKey
		ifPresent: aPresentBlock
		ifAbsent: anAbsentBlock! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
at: aKey newPut: aValue
	"added to be consistent with XMLAttributeDictionary,
	but it shouldn't be needed"
	^ self copiedAttributeDictionary
		at: aKey
		newPut: aValue! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
at: aKey put: aValue
	^ self copiedAttributeDictionary
		at: aKey
		put: aValue! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName
	^ attributeDictionary atName: aQualifiedOrLocalName! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName ifAbsent: aBlock
	^ attributeDictionary
		atName: aQualifiedOrLocalName
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName namespaceURI: aURI
	^ attributeDictionary
		atName: aQualifiedOrLocalName
		namespaceURI: aURI! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
atName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock
	^ attributeDictionary
		atName: aQualifiedOrLocalName
		namespaceURI: aURI
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
attributeDictionary
	^ attributeDictionary! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
capacity
	^ attributeDictionary capacity! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
collect: aBlock
	^ self copyEmpty setAttributeDictionary:
		(attributeDictionary collect: aBlock)! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
copiedAttributeDictionary
	"replaces the shared, empty order-preserving dictionary with a new
	mutable one ready for modification"
	^ attributeDictionary == self emptyAttributeDictionary
		ifTrue: [attributeDictionary := self copyEmptyAttributeDictionary]
		ifFalse: [attributeDictionary]! !
!XMLLazyAttributeDictionary methodsFor: 'copying'!
copyEmpty
	"Squeak and GS don't have Collection>>#copyEmpty, so it is
	reimplemented for portability"
	^ self species new! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
copyEmptyAttributeDictionary
	^ attributeDictionary copy! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
dictionary
	^ attributeDictionary dictionary! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
dictionaryClass
	^ attributeDictionary dictionaryClass! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
do: aBlock
	attributeDictionary do: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
emptyAttributeDictionary
	^ self class emptyAttributeDictionary! !
!XMLLazyAttributeDictionary methodsFor: 'comparing'!
hash
	^ attributeDictionary hash! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
identityIndexOfKey: aKey
	^ attributeDictionary identityIndexOfKey: aKey! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
identityIndexOfKey: aKey ifAbsent: aBlock
	^ attributeDictionary
		identityIndexOfKey: aKey
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
includesAssociation: anAssociation
	^ attributeDictionary includesAssociation: anAssociation! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
includesIdentity: anObject
	^ attributeDictionary includesIdentity: anObject! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
includesKey: aKey
	^ attributeDictionary includesKey: aKey! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
indexOfKey: aKey
	^ attributeDictionary indexOfKey: aKey! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
indexOfKey: aKey ifAbsent: aBlock
	^ attributeDictionary
		indexOfKey: aKey
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
isDictionary
	^ true! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
isEmpty
	"Squeak's Collection>>#isEmpty is inefficient"
	^ attributeDictionary isEmpty! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
isIdentityDictionary
	^ attributeDictionary isIdentityDictionary! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
isOrderPreservingDictionary
	^ true! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keyAtIdentityValue: aValue
	^ attributeDictionary keyAtIdentityValue: aValue! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keyAtIdentityValue: aValue ifAbsent: aBlock
	^ attributeDictionary
		keyAtIdentityValue: aValue
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keyAtIndex: anIndex
	^ attributeDictionary keyAtIndex: anIndex! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keyAtIndex: anIndex ifAbsent: aBlock
	^ attributeDictionary
		keyAtIndex: anIndex
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keyAtValue: anObject
	^ attributeDictionary keyAtValue: anObject! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keyAtValue: anObject ifAbsent: aBlock
	^ attributeDictionary
		keyAtValue: anObject
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keyForIdentity: anObject
	^ attributeDictionary keyForIdentity: anObject! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keys
	^ attributeDictionary keys! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
keysAndValuesDo: aBlock
	attributeDictionary keysAndValuesDo: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'removing'!
keysAndValuesRemove: aTwoArgumentBlock
	self copiedAttributeDictionary keysAndValuesRemove: aTwoArgumentBlock! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
keysDo: aBlock
	attributeDictionary keysDo: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
keysSortedSafely
	^ attributeDictionary keysSortedSafely! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
namespaceScope
	^ attributeDictionary namespaceScope! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
namespaceURIOf: aKey
	^ attributeDictionary namespaceURIOf: aKey! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
orderedKeys
	^ attributeDictionary orderedKeys! !
!XMLLazyAttributeDictionary methodsFor: 'copying'!
postCopy
	attributeDictionary == self emptyAttributeDictionary
		ifFalse: [attributeDictionary := attributeDictionary copy]! !
!XMLLazyAttributeDictionary methodsFor: 'printing'!
printElementsOn: aStream
	attributeDictionary printElementsOn: aStream! !
!XMLLazyAttributeDictionary methodsFor: 'removing'!
remove: anObject ifAbsent: aBlock
	self shouldNotImplement! !
!XMLLazyAttributeDictionary methodsFor: 'removing'!
removeAll
	attributeDictionary := self emptyAttributeDictionary! !
!XMLLazyAttributeDictionary methodsFor: 'removing'!
removeKey: aKey
	^ self copiedAttributeDictionary removeKey: aKey! !
!XMLLazyAttributeDictionary methodsFor: 'removing'!
removeKey: aKey ifAbsent: aBlock
	^ self copiedAttributeDictionary
		removeKey: aKey
		ifAbsent: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'removing'!
removeKeys: aKeyCollection
	self copiedAttributeDictionary removeKeys: aKeyCollection! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
resolvePrefix: aPrefix
	^ attributeDictionary resolvePrefix: aPrefix! !
!XMLLazyAttributeDictionary methodsFor: 'private'!
resolvePrefix: aPrefix ifUnresolvable: aBlock
	^ attributeDictionary
		resolvePrefix: aPrefix
		ifUnresolvable: aBlock! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
select: aBlock
	^ self copyEmpty setAttributeDictionary:
		(attributeDictionary select: aBlock)! !
!XMLLazyAttributeDictionary methodsFor: 'initialization'!
setAttributeDictionary: anAttributeDictionary
	attributeDictionary := anAttributeDictionary! !
!XMLLazyAttributeDictionary methodsFor: 'initialization'!
setNamespaceScope: aNamespaceScope! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
size
	^ attributeDictionary size! !
!XMLLazyAttributeDictionary methodsFor: 'testing'!
usesNamespaces
	^ attributeDictionary usesNamespaces! !
!XMLLazyAttributeDictionary methodsFor: 'accessing'!
values
	^ attributeDictionary values! !
!XMLLazyAttributeDictionary methodsFor: 'enumerating'!
valuesDo: aBlock
	attributeDictionary valuesDo: aBlock! !
!XMLLazyNamespacedAttributeDictionary class methodsFor: 'private'!
emptyAttributeDictionaryClass
	^ XMLNamespacedAttributeDictionary! !
!XMLLazyNamespacedAttributeDictionary class methodsFor: 'class initialization'!
initialize
	"self initialize"

	self initializeEmptyAttributeDictionary! !
!XMLLazyNamespacedAttributeDictionary methodsFor: 'private'!
copyEmptyAttributeDictionary
	^ super copyEmptyAttributeDictionary setNamespaceScope: self namespaceScope! !
!XMLLazyNamespacedAttributeDictionary methodsFor: 'private'!
namespaceScope
	^ namespaceScope
		ifNil: [
			namespaceScope :=
				attributeDictionary == self emptyAttributeDictionary
					ifTrue: [XMLNamespaceScope new]
					ifFalse: [attributeDictionary namespaceScope]]! !
!XMLLazyNamespacedAttributeDictionary methodsFor: 'initialization'!
setNamespaceScope: aNamespaceScope
	namespaceScope := aNamespaceScope! !
!XMLNFAStateSet class methodsFor: 'instance creation'!
new
	^ self new: 5! !
!XMLNFAStateSet class methodsFor: 'instance creation'!
new: aCapacity
	^ self basicNew initialize: aCapacity! !
!XMLNFAStateSet class methodsFor: 'instance creation'!
newFrom: aCollection
	"for GS portability"
	^ self withAll: aCollection! !
!XMLNFAStateSet methodsFor: 'copying'!
, aCollection
	"GS doesn't define #, for non-Sequenceable collections"
	^ self copy
		addAll: aCollection;
		yourself! !
!XMLNFAStateSet methodsFor: 'comparing'!
= anObject
	self == anObject
		ifTrue: [^ true].

	(self species == anObject species
		and: [self size = anObject size])
		ifFalse: [^ false].

	"use #do: instead of #allSatisfy: for speed"
	self do: [:each |
		(anObject includes: each)
			ifFalse: [^ false]].

	^ true.! !
!XMLNFAStateSet methodsFor: 'adding'!
add: aState
	isAccepting
		ifFalse: [isAccepting := aState isAccepting].

	^ set add: aState.! !
!XMLNFAStateSet methodsFor: 'converting'!
asDFAState
	^ self asDFAStateWithStateCache: nil! !
!XMLNFAStateSet methodsFor: 'converting'!
asDFAStateWithStateCache: aDFAStateCache
	^ XMLDFAState
		nfaStates: self
		dfaStateCache: aDFAStateCache! !
!XMLNFAStateSet methodsFor: 'accessing'!
capacity
	^ set capacity! !
!XMLNFAStateSet methodsFor: 'enumerating'!
do: aBlock
	set do: aBlock! !
!XMLNFAStateSet methodsFor: 'comparing'!
hash
	| hash |

	hash := self species hash.
	self size > 5
		ifFalse: [
			self do: [:each |
				hash := hash bitXor: each hash]].
	^ hash bitXor: self size hash.! !
!XMLNFAStateSet methodsFor: 'testing'!
includes: aState
	^ set includes: aState! !
!XMLNFAStateSet methodsFor: 'initialization'!
initialize: aCapacity
	set := IdentitySet new: aCapacity.
	isAccepting := false.! !
!XMLNFAStateSet methodsFor: 'testing'!
isAccepting
	^ isAccepting! !
!XMLNFAStateSet methodsFor: 'testing'!
isEmpty
	"Squeak's Collection>>#isEmpty is inefficient"
	^ self size = 0! !
!XMLNFAStateSet methodsFor: 'copying'!
postCopy
	set := set copy! !
!XMLNFAStateSet methodsFor: 'removing'!
remove: aState ifAbsent: aBlock
	set
		remove: aState
		ifAbsent: [^ aBlock value].

	isAccepting
		ifTrue: [isAccepting := set anySatisfy: [:each | each isAccepting]].

	^ aState.! !
!XMLNFAStateSet methodsFor: 'removing'!
removeAll
	"Redefined because Collection>>#removeAll assumes the collection can
	be safely modified while iterating it with #do:, and 'set removeAll'
	is not used because GS's Set/IdentitySet don't implement it"

	self initialize: self capacity! !
!XMLNFAStateSet methodsFor: 'private'!
set
	^ set! !
!XMLNFAStateSet methodsFor: 'accessing'!
size
	^ set size! !
!XMLAttributeList class methodsFor: 'instance creation'!
new
	^ self new: 5! !
!XMLAttributeList methodsFor: 'adding'!
addAttributeAssociation: anAssociation
	^ self
		addAttributeName: anAssociation key
		value: anAssociation value! !
!XMLAttributeList methodsFor: 'adding'!
addAttributeName: aName value: aValue
	^ self addLast:
		(self attributeClass
			name: aName
			value: aValue)! !
!XMLAttributeList methodsFor: 'private'!
afterAdding: aNode at: anIndex
	(self
		removeDuplicateOf: aNode
		notAt: anIndex)
		ifNotNil: [:duplicate |
			duplicate = aNode
				ifTrue: [^ self]].
	observer
		ifNotNil: [observer addedAttribute: aNode].! !
!XMLAttributeList methodsFor: 'private'!
afterAddingLast: aNode
	(self
		removeDuplicateOf: aNode
		notAt: self size)
		ifNotNil: [:duplicate |
			duplicate = aNode
				ifTrue: [^ self]].
	observer
		ifNotNil: [observer addedAttribute: aNode].! !
!XMLAttributeList methodsFor: 'private'!
afterAddingToCopyLast: aNode
	observer
		ifNotNil: [observer addedAttribute: aNode]! !
!XMLAttributeList methodsFor: 'private'!
afterRemoving: aNode
	observer
		ifNotNil: [observer removedAttribute: aNode].! !
!XMLAttributeList methodsFor: 'converting'!
asDictionary
	^ self attributes! !
!XMLAttributeList methodsFor: 'accessing'!
attributeAssociations
	^ self collect: [:each | each name -> each value]! !
!XMLAttributeList methodsFor: 'accessing'!
attributeAt: aName
	^ self attributeValueAt: aName! !
!XMLAttributeList methodsFor: 'accessing'!
attributeAt: aName ifAbsent: aBlock
	^ self
		attributeValueAt: aName
		ifAbsent: aBlock! !
!XMLAttributeList methodsFor: 'accessing'!
attributeAt: aName ifAbsentPut: aBlock
	^ self
		attributeValueAt: aName
		ifAbsentPut: aBlock! !
!XMLAttributeList methodsFor: 'accessing'!
attributeAt: aName put: aValue
	^ self
		attributeValueAt: aName
		put: aValue! !
!XMLAttributeList methodsFor: 'defaults'!
attributeClass
	"Can be overridden in subclasses to use a custom attribute class"

	^ XMLAttribute
! !
!XMLAttributeList methodsFor: 'accessing'!
attributeNames
	^ self collect: [:each | each name]! !
!XMLAttributeList methodsFor: 'enumerating'!
attributeNamesAndValuesDo: aTwoArgumentBlock
	self do: [:each |
		aTwoArgumentBlock
			value: each name
			value: each value]! !
!XMLAttributeList methodsFor: 'enumerating'!
attributeNamesDo: aBlock
	self do: [:each | aBlock value: each name]! !
!XMLAttributeList methodsFor: 'accessing'!
attributeNodeAt: aName
	^ self
		attributeNodeAt: aName
		ifAbsent: [self defaultValue]! !
!XMLAttributeList methodsFor: 'accessing'!
attributeNodeAt: aName ifAbsent: aBlock
	self do: [:each |
		(each isNamed: aName)
			ifTrue: [^ each]].
	^ aBlock value.! !
!XMLAttributeList methodsFor: 'accessing'!
attributeNodeAt: aName namespaceURI: aURI
	^ self
		attributeNodeAt: aName
		namespaceURI: aURI
		ifAbsent: [self defaultValue]! !
!XMLAttributeList methodsFor: 'accessing'!
attributeNodeAt: aName namespaceURI: aURI ifAbsent: aBlock
	self do: [:each |
		((each isNamed: aName)
			and: [each namespaceURI = aURI])
			ifTrue: [^ each]].
	^ aBlock value.! !
!XMLAttributeList methodsFor: 'private'!
attributeValueAt: aName
	^ self
		attributeValueAt: aName
		ifAbsent: ['']! !
!XMLAttributeList methodsFor: 'private'!
attributeValueAt: aName ifAbsent: aBlock
	| i |

	^ (i := self indexOfAttributeValueAt: aName) > 0
		ifTrue: [(self at: i) value]
		ifFalse: [aBlock value]! !
!XMLAttributeList methodsFor: 'private'!
attributeValueAt: aName ifAbsentPut: aBlock
	^ self
		attributeValueAt: aName
		ifAbsent: [
			"use #addToCopyLast:, since we know it's not in the collection"
			(self addToCopyLast:
				(self attributeClass
					name: aName
					value: aBlock value)) value]! !
!XMLAttributeList methodsFor: 'private'!
attributeValueAt: aName put: aValue
	| i |

	(i := self indexOfAttributeValueAt: aName) > 0
		ifTrue: [(self at: i) value: aValue]
		ifFalse: [
			"use #addToCopyLast: since we know it's not already in the collection"
			self addToCopyLast:
				(self attributeClass
					name: aName
					value: aValue)].
	^ aValue.! !
!XMLAttributeList methodsFor: 'accessing'!
attributes
	| dictionary |

	dictionary := self attributesClass new: self size.
	self do: [:each |
		dictionary
			at: each name
			put: each value].
	^ dictionary.! !
!XMLAttributeList methodsFor: 'defaults'!
attributesClass
	"Can be overridden in subclasses to use a custom collection
	class for #attributes to use when returning attribute associations"

	^ OrderPreservingStringDictionary! !
!XMLAttributeList methodsFor: 'private'!
duplicateIndexOf: aNode notAt: anIndex
	"like the superclass version, but it considers nodes with
	the same name to be duplicates"
	1 to: anIndex - 1 do: [:i | | node |
		(node := collection at: i) name = aNode name
			ifTrue: [^ i]].

	anIndex + 1 to: collection size do: [:i | | node |
		(node := collection at: i) name = aNode name
			ifTrue: [^ i]].

	^ 0.! !
!XMLAttributeList methodsFor: 'testing'!
includesAttribute: aName
	^ (self indexOfAttributeValueAt: aName) > 0! !
!XMLAttributeList methodsFor: 'testing'!
includesAttributeNode: aName
	self
		attributeNodeAt: aName
		ifAbsent: [^ false].
	^ true.! !
!XMLAttributeList methodsFor: 'testing'!
includesAttributeNode: aName namespaceURI: aURI
	self
		attributeNodeAt: aName
		namespaceURI: aURI
		ifAbsent: [^ false].
	^ true.! !
!XMLAttributeList methodsFor: 'private'!
indexOfAttributeValueAt: aName
	"Returns the index of the attribute value with the exact name of aName"

	"this needs to be fast, for #attributeValueAt:... methods, so
	use #to:do: for speed"
	1 to: collection size do: [:i | | node |
		(node := collection at: i) name = aName
			ifTrue: [^ i]].
	^ 0.! !
!XMLAttributeList methodsFor: 'removing'!
removeAttribute: aName
	^ (self removeAt: (self indexOfAttributeValueAt: aName)) value! !
!XMLAttributeList methodsFor: 'removing'!
removeAttribute: aName ifAbsent: aBlock
	| i |

	(i := self indexOfAttributeValueAt: aName) > 0
		ifTrue: [^ (self removeAt: i) value]
		ifFalse: [^ aBlock value].! !
!XMLAttributeList methodsFor: 'notifying'!
renamedAttribute: anAttribute from: anOldName to: aNewName
	self
		removeDuplicateOf: anAttribute
		notAt: (self indexOf: anAttribute)! !
!XMLAttributeList methodsFor: 'initialization'!
setAttributes: anAssociationCollection
	self removeAll.
	anAssociationCollection associationsDo: [:each |
		self addAttributeAssociation: each].! !
!XMLAttributeList methodsFor: 'private'!
setAttributesFromOrderPreservingDictionary: anOrderPreservingDictionary
	"This should only be sent by DOM parsers/builders, not public API users"
	| orderedKeys |

	"Add the XMLAttributes in order directly to the collection to avoid
	sending notifications that would do unneeded, costly namespace prefix
	revalidation.
	Use the internal #orderedKeys with #to:do: to create an inlined #keysDo:
	without block closure overhead."
	orderedKeys := anOrderPreservingDictionary orderedKeys.
	1 to: anOrderPreservingDictionary size do: [:i | | key |
		key := orderedKeys at: i.
		collection addLast: 
			(self attributeClass new
				setName: key
				value:
					"use dictionary at:ifAbsent: for speed over at:"
					(anOrderPreservingDictionary
						at: key
						ifAbsent: nil)
				element: observer)].! !
!XMLAttributeList methodsFor: 'sorting'!
sort
	self sort: [:a :b | a sortKey <= b sortKey]! !
!XMLAttributeList methodsFor: 'private'!
writeAttributesOn: aWriter
	"use #to:do: with direct access for fast writing"
	1 to: collection size do: [:i | | attribute |
		attribute := collection at: i.
		aWriter
			writeAttributeName: attribute name
			value: attribute value]! !
!XMLAttributeList methodsFor: 'private'!
writeCanonicalAttributesOn: aWriter
	| sortedAttributes |

	(sortedAttributes := self asArray) sort: [:a :b | | prefixOfA prefixOfB |
		prefixOfA := a prefix.
		prefixOfB := b prefix.
		prefixOfA = prefixOfB
			ifTrue: [
				(a name xmlLocalNameAfterPrefix: prefixOfA)
					<= (b name xmlLocalNameAfterPrefix: prefixOfB)]
			ifFalse: [| uriOfA uriOfB |
				"the namespace URI is the primary key and
				the local name is the secondary key"
				uriOfA := a resolvePrefix: prefixOfA.
				uriOfB := b resolvePrefix: prefixOfB.
				uriOfA < uriOfB
					or: [
						uriOfA = uriOfB
							and: [
								(a name xmlLocalNameAfterPrefix: prefixOfA)
									<= (b name xmlLocalNameAfterPrefix: prefixOfB)]]]].

	"use #to:do: for fast writing"
	1 to: sortedAttributes size do: [:i | | attribute |
		attribute := sortedAttributes at: i.
		aWriter
			writeAttributeName: attribute name
			value: attribute value].! !
!XMLCachingAttributeList methodsFor: 'private'!
afterAdding: aNode at: anIndex
	self attributeNodesByName
		at: aNode name ifPresent: [:duplicate |
			self
				removeDuplicateOf: aNode
				notAt: anIndex.
			duplicate = aNode
				ifTrue: [^ self]];
		at: aNode name put: aNode.
	observer
		ifNotNil: [observer addedAttribute: aNode].! !
!XMLCachingAttributeList methodsFor: 'private'!
afterAddingLast: aNode
	self attributeNodesByName
		at: aNode name ifPresent: [:duplicate |
			self
				removeDuplicateOf: aNode
				notAt: self size.
			duplicate = aNode
				ifTrue: [^ self]];
		at: aNode name put: aNode.
	observer
		ifNotNil: [observer addedAttribute: aNode].! !
!XMLCachingAttributeList methodsFor: 'private'!
afterAddingToCopyLast: aNode
	self attributeNodesByName
		at: aNode name
		put: aNode.
	observer
		ifNotNil: [observer addedAttribute: aNode].! !
!XMLCachingAttributeList methodsFor: 'private'!
afterRemoving: aNode
	self attributeNodesByName removeKey: aNode name.
	observer
		ifNotNil: [observer removedAttribute: aNode].! !
!XMLCachingAttributeList methodsFor: 'private'!
attributeNodesByName
	^ attributeNodesByName
		ifNil: [attributeNodesByName := Dictionary new: self capacity]! !
!XMLCachingAttributeList methodsFor: 'private'!
attributeValueAt: aName ifAbsent: aBlock
	^ (self attributeNodesByName
		at: aName
		ifAbsent: [^ aBlock value]) value! !
!XMLCachingAttributeList methodsFor: 'private'!
attributeValueAt: aName put: aValue
	(self attributeNodesByName
		at: aName
		ifAbsent: [
			"use #addToCopyLast: since we know it's not already in the collection"
			self addToCopyLast:
				(self attributeClass
					name: aName
					value: aValue).
			^ aValue]) value: aValue.
	^ aValue.! !
!XMLCachingAttributeList methodsFor: 'defaults'!
copyClass
	"use the non-caching superclass for copies for performance"
	^ XMLAttributeList! !
!XMLCachingAttributeList methodsFor: 'testing'!
includes: aNode
	^ aNode isAttribute
		and: [
			(self attributeNodesByName
				at: aNode name
				ifAbsent: [^ false]) = aNode]! !
!XMLCachingAttributeList methodsFor: 'testing'!
includesAttribute: aName
	^ self attributeNodesByName includesKey: aName! !
!XMLCachingAttributeList methodsFor: 'private'!
indexOfAttributeValueAt: aName
	^ (self attributeNodesByName includesKey: aName)
		ifTrue: [super indexOfAttributeValueAt: aName]
		ifFalse: [0]! !
!XMLCachingAttributeList methodsFor: 'removing'!
removeAttribute: aName
	^ (self remove: (self attributeNodesByName at: aName)) value! !
!XMLCachingAttributeList methodsFor: 'removing'!
removeAttribute: aName ifAbsent: aBlock
	^ (self remove:
		(self attributeNodesByName
			at: aName
			ifAbsent: [^ aBlock value])) value! !
!XMLCachingAttributeList methodsFor: 'notifying'!
renamedAttribute: anAttribute from: anOldName to: aNewName
	self attributeNodesByName
		removeKey: anOldName;
		at: aNewName ifPresent: [:duplicate |
			self
				removeDuplicateOf: anAttribute
				notAt: (self indexOf: anAttribute)];
		at: aNewName put: anAttribute! !
!XMLCachingAttributeList methodsFor: 'private'!
setAttributesFromOrderPreservingDictionary: anOrderPreservingDictionary
	"This should only be sent by DOM parsers/builders, not public API users"
	| orderedKeys |

	"Hack to reuse its internal dictionary for speed, which we will
	modify the association values of. This is safe because the DOM
	parser/builder will never use it again."
	attributeNodesByName := anOrderPreservingDictionary dictionary.

	"Add the XMLAttributes in order directly to the collection to avoid
	sending notifications that would do unneeded, costly namespace prefix
	revalidation and also replace the value in the attributeNodesByName
	association with the new XMLAttribute.
	Use the internal #orderedKeys with #to:do: to create an inlined #keysDo:
	without block closure overhead."
	orderedKeys := anOrderPreservingDictionary orderedKeys.
	1 to: anOrderPreservingDictionary size do: [:i | | key association |
		key := orderedKeys at: i.
		"use associationAt:ifAbsent: for speed over associationAt:"
		association :=
			attributeNodesByName
				associationAt: key
				ifAbsent: nil.
		"replace its string value with the new XMLAttribute"
		association value:
			(collection addLast: 
				(self attributeClass new
					setName: key
					value: association value
					element: observer))].! !
!XMLInternalSubsetList methodsFor: 'private'!
afterAdding: aNode at: anIndex
	(aNode hasParentWithNodeList: self)
		ifTrue: [
			self
				removeDuplicateOf: aNode
				notAt: anIndex]
		ifFalse: [
			observer
				ifNotNil: [observer addedNode: aNode]]! !
!XMLInternalSubsetList methodsFor: 'private'!
afterAddingLast: aNode
	(aNode hasParentWithNodeList: self)
		ifTrue: [
			self
				removeDuplicateOf: aNode
				notAt: self size]
		ifFalse: [
			observer
				ifNotNil: [observer addedNode: aNode]]! !
!XMLInternalSubsetList methodsFor: 'private'!
afterAddingToCopyLast: aNode
	observer
		ifNotNil: [observer addedNode: aNode]! !
!XMLInternalSubsetList methodsFor: 'private'!
afterRemoving: aNode
	observer ifNotNil: [observer removedNode: aNode]! !
!XMLInternalSubsetList methodsFor: 'sorting'!
sort
	self sort: [:a :b | a sortKey <= b sortKey]! !
!XMLCachingNodeList methodsFor: 'private'!
afterAdding: aNode at: anIndex
	(aNode hasParentWithNodeList: self)
		ifTrue: [
			self
				removeDuplicateOf: aNode
				notAt: anIndex.
			aNode isElement
				ifTrue: [self rebuildCachedElements]]
		ifFalse: [
			aNode isElement
				ifTrue: [
					self
						cacheElement: aNode
						addedAt: anIndex].
			observer
				ifNotNil: [observer addedNode: aNode]]! !
!XMLCachingNodeList methodsFor: 'private'!
afterAddingLast: aNode
	(aNode hasParentWithNodeList: self)
		ifTrue: [
			self
				removeDuplicateOf: aNode
				notAt: self size.
			aNode isElement
				ifTrue: [self rebuildCachedElements]]
		ifFalse: [
			aNode isElement
				ifTrue: [self cacheElementAddedLast: aNode].
			observer
				ifNotNil: [observer addedNode: aNode]]! !
!XMLCachingNodeList methodsFor: 'private'!
afterAddingToCopyLast: aNode
	aNode isElement
		ifTrue: [self cacheElementAddedLast: aNode].
	observer
		ifNotNil: [observer addedNode: aNode].! !
!XMLCachingNodeList methodsFor: 'private'!
afterRemoving: aNode
	aNode isElement
		ifTrue: [self uncacheElement: aNode].
	observer
		ifNotNil: [observer removedNode: aNode].! !
!XMLCachingNodeList methodsFor: 'private'!
cacheElement: anElement addedAt: anIndex
	anIndex = self size
		ifTrue: [^ self cacheElementAddedLast: anElement].

	(self findElementAfterIndex: anIndex)
		ifNil: [self cachedElements addLast: anElement]
		ifNotNil: [:elementAfter |
			self cachedElements
				add: anElement
				before: elementAfter].
	self
		cachedElementsByNameAt: anElement name
		add: anElement
		beforeNextAfterIndex: anIndex.
	anElement hasPrefix
		ifTrue: [
			self
				cachedElementsByNameAt: anElement localName
				add: anElement
				beforeNextAfterIndex: anIndex].! !
!XMLCachingNodeList methodsFor: 'private'!
cacheElementAddedLast: anElement
	self cachedElements addLast: anElement.
	self
		cachedElementsByNameAt: anElement name
		addLast: anElement.
	anElement hasPrefix
		ifTrue: [
			self
				cachedElementsByNameAt: anElement localName
				addLast: anElement].! !
!XMLCachingNodeList methodsFor: 'private'!
cachedElements
	^ cachedElements ifNil: [cachedElements := OrderedCollection new]! !
!XMLCachingNodeList methodsFor: 'private'!
cachedElementsByName
	^ cachedElementsByName ifNil: [cachedElementsByName := Dictionary new]! !
!XMLCachingNodeList methodsFor: 'private'!
cachedElementsByNameAt: aName add: anElement beforeNextAfterIndex: anIndex
	| elementAfter elementsWithName |

	(elementAfter :=
		self
			findElementAfterIndex: anIndex
			named: aName)
		ifNil: [
			^ self
				cachedElementsByNameAt: aName
				addLast: anElement].

	(elementsWithName := self cachedElementsByName at: aName) isCollection
		ifTrue: [elementsWithName add: anElement before: elementAfter]
		ifFalse: [
			self cachedElementsByName
				at: aName
				put: (OrderedCollection with: anElement with: elementAfter)].! !
!XMLCachingNodeList methodsFor: 'private'!
cachedElementsByNameAt: aName addLast: anElement
	| elementsWithName |

	elementsWithName :=
		self cachedElementsByName
			at: aName
			ifAbsent: [
				self cachedElementsByName at: aName put: anElement.
				^ self].

	 elementsWithName isCollection
		ifTrue: [elementsWithName addLast: anElement]
		ifFalse: [
			self cachedElementsByName
				at: aName
				put: (OrderedCollection with: elementsWithName with: anElement)].! !
!XMLCachingNodeList methodsFor: 'private'!
cachedElementsByNameAt: aName remove: anElement
	| elementsWithName |

	(elementsWithName := self cachedElementsByName at: aName) isCollection
		ifTrue: [
			elementsWithName remove: anElement.
			elementsWithName isEmpty
				ifTrue: [self cachedElementsByName removeKey: aName]]
		ifFalse: [self cachedElementsByName removeKey: aName]! !
!XMLCachingNodeList methodsFor: 'defaults'!
copyClass
	"use the non-caching superclass for copies for performance"
	^ XMLNodeList! !
!XMLCachingNodeList methodsFor: 'accessing'!
elementAt: aName ifAbsent: aBlock
	| elementsWithName |

	(elementsWithName :=
		self cachedElementsByName
			at: aName
			ifAbsent: [^ aBlock value]) isCollection
		ifTrue: [^ elementsWithName first]
		ifFalse: [^ elementsWithName]! !
!XMLCachingNodeList methodsFor: 'accessing'!
elements
	^ self copyEmpty
		addAll: self cachedElements;
		yourself! !
!XMLCachingNodeList methodsFor: 'accessing'!
elementsAt: aName
	| elementsWithName copiedElements |

	copiedElements := self copyEmpty.
	(elementsWithName :=
		self cachedElementsByName
			at: aName
			ifAbsent: [^ copiedElements]) isCollection
		ifTrue: [
			elementsWithName do: [:each |
				copiedElements addToCopyLast: each]]
		ifFalse: [
			copiedElements addToCopyLast: elementsWithName].
	^ copiedElements.! !
!XMLCachingNodeList methodsFor: 'enumerating'!
elementsAt: aName do: aBlock
	| elementsWithName |

	(elementsWithName :=
		self cachedElementsByName
			at: aName
			ifAbsent: [^ self]) isCollection
		ifTrue: [elementsWithName do: aBlock]
		ifFalse: [aBlock value: elementsWithName]! !
!XMLCachingNodeList methodsFor: 'enumerating'!
elementsDo: aBlock
	self cachedElements do: aBlock! !
!XMLCachingNodeList methodsFor: 'private'!
findElementAfterIndex: anIndex
	anIndex + 1 to: self size do: [:i | | node |
		node := self at: i.
		node isElement
			ifTrue: [^ node]].
	^ nil.! !
!XMLCachingNodeList methodsFor: 'private'!
findElementAfterIndex: anIndex named: aName
	anIndex + 1 to: self size do: [:i | | node |
		node := self at: i.
		(node isElement
			and: [node isNamed: aName])
			ifTrue: [^ node]].
	^ nil.! !
!XMLCachingNodeList methodsFor: 'accessing'!
firstElement
	^ self cachedElements
		at: 1
		ifAbsent: [self defaultValue]! !
!XMLCachingNodeList methodsFor: 'testing'!
hasElements
	^ cachedElements notNil and: [cachedElements notEmpty]! !
!XMLCachingNodeList methodsFor: 'testing'!
includesElement: aName
	^ self cachedElementsByName includesKey: aName! !
!XMLCachingNodeList methodsFor: 'accessing'!
lastElement
	^ self cachedElements
		at: self cachedElements size
		ifAbsent: [self defaultValue]! !
!XMLCachingNodeList methodsFor: 'private'!
rebuildCachedElements
	self cachedElements removeAll.
	self cachedElementsByName removeAll.
	self do: [:each |
		each isElement
			ifTrue: [self cacheElementAddedLast: each]].! !
!XMLCachingNodeList methodsFor: 'notifying'!
renamedElement: anElement from: anOldName to: aNewName
	| oldPrefix index |

	self
		cachedElementsByNameAt: anOldName
		remove: anElement.
	(oldPrefix := anOldName xmlPrefixBeforeLocalName) notEmpty
		ifTrue: [
			self
				cachedElementsByNameAt: (anOldName xmlLocalNameAfterPrefix: oldPrefix)
				remove: anElement].
	index := self indexOf: anElement.
	self
		cachedElementsByNameAt: anElement name
		add: anElement
		beforeNextAfterIndex: index.
	anElement hasPrefix
		ifTrue: [
			self
				cachedElementsByNameAt: anElement localName
				add: anElement
				beforeNextAfterIndex: index].! !
!XMLCachingNodeList methodsFor: 'sorting'!
sort: aSortBlock
	super sort: aSortBlock.

	self cachedElements sort: aSortBlock.
	self cachedElementsByName valuesDo: [:each |
		each isCollection
			ifTrue: [each sort: aSortBlock]].! !
!XMLCachingNodeList methodsFor: 'accessing'!
swap: aFirstIndex with: aSecondIndex
	super swap: aFirstIndex with: aSecondIndex.

	((self at: aFirstIndex) isElement
		or: [(self at: aSecondIndex) isElement])
		ifTrue: [self rebuildCachedElements].! !
!XMLCachingNodeList methodsFor: 'private'!
uncacheElement: anElement
	self cachedElements remove: anElement.
	self
		cachedElementsByNameAt: anElement name
		remove: anElement.
	anElement hasPrefix
		ifTrue: [
			self
				cachedElementsByNameAt: anElement localName
				remove: anElement].! !
!XMLNodeList class methodsFor: 'instance creation'!
new
	^ self new: 5! !
!XMLNodeList methodsFor: 'private'!
afterAdding: aNode at: anIndex
	(aNode hasParentWithNodeList: self)
		ifTrue: [
			self
				removeDuplicateOf: aNode
				notAt: anIndex]
		ifFalse: [
			observer
				ifNotNil: [observer addedNode: aNode]]! !
!XMLNodeList methodsFor: 'private'!
afterAddingLast: aNode
	(aNode hasParentWithNodeList: self)
		ifTrue: [
			self
				removeDuplicateOf: aNode
				notAt: self size]
		ifFalse: [
			observer
				ifNotNil: [observer addedNode: aNode]]! !
!XMLNodeList methodsFor: 'private'!
afterAddingToCopyLast: aNode
	observer
		ifNotNil: [observer addedNode: aNode]! !
!XMLNodeList methodsFor: 'private'!
afterRemoving: aNode
	observer
		ifNotNil: [observer removedNode: aNode]! !
!XMLNodeList methodsFor: 'accessing'!
contentNodes
	^ self select: [:each | each isContentNode]! !
!XMLNodeList methodsFor: 'enumerating'!
contentNodesDo: aBlock
	self do: [:each |
		each isContentNode
			ifTrue: [aBlock value: each]]! !
!XMLNodeList methodsFor: 'accessing'!
contentStringAt: aName
	^ (self
		elementAt: aName
		ifAbsent: [^ '']) contentString! !
!XMLNodeList methodsFor: 'accessing'!
elementAfter: anElement
	| last |

	self elementsDo: [:each |
		last = anElement
			ifTrue: [^ each].
		last := each].
	^ self defaultValue.! !
!XMLNodeList methodsFor: 'accessing'!
elementAt: aName
	^ self
		elementAt: aName
		ifAbsent: [self defaultValue]! !
!XMLNodeList methodsFor: 'accessing'!
elementAt: aName ifAbsent: aBlock
	self elementsDo: [:each |
		(each isNamed: aName)
			ifTrue: [^ each]].
	^ aBlock value.! !
!XMLNodeList methodsFor: 'accessing'!
elementAt: aName namespaceURI: aURI
	^ self
		elementAt: aName
		namespaceURI: aURI
		ifAbsent: [self defaultValue]! !
!XMLNodeList methodsFor: 'accessing'!
elementAt: aName namespaceURI: aURI ifAbsent: aBlock
	self
		elementsAt: aName
		do: [:each |
			each namespaceURI = aURI
				ifTrue: [^ each]].
	^ aBlock value.! !
!XMLNodeList methodsFor: 'accessing'!
elementBefore: anElement
	| last |

	last := self defaultValue.
	self elementsDo: [:each |
		each = anElement
			ifTrue: [^ last].
		last := each].
	^ self defaultValue.! !
!XMLNodeList methodsFor: 'accessing'!
elementNames
	^ self elementsCollect: [:each | each name]! !
!XMLNodeList methodsFor: 'accessing'!
elements
	^ self select: [:each | each isElement]! !
!XMLNodeList methodsFor: 'accessing'!
elementsAt: aName
	^ self elementsSelect: [:each | each isNamed: aName]! !
!XMLNodeList methodsFor: 'enumerating'!
elementsAt: aName do: aBlock
	self elementsDo: [:each |
		(each isNamed: aName)
			ifTrue: [aBlock value: each]]! !
!XMLNodeList methodsFor: 'accessing'!
elementsAt: aName namespaceURI: aURI
	^ self elementsSelect: [:each |
		(each isNamed: aName)
			and: [each namespaceURI = aURI]]! !
!XMLNodeList methodsFor: 'enumerating'!
elementsCollect: aBlock
	| collectedElements |

	"implementing with #elementsDo: benefits the caching subclass because
	of its fast #elementsDo: implementation"
	collectedElements := self copyEmptyForCollect.
	self elementsDo: [:each |
		collectedElements addLast: (aBlock value: each)].
	^ collectedElements.! !
!XMLNodeList methodsFor: 'enumerating'!
elementsDetect: aBlock
	^ self
		elementsDetect: aBlock
		ifNone: [self defaultValue]! !
!XMLNodeList methodsFor: 'enumerating'!
elementsDetect: aBlock ifNone: anExceptionBlock
	"implementing with #elementsDo: benefits the caching subclass because
	of its fast #elementsDo: implementation"
	self elementsDo: [:each |
		(aBlock value: each)
			ifTrue: [^ each]].
	^ anExceptionBlock value.! !
!XMLNodeList methodsFor: 'enumerating'!
elementsDo: aBlock
	"use #to:do: for performance, because so many methods rely on this"
	1 to: collection size do: [:i | | node |
		(node := collection at: i) isElement
			ifTrue: [aBlock value: node]]! !
!XMLNodeList methodsFor: 'enumerating'!
elementsSelect: aBlock
	| selectedElements |

	"implementing with #elementsDo: benefits the caching subclass because
	of its fast #elementsDo: implementation"
	selectedElements := self copyEmpty.
	self elementsDo: [:each |
		(aBlock value: each)
			ifTrue: [selectedElements addToCopyLast: each]].
	^ selectedElements.! !
!XMLNodeList methodsFor: 'accessing'!
firstElement
	self elementsDo: [:each | ^ each].
	^ self defaultValue.! !
!XMLNodeList methodsFor: 'testing'!
hasContentNodes
	^ self anySatisfy: [:each | each isContentNode]! !
!XMLNodeList methodsFor: 'testing'!
hasElements
	^ self anySatisfy: [:each | each isElement]! !
!XMLNodeList methodsFor: 'testing'!
hasStringNodes
	^ self anySatisfy: [:each | each isStringNode]! !
!XMLNodeList methodsFor: 'testing'!
includesElement: aName
	self
		elementAt: aName
		ifAbsent: [^ false].
	^ true.! !
!XMLNodeList methodsFor: 'testing'!
includesElement: aName namespaceURI: aURI
	self
		elementAt: aName
		namespaceURI: aURI
		ifAbsent: [^ false].
	^ true.! !
!XMLNodeList methodsFor: 'accessing'!
lastElement
	self reverseDo: [:each |
		each isElement
			ifTrue: [^ each]].
	^ self defaultValue.! !
!XMLNodeList methodsFor: 'accessing'!
rawContentStringAt: aName
	^ (self
		elementAt: aName
		ifAbsent: [^ '']) rawContentString! !
!XMLNodeList methodsFor: 'notifying'!
renamedElement: anElement from: anOldName to: aNewName! !
!XMLNodeList methodsFor: 'sorting'!
sort
	self sort: [:a :b | a sortKey <= b sortKey]! !
!XMLNodeList methodsFor: 'accessing'!
stringNodes
	^ self select: [:each | each isStringNode]! !
!XMLNodeList methodsFor: 'enumerating'!
stringNodesDo: aBlock
	self do: [:each |
		each isStringNode
			ifTrue: [aBlock value: each]]! !
!XMLNodeList methodsFor: 'accessing'!
strings
	^ self
		select: [:each | each isStringNode]
		thenCollect: [:each | each string]! !
!XMLNodeList methodsFor: 'enumerating'!
stringsDo: aBlock
	self stringNodesDo: [:each | aBlock value: each string]! !
!XMLObservableList class methodsFor: 'instance creation'!
observer: anObserver
	^ self new observer: anObserver! !
!XMLObservableList class methodsFor: 'instance creation'!
ofSize: aSize
	self shouldNotImplement! !
!XMLObservableList methodsFor: 'adding'!
add: anObject after: aPreviousObject
	^ self
		add: anObject
		afterIndex:
			(collection
				indexOf: aPreviousObject
				ifAbsent: [-1])! !
!XMLObservableList methodsFor: 'adding'!
add: anObject afterIndex: anIndex
	collection
		add: anObject
		afterIndex: anIndex.
	self
		afterAdding: anObject
		at: anIndex + 1.
	^ anObject.! !
!XMLObservableList methodsFor: 'adding'!
add: anObject before: aNextObject
	^ self
		add: anObject
		beforeIndex:
			(collection
				indexOf: aNextObject
				ifAbsent: [-1])! !
!XMLObservableList methodsFor: 'adding'!
add: anObject beforeIndex: anIndex
	collection
		add: anObject
		beforeIndex: anIndex.
	self
		afterAdding: anObject
		at: anIndex.
	^ anObject.! !
!XMLObservableList methodsFor: 'adding'!
addFirst: anObject
	collection addFirst: anObject.
	self afterAdding: anObject at: 1.
	^ anObject.! !
!XMLObservableList methodsFor: 'adding'!
addLast: anObject
	collection addLast: anObject.
	self afterAddingLast: anObject.
	^ anObject.! !
!XMLObservableList methodsFor: 'private'!
addToCopyLast: anObject
	collection addLast: anObject.
	self afterAddingToCopyLast: anObject.
	^ anObject.! !
!XMLObservableList methodsFor: 'private'!
afterAdding: anObject at: anIndex
	observer
		ifNotNil: [
			observer
				added: anObject
				to: self]! !
!XMLObservableList methodsFor: 'private'!
afterAddingLast: anObject
	"can be used to handle appending separately and more efficiently than
	insertion"

	self
		afterAdding: anObject
		at: self size! !
!XMLObservableList methodsFor: 'private'!
afterAddingToCopyLast: anObject
	"can be used to handle appending existing elements to a copy separately and
	more efficiently than #afterAddingLast: so not as much checking needs to be
	done (because no new elements are being added to the copy)"

	self afterAddingLast: anObject! !
!XMLObservableList methodsFor: 'private'!
afterRemoving: anObject
	observer
		ifNotNil: [
			observer
				removed: anObject
				from: self]! !
!XMLObservableList methodsFor: 'accessing'!
at: anIndex put: anObject
	| oldObject |

	"Gemstone's OrderedCollection>>#at:put: allows the index to be
	just after the last, treating it like addLast:, so this is needed
	for compatbility"
	anIndex = (self size + 1)
		ifTrue: [^ self addLast: anObject].

	"this will raise an error if the index is invalid"
	oldObject := collection at: anIndex.

	"remove the old object and notify any observer"
	collection at: anIndex put: nil.
	oldObject
		ifNotNil: [self afterRemoving: oldObject].
	
	"now add the new object and notify any observer"
	collection at: anIndex put: anObject.
	self
		afterAdding: anObject
		at: anIndex.

	^ anObject.! !
!XMLObservableList methodsFor: 'private'!
duplicateIndexOf: anObject notAt: anIndex
	"to:do: for speed because some subclasses need this to be fast"
	1 to: anIndex - 1 do: [:i |
		(collection at: i) = anObject
			ifTrue: [^ i]].

	"to:do: for speed because some subclasses need this to be fast"
	anIndex + 1 to: collection size do: [:i |
		(collection at: i) = anObject
			ifTrue: [^ i]].

	^ 0.! !
!XMLObservableList methodsFor: 'observing'!
observer
	^ observer! !
!XMLObservableList methodsFor: 'observing'!
observer: anObserver
	observer := anObserver! !
!XMLObservableList methodsFor: 'removing'!
remove: anObject ifAbsent: aBlock
	collection remove: anObject ifAbsent: [^ aBlock value].
	self afterRemoving: anObject.
	^ anObject.! !
!XMLObservableList methodsFor: 'removing'!
removeAt: anIndex
	| removed |

	removed := super removeAt: anIndex.
	self afterRemoving: removed.
	^ removed.! !
!XMLObservableList methodsFor: 'private'!
removeDuplicateOf: anObject notAt: anIndex
	"Removes a duplicate of anObject at any index besides anIndex and
	returns the removed duplicate or nil if there isn't one."

	| duplicateIndex |

	(duplicateIndex := 
		self
			duplicateIndexOf: anObject
			notAt: anIndex) > 0
		ifTrue: [| duplicate |
			(duplicate := collection removeAt: duplicateIndex) = anObject
				ifFalse: [
					"subclasses may implement #duplicateIndexOf:notAt: to test
					for duplicates not with #=, so 'duplicate' can be a
					distinct object from 'anObject' that's been removed"
					self afterRemoving: duplicate].
			^ duplicate]
		ifFalse: [^ nil]! !
!XMLObservableList methodsFor: 'removing'!
reset
	| removed |

	removed := collection copy.
	collection reset.
	removed reverseDo: [:each |
		self afterRemoving: each].! !
!XMLOrderedList class methodsFor: 'private'!
collection: aCollection
	^ self basicNew setCollection: aCollection! !
!XMLOrderedList class methodsFor: 'defaults'!
collectionClass
	^ OrderedCollection! !
!XMLOrderedList class methodsFor: 'inspecting'!
inspectorClass
	"for pre-GTInspector Pharo"
	^ self collectionClass inspectorClass! !
!XMLOrderedList class methodsFor: 'instance creation'!
new
	^ self new: 10! !
!XMLOrderedList class methodsFor: 'instance creation'!
new: aCapacity
	^ self basicNew setCollection: (self collectionClass new: aCapacity)! !
!XMLOrderedList class methodsFor: 'instance creation'!
new: aSize withAll: anObject
	| newList |

	"reimplement for portability"
	newList := self new: aSize.
	1 to: aSize do: [:i | newList addLast: anObject].
	^ newList.! !
!XMLOrderedList class methodsFor: 'instance creation'!
newFrom: aCollection
	^ (self new: aCollection size)
		addAll: aCollection;
		yourself! !
!XMLOrderedList class methodsFor: 'instance creation'!
ofSize: aSize
	^ self new: aSize withAll: nil! !
!XMLOrderedList methodsFor: 'copying'!
, aCollection
	"GS doesn't define #, for non-Sequenceable collections"
	^ self copy
		addAll: aCollection;
		yourself! !
!XMLOrderedList methodsFor: 'comparing'!
= anObject
	"Returns true if anObject is any kind of XMLOrderedList (not just the
	class of the receiver) and it and the receiver have the same items
	in the same order."

	self == anObject
		ifTrue: [^ true].

	(self species == anObject species
		and: [collection size = anObject size])
		ifFalse: [^ false].

	"Test each position with #= using #to:do: for speed instead of
	just 'collection = anObject collection' because that would
	make equality depend on the internal collection types instead
	of just their items."
	1 to: collection size do: [:i |
		(collection at: i) = (anObject at: i)
			ifFalse: [^ false]].

	^ true.! !
!XMLOrderedList methodsFor: 'adding'!
add: anObject
	^ self addLast: anObject! !
!XMLOrderedList methodsFor: 'adding'!
add: anObject after: aPreviousObject
	^ collection add: anObject after: aPreviousObject! !
!XMLOrderedList methodsFor: 'adding'!
add: anObject afterIndex: anIndex
	^ collection add: anObject afterIndex: anIndex! !
!XMLOrderedList methodsFor: 'adding'!
add: anObject before: aNextObject
	^ collection add: anObject before: aNextObject! !
!XMLOrderedList methodsFor: 'adding'!
add: anObject beforeIndex: anIndex
	^ collection add: anObject beforeIndex: anIndex! !
!XMLOrderedList methodsFor: 'adding'!
addAll: aCollection
	^ self addAllLast: aCollection! !
!XMLOrderedList methodsFor: 'adding'!
addAllFirst: aCollection
	aCollection reverseDo: [:each | self addFirst: each].
	^ aCollection.! !
!XMLOrderedList methodsFor: 'adding'!
addAllLast: aCollection
	aCollection do: [:each | self addLast: each].
	^ aCollection.! !
!XMLOrderedList methodsFor: 'adding'!
addFirst: anObject
	^ collection addFirst: anObject! !
!XMLOrderedList methodsFor: 'adding'!
addLast: anObject
	^ collection addLast: anObject! !
!XMLOrderedList methodsFor: 'private'!
addToCopyLast: anObject
	"this is used to efficiently append to copies for methods like #copy,
	#copyWithout:, #select:, and #reject: that create copies with no new elements
	(only old ones) so duplicate or other constraint checking can be skipped
	by subclasses"

	^ collection addLast: anObject! !
!XMLOrderedList methodsFor: 'accessing'!
after: anObject
	^ self after: anObject ifAbsent: [self defaultValue]! !
!XMLOrderedList methodsFor: 'accessing'!
after: anObject ifAbsent: aBlock
	^ collection after: anObject ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
allButFirst
	^ self allButFirst: 1! !
!XMLOrderedList methodsFor: 'accessing'!
allButFirst: anInteger
	^ self copyFrom: anInteger + 1 to: self size! !
!XMLOrderedList methodsFor: 'enumerating'!
allButFirstDo: aBlock
	"reimplemented for portability"
	2 to: collection size do: [:i |
		aBlock value: (collection at: i)]! !
!XMLOrderedList methodsFor: 'accessing'!
allButLast
	^ self allButLast: 1! !
!XMLOrderedList methodsFor: 'accessing'!
allButLast: anInteger
	^ self copyFrom: 1 to: self size - anInteger! !
!XMLOrderedList methodsFor: 'enumerating'!
allButLastDo: aBlock
	"reimplemented for portability"
	1 to: collection size - 1 do: [:i |
		aBlock value: (collection at: i)]! !
!XMLOrderedList methodsFor: 'accessing'!
anyOne
	^ self first! !
!XMLOrderedList methodsFor: 'converting'!
asArray
	"use withAll: not newFrom: for portability"
	^ Array withAll: collection! !
!XMLOrderedList methodsFor: 'converting'!
asOrderedCollection
	"use withAll: not newFrom: for portability"
	^ OrderedCollection withAll: collection! !
!XMLOrderedList methodsFor: 'converting'!
asString
	"don't assume Object>>#asString is defined, for portability"
	^ self printString! !
!XMLOrderedList methodsFor: 'accessing'!
at: anIndex
	"optimized"
	(anIndex > 0 and: [anIndex <= collection size])
		ifTrue: [^ collection at: anIndex]
		ifFalse: [^ self defaultValue]! !
!XMLOrderedList methodsFor: 'accessing'!
at: anIndex ifAbsent: aBlock
	^ collection at: anIndex ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
at: anIndex put: aValue
	"treats index = size + 1 as addLast: gemstone compatibility"
	anIndex = (collection size + 1)
		ifTrue: [^ collection addLast: aValue]
		ifFalse: [^ collection at: anIndex put: aValue]! !
!XMLOrderedList methodsFor: 'accessing'!
atLast: anIndexFromEnd
	^ self atLast: anIndexFromEnd ifAbsent: [self defaultValue]! !
!XMLOrderedList methodsFor: 'accessing'!
atLast: anIndexFromEnd ifAbsent: aBlock
	^ collection atLast: anIndexFromEnd ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
before: anObject
	^ self before: anObject ifAbsent: [self defaultValue]! !
!XMLOrderedList methodsFor: 'accessing'!
before: anObject ifAbsent: aBlock
	 ^ collection before: anObject ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'testing'!
beginsWith: aCollection
	^ collection beginsWith: aCollection! !
!XMLOrderedList methodsFor: 'accessing'!
capacity
	^ collection capacity! !
!XMLOrderedList methodsFor: 'enumerating'!
collect: aBlock
	| collected |

	collected := self copyEmptyForCollect.
	"use #to:do: for speed"
	1 to: collection size do: [:i |
		collected addLast: (aBlock value: (collection at: i))].
	^ collected.! !
!XMLOrderedList methodsFor: 'enumerating'!
collect: aCollectBlock thenSelect: aSelectBlock
	| selected |

	selected := self copyEmpty.
	"use #to:do: for speed"
	1 to: collection size do: [:i | | item |
		item := aCollectBlock value: (collection at: i).
		(aSelectBlock value: item)
			ifTrue: [selected addLast: item]].
	^ selected.! !
!XMLOrderedList methodsFor: 'private'!
collection
	^ collection! !
!XMLOrderedList methodsFor: 'copying'!
copy
	| copy |

	copy := self copyEmpty.
	"use #to:do: for speed with direct access"
	1 to: collection size do: [:i |
		copy addToCopyLast: (collection at: i)].
	^ copy.! !
!XMLOrderedList methodsFor: 'copying'!
copyAfter: anObject
	| copy |

	copy := self copyEmpty.
	(self
		indexOf: anObject
		ifAbsent: [^ copy]) + 1
			to: self size
			do: [:i | copy addToCopyLast: (self at: i)].
	^ copy.! !
!XMLOrderedList methodsFor: 'copying'!
copyAfterLast: anObject
	| copy |

	copy := self copyEmpty.
	(self
		lastIndexOf: anObject
		ifAbsent: [^ copy]) + 1
			to: self size
			do: [:i | copy addToCopyLast: (self at: i)].
	^ copy.! !
!XMLOrderedList methodsFor: 'defaults'!
copyClass
	"the class to use for copies"
	^ self class! !
!XMLOrderedList methodsFor: 'copying'!
copyEmpty
	^ self copyClass collection: collection copyEmpty! !
!XMLOrderedList methodsFor: 'private'!
copyEmptyForCollect
	"collect: methods return instances of the generic ordered list species class
	because a collect block can return any value, which may not be appropiate to
	store in copies of particular subclasses (like XMLNodeList)"

	^ self species new: self size! !
!XMLOrderedList methodsFor: 'copying'!
copyFrom: aStart to: anEnd
	| copy |

	copy := self copyEmpty.
	(aStart max: 1)
		to: (anEnd min: self size)
		do: [:i | copy addToCopyLast: (self at: i)].
	^ copy.! !
!XMLOrderedList methodsFor: 'copying'!
copyReplaceAll: aSearchCollection with: aReplacementCollection
	| copy index size searchCollectionSize |

	"this implementation always returns a copy, even if it doesn't replace"
	(searchCollectionSize := aSearchCollection size) > 0
		ifFalse: [^ self copy].

	copy := self copyEmpty.
	index := 1.
	size := self size.
	[index <= size]
		whileTrue: [
			(self at: index) = (aSearchCollection at: 1)
				ifTrue: [| searchCollectionIndex |
					searchCollectionIndex := 2.
					[searchCollectionIndex <= searchCollectionSize
						and: [
							(self at: index + searchCollectionIndex - 1) =
								(aSearchCollection at: searchCollectionIndex)]]
						whileTrue: [searchCollectionIndex := searchCollectionIndex + 1].
					searchCollectionIndex > searchCollectionSize
						ifTrue: [
							"found a match, add the replacement and skip the replaced"
							copy addAll: aReplacementCollection.
							index := index + searchCollectionSize]
						ifFalse: [
							copy addLast: (self at: index).
							index := index + 1]]
				ifFalse: [ 
					copy addLast: (self at: index).
					index := index + 1]].
	^ copy.! !
!XMLOrderedList methodsFor: 'copying'!
copyReplaceFrom: aStart to: aStop with: aReplacementCollection
	| copy start stop |

	(self size < 1
		or: [self size < aStart])
		ifTrue: [
			^ self copy
				addAll: aReplacementCollection;
				yourself].

	copy := self copyEmpty.
	start := aStart max: 1.
	stop := aStop min: self size.
	1 to: self size do: [:i |
		(i = start)
			ifTrue: [
				copy addAll: aReplacementCollection.
				start > stop
					ifTrue: [copy addLast: (self at: i)]]
			ifFalse: [
				(i > start and: [i <= stop])
					ifFalse: [copy addLast: (self at: i)]]].
	^ copy.! !
!XMLOrderedList methodsFor: 'copying'!
copyUpTo: anObject
	| copy |

	copy := self copyEmpty.
	1
		to:
			(self
				indexOf: anObject
				ifAbsent: [self size + 1]) - 1
		do: [:i | copy addToCopyLast: (self at: i)].
	^ copy.! !
!XMLOrderedList methodsFor: 'copying'!
copyUpToLast: anObject
	| copy |

	copy := self copyEmpty.
	1
		to:
			(self
				lastIndexOf: anObject
				ifAbsent: [collection size + 1]) - 1
		do: [:i | copy addToCopyLast: (self at: i)].
	^ copy.! !
!XMLOrderedList methodsFor: 'copying'!
copyWith: anObject
	^ self copy
		addLast: anObject;
		yourself! !
!XMLOrderedList methodsFor: 'copying'!
copyWithFirst: anObject
	^ self copyEmpty
		addLast: anObject;
		addAll: self;
		yourself! !
!XMLOrderedList methodsFor: 'copying'!
copyWithout: anObject
	^ self reject: [:each | each = anObject]! !
!XMLOrderedList methodsFor: 'copying'!
copyWithoutAll: aCollection
	| rejected |

	rejected :=
		aCollection size > 5
			ifTrue: [aCollection asSet]
			ifFalse: [aCollection].
	^ self reject: [:each | rejected includes: each].! !
!XMLOrderedList methodsFor: 'defaults'!
defaultValue
	^ nil! !
!XMLOrderedList methodsFor: 'enumerating'!
detect: aBlock
	^ self detect: aBlock ifNone: [self defaultValue]! !
!XMLOrderedList methodsFor: 'enumerating'!
detect: aBlock ifNone: anExceptionBlock
	^ collection detect: aBlock ifNone: anExceptionBlock! !
!XMLOrderedList methodsFor: 'enumerating'!
do: aBlock
	collection do: aBlock! !
!XMLOrderedList methodsFor: 'enumerating'!
doWithIndex: aBlock
	^ self withIndexDo: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
eighth
	^ self at: 8! !
!XMLOrderedList methodsFor: 'testing'!
endsWith: aCollection
	^ collection endsWith: aCollection! !
!XMLOrderedList methodsFor: 'accessing'!
fifth
	^ self at: 5! !
!XMLOrderedList methodsFor: 'accessing'!
first
	"optimized implementation"
	^ collection size > 0
		ifTrue: [collection at: 1]
		ifFalse: [self defaultValue]! !
!XMLOrderedList methodsFor: 'accessing'!
first: anInteger
	^ self copyFrom: 1 to: anInteger! !
!XMLOrderedList methodsFor: 'accessing'!
fourth
	^ self at: 4! !
!XMLOrderedList methodsFor: 'comparing'!
hash
	| hash |

	hash := self species hash.
	self size > 10
		ifFalse: [
			self do: [:each |
				hash := hash bitXor: each hash]].
	^ hash bitXor: self size hash.! !
!XMLOrderedList methodsFor: 'accessing'!
identityIndexOf: anObject
	^ self identityIndexOf: anObject ifAbsent: [0]! !
!XMLOrderedList methodsFor: 'accessing'!
identityIndexOf: anObject ifAbsent: aBlock
	^ collection identityIndexOf: anObject ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
indexOf: anObject
	^ self indexOf: anObject ifAbsent: [0]! !
!XMLOrderedList methodsFor: 'accessing'!
indexOf: anObject ifAbsent: aBlock
	^ collection
		indexOf: anObject
		ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
indexOf: anObject startingAt: anIndex 
	^ self
		indexOf: anObject
		startingAt: anIndex
		ifAbsent: [0]! !
!XMLOrderedList methodsFor: 'accessing'!
indexOf: anObject startingAt: anIndex ifAbsent: aBlock
	^ collection
		indexOf: anObject
		startingAt: (anIndex max: 1)
		ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
indexOfSubCollection: aSubCollection startingAt: anIndex
	^ self
		indexOfSubCollection: aSubCollection
		startingAt: anIndex
		ifAbsent: [0]! !
!XMLOrderedList methodsFor: 'accessing'!
indexOfSubCollection: aSubCollection startingAt: anIndex ifAbsent: aBlock
	^ collection
		indexOfSubCollection: aSubCollection
		startingAt: anIndex
		ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'inspecting'!
inspectorClass
	"for Squeak"
	^ collection inspectorClass! !
!XMLOrderedList methodsFor: 'testing'!
isEmpty
	"Squeak's Collection>>#isEmpty is inefficient"
	^ self size = 0! !
!XMLOrderedList methodsFor: 'testing'!
isSequenceable
	^ true! !
!XMLOrderedList methodsFor: 'accessing'!
last
	| lastIndex |

	"optimized implementation"
	^ (lastIndex := collection size) > 0
		ifTrue: [collection at: lastIndex]
		ifFalse: [self defaultValue]! !
!XMLOrderedList methodsFor: 'accessing'!
last: anInteger
	^ self copyFrom: self size - anInteger + 1 to: self size! !
!XMLOrderedList methodsFor: 'accessing'!
lastIndexOf: anObject
	^ self lastIndexOf: anObject ifAbsent: [0]! !
!XMLOrderedList methodsFor: 'accessing'!
lastIndexOf: anObject ifAbsent: aBlock
	^ collection lastIndexOf: anObject ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'accessing'!
ninth
	^ self at: 9! !
!XMLOrderedList methodsFor: 'enumerating'!
pairsDo: aBlock
	collection pairsDo: aBlock! !
!XMLOrderedList methodsFor: 'converting'!
readStream
	"use #readStream to get a 0-based position stream on GS"
	^ collection readStream! !
!XMLOrderedList methodsFor: 'enumerating'!
reject: aBlock
	| selected |

	selected := self copyEmpty.
	"use #to:do: for speed"
	1 to: collection size do: [:i | | item |
		item := collection at: i.
		(aBlock value: item)
			ifFalse: [selected addToCopyLast: item]].
	^ selected.! !
!XMLOrderedList methodsFor: 'enumerating'!
reject: aRejectBlock thenCollect: aCollectBlock
	| collected |

	collected := self copyEmptyForCollect.
	"use #to:do: for speed"
	1 to: collection size do: [:i | | item |
		item := collection at: i.
		(aRejectBlock value: item)
			ifFalse: [collected addLast: (aCollectBlock value: item)]].
	^ collected.! !
!XMLOrderedList methodsFor: 'removing'!
remove: anObject ifAbsent: aBlock
	^ collection remove: anObject ifAbsent: aBlock! !
!XMLOrderedList methodsFor: 'removing'!
removeAll
	"Redefined because Collection>>#removeAll assumes the collection can
	be safely modified while iterating it with #do:"

	self size timesRepeat: [self removeLast]! !
!XMLOrderedList methodsFor: 'removing'!
removeAt: anIndex
	^ collection removeAt: anIndex! !
!XMLOrderedList methodsFor: 'removing'!
removeFirst
	^ self removeAt: 1! !
!XMLOrderedList methodsFor: 'removing'!
removeFirst: aNumber
	| removed |

	removed := self copyFrom: 1 to: aNumber.
	aNumber timesRepeat: [self removeFirst].
	^ removed.! !
!XMLOrderedList methodsFor: 'removing'!
removeLast
	^ self removeAt: self size! !
!XMLOrderedList methodsFor: 'removing'!
removeLast: aNumber
	| removed |

	removed := self copyFrom: self size - (aNumber - 1) to: self size.
	aNumber timesRepeat: [self removeLast].
	^ removed.! !
!XMLOrderedList methodsFor: 'accessing'!
replaceFrom: aStart to: aStop with: aReplacementCollection
	^ self
		replaceFrom: aStart
		to: aStop
		with: aReplacementCollection
		startingAt: 1! !
!XMLOrderedList methodsFor: 'accessing'!
replaceFrom: aStart to: aStop with: aReplacementCollection startingAt: aReplacementStart
	| offset |

	offset := 0.
	[aStart + offset <= aStop]
		whileTrue: [
			self
				at: aStart + offset
				put: (aReplacementCollection at: aReplacementStart + offset).
			offset := offset + 1].! !
!XMLOrderedList methodsFor: 'removing'!
reset
	collection reset! !
!XMLOrderedList methodsFor: 'converting'!
reverse
	"returns a copy like #reversed instead of doing in-place reversal to
	be compatible with SequenceableCollection>>#reverse"

	^ self reversed! !
!XMLOrderedList methodsFor: 'enumerating'!
reverseDo: aBlock
	collection reverseDo: aBlock! !
!XMLOrderedList methodsFor: 'converting'!
reversed
	| reversed |

	reversed := self copyEmpty.
	self reverseDo: [:each | reversed addToCopyLast: each].
	^ reversed.! !
!XMLOrderedList methodsFor: 'accessing'!
second
	^ self at: 2! !
!XMLOrderedList methodsFor: 'enumerating'!
select: aBlock
	| selected |

	selected := self copyEmpty.
	"use #to:do: for speed"
	1 to: collection size do: [:i | | item |
		item := collection at: i.
		(aBlock value: item)
			ifTrue: [selected addToCopyLast: item]].
	^ selected.! !
!XMLOrderedList methodsFor: 'enumerating'!
select: aSelectBlock thenCollect: aCollectBlock
	| collected |

	collected := self copyEmptyForCollect.
	"use #to:do: for speed"
	1 to: collection size do: [:i | | item |
		item := collection at: i.
		(aSelectBlock value: item)
			ifTrue: [collected addLast: (aCollectBlock value: item)]].
	^ collected.! !
!XMLOrderedList methodsFor: 'private'!
setCollection: aCollection
	collection := aCollection! !
!XMLOrderedList methodsFor: 'accessing'!
seventh
	^ self at: 7! !
!XMLOrderedList methodsFor: 'accessing'!
sixth
	^ self at: 6! !
!XMLOrderedList methodsFor: 'accessing'!
size
	^ collection size! !
!XMLOrderedList methodsFor: 'sorting'!
sort
	self sort: [:a :b | a <= b]! !
!XMLOrderedList methodsFor: 'sorting'!
sort: aSortBlock
	collection sort: aSortBlock! !
!XMLOrderedList methodsFor: 'sorting'!
sorted
	^ self copy sort! !
!XMLOrderedList methodsFor: 'sorting'!
sorted: aSortBlock
	^ self copy sort: aSortBlock! !
!XMLOrderedList methodsFor: 'private'!
species
	"this makes instances of this class and all subclasses with the same
	items in the same order be equal"
	^ XMLOrderedList! !
!XMLOrderedList methodsFor: 'accessing'!
swap: aFirstIndex with: aSecondIndex
	"swap positions of the objects at aFirstIndex and aSecondIndex,
	raising an error if either index is out of bounds"

	| temp |

	temp := collection at: aFirstIndex.
	collection
		at: aFirstIndex
		put: (collection at: aSecondIndex).
	collection
		at: aSecondIndex
		put: temp.! !
!XMLOrderedList methodsFor: 'accessing'!
third
	^ self at: 3! !
!XMLOrderedList methodsFor: 'enumerating'!
with: aCollection collect: aBlock
	| collected |

	collected := self copyEmptyForCollect.
	1 to: (collection size min: aCollection size) do: [:i |
		collected addLast:
			(aBlock
				value: (collection at: i)
				value: (aCollection at: i))].
	^ collected.! !
!XMLOrderedList methodsFor: 'enumerating'!
with: aCollection do: aBlock
	1 to: (collection size min: aCollection size) do: [:i |
		aBlock
			value: (collection at: i)
			value: (aCollection at: i)]! !
!XMLOrderedList methodsFor: 'enumerating'!
withIndexCollect: aTwoArgumentBlock
	| collected |

	collected := self copyEmptyForCollect.
	1 to: collection size do: [:i |
		collected addLast:
			(aTwoArgumentBlock
				value: (collection at: i)
				value: i)].
	^ collected.! !
!XMLOrderedList methodsFor: 'enumerating'!
withIndexDo: aBlock
	collection withIndexDo: aBlock! !
!XMLOrderedList methodsFor: 'converting'!
writeStream
	"This is not supported because the collection already supports WriteStream
	behavior with #addLast: and the Pharo/Squeak WriteStream works by expanding
	its collection with #grownBy:, which should fill the new space with nils,
	but some subclasses cannot contain nil"

	self shouldNotImplement! !
!XMLOrderedList methodsFor: 'accessing'!
xmlLastOrNil
	^ self last! !
!SequenceableCollection methodsFor: '*XML-Parser'!
includesXMLName: aName
	"optimized with #to:do:"
	1 to: self size do: [:i |
		(aName isXMLQualifiedOrLocalName: (self at: i))
			ifTrue: [^ true]].
	^ false.! !
!SequenceableCollection methodsFor: '*XML-Parser'!
xmlLastOrNil
	"for speed to avoid at:ifAbsent: closure"
	| lastOrNilOffset |

	(lastOrNilOffset := self size) > 0
		ifTrue: [^ self at: lastOrNilOffset]
		ifFalse: [^ nil]! !

"XML-Parser"!
!FTTableMorph methodsFor: '*PharoLauncher-80Compatibility'!
alternateRowsColor
	self container alternateRowsColor! !
!ZnUrl class methodsFor: '*PharoLauncher-80Compatibility'!
fromSton: stonReader
	^ [ self fromString: stonReader parseListSingleton ]
		on: STONReaderError
		do: [ super fromSton: stonReader ]! !
!FTSelectableMorph methodsFor: 'initialization' prior: 25570758!
defaultColor
	^ Color transparent! !
!FTSelectableMorph methodsFor: 'initialization' prior: 25570855!
initialize
	super initialize.
	selectionColor := self defaultColor! !
!FTSelectableMorph methodsFor: 'event handling' prior: 25570430!
mouseEnter: evt
	colorBeforeOver := self color.
	self color: (selectionColor isTransparent ifTrue: [ self mouseOverColor ] ifFalse: [ self mouseOverColor mixed: 0.5 with: selectionColor ])! !
!FTSelectableMorph methodsFor: 'event handling' prior: 25571121!
mouseLeave: evt
	self color: 	colorBeforeOver "self selectionColor"! !
!FTSelectableMorph methodsFor: 'accessing' prior: 25570645!
mouseOverColor
	^ self theme lightBackgroundColor lighter! !
!FTSelectableMorph methodsFor: 'initialization' prior: 25570334!
selectionColor
	^ selectionColor! !
!FTSelectableMorph methodsFor: 'accessing' prior: 25570980!
selectionColor: aColor
	selectionColor := aColor.
	self color: selectionColor! !
!FTSelectableMorph methodsFor: 'accessing' prior: 25570234!
table
	^ self owner ifNotNil: #table! !
!FTTableContainerMorph class methodsFor: 'accessing' prior: 25612970!
rowLeftMargin
	"I'm keeping a small margin beween the list and the begining of a row, to enhance visibility."
	^ 1! !
!FTTableContainerMorph methodsFor: 'drawing' prior: 25606190!
addResizeSplitters
	| columnWidths nextColumn delta |
	columnWidths := self calculateColumnWidths.
	nextColumn := self left.
	delta := FTColumnResizerMorph resizerWidth / 2.
	self table columns overlappingPairsWithIndexDo:  [ :leftColumn :rightColumn :index |
		nextColumn := nextColumn + (columnWidths at: index) + self table intercellSpacing x.
		self addMorph: ((FTColumnResizerMorph 
			container: self 
				left: (FTDisplayColumn column: leftColumn width: (columnWidths at: index))
				right: (FTDisplayColumn column: rightColumn width: (columnWidths at: (index + 1))))
			bounds: ((nextColumn - delta)@(self top) extent: delta@(self height));
			color: Color transparent;
			yourself)	 ]! !
!FTTableContainerMorph methodsFor: 'updating' prior: 25598894!
adjustToHorizontalScrollBarValue: aNumber 
	| newStartColumnIndex | 
	newStartColumnIndex := (self table numberOfColumns * aNumber) rounded 
		min: self table numberOfColumns 
		max: 1 .
	newStartColumnIndex ~= self startColumnIndex 
		ifTrue: [ 
			self startColumnIndex: newStartColumnIndex.
			self changed  ]
! !
!FTTableContainerMorph methodsFor: 'configuring'!
alternateRowsColor
	rowColors := Array
		with: self theme backgroundColor lighter
		with: self theme backgroundColor darker! !
!FTTableContainerMorph methodsFor: 'private' prior: 25611470!
calculateColumnWidths

	"do three runs 
	- first collect defined columnwidth that fit
	- collect remaining undefined columnwidth 
	- return if all fit 
	  or collect and distribute remaining width.
	
   the method was adjusted to distribute space starting from startColumnIndex 
	to enable horizontal scrolling when columns do not fit the window,
	see #columnOrderOfWidthDistribution"
	

	| undefinedColumnWidths widths remainingWidth |
	remainingWidth := self table bounds width.

	widths := Array new: self table numberOfColumns withAll: 0.
	self columnOrderOfWidthDistribution do: [ :idx || column columnWidth |
		column := self table columns at: idx. 
		columnWidth := column acquireWidth: remainingWidth.
		widths at: idx put: columnWidth.
		remainingWidth := remainingWidth - columnWidth ].

	undefinedColumnWidths := widths count: #isZero.
	undefinedColumnWidths isZero
		ifTrue: [ widths size > 1 ifTrue: [ "Set the remaining space to the last column" widths at: widths size put: widths last + remainingWidth ].
			^ widths ].


	"collect and distribute remaining space"
	self columnOrderOfWidthDistribution do: [ :idx | 
		(widths at: idx) = 0 	ifTrue: [ widths at: idx put: (remainingWidth / undefinedColumnWidths) ] ].
	^widths! !
!FTTableContainerMorph methodsFor: 'private' prior: 25602947!
calculateExactVisibleRows
	"Answer the rows to show in list - with possible fraction"

	| visibleRows |
	visibleRows := self height / (self table rowHeight + self table intercellSpacing y).
	^ headerRow 
		ifNotNil: [ visibleRows - 1 ] 
		ifNil: [ visibleRows ]! !
!FTTableContainerMorph methodsFor: 'private' prior: 25599268!
calculateMaxVisibleRows
	"Answer the maximal number of rows to shown in list"

	^ self calculateExactVisibleRows ceiling! !
!FTTableContainerMorph methodsFor: 'private' prior: 25612769!
calculateMinVisibleRows
	"Answer the minimal fully visible number of rows to shown in list"

	^ self calculateExactVisibleRows floor! !
!FTTableContainerMorph methodsFor: 'private' prior: 25600537!
calculateStartIndexWhenShowing: visibleRows
	"Answer the first row to show when showing visibleRows rows. 
	 This works in case we are exceeding the available rows to show"
	| currentIndex startIndex oldIndex |
	
	currentIndex := self table showIndex.
	currentIndex + visibleRows - 1 > self table numberOfRows 
		ifTrue: [ currentIndex := self table numberOfRows - visibleRows + 2 ].
	startIndex := currentIndex max: 1.
	oldIndex := self table showIndex.
	self table basicMoveShowIndexTo: startIndex.
	self table announceScrollChangedFrom: oldIndex to: self table showIndex.
	^ startIndex! !
!FTTableContainerMorph methodsFor: 'private' prior: 25600311!
calculateVisibleRows
	"Answer the rows to show in list. 
	 Ensures we show the maximum amount possible"

	^ self calculateMaxVisibleRows min: self table numberOfRows! !
!FTTableContainerMorph methodsFor: 'testing' prior: 25609957!
canRefreshValues
	^ self needsRefreshExposedRows and: [ self table isNotNil and: [ self table hasDataSource ] ]! !
!FTTableContainerMorph methodsFor: 'updating' prior: 25609698!
changed
	self table ifNil: [ ^ self ].
	self setNeedsRefreshExposedRows.
	super changed! !
!FTTableContainerMorph methodsFor: 'drawing' prior: 25610379!
clipSubmorphs

	^ true! !
!FTTableContainerMorph methodsFor: 'private' prior: 25607351!
columnOrderOfWidthDistribution
	"returns column indexes ordered by priority to get screenspace"
	| idxToLast idxToFirstReversed |
	self startColumnIndex isZero "a special case implementing default/current behaviour -- natural order of columns starting from the first one"
		ifTrue: [ ^(1 to: self table numberOfColumns) ].
	"new behaviour intended to garantee the visibility of columns around startColumnIndex
		first give width starting from startColumnIndex towards end,
		then from previous available column towards beginning"
	idxToLast := startColumnIndex to: self table numberOfColumns.
	idxToFirstReversed := startColumnIndex>1 ifTrue: [startColumnIndex-1 to: 1 by: -1] ifFalse: [#()].
	^idxToLast,idxToFirstReversed! !
!FTTableContainerMorph methodsFor: 'private' prior: 25609127!
createResizableHeaderWith: aMorph between: leftColumn and: rightColumn
	"Create a wrapper morph with a resizable morph et the left (so we bind two columns). 
	 This morph will be completely transparent in all terms... it acts just as a container."
	^ Morph new 
		color: Color transparent;
		clipSubmorphs: true;
		layoutPolicy: FTRowLayout new;
		bounds: aMorph bounds;
		addMorphBack: (FTColumnResizerMorph 
			container: self 
			left: leftColumn 
			right: rightColumn);
		addMorphBack: aMorph;
		yourself! !
!FTTableContainerMorph methodsFor: 'initialization' prior: 25602852!
defaultColor

	^Color transparent ! !
!FTTableContainerMorph methodsFor: 'drawing' prior: 25607107!
drawOn: canvas

	super drawOn: canvas.
	self drawRowsOn: canvas! !
!FTTableContainerMorph methodsFor: 'drawing' prior: 25598753!
drawOnAthensCanvas: anAthensCanvas
	self drawOnCanvasWrapperFor: anAthensCanvas! !
!FTTableContainerMorph methodsFor: 'drawing' prior: 25603472!
drawRowsOn: canvas
	| x y cellWidth cellHeight rowsToDisplay rowSubviews highligtedIndexes primarySelectionIndex |

	self canRefreshValues ifFalse: [ ^ self ].	"Nothing to update yet"

	x := self left + self class rowLeftMargin.
	y := self top.
	cellWidth := self width - self class rowLeftMargin.
	cellHeight := self table rowHeight rounded.
	highligtedIndexes := self table selectedIndexes, self table highlightedIndexes.
	primarySelectionIndex := self table selectedIndex.

	"For some superweird reason, calling #calculateExposedRows here instead in #changed (where
	 it should be called) is 10x faster. Since the whole purpose of this component is speed, for 
	 now I'm calling it here and adding the #setNeedRecalculateRows mechanism. 
	 History, please forgive me."
	self updateAllRows.

	rowsToDisplay := self exposedRows.
	rowSubviews := OrderedCollection new: rowsToDisplay size + 1.
	headerRow ifNotNil: [ 
		headerRow bounds: (self left @ y extent: self width @ cellHeight).
		y := y + cellHeight + self table intercellSpacing y.
		rowSubviews add: headerRow ].
	
	rowsToDisplay keysAndValuesDo: [ :rowIndex :row | 
		| visibleHeight |
		visibleHeight := (self rowHeight: rowIndex default: cellHeight) min: self bottom - y.
		row bounds: (x @ y extent: cellWidth @ visibleHeight).
		y := y + visibleHeight + self table intercellSpacing y.

		rowSubviews add: row.
		self setColorRow: row index: rowIndex.

		(self table selectionModeStrategy
				selectablesToHighlightFromRow: row
				at: rowIndex
				withHighlightedIndexes: highligtedIndexes
				andPrimaryIndex: primarySelectionIndex) 
			keysAndValuesDo: [ :morph :isPrimary | 
				morph selectionColor: (self table colorForSelection: isPrimary) ] ].

	"We should notify existing rows about deletion and new rows about insertion. 
	It is required to correctly manage stepping animation of cells"
	submorphs do: [ :each | 
		each
			privateOwner: nil;
			outOfWorld: self world ].
	submorphs := rowSubviews asArray.
	submorphs do: [ :each | each intoWorld: self world ].

	self table isResizable ifTrue: [ self addResizeSplitters ].

	needsRefreshExposedRows := false! !
!FTTableContainerMorph methodsFor: 'private' prior: 25599449!
exposedColumnsRange: columnWidths
	"Return a subset of indexes for columns which are to be drawn.
	startColumnIndex=0 is default/current behaviour -- draw all, even if they will not fit
	otherwise, we select only indexes of columns having non-zero screen width"
	
	^self startColumnIndex isZero
		ifTrue: [1 to: self table numberOfColumns] 
		ifFalse: [(1 to: columnWidths size) select: [ :idx | (columnWidths at: idx)>0 ]  ]
! !
!FTTableContainerMorph methodsFor: 'private' prior: 25599936!
exposedRows
	"Answer a dictionary of rowIndex->row pairs"

	^ exposedRows! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25606946!
firstVisibleRowIndex

	^ self exposedRows
		ifNotEmpty: [ :rows | rows keys first ]
		ifEmpty: [ 0 ]! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25598669!
headerRow

	^ headerRow! !
!FTTableContainerMorph methodsFor: 'initialization' prior: 25610469!
initialize 
	super initialize.
	needsRefreshExposedRows := false.
	startColumnIndex :=0.! !
!FTTableContainerMorph methodsFor: 'testing' prior: 25610840!
isRowIndexExceding: rowIndex
	| headerPresentModificator nextRowIndexByPosition heightWithSpacing |
	
	headerPresentModificator := headerRow ifNotNil: [ 1 ] ifNil: [ 0 ].
	nextRowIndexByPosition := rowIndex - self table showIndex + 1 + headerPresentModificator.
	heightWithSpacing := self table rowHeight + self table intercellSpacing y.
	
	^ (nextRowIndexByPosition * heightWithSpacing) > self height! !
!FTTableContainerMorph methodsFor: 'testing' prior: 25601186!
isRowIndexFullyVisible: rowIndex
	"Answer if a row is *fully* visible. That means row is completely visible (there is 
	 not hidden part)"
	^ (self isRowIndexVisible: rowIndex) 
		and: [ (self isRowIndexExceding: rowIndex) not ]! !
!FTTableContainerMorph methodsFor: 'testing' prior: 25611302!
isRowIndexVisible: rowIndex
	self exposedRows ifNil: [ ^ false ].
	^ self exposedRows includesKey: rowIndex! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25610131!
lastVisibleRowIndex

	^ self exposedRows
		ifNotEmpty: [ :rows | rows keys last ]
		ifEmpty: [ 0 ]! !
!FTTableContainerMorph methodsFor: 'private' prior: 25609846!
needsRefreshExposedRows
	^ needsRefreshExposedRows! !
!FTTableContainerMorph methodsFor: 'geometry' prior: 25610291!
outerBounds 
	^ self bounds! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25605625!
rowAndColumnIndexContainingPoint: aPoint
	"answer a tuple containing { rowIndex. columnNumber } to be used for menus, etc. 
	 (check senders for references)"

	self exposedRows keysAndValuesDo: [ :rowIndex :row | 
		(row bounds containsPoint: aPoint) ifTrue: [ 
			row submorphs withIndexDo: [ :each :columnIndex |
				 (each bounds containsPoint: aPoint) 
					ifTrue: [ ^ { rowIndex. columnIndex } ] ] ] ].
	^ {nil. nil}! !
!FTTableContainerMorph methodsFor: 'private' prior: 25601475!
rowHeight: rowIndex default: aNumber

	^ aNumber! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25610620!
rowIndexContainingPoint: aPoint
	self exposedRows keysAndValuesDo: [ :rowIndex :row | 
		(row bounds containsPoint: aPoint)
			ifTrue: [ ^ rowIndex ] ].
	^ nil! !
!FTTableContainerMorph methodsFor: 'drawing'!
setColorRow: aFTTableRowMorph index: rowIndex
	"Set the raw color if needed, e.g. when alternateRowsColor is configured"
	rowColors ifNotNil: [ aFTTableRowMorph color: (rowColors at: ((rowIndex \\ 2) + 1)) ].
! !
!FTTableContainerMorph methodsFor: 'private' prior: 25607231!
setNeedsRefreshExposedRows
	needsRefreshExposedRows := true! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25601586!
startColumnIndex
	startColumnIndex ifNil: [ startColumnIndex := 0 ].
	^startColumnIndex! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25600072!
startColumnIndex: anObject
	startColumnIndex := anObject! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25606110!
table
	^ self owner! !
!FTTableContainerMorph methodsFor: 'updating' prior: 25603270!
updateAllRows

	self table isShowColumnHeaders 
		ifTrue: [ self updateHeaderRow ]
		ifFalse: [ headerRow := nil ].
	self updateExposedRows
	! !
!FTTableContainerMorph methodsFor: 'updating' prior: 25608136!
updateExposedRows
	"updated (as #updateHeaderRow also) to draw only subset of columns if horizontal scrolling in use, see #exposedColumnsRange:"
	| visibleRows columns columnWidths startIndex |
	
	self canRefreshValues ifFalse: [ ^ self ].

	visibleRows := self calculateMaxVisibleRows.
	startIndex := self calculateStartIndexWhenShowing: visibleRows.
	columns := self table columns. 
	columnWidths := self calculateColumnWidths.

	exposedRows := SmallDictionary new.
	startIndex to: ((startIndex + visibleRows - 1) min: self table numberOfRows) do: [ :rowIndex | 
		| row |
		row := FTTableRowMorph table: self table.
		(self exposedColumnsRange: columnWidths) do: [ :columnIndex | | cell |
			cell := (self table dataSource 
				cellColumn: (columns at: columnIndex)
				row: rowIndex).  
			cell width: (columnWidths at: columnIndex).
			row addMorphBack: cell ].
		row privateOwner: self.
		exposedRows at: rowIndex put: row ]! !
!FTTableContainerMorph methodsFor: 'updating' prior: 25601735!
updateHeaderRow
	"Recalculates the header row if they are defined. 
	 Please, note that If one of the headers is nil, I assume all are nil and I return. 
	 This is probably not the best approach, but like that I enforce people defines at least 
	 a default if they want headers."
	| columns columnHeaders columnWidths |

	self canRefreshValues ifFalse: [ ^ self ].

	headerRow := nil.
	columns := self table columns.	
	columnHeaders := OrderedCollection new.
	columnWidths := self calculateColumnWidths.
	
	(self exposedColumnsRange: columnWidths)  do: [ :index | | column headerCell columnWidth|
		column := columns at: index.
		columnWidth := columnWidths at: index.
		headerCell :=  self table dataSource headerColumn: column. 
		headerCell ifNil: [ ^ self ]. 
		headerCell 
			color: self table headerColor;
			width: columnWidth.
		columnHeaders addLast: headerCell.
		FTDisplayColumn column: column width: columnWidth ].
	 
	headerRow := (FTTableHeaderRowMorph table: self table)
		privateOwner: self;
		addAllMorphs: columnHeaders;
		yourself! !
!FTTableContainerMorph methodsFor: 'accessing' prior: 25600191!
visibleRowMorphAtIndex: index
	^ self exposedRows at: index! !

"PharoLauncher-80Compatibility"!
!FileLocator class methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
fromPath: aPath ifNone: notFoundBlock
	"Returns a file locator if aPath is a reference to a supported origin or is a child of an origin.
	If no locator matches, return the result of the evaluation of notFoundBlock.
	Should not be called direcly. Prefer the use of Path or String>>#asFileLocatorOrReference "

	| locators locatorsPaths |
	locators := self supportedOrigins
		collect: [ :origin | self origin: origin ]
		as: OrderedCollection.
	locatorsPaths := (locators collect: [ :e | e -> e asPath ]) asDictionary.
	(locators sort:
			[ :a :b | (locatorsPaths at: b) <= (locatorsPaths at: a) ])
		do: [ :locator | 
			((locatorsPaths at: locator) = aPath or: [ (locatorsPaths at: locator) containsPath: aPath ])
				ifTrue: [ ^ locator resolve: (aPath relativeToPath: (locatorsPaths at: locator)) ] ].
	^ notFoundBlock value! !
!FileLocator class methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
fromString: aString ifNone: notFoundBlock
	"Returns a file locator if aString converted as path is a reference to a supported origin or is a child of an origin.
	If no locator matches, return the result of the evaluation of notFoundBlock.
	Should not be called direcly. Prefer the use of Path or String>>#asFileLocatorOrReference "
	
	^ self fromPath: aString asPath ifNone: notFoundBlock! !
!FileLocator methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
asFileLocatorOrReference
	^ self! !
!Path methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
asFileLocatorOrReference

	^ FileLocator fromPath: self ifNone: [ self asFileReference ]! !
!String methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
asFileLocatorOrReference

	^ FileLocator fromString: self ifNone: [ self asFileReference ]! !
!FileReferenceTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testAsFileLocatorOrReferenceReturnsALocatorWhenStringRefersToAKnownOrigin
	| fileRef locator |
	fileRef := (FileLocator home / 'foo') asFileReference.
	
	locator := fileRef asFileLocatorOrReference.
		
	self
		assert: locator origin
		equals: #home.
	self
		assert: locator fullName
		equals: fileRef fullName.! !
!FileReferenceTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testAsFileLocatorOrReferenceReturnsAReferenceWhenStringDoesNotReferToAKnownOrigin
	| fileRef result |
	fileRef := '/foo' asFileReference.
	
	result := fileRef asFileLocatorOrReference.
	
	self
		assert: result
		equals: fileRef.! !
!FileReference methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
asFileLocatorOrReference
	filesystem isMemoryFileSystem ifTrue: [ ^ self "no convertion for memory file system" ].
	
	^ self path asFileLocatorOrReference! !
!StringTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testAsFileLocatorOrReferenceReturnsALocatorWhenStringRefersToAKnownOrigin
	| pathString locator |
	pathString := (FileLocator home / 'foo') fullName.
	
	locator := pathString asFileLocatorOrReference.
		
	self
		assert: locator origin
		equals: #home.
	self
		assert: locator fullName
		equals: pathString.! !
!StringTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testAsFileLocatorOrReferenceReturnsAReferenceWhenStringDoesNotReferToAKnownOrigin
	| fileRef result |
	fileRef := '/foo' asFileReference.
	
	result := fileRef fullName asFileLocatorOrReference.
	
	self
		assert: result
		equals: fileRef.! !
!FileLocatorTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testCanCreateLocatorFromStringWhenDeepChild
	| path |
	path := (FileLocator home / 'foo' / 'bar' / 'bee' / 'see') fullName.
	
	locator := FileLocator fromString: path ifNone: [ nil ].
	
	self
		assert: locator origin
		equals: #home.
	self
		assert: locator fullName
		equals: path.! !
!FileLocatorTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testCanCreateLocatorFromStringWhenDirectChild
	| path |
	path := (FileLocator home / 'foo') fullName.
	
	locator := FileLocator fromString: path ifNone: [ nil ].
		
	self
		assert: locator origin
		equals: #home.
	self
		assert: locator fullName
		equals: path.! !
!FileLocatorTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testCanCreateLocatorFromStringWhenSamePath
	| path |
	path := FileLocator home fullName.
	
	locator := FileLocator fromString: path ifNone: [ nil ].
	
	self
		assert: locator
		equals: FileLocator home.
	self
		assert: locator fullName
		equals: path.! !
!FileLocatorTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testFromPathReturnsBlockValueIfPathNotPartOfAnOrigin
	| path |
	path := '/foo' asFileReference path.
	
	locator := FileLocator fromPath: path ifNone: [ nil ].
	
	self
		assert: locator
		equals: nil.! !
!FileLocatorTest methodsFor: '*PharoLauncher-Pharo9ToRemove-FileLocator'!
testGetRightLocatorWhenCreatingFromString
	| path |
	path := (FileLocator documents / 'foo') fullName.

	locator := FileLocator fromString: path ifNone: [ nil ].

	self
		assert: locator origin
		equals: #documents.
	self
		assert: locator fullName
		equals: path.! !
!PhLSettingBrowser commentStamp: '' prior: 0!
I'm exactly the same as the standard settings browser except I save to a dedicated pharo launcher setting file.!
!PhLSettingTree commentStamp: '' prior: 0!
I'm exactly the same as the standard settings browser except I save to a dedicated pharo launcher setting file.!
!PhLGeneralCommand commentStamp: '' prior: 0!
Abstract superclass for all general-purpose commands. These commands concern the launcher in general, not a particular template or image.!
!PhLAboutCommand commentStamp: '' prior: 0!
Command to display a box with information related to the Pharo Launcher!
!PhLOpenNewImageWindowCommand commentStamp: '' prior: 0!
Open the image creation UI.!
!PhLOpenSettingsCommand commentStamp: '' prior: 0!
Command to open the Settings browser.!
!PhLOpenVmManagerCommand commentStamp: '' prior: 0!
Open the VM Manager UI!
!PhLQuitCommand commentStamp: '' prior: 0!
Quit Pharo Launcher.!
!PhLRefreshImageRepositoryCommand commentStamp: '' prior: 0!
Ask the image repository to update.!
!PhLRefreshTemplateRepositoryCommand commentStamp: '' prior: 0!
Ask the template repository to update.!
!PhLImageCommand commentStamp: '' prior: 0!
Superclass of all commands that are applied to one image or multiple images.!
!PhLCopyImageCommand commentStamp: '' prior: 0!
Copy one image to another name.!
!PhLCopyLaunchCommand commentStamp: '' prior: 0!
Copy the command used to launch the selected image to the system clipboard.!
!PhLCopyPathname commentStamp: '' prior: 0!
Copy the selected image pathname to the system clipboard.
!
!PhLCreateTemplateFromImageCommand commentStamp: '' prior: 0!
Create a new local template based on the selected image.!
!PhLDeleteImageCommand commentStamp: '' prior: 0!
Remove an image from the hard disk. Can be applied to multiple images at the same time.!
!PhLImportImageCommand commentStamp: '' prior: 0!
I can be used to import an image into Pharo Launcher.

I move the image file and its associated changes file to the default location of Pharo Launcher images store.!
!PhLInspectCommand commentStamp: '' prior: 0!
Command to inspect the current selection!
!PhLLaunchImageCommand commentStamp: '' prior: 0!
Launch the selected image with the appropriate virtual machine.!
!PhLLaunchImageFromDiskCommand commentStamp: '' prior: 0!
Launch an image from the filesystem without importing it into Pharo Launcher!
!PhLOpenLaunchConfigurationEditorCommand commentStamp: '' prior: 0!
Open Launch configuration editor for the selected image.!
!PhLRecreateImageCommand commentStamp: '' prior: 0!
Refresh the currently selected image.
It will first drop the current local image and fetch a fresh version of the template. The name of the local image will not be updated.!
!PhLRenameImageCommand commentStamp: '' prior: 0!
Rename the currently selected image and move the files accordingly.!
!PhLShowImageInFolderCommand commentStamp: '' prior: 0!
Open your OS's file browser on the selected image directory.!
!PhLTemplateCommand commentStamp: '' prior: 0!
Superclass of all commands that are applied to one template or multiple templates.!
!PhLCreateImageFromTemplateCommand commentStamp: '' prior: 0!
Extract the selected template to a new image.!
!PhLRemoveTemplateCommand commentStamp: '' prior: 0!
Removes the selected template!
!PhLRenameTemplateCommand commentStamp: '' prior: 0!
Rename the selected template!
!PhLVmCommand commentStamp: '' prior: 0!
Superclass of all commands that are applied to one VM or multiple VMs.!
!PhLDeleteVmCommand commentStamp: '' prior: 0!
Remove a VM from the hard disk. Can be applied to multiple VMs at the same time.!
!PhLShowVmInFolderCommand commentStamp: '' prior: 0!
Open your OS's file browser on the selected VM directory.!
!PhLToggleVmPrivateVmCommand commentStamp: '' prior: 0!
Toggle between display of VMs used to launch Pharo images and "private" VMs used to determine Pharo version of an image (one VM per image format)!
!PhLUpdateVmCommand commentStamp: '' prior: 0!
Will update selected Virtual Machines. Update will download and install the lastest available archive for the selected VM.!
!PhLError commentStamp: '' prior: 0!
I represent an error as can be signaled by any code of Pharo Launcher.!
!PhLCommandError commentStamp: '' prior: 0!
This error is thrown each time a command can not do its job.!
!PhLCorruptedTemplateError commentStamp: '' prior: 0!
Error thrown when a template (zip archive) is corrupted!
!PhLDownloadError commentStamp: '' prior: 0!
I represent download errors.!
!PhLExecutableNotFoundError commentStamp: '' prior: 0!
Error thrown when Pharo Launcher did not succeed to find a Pharo binary or executable inside a given folder.
Probably, the folder should be deleted as the VM are only cached!
!PhLImageVersionDeterminationError commentStamp: '' prior: 0!
Error thrown when Pharo Launcher did not succeed to determine the Pharo version of the image to launch.
Probably, the run command failed.
I hold the command run to determoine the version so that it can be reused for debugging purposes.!
!PhLLaunchError commentStamp: '' prior: 0!
Error raised when the launch of an image failed!!!
!PhLArchitectureError commentStamp: '' prior: 0!
Error raised when trying to run a 32-bit image whereas the underlying Operating System does not support 32-bit applications.!
!PhLMissingVirtualMachineError commentStamp: '' prior: 0!
Error raised when a virtual machine object describes a VM that cannot be found on disk (i.e. executable not found).!
!PhLNameNotAvailableError commentStamp: '' prior: 0!
Error raised when the name provided is not available.
e.g. trying to create an image with the same name as an existing Pharo image!
!PhLProcessTimeOut commentStamp: '' prior: 0!
Exception signaled when a Pharo Launcher process launched exceeds the timeout given.!
!PhLQuitOnLaunchValueChanged commentStamp: '' prior: 0!
Annoucement used to update the UI when QuitOnLaunchValueIsChanged from another part (ex: settings, not widget on main window)!
!PhLSourcesFileUpdateAvailable commentStamp: '' prior: 0!
Announcement thrown when current templates sources do not match downloaded templates sources.!
!PhLCommandCancellation commentStamp: '' prior: 0!
Get notified if a user canceled an operation do not run following operations if any!
!PhLFileBrowser commentStamp: '' prior: 0!
I'm a simple visitor in charge of opening an operating system browser on the provided path string.!
!PhLLaunchImageProcessConfigurator commentStamp: '' prior: 0!
Visitor used to configure the process to launch image dependending on the target OS platform.!
!PhLProcessWrapper commentStamp: '' prior: 0!
This class allows to run external (OS) processes for Pharo Launcher.
It hides some complexity to the Launcher.
OSSubProcess is used on Linux and OS X, while OSWinSubprocess is used on Windows.

Use me as a builder to configure the process, then call prepareProcess (will use a visitor pattern to visit code specific to targeted OS) to have a PhLProcess ready to run.
I act as a facade to OSSubProcess and OSWinSubprocess.!
!PhLProcessWrapperCommandStringGenerator commentStamp: '' prior: 0!
I'm a visitor used to generate a command string out of the given PhLProcessWrapper instance.!
!PhLArchitectureMismatchWarning commentStamp: '' prior: 0!
Warning raised when PharoLauncher architecture (image / VM) does not match the image (and by consequence the VM to run it) architecture.
e.g. raised when PharoLauncher 64-bit tries to run a 32-bit image (possibly missing libraries)!
!ManifestPharoLauncherCore commentStamp: '' prior: 0!
I stores metadata on true and false positive critics. These meta data are used by the SmalllintManifestChecker and the critics Browser !
!PhLDownloadManager commentStamp: '' prior: 0!
I present a simple interface to an HTTP library.

My semaphore takes care of error handling when multiple downloads occur in parallel.!
!PhLImageDescriptionUpdater commentStamp: '' prior: 0!
I'm used to update and by so, serialize the image description to disk.
I implement a mechanism to delay the saving by a few seconds to avoid too much disk i/o.
Indeed, If I'm asked to update many times within a short delay, I will abort the current saving and replace it by the new one. It can be used to update the description at each text change in the UI.!
!PhLJenkinsArtifact commentStamp: '' prior: 0!
Represent a file artifact as built on a Jenkins server.

Instance Variables
	name:		a String
	options:		a dictionary mapping option names to option values. Used by Jenkins matrix jobs
	url:		location of job on Jenkins
!
!PhLLaunchConfiguration commentStamp: '' prior: 0!
I am a launch configuration that knows how to launch an image.
I have all the required information to run one:
 - vm
 - arguments
 - use settings
An image stores many of my instances so the user can choose one to launch it.!
!PhLLaunchedImagesWatcher commentStamp: '' prior: 0!
I'm in charge of watching launched images to detect if a problem occured at the launch.

To watch a process:
	PhLLaunchedImagesWatcher new
		checkProcess: aPhLProcess image: aPhLImage!
!PhLNetworkSettings commentStamp: '' prior: 0!
I provide NetworkSystemSettings proxy setting
for the PhLSettingsBrowser (pragma pharoLauncherSettings).
!
!PhLObject commentStamp: '' prior: 0!
Super class of everything the user can act on!
!PhLAbstractTemplate commentStamp: '' prior: 0!
I'm an object that can create new identical images. I have a name to distinguish myself from other templates.

Currently, all templates are represented by a zip file locally or on the network.
!
!PhLLocalTemplate commentStamp: '' prior: 0!
I am a template that has already been downloaded in the past and stored somewhere on the disk.!
!PhLRemoteTemplate commentStamp: '' prior: 0!
I represent a template that is somewhere on the network.!
!PhLAbstractTemplateGroup commentStamp: '' prior: 0!
I represent a group of templates.

The #templateAndGroups method is very important. Calling this method must answer a collection of my subgroups and of templates that I directly contain.

Most of my subclasses won't have to do any caching, even the network-intensive ones. This is because PhLCacheTemplateGroup does that for everyone.!
!PhLCacheTemplateGroup commentStamp: '' prior: 0!
Take care of caching for all subclasses of PhLAbstractTemplateGroup. 

Instance Variables
	delegate:		a PhLAbstractTemplateGroup
	simplifiedTemplateAndGroups:			a cached version of what my delegate answered to #simplifiedTemplateAndGroups.!
!PhLDownloadedTemplateGroup commentStamp: '' prior: 0!
I represent a group of templates already downloaded from the network. I maintain a set of zip files in my baseDirectory and a cache.json which contains meta-data about these files.

IMPLEMENTATION

I don't cache anything as variables in the image. For each action, I read the cache.json and update it.!
!PhLFixedURLsTemplateGroup commentStamp: '' prior: 0!
Represent a list of templates that is defined at construction time. The interesting property of this group is that is does not require the network to be shown. The network is only needed to actually download a template.!
!PhLHTTPListingTemplateGroup commentStamp: '' prior: 0!
Represent a list of templates as given by an HTML webpage. <a href="*.zip"> are searched in the webpage.!
!PhLJenkins2BuildGroup commentStamp: '' prior: 0!
I  represent a named group of builds for a Jenkins job.
By example, I'm used to offer a group 'All builds' provinding a list of all builds of a particualr job.!
!PhLJenkins2Entity commentStamp: '' prior: 0!
Abstract superclass for everything that is in a Jenkins server (and is visible from the JSON Jenkins API)!
!PhLJenkins2Job commentStamp: '' prior: 0!
I'm a job as can be available on a Jenkins platform.!
!PhLJenkins2Server commentStamp: '' prior: 0!
I represent a group of templates as built by a Jenkins server (url of the server is in my url instance variable). I use Jenkins' JSON API to get the data from the server.
!
!PhLJenkins2WithArtifactsEntity commentStamp: '' prior: 0!
Abstract superclass for everything in a Jenkins server that produces artifacts: currently, only simple jobs (i.e., non-matrix jobs) and runs (i.e., what is executed by a matrix job).!
!PhLJenkins2Build commentStamp: '' prior: 0!
I represent a Jenkins job. If I'm a simple job, artifacts are available directly. If I'm a matrix job, artefacts are available from runs.!
!PhLJenkins2Run commentStamp: '' prior: 0!
I represent a run of a job (one configuration) resulting from a matrix job.!
!PhLImage commentStamp: '' prior: 0!
I represent a Pharo image. I live in a particular location and have a name. Users can launch me.

Instance Variables
	file:		a reference to the .image file
	description: user description of the image
	formatNumber: image format number encoded in the image header
	architecture: is the image 32-bit or 64-bit
	pharoVersion: the Pharo version number of the image 
	originTemplate: template that was used to create this image
	
My metadata are serialized when setting description, template or before launching the image (implies to compute formatNumber, architecture and pharo version)!
!PhLROCheckStartup commentStamp: '' prior: 0!
Startup action used to check if the image can write in the working directory.
Currently needed for Epicea, logs, etc.!
!PhLRepository commentStamp: '' prior: 0!
Abstract superclass of the template and image repositories. User interfaces can use my interface to be notified when my instances change.!
!PhLDirectoryBasedImageRepository commentStamp: '' prior: 0!
I'm a group of images which are stored in subdirectories of a dedicated directory.

Each image in the group is stored in its own subdirectory with the same name as the image. E.g., if the group's baseDirectory is ~/.config/pharo/images, one example of an image could be ~/.config/pharo/images/Seaside3.0/Seaside3.0.image.

Instance Variables
	baseDirectory:		place where the images are stored
	images:		collection of PhImage
!
!PhLTemplateGroupRepository commentStamp: '' prior: 0!
I maintain a collection of PhLTemplateGroup. I take care of adding a cache to each group.!
!PhLStartupManager commentStamp: '' prior: 0!
PhLStartupManager is in charge of running startup actions related to the PharoLauncher.!
!PhLTemplateGroupsBuilder commentStamp: '' prior: 0!
I'm in charge of building the list of templates groups and its associated templates from a list of template sources.

I use as input an instance of PhLTemplateSources.
The default input is the serialized ston file 'sources.list' defining templates sources (stored in Launcher directory) + the user ston file 'mysources.list' if exists.
I'm used at Launcher creation, see PharoLauncherApplication >>#resetTemplateRepository.

To update the list of official sources, please update the sources files hosted at http://files.pharo.org/pharo-launcher/sources.list!
!PhLTemplateSource commentStamp: '' prior: 0!
I represent a source for templates used by Pharo Launcher to create an image.
	type could be a value between: jenkins, URL, http listing, cache, etc.

I'm just a state holder easily serializable with Ston !
!PhLTemplateSources commentStamp: '' prior: 0!
I represent a list of template sources used by Pharo Launcher.

You initialize me with a reference to a file (serialized with Ston) and then, you can ask me the list of PhlTemplateSource (you can see them as template groups).

ex:
 	(self withFile: PhLPharoTemplateSources sourcesFile) sources !
!PhLCompositeTemplateSources commentStamp: '' prior: 0!
I aggregate different template sources and provide a common API to access sources.!
!PhLPharoTemplateSources commentStamp: '' prior: 0!
I represent the official template sources used by Pharo Launcher.

Preview :
	PhLTemplateGroupsBuilder buildFrom: PhLPharoTemplateSources fromFile.
	
Serialization:
	self generateSourcesFile!
!PhLUserTemplateSources commentStamp: '' prior: 0!
I represent the template sources defined by the user locally and used by Pharo Launcher.

Preview :
	PhLTemplateGroupsBuilder buildFrom: PhLUserTemplateSources fromUserFile.!
!PhLTemplateSourcesUpdateChecker commentStamp: '' prior: 0!
Process used to chek regurlarly if there is an update for Launcher template sources.

PhLTemplateSourcesUpdateChecker run.
PhLTemplateSourcesUpdateChecker terminate 
!
!PhLTreeSelection commentStamp: '' prior: 0!
A container for holding nodes selected in a tree, as well as being able to render a full pathName for each selection.

!
!PhLUIConfirmation commentStamp: '' prior: 0!
Abstraction of a yes/no dialog.!
!PhLUIInformation commentStamp: '' prior: 0!
Abstraction of an information dialog.!
!PhLUIRequest commentStamp: '' prior: 0!
Abstraction of a string request dialog.!
!PhLVirtualMachine commentStamp: '' prior: 0!
I represent a Pharo virtual machine that can be used to run image.

executableRef is a reference to the script/binary to actually use to launch images.
vmBinaryRef is a reference to the vm binary (not a bash file).!
!PhLPrivateVirtualMachine commentStamp: '' prior: 0!
I represent a Pharo virtual machine used to determine an image phar version by running it with a VM compatible with its image format.

	ex: 6505 6521 68021
!
!PhLVirtualMachineManager commentStamp: '' prior: 0!
I'm in charge of selecting the appropriate Virtual Machine for a given image. If the required virtual machine is not found on disk, I will download it from http://files.pharo.org.
I determine the VM to use by reading the image file header.!
!PhLVirtualMachinesDataSource commentStamp: '' prior: 0!
I provide the list of virtual machines and private virtual machines for PharoLauncher.
!
!PharoLauncherModel commentStamp: '' prior: 0!
Provide an environment that the commands can query and change. The environment is composed of an image repository, a template repository, and a selection (of either images or templates).

Instance Variables
	imageRepository:		the list of available images in the system
	selection:		a current selection of either images or templates
	templateRepository:		the list of templates that can be used to create images.
!
!String methodsFor: '*PharoLauncher-Core'!
asLegalSelector
	"'234znak 43 ) 2' asLegalSelector"
	
	| toUse |
 	toUse := self select: [:char | char isAlphaNumeric].
	(toUse size = 0 or: [ toUse first isLetter not ])
		ifTrue: [ toUse := 'v', toUse ].
	^ toUse uncapitalized asSymbol.! !
!String methodsFor: '*PharoLauncher-Core'!
formatTemplateName: aUrlString
	"Format the receiver by interpolating elements from url string path segments, as in the following examples:" 
	"('{6} ({5})' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip') >>> 'Pharo7.0-32bit-TelePharo (v0.4.2)'"
	"We always remove the extension of the last segment ('.zip)"
	| segments |
	segments:= aUrlString asZnUrl segments.

	^ self class
		new: self size
		streamContents: [ :result | 
			| stream |
			stream := self readStream.
			[ stream atEnd ]
				whileFalse: [ | currentChar |
					(currentChar := stream next) == ${
						ifTrue: [ | expression index value |
							expression := stream upTo: $}.
							index := Integer readFrom: expression ifFail: [ expression ].
							value := segments at: index.
							result nextPutAll: (index = segments size ifTrue: [ value copyUpToLast: $. ] ifFalse: [ value ]) ]
						ifFalse: [ currentChar == $\
								ifTrue: [ stream atEnd
										ifFalse: [ result nextPut: stream next ] ]
								ifFalse: [ result nextPut: currentChar ] ] ] ]! !
!PhLSettingBrowser class methodsFor: 'initialization'!
initialize

	PhLStartupManager addToLauncherStartUpList: self! !
!PhLSettingBrowser class methodsFor: 'system startup'!
launcherStartUp
	PharoLauncherApplication isDeployed ifFalse: [ ^ self ].

	self preferencesFile ifNotNil: [ self new treeHolder updateSettingNodes ].

	"Allow to have manual settings in the preferences foldor of Pharo Launcher."
	self preferencesFolder exists ifTrue: [ StartupPreferencesLoader default load: (self preferencesFolder filesMatching: '*.st') ]! !
!PhLSettingBrowser class methodsFor: 'system startup'!
launcherStartUpPriority
	^ 100! !
!PhLSettingBrowser class methodsFor: 'accessing'!
preferencesFile
	^ (self preferencesFolder / 'settings.ston') asFileReference! !
!PhLSettingBrowser class methodsFor: 'private'!
preferencesFolder
	^ FileLocator preferences / 'pharo-launcher'! !
!PhLSettingBrowser methodsFor: 'private'!
exportSettings: aCollection toFileNamed: filename
	aCollection do: [ :startupAction | startupAction runOnce: false ].
	StartupPreferencesLoader default addAtStartup: aCollection inDirectory: self class preferencesFolder named: filename! !
!PhLSettingBrowser methodsFor: 'instance creation'!
newTreeHolder
	^ PhLSettingTree new 
		acceptableKeywords: self settingsKeywords
		! !
!PlatformResolver methodsFor: '*PharoLauncher-Core'!
launcherImagesLocation
	<origin>
	^ PhLDirectoryBasedImageRepository location resolve! !
!PlatformResolver methodsFor: '*PharoLauncher-Core'!
launcherUserFilesLocation
	"Where to put the user files (images, virtual machines) for the pharo launcher"
	<origin>
	^ self documents resolve / 'Pharo'! !
!PlatformResolver methodsFor: '*PharoLauncher-Core'!
launcherVMsLocation
	<origin>
	^ PhLVirtualMachineManager vmStore resolve! !
!PlatformResolver methodsFor: '*PharoLauncher-Core'!
vmExecutableName
	self subclassResponsibility! !
!VirtualMachine methodsFor: '*PharoLauncher-Core' prior: 86856168!
fullPath
	"Return the full vm path as a string"
	"Ex: '/Applications/Squeak/Squeak 4.2.5beta1U.app/Contents/MacOS/Squeak VM Opt'"
	"SmalltalkImage current vmFullPath"

	^(self getSystemAttribute: 0) asByteArray utf8Decoded! !
!Win32Platform methodsFor: '*PharoLauncher-Core'!
privShellExecute: lpOperation file: lpFile parameters: lpParameters directory: lpDirectory show: nShowCmd
	
	^self ffiCall: #( 
			FFIConstantHandle ShellExecuteA(
     				0,
     				char* lpOperation,
         			char* lpFile,
     				char* lpParameters,
     				char* lpDirectory,
        			int nShowCmd)) module: #shell32
	
! !
!Win32Platform methodsFor: '*PharoLauncher-Core'!
privShellExplore: folder
	"
	self privShellExplore: 'c:\'
	"

	^self privShellExecute: 'explore' file: folder parameters: '' directory: '' show: 5 "SW_SHOW"! !
!MacOSResolver methodsFor: '*PharoLauncher-Core'!
vmExecutableName
	^ 'Pharo'! !
!PhLSettingTree methodsFor: 'accessing'!
persistence
	^ persistence ifNil: 
		[ persistence := SystemSettingsPersistence new 
			fileReference: PhLSettingBrowser preferencesFile;
			settingTree: self;
			yourself ]! !
!OSPlatform methodsFor: '*PharoLauncher-Core'!
canRun32bitApp
	^ true! !
!SpecWindow methodsFor: '*PharoLauncher-Core' prior: 65653940!
close

	self model 
		ifNotNil: [ 
			self model askOkToClose
				ifTrue: [ self okToChange ifFalse: [ ^ self ] ] ].
		
	super close! !
!ZnUrl methodsFor: '*pharolauncher-core'!
jenkinsOptions
	| options |
	options := Dictionary new.
	(self segments atWrap: -2)
		splitOn: $,
		do: [ :option | 
			| pair |
			pair := option splitOn: $=.
			pair size ~= 2
				ifTrue: [ ^ Dictionary new	"the url is not properly formatted, we can't extract anything." ].
			options at: pair first put: pair second ].
	^ options! !
!WindowsResolver methodsFor: '*PharoLauncher-Core'!
vmExecutableName
	^ 'Pharo.exe'! !
!PhLAboutCommand class methodsFor: 'versions'!
version: aString

	LauncherVersion := aString.! !
!PhLAboutCommand methodsFor: 'querying'!
aboutText
	^ String streamContents: [:stream |
		stream
			<< 'Pharo Launcher version: ';
			<< self launcherVersion;
			cr; cr;
			<< 'Pharo Launcher is a tool that eases the management of Pharo images and their associated Virtual Machines. It can download official Pharo images from the Pharo repository, fetch the right virtual machine to run your image and many other things.';
			cr;
			<< 'Documentation is available at https://pharo-project.github.io/pharo-launcher.';
			cr;
			<< 'If you find a bug, please open an issue at https://github.com/pharo-project/pharo-launcher/issues.'.
 ]
	! !
!PhLAboutCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #help;
		shortcutKey: $? meta;
		yourself! !
!PhLAboutCommand methodsFor: 'executing'!
execute
	| presenter |
	presenter := PhLAboutPresenter 
		text: self aboutText
		iconName: #pharo.
	presenter application: self application.
	
	presenter openDialogWithSpec.
	^ presenter! !
!PhLAboutCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'About';
		description: 'Documentation and information about Pharo Launcher'! !
!PhLAboutCommand methodsFor: 'querying'!
launcherVersion

	^ LauncherVersion ifNil: [ 'N/A' ] ! !
!PhLGeneralCommand methodsFor: 'accessing'!
application
	^ self context application! !
!PhLOpenNewImageWindowCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallNew;
		shortcutKey: $n meta;
		yourself! !
!PhLOpenNewImageWindowCommand methodsFor: 'executing'!
execute
	^ (PhLTemplatesPresenter 
			newApplication: self application
			model: PhLTemplateGroupRepository default)
		selectCategory: 3; "official category"
		openWithSpec;
		yourself! !
!PhLOpenNewImageWindowCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'New';
		description: self class comment.! !
!PhLOpenSettingsCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #configurationIcon;
		yourself! !
!PhLOpenSettingsCommand methodsFor: 'executing'!
execute
	^ (PhLSettingBrowser forKeywords: #( #pharoLauncherSettings )) open! !
!PhLOpenSettingsCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Open settings';
		description: 'Open Pharo Launcher settings'! !
!PhLOpenVmManagerCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconProvider: self;
		iconName: #configurationIcon;
		yourself! !
!PhLOpenVmManagerCommand methodsFor: 'executing'!
execute
	(PhLVMPresenter 
		newApplication: self application
		model: PhLVirtualMachinesDataSource default) openWithSpec! !
!PhLOpenVmManagerCommand methodsFor: 'accessing'!
icon
	"encoded with 
		ZnBase64Encoder new encode: 'Cog-icon-grey.png' asFileReference binaryReadStream upToEnd."
	^ ImageReadWriter formFromStream: (ZnBase64Encoder new decode: 
		'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gkECQkiHlkkLQAAAu1JREFUOMttk09oXFUYxX/33Zs3k8wbhmQaMyUWBy00Jg1Yl1p3igpqwHaSgAs3QjZF60JwZWYVk6wEkSQlGxcuMqM7hUqxRJSIUs0iZqwiE9qq8TExf18yee/d+66bMUyxZ/Wtzvm+c84nAMbGxgAeX1paul0qlc4Aa8ArjuN8DZxPkuSXarVqeAAEQKlUAlgBHgKanuedD4LgLvAP0A0MDw0NBYBTLpeTdgKnbf4ik8k8BjhBEFwF7mQymQvAV5VK5XB5eVkNDg4mlUpFWmvFyQYt9R+llE8aY2ySJGfz+Xwd6NjZ2dmUUuajKLolpXy5Wq3+DWCtBRBCCCvGx8cBilrrN9Pp9NthGC4JIT601o6nUqkrcRx/XigUfk6S5KOurq4/gFFr7crGxsZmtVo17R5cB54HjlKpVFcYhlprvem6blQsFovAmrX212w2OxYEwQszMzNfAkKUy2UAZ319/VXgB6Agpfzedd2rhULhchzHF13XBTgEmkqpU1rrm9bah2dnZ8+pFkECfNq67d7AwMCjSqk/R0ZG3M7OzovHx8erxphnpJSHWusPcrncW7u7uzcBVHsko6OjAM7U1JSo1+sdvu87LVIcx3Huy1+IGED95+ji4uIlpdStMAxPHxwcrCil3nNd93Iul2N/f/9CHMc+cKSUyu/t7d0ATp8UaWFhAeCG4zjPGmOa2Wy2MwiCWErpG2OO6vX6GWttzXGc3z3PGwuC4MXp6enrgJBzc3NYa4tCiEc8z3sqiqLPoih6Awg9z3suDMNvtNaf5HK5d5rN5sdRFN0xxqz29/fv12q1RLTUV13XfSKKImuMOSulrAMdwF/pdPpUFEU/JUny0sTExOb/itR2wrs9PT3vb29v3wauWWsv9fb2Pr21tXWtu7t7ApC1Ws0AanJy0ggh7IkH8/PzAN8JIfLAcV9f37Dv+3eBLaBHaz3caDQe+EyqFRHA68aY34B+3/fXgNestd8Cg41G46itL/fhX0CxZrLKWx8FAAAAAElFTkSuQmCC') readStream! !
!PhLOpenVmManagerCommand methodsFor: 'accessing'!
iconNamed: aName
	^ self icon! !
!PhLOpenVmManagerCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Open VM Manager';
		description:
			'Open a new window allowing to manage Virtual Machines used to launch images'! !
!PhLQuitCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallQuitIcon;
		shortcutKey: $q meta;
		yourself! !
!PhLQuitCommand methodsFor: 'executing'!
execute
	PhLDownloadManager reset. "reset error logging"
	Smalltalk snapshot: false andQuit: true! !
!PhLQuitCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Quit';
		description: 'Quit Pharo Launcher'! !
!PhLRefreshImageRepositoryCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallUpdateIcon;
		shortcutKey: $u meta;
		yourself! !
!PhLRefreshImageRepositoryCommand methodsFor: 'executing'!
execute
	self context imageRepository contentsChanged.! !
!PhLRefreshImageRepositoryCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Refresh';
		description: 'Refresh image list'! !
!PhLRefreshTemplateRepositoryCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallUpdateIcon;
		shortcutKey: $u meta;
		yourself! !
!PhLRefreshTemplateRepositoryCommand methodsFor: 'executing'!
execute
	self context templateRepository refresh! !
!PhLRefreshTemplateRepositoryCommand methodsFor: 'initialization'!
initialize 
	super initialize.
	self
		basicName: 'Refresh';
		basicDescription: 'Refresh template list'.! !
!PhLRelocateImageDirectoryCommand methodsFor: 'executing'!
canBeExecuted
	self target ensureCreateDirectory.
	^ self source ~= self target 
		and: [ self source hasChildren 
		and: [ self target hasChildren not ] ]! !
!PhLRelocateImageDirectoryCommand methodsFor: 'executing'!
execute
	self canBeExecuted
		ifTrue: [ 
			UIManager default showWaitCursorWhile:
				[ self relocate.
				self informMigrationDone ] ]
		ifFalse: [ self informManualMigrationNeeded ]! !
!PhLRelocateImageDirectoryCommand methodsFor: 'user interaction'!
informManualMigrationNeeded
	self application newInformation
		message:
				('You need to manually relocate your images from {1} to {2}'
						format:
							{(self source pathString).
							(self target pathString)});
		inform! !
!PhLRelocateImageDirectoryCommand methodsFor: 'user interaction'!
informMigrationDone
	self application newInformation
		message:
				('Migration of your images from {1} to {2} done'
						format:
							{(self source pathString).
							(self target pathString)});
		inform! !
!PhLRelocateImageDirectoryCommand methodsFor: 'executing'!
relocate
	self source children do: [ :child | 
		child moveTo:
			(self target resolvePath: (child relativeTo: self source)) resolve ]! !
!PhLRelocateImageDirectoryCommand methodsFor: 'user interaction'!
requestTargetLocation
	^ self application newRequest
		initialAnswer: self source;
		title: 'New location for your images';
		validateAnswer: [ :answer | answer asFileReference ~= self source ];
		request! !
!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!
source
	^ source ifNil: [ source := PhLDirectoryBasedImageRepository location ]! !
!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!
source: aDirectory
	source := aDirectory! !
!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!
target
	^ target ifNil: [ target := self requestTargetLocation asFileReference ]! !
!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!
target: aDirectory
	target := aDirectory! !
!PhLCopyImageCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallCopyIcon;
		shortcutKey: $c meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLCopyImageCommand methodsFor: 'executing'!
execute
	| name |
	name := self newImageName.
	name ifNil: [ ^ self ].
	self imagesPresenter ensure: (self imageRepository isNewImageNameValid: name).
	UIManager default showWaitCursorWhile:
		[ self imageRepository
			copyImage: self imagesPresenter singleImage
			to: name ]! !
!PhLCopyImageCommand methodsFor: 'executing'!
imageRepository
	^ self imagesPresenter imageRepository! !
!PhLCopyImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Copy image';
		description: 'Copy the currently selected image to the new name.'! !
!PhLCopyImageCommand methodsFor: 'instance creation'!
newImageName
	^ self newImageName: self imagesPresenter singleImageName! !
!PhLCopyImageCommand methodsFor: 'instance creation'!
newImageName: aString 
	^ self imagesPresenter newRequest 
		title: 'Image name?';
		initialAnswer: aString;
		validateAnswer: [ :answer | (self imagesPresenter imageRepository hasImageNamed: answer) not ];
		request! !
!PhLCopyLaunchCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallCopyIcon;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLCopyLaunchCommand methodsFor: 'executing'!
execute
	Clipboard clipboardText: 
		self imagesPresenter selectedLaunchConfiguration commandString! !
!PhLCopyLaunchCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self name: 'Copy launch command'! !
!PhLCopyPathname methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallCopyIcon;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLCopyPathname methodsFor: 'executing'!
execute
	Clipboard clipboardText: 
		self imagesPresenter singleImage file fullName surroundedByDoubleQuotes.! !
!PhLCopyPathname methodsFor: 'initialization'!
initialize
	super initialize.
	self name: 'Copy pathname'! !
!PhLCreateTemplateFromImageCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallNewIcon;
		shortcutKey: $t meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLCreateTemplateFromImageCommand methodsFor: 'converting'!
asSpecCommandWithImageRemoval
	self
		willRemoveImage;
		name: 'Create Template and delete image';
		description:
			'Create a Template from the selected Pharo image and delete the image just after template creation'.
	^ super asSpecCommand
		iconName: #smallNewIcon;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLCreateTemplateFromImageCommand methodsFor: 'accessing'!
confirmTemplateOverride
	^ self imagesPresenter newConfirmation
		message: 'Do you want to override exisiting template?';
		confirm! !
!PhLCreateTemplateFromImageCommand methodsFor: 'executing'!
execute
	| name |
	name := self newTemplateName.
	name ifNil: [ PhLCommandCancellation signal ].
	self imagesPresenter createLocalTemplateFromSelectionNamed: name.
	"ensure the template is created before removing the image"
	(willRemoveImage and: [self imagesPresenter templateRepository hasLocalTemplateNamed: name])
		ifTrue: [ PhLDeleteImageCommand new
						context: context;
						execute ]! !
!PhLCreateTemplateFromImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	willRemoveImage := false.
	self
		name: 'Create Template';
		description: 'Create a Template from the selected Pharo image'! !
!PhLCreateTemplateFromImageCommand methodsFor: 'accessing'!
newTemplateName
	^ newTemplateName 
		ifNil: [ newTemplateName := self requestNewTemplateName: self imagesPresenter singleImageName ]! !
!PhLCreateTemplateFromImageCommand methodsFor: 'accessing'!
requestNewTemplateName: aString
	| templateRepository |
	templateRepository := self imagesPresenter templateRepository.
	^ self imagesPresenter newRequest
		title: 'Template name?';
		initialAnswer: (templateRepository makeUniqueTemplateName: aString);
		validateAnswer: [ :answer | 
			(templateRepository hasLocalTemplateNamed: answer)
				ifTrue: [ self confirmTemplateOverride ]
				ifFalse: [ true ] ];
		request! !
!PhLCreateTemplateFromImageCommand methodsFor: 'configuring'!
willRemoveImage
	willRemoveImage := true.! !
!PhLDeleteImageCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallDeleteIcon;
		shortcutKey: $x meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLDeleteImageCommand methodsFor: 'accessing'!
canBeExecuted 
	^ self imagesPresenter selectedImages notEmpty! !
!PhLDeleteImageCommand methodsFor: 'accessing'!
execute
	| images imageNames confirmMessage answer |
	images := self imagesPresenter selectedImages.
	imageNames := images collect: #name.
	confirmMessage := 'Are you sure you want to delete ', (imageNames joinUsing: ', ' last: ' and ').
	answer := self imagesPresenter newConfirmation
		message: (confirmMessage withNoLineLongerThan: 60) , '?';
		confirm.
	answer ifFalse: [ ^ self ].

	UIManager default showWaitCursorWhile:
		[ self imagesPresenter imageRepository deleteImages: images ].! !
!PhLDeleteImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Delete';
		description: 'Delete the selected Pharo images'! !
!PhLImageCommand methodsFor: 'accessing'!
canBeExecuted
	^ self imagesPresenter hasSingleImageSelected! !
!PhLImageCommand methodsFor: 'accessing'!
imagesPresenter
	^ self context! !
!PhLImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self description: self class comment! !
!PhLImportImageCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallLoadProject;
		shortcutKey: $y meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLImportImageCommand methodsFor: 'accessing'!
canBeExecuted
	^ true! !
!PhLImportImageCommand methodsFor: 'ui interaction'!
chooseNewImageNameFor: anImageName
	^ self imagesPresenter newRequest
		title: 'An image with the name ', anImageName , ' already exists. Please choose a new name:';
		initialAnswer: (self imagesPresenter imageRepository makeUniqueImageName: anImageName);
		validateAnswer: [ :answer | (self imagesPresenter imageRepository hasImageNamed: answer) not ];
		request! !
!PhLImportImageCommand methodsFor: 'executing'!
execute
	| answer |
	importSiblings := false.
	answer := self imagesPresenter newRequest
		title: 'What would you like to do?';
		chooseFrom:
			{ 'Import an image into Pharo Launcher images store (will move files)' .
			'Import the image directory (and all files it contains) into Pharo Launcher images store (will move files)' }.
	answer = 0 
		ifTrue: [ ^ self "cancel" ].
	answer = 2
		ifTrue: [ importSiblings := true ].
	self importImage.! !
!PhLImportImageCommand methodsFor: 'executing'!
import: imageFileRef
	| infoMessage destFolderName imageRepository |
	destFolderName := imageFileRef basenameWithoutExtension.
	imageRepository := self imagesPresenter imageRepository.
	[ imageRepository ensureNoImageWithName: destFolderName ]
		on: PhLNameNotAvailableError
		do: [ destFolderName := self chooseNewImageNameFor: destFolderName ].
	destFolderName ifNil: [ ^ self "abort" ].
	
	importSiblings
		ifTrue: [ 
			imageRepository
				importImageNamed: imageFileRef
				andSiblingFilesto: destFolderName ]
		ifFalse:
			[ imageRepository importImage: imageFileRef to: destFolderName ].
	infoMessage := 'Image ' , imageFileRef fullName , ' imported!!'.
	self imagesPresenter newInformation
		message: (infoMessage withNoLineLongerThan: 60);
		inform! !
!PhLImportImageCommand methodsFor: 'executing'!
importImage
	| imageFile |
	imageFile := self imagesPresenter newFileRequest
		title: 'Import a Pharo image (will move image, changes file and pharo-local folder)';
		extensionsToShow: #('image');
		path: FileLocator home;
		chooseFile.
	imageFile ifNil: [ 
		self imagesPresenter newInformation 
			message: 'No path selected. Import failed.';
			inform.
		^ self ].
	imageFile asFileReference isDirectory ifTrue: [ 
		self imagesPresenter newInformation 
			message: 'The file selected is a directory and not a Pharo image. Import failed.';
			inform.
		^ self ].
	self import: imageFile! !
!PhLImportImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Import';
		description:
			'Import into Pharo Launcher an existing Pharo image (and possibly its parent folder)'! !
!PhLInspectCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallInspectIt;
		shortcutKey: $i meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLInspectCommand methodsFor: 'accessing'!
canBeExecuted 
	^ self imagesPresenter selectedImages notEmpty! !
!PhLInspectCommand methodsFor: 'executing'!
execute
	self imagesPresenter singleImage inspect! !
!PhLInspectCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Inspect';
		description: 'Inspect the selected element'! !
!PhLLaunchImageCommand class methodsFor: 'settings'!
archMismatchSettingDescription
	^ 'Get a warning when trying to launch an image with a different architecture than the Launcher (i.e. trying to launch a 32-bit image from Pharo Launcher 64-bit). '! !
!PhLLaunchImageCommand class methodsFor: 'settings'!
archMismatchSettingLabel
	^ 'Warn on image architecture mismatch? ' translated! !
!PhLLaunchImageCommand class methodsFor: 'settings'!
quitOnLaunch
	^ QuitOnLaunch ifNil: [  QuitOnLaunch := false ].! !
!PhLLaunchImageCommand class methodsFor: 'settings'!
quitOnLaunch: aBoolean
	QuitOnLaunch = aBoolean 
		ifFalse: [ QuitOnLaunch := aBoolean ]! !
!PhLLaunchImageCommand class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #quitOnLaunch)
		label: 'Quit On Launch' translated;
		parent: #pharoLauncher;
		target: self;
		order: 30;
		description:
			'When enabled, Launcher quits when an image is launched. ' , String cr
				, 'When disabled, Launcher stays alive when an image is launched.'.
	(aBuilder setting: #warnOnArchMismatch)
		label: self archMismatchSettingLabel;
		parent: #pharoLauncher;
		target: self;
		order: 35;
		description: self archMismatchSettingDescription! !
!PhLLaunchImageCommand class methodsFor: 'settings'!
warnOnArchMismatch
	^ WarnOnArchMismatch ifNil: [  WarnOnArchMismatch := true ].! !
!PhLLaunchImageCommand class methodsFor: 'settings'!
warnOnArchMismatch: aBoolean
	WarnOnArchMismatch := aBoolean.
! !
!PhLLaunchImageCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallDoItIcon;
		shortcutKey: $l meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLLaunchImageCommand methodsFor: 'converting'!
asSpecLaunchWithoutSettingsCommand
	self
		doNotUseSettings;
		name: 'Basic lau...';
		description: 'Launch the selected Pharo image without settings'.
	^ super asSpecCommand
		iconProvider: self;
		iconName: #smallDoItIcon;
		"shortcutKey: $l meta, $b meta ;"
		beDisabledWhenCantBeRun;
		yourself! !
!PhLLaunchImageCommand methodsFor: 'private'!
basicIconNamed: aName
	"Only used for basic launch command"
	^ super iconNamed: aName! !
!PhLLaunchImageCommand methodsFor: 'configuring'!
doNotUseSettings
	useSettings := false.! !
!PhLLaunchImageCommand methodsFor: 'executing'!
execute
	self imagesPresenter hasSingleImageSelected
		ifTrue: [ ^ self launchSelectedImage ]
		ifFalse: [ ^ nil ]! !
!PhLLaunchImageCommand methodsFor: 'private'!
iconNamed: aName
	"Only used for basic launch command"
	^ (self basicIconNamed: aName) asGrayScaleWithAlpha! !
!PhLLaunchImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	useSettings := true.
	self name: 'Launch'! !
!PhLLaunchImageCommand methodsFor: 'executing'!
launchConfigurationOfImage: aPhLImage
	^ self imagesPresenter selectedLaunchConfiguration! !
!PhLLaunchImageCommand methodsFor: 'executing'!
launchImage: aPhLImage
	| process launchConfig |
	[ launchConfig := self launchConfigurationOfImage: aPhLImage.
	launchConfig useSettings: useSettings.
	process := aPhLImage launchWithConfiguration: launchConfig. ]
		on: PhLError
		do: [ :error | error uiAlert. ^ process ].
	"Waiting for https://github.com/pharo-contributions/OSSubprocess/issues/58 to be fixed
	(PhLLaunchedImagesWatcher process: process image: aPhLImage) check."
	self class quitOnLaunch
		ifTrue: [ self quit ].
	^ process! !
!PhLLaunchImageCommand methodsFor: 'executing'!
launchSelectedImage
	^ self launchImage: self imagesPresenter singleImage! !
!PhLLaunchImageCommand methodsFor: 'private'!
quit
	(PhLQuitCommand forSpecContext: self imagesPresenter) execute! !
!PhLLaunchImageFromDiskCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		"iconName: #smallLoadProject;
		shortcutKey: $d meta;"
		beDisabledWhenCantBeRun;
		iconName: self;
		iconProvider: self;
		yourself! !
!PhLLaunchImageFromDiskCommand methodsFor: 'accessing'!
canBeExecuted
	^ true! !
!PhLLaunchImageFromDiskCommand methodsFor: 'executing'!
execute
	| imageFile |
	imageFile := self imagesPresenter newFileRequest 
		title: 'Open a Pharo image';
		extensionsToShow: #('image');
		path: FileLocator home;
		chooseFile.
	imageFile ifNil: [ ^ self ].
	imageFile isFile ifFalse: [ ^self ].
	^ self launchImage: (PhLImage location: imageFile).! !
!PhLLaunchImageFromDiskCommand methodsFor: 'accessing'!
iconNamed: anIconName
	^ (self basicIconNamed: #open) mergeWith: (self basicIconNamed: #smallDoItIcon) at:0@0! !
!PhLLaunchImageFromDiskCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self name: 'From disk'! !
!PhLLaunchImageFromDiskCommand methodsFor: 'executing'!
launchConfigurationOfImage: aPhLImage
	^ aPhLImage defaultLaunchConfiguration! !
!PhLOpenLaunchConfigurationEditorCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #edit;
		yourself! !
!PhLOpenLaunchConfigurationEditorCommand methodsFor: 'executing'!
execute
	^ (PhLLaunchConfigurationPresenter 
			newApplication: self imagesPresenter application
			model: self imagesPresenter singleImage)
		openWithSpec;
		yourself! !
!PhLOpenLaunchConfigurationEditorCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self 
		name: '';
		description: self class comment.! !
!PhLRecreateImageCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #refreshIcon;
		shortcutKey: $R meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLRecreateImageCommand methodsFor: 'user interaction'!
askConfirmation
	| confirmMessage |
	
	confirmMessage := 'Are you sure you want to recreate this image?' , Character cr asString, 
							'This will overwrite the existing image and you will lose changes.'.
	^ self imagesPresenter newConfirmation
		message: (confirmMessage withNoLineLongerThan: 60) , '?';
		confirm.! !
!PhLRecreateImageCommand methodsFor: 'executing'!
execute
	self askConfirmation
		ifTrue: [ self imagesPresenter selectedImages 
						do: [ :image |	
								UIManager default showWaitCursorWhile:
									[ self imagesPresenter imageRepository recreateImage: image ] ] ]! !
!PhLRecreateImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Recreate';
		description: self class comment! !
!PhLRenameImageCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #workspaceIcon;
		shortcutKey: $r meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLRenameImageCommand methodsFor: 'executing'!
execute
	| name |
	name := self newImageName.
	name ifNil: [ ^ self ].
	self imagesPresenter imageRepository 
		renameImage: self imagesPresenter singleImage 
		to: name! !
!PhLRenameImageCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Rename';
		description: 'Rename the currently selected image and move the files accordingly.'! !
!PhLRenameImageCommand methodsFor: 'private'!
newImageName
	^ self newImageName: self imagesPresenter singleImageName! !
!PhLRenameImageCommand methodsFor: 'private'!
newImageName: aString 
	^ self imagesPresenter newRequest 
		title: 'Image name?';
		initialAnswer: aString;
		validateAnswer: [ :answer | (self imagesPresenter imageRepository hasImageNamed: answer) not ];
		request! !
!PhLShowImageInFolderCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #openIcon;
		shortcutKey: $o meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLShowImageInFolderCommand methodsFor: 'executing'!
execute
	self imagesPresenter singleImage showNativeFolder! !
!PhLShowImageInFolderCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self name: 'Show in folder'! !
!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!
addDescriptionIfAny
	| description |
	description := self templatesPresenter description.
	description isNotEmpty
		ifTrue: [ image description: description ].! !
!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!
addInitializationScriptMetadataIfPresent
	| initScript |
	initScript := self templatesPresenter initializationScript.
	(initScript exists and: [ initScript contents isNotEmpty ])
		ifTrue: [ image initializationScript: initScript ].! !
!PhLCreateImageFromTemplateCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallNewIcon;
		shortcutKey: $s meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!
createImage
	| name |
	name := self templatesPresenter imageName.
	name isEmptyOrNil ifTrue: [ ^ self ].
	
	image := self templatesPresenter imageRepository
		extractTemplate: self templatesPresenter singleTemplate
		to: name.
	self addInitializationScriptMetadataIfPresent.
	self addDescriptionIfAny.
	self templatesPresenter application imageRepositoryChanged: image.
	^ image! !
!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!
execute
	
	[ ^ self createImage ]
		on: PhLCorruptedTemplateError
		do: [ :error | 
			UIManager default
				alert: 'This template appears to be corrupted!! Please try again.' ]! !
!PhLCreateImageFromTemplateCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Create image';
		description: 'Create a new image from the selected template'! !
!PhLRemoveTemplateCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallDelete;
		shortcutKey: $x meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLRemoveTemplateCommand methodsFor: 'testing'!
canBeExecuted
	^ self templatesPresenter hasLocalTemplatesSelected! !
!PhLRemoveTemplateCommand methodsFor: 'executing'!
execute 
	| templates templateNames confirmMessage answer |
	templates := self templatesPresenter selectedTemplates.
	templates ifEmpty: [ ^ self ].
	
	templateNames := templates collect: #name.
	confirmMessage := 'Are you sure you want to delete ' , (templateNames joinUsing: ', ' last: ' and ').
	answer := self templatesPresenter newConfirmation
		message: (confirmMessage withNoLineLongerThan: 60) , '?';
		confirm.
	answer ifFalse: [ ^ self "abort" ].
		
	self templatesPresenter templateRepository deleteTemplates: templates.
	self templatesPresenter refresh. ! !
!PhLRemoveTemplateCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Remove template';
		description: 'Remove the selected template from the local cache'! !
!PhLRenameTemplateCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #workspace;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLRenameTemplateCommand methodsFor: 'testing'!
canBeExecuted
	^ self templatesPresenter hasLocalTemplateSelected! !
!PhLRenameTemplateCommand methodsFor: 'executing'!
execute 
	| name template |
	template := self templatesPresenter singleTemplate.
	name := self newTemplateName.
	name ifNil: [ ^ self "cancel" ].
	
	self templatesPresenter templateRepository rename: template to: name.
	self templatesPresenter refresh. ! !
!PhLRenameTemplateCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Rename template';
		description: 'Rename the selected template from the local cache'! !
!PhLRenameTemplateCommand methodsFor: 'instance creation'!
newTemplateName
	^ self newTemplateName: self templatesPresenter singleTemplate name! !
!PhLRenameTemplateCommand methodsFor: 'instance creation'!
newTemplateName: aString 
	^ self templatesPresenter newRequest 
		title: 'New name for the template?';
		initialAnswer: aString;
		validateAnswer: [ :answer | (self templatesPresenter templateRepository hasLocalTemplateNamed: answer) not ];
		request! !
!PhLTemplateCommand methodsFor: 'accessing'!
templatesPresenter
	^ self context! !
!PhLDeleteVmCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallDeleteIcon;
		shortcutKey: $x meta;
		beDisabledWhenCantBeRun;
		yourself! !
!PhLDeleteVmCommand methodsFor: 'executing'!
execute
	| vms vmNames confirmMessage answer |
	vms := self vmsPresenter selectedVms.
	vmNames := vms collect: #name.
	confirmMessage := 'Are you sure you want to delete VM ' , (vmNames joinUsing: ', ' last: ' and ').
	answer := self vmsPresenter newConfirmation
		message: (confirmMessage withNoLineLongerThan: 60) , '?';
		confirm.
	answer ifFalse: [ ^ self ].
	
	UIManager default showWaitCursorWhile:
		[ vms do: #removeFromSystem.
		self vmsPresenter refresh. ]! !
!PhLDeleteVmCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self
		name: 'Delete';
		description: 'Delete the selected Pharo Virtual Machines'! !
!PhLShowVmInFolderCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #openIcon;
		shortcutKey: $o meta;
		yourself! !
!PhLShowVmInFolderCommand methodsFor: 'executing'!
execute
	| vms |
	vms := self vmsPresenter selectedVms.
	vms size >= 1
		ifTrue: [ vms first showInFolder ]! !
!PhLShowVmInFolderCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self name: 'Show in Folder'! !
!PhLToggleVmPrivateVmCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #remote;
		beDisplayedOnRightSide;
		configureAsToolBarToggleButton;
		yourself! !
!PhLToggleVmPrivateVmCommand methodsFor: 'executing'!
execute
	self vmsPresenter toggleShowVmPrivateVm.! !
!PhLToggleVmPrivateVmCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self name: 'public'! !
!PhLUpdateVmCommand methodsFor: 'converting'!
asSpecCommand
	^ super asSpecCommand
		iconName: #smallUpdate;
		shortcutKey: $u meta;
		yourself! !
!PhLUpdateVmCommand methodsFor: 'executing'!
execute
	self vmsPresenter selectedVms do: #updateFromUrl.
	self vmsPresenter refresh.! !
!PhLUpdateVmCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self name: 'Update'! !
!PhLVmCommand methodsFor: 'initialization'!
initialize
	super initialize.
	self description: self class comment! !
!PhLVmCommand methodsFor: 'accessing'!
vmsPresenter
	^ self context! !
!PhLCommandError methodsFor: 'accessing'!
longDescription
	^ 'Pharo Launcher Command Error!!'! !
!PhLCommandError methodsFor: 'accessing'!
name
	^ 'command error'! !
!PhLDownloadError class methodsFor: 'signalling'!
signalUrl: anUrl
	^ self new
		setUrl: anUrl;
		signal! !
!PhLDownloadError methodsFor: 'accessing'!
longDescription
	^ 'Error downloading ', (url printStringLimitedTo: 100)! !
!PhLDownloadError methodsFor: 'accessing'!
name
	^ 'network error'! !
!PhLDownloadError methodsFor: 'initialization'!
setUrl: anUrl	
	url := anUrl! !
!PhLError methodsFor: 'accessing'!
longDescription
	^ self subclassResponsibility! !
!PhLError methodsFor: 'accessing'!
name
	^ self subclassResponsibility! !
!PhLError methodsFor: 'ui'!
uiAlert
	UIManager default
		alert: self longDescription
		title: self name
		configure: [ :morph | (morph findDeeplyA: TextMorph) unlock ]! !
!PhLExecutableNotFoundError class methodsFor: 'signalling'!
signalKind: aKindOfApp inPath: aString
	^ self new
		kindOfApplication: aKindOfApp;
		path: aString;
		signal! !
!PhLExecutableNotFoundError methodsFor: 'accessing'!
kindOfApplication: string
	kindOfApplication := string! !
!PhLExecutableNotFoundError methodsFor: 'accessing'!
longDescription
	^ 'Cannot detect Pharo ', kindOfApplication ,' in ', path, '.', String cr, 'Delete the folder and retry!! It can also due to a corruption of the downloaded file...'! !
!PhLExecutableNotFoundError methodsFor: 'accessing'!
name
	^ 'Pharo Executable Not Found'! !
!PhLExecutableNotFoundError methodsFor: 'accessing'!
path
	^ path! !
!PhLExecutableNotFoundError methodsFor: 'accessing'!
path: string
	path := string! !
!PhLImageVersionDeterminationError class methodsFor: 'signalling'!
signalCommand: aCommandString
	^ self new
		setCommand: aCommandString;
		signal! !
!PhLImageVersionDeterminationError methodsFor: 'accessing'!
longDescription
	^ PhLImage versionFileName , 
	' file was not found for your image, and probably your VMs are not up to date.
Please, contact us at http://pharo.org/community'! !
!PhLImageVersionDeterminationError methodsFor: 'accessing'!
name
	^ 'Cannot determine image version'! !
!PhLImageVersionDeterminationError methodsFor: 'initialization'!
setCommand: aCommandString
	command := aCommandString reject: [ :c | c = Character cr ] "easier to run the copy/pasted command in a shell if command has only one line"! !
!PhLArchitectureError class methodsFor: 'signalling'!
signalImage: anImage
	^ self new 
		process: nil image: anImage;
		signal! !
!PhLArchitectureError methodsFor: 'accessing'!
longDescription
	^ ('Cannot run {1} image!!' format: { image name }), 
		String cr, 
		'This image requires a 32-bit VM to run and 32-bit applications are not supported on this Operating System!!'! !
!PhLArchitectureError methodsFor: 'accessing'!
name
	^ 'Architecture error'! !
!PhLLaunchError class methodsFor: 'signalling'!
signalProcess: aProcess image: anImage
	^ self new 
		process: aProcess image: anImage;
		signal! !
!PhLLaunchError methodsFor: 'action'!
defaultAction 
	PhLUIInformation new
		message: self longDescription;
		alert! !
!PhLLaunchError methodsFor: 'accessing'!
longDescription
	^ ('An error occured while launching {1} image' format: image name), 
		String cr, process stderrString! !
!PhLLaunchError methodsFor: 'accessing'!
name
	^ 'Launch error'! !
!PhLLaunchError methodsFor: 'initialization'!
process: aPhLProcessWrapper image: aPhLImage 
	process := aPhLProcessWrapper.
	image := aPhLImage.! !
!PhLMissingVirtualMachineError class methodsFor: 'signalling'!
signalVm: aPhLVirtualMachine
	^ self new 
		setVm: aPhLVirtualMachine;
		signal! !
!PhLMissingVirtualMachineError methodsFor: 'private'!
isResumable 
	^ true! !
!PhLMissingVirtualMachineError methodsFor: 'accessing'!
longDescription
	^ vm id , 
	' virtual machine was not found!!'! !
!PhLMissingVirtualMachineError methodsFor: 'accessing'!
name
	^ 'Cannot find VM'! !
!PhLMissingVirtualMachineError methodsFor: 'initialization'!
setVm: aPhlVirtualMachine
	vm := aPhlVirtualMachine! !
!PhLNameNotAvailableError class methodsFor: 'signalling'!
signalName: aString
	^ self new
		setProvidedName: aString;
		signal! !
!PhLNameNotAvailableError methodsFor: 'accessing'!
longDescription
	^ 'Provided name {1} is not available!!' format: self providedName! !
!PhLNameNotAvailableError methodsFor: 'accessing'!
name
	^ 'Name error'! !
!PhLNameNotAvailableError methodsFor: 'initialization'!
providedName
	^ providedName! !
!PhLNameNotAvailableError methodsFor: 'initialization'!
setProvidedName: aString
	providedName := aString! !
!PhLProcessTimeOut methodsFor: 'accessing'!
longDescription
	^ 'Process took too much time. Aborted!!'! !
!PhLProcessTimeOut methodsFor: 'accessing'!
name
	^ 'Process timeout'! !
!MacOSXPlatform methodsFor: '*PharoLauncher-Core'!
canRun32bitApp
	^ self version asInteger < 1015 "OS X Mojave 10.15 drop support of 32-bit application "! !
!PhLSourcesFileUpdateAvailable class methodsFor: 'instance creation'!
sources: aListOfTemplateSources 
	^ self new 
		sources: aListOfTemplateSources;
		yourself! !
!PhLSourcesFileUpdateAvailable methodsFor: 'accessing'!
sources
	^ sources! !
!PhLSourcesFileUpdateAvailable methodsFor: 'accessing'!
sources: aListOfTemplateSources 
	sources := aListOfTemplateSources! !
!LGitLibrary class methodsFor: '*PharoLauncher-Core' prior: 32640690!
startUp: isImageStarting
	"avoid init error with libgit. See https://github.com/pharo-project/pharo/issues/4463"
	(isImageStarting and: [ PharoLauncherApplication isDeployed not ])
		ifTrue: [ self uniqueInstance initializeLibGit2 ]! !
!LGitLibrary methodsFor: '*PharoLauncher-Core' prior: 32637665!
unixModuleName
	| pluginDir |
	pluginDir := Smalltalk vm directory asFileReference.
	#('libgit2.so' 'libgit2.so.0')
		detect: [ :each | (pluginDir / each) exists ] 
		ifFound: [ :libName | ^ libName ].

	self error: 'Module not found.'! !
!PhLFileBrowser class methodsFor: 'instance creation'!
openOn: aFileReferenceOrPathString

	^ self new 
		path: aFileReferenceOrPathString;
		open.! !
!PhLFileBrowser methodsFor: 'action'!
open 
	self visit! !
!PhLFileBrowser methodsFor: 'accessing'!
path: aFileReferenceOrPathString
	"Opens an OS-specific file and directory browser on ==aFileReference==. If aFileReference is a file, opens the browser on its containing directory instead."
	| ref |
	aFileReferenceOrPathString isNil ifTrue: [ ^ nil ].
	ref := aFileReferenceOrPathString asFileReference.
	ref exists ifFalse: [ ^ nil ].
	
	ref := ref isFile ifTrue: [ ref parent ] ifFalse: [ ref ].
	(ref isNil or: [ ref exists not ])
		ifTrue: [ ^ nil ].

	path := ref fullName.! !
!PhLFileBrowser methodsFor: 'visiting'!
visitMacOS: aPlatform
	^ PhLProcessWrapper new 
		shellCommand;
		addArgument: ('open "{1}"' format: {path});
		runUnwatch! !
!PhLFileBrowser methodsFor: 'visiting'!
visitUnix: aPlatform
	^  PhLProcessWrapper new 
		shellCommand;
		addArgument: ('xdg-open "{1}"' format: {path});
		runUnwatch! !
!PhLFileBrowser methodsFor: 'visiting'!
visitWindows: aPlatform
	^ aPlatform privShellExplore: path! !
!PhLLaunchImageProcessConfigurator methodsFor: 'private - unix'!
cleanLDLibraryPath
	^ (self currentLDLibraryPaths
		reject: [ :path | path = FileLocator vmDirectory pathString ])
! !
!PhLLaunchImageProcessConfigurator methodsFor: 'private'!
configurePotentialInitializationScript
	launchConfiguration image shouldRunInitializationScript 
		ifFalse: [ ^ self ].
		
	launchConfiguration image initializationScript 
		ifNotNil: [ :script | 
						process 
							addArgument: 'eval';
							addArgument: script fullName surroundedByDoubleQuotes ].! !
!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!
configureVm
	super visit.	"platform specific behavior"
	launchConfiguration vm isHeadless
		ifTrue: [ process addArgument: launchConfiguration vm class headlessOptionString ].
	launchConfiguration vmArguments 
		do: [ :arg | process addArgument: arg ].! !
!PhLLaunchImageProcessConfigurator methodsFor: 'private - unix'!
currentLDLibraryPaths
	^ (OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ])
		substrings: ':'! !
!PhLLaunchImageProcessConfigurator methodsFor: 'private - unix'!
exportLDLibraryPathCommandWith: vmDirectoryPath
	^ 'export LD_LIBRARY_PATH=' ,
		($: join: ((self cleanLDLibraryPath copyWithFirst: vmDirectoryPath) collect: #surroundedBySingleQuotes))
! !
!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!
imageFile
	^ launchConfiguration image imageFile! !
!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!
launchConfiguration: aPhLLaunchConfiguration
	launchConfiguration := aPhLLaunchConfiguration! !
!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!
launchInALoginShell: anObject
	launchInALoginShell := anObject! !
!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!
usePharoSettings
	^ launchConfiguration isUsingPharoSettings! !
!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!
visit
	process := PhLProcessWrapper new.
	process workingDirectory: self imageFile parent pathString.
	self configureVm.
	process
		addArgument: self imageFile pathString surroundedByDoubleQuotes.
	self usePharoSettings
		ifFalse: [ process addArgument: '--no-default-preferences' ].
	self configurePotentialInitializationScript.
	launchConfiguration imageArguments 
		do: [ :arg | process addArgument: arg ].
	^ process! !
!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!
visitGeneric: aPlatform
	launchInALoginShell
		ifTrue: [ process loginShellCommand.
					process addArgument: self vmPath surroundedByDoubleQuotes ]
		ifFalse: [process command: self vmPath "surroundedByDoubleQuotes" ].! !
!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!
visitUnix: aPlatform
	
	launchInALoginShell
		ifTrue: [ process loginShellCommand ]
		ifFalse: [ process shellCommand ].
	process 
		addArguments: (self exportLDLibraryPathCommandWith: self vmDirectoryPath);
		addArguments: '&& export SQUEAK_PLUGINS="" &&';
		addArgument: self vmPath.! !
!PhLLaunchImageProcessConfigurator methodsFor: 'private'!
vmDirectoryPath
	^ self vmPath asFileReference parent fullName! !
!PhLLaunchImageProcessConfigurator methodsFor: 'private'!
vmPath
	^ launchConfiguration vm executablePath! !
!PhLProcessWrapper class methodsFor: 'testing'!
isCommandAvailable: aCommand
	| process |
	
	[ process := self new 
		shellCommand;
		addArgument: aCommand;
		runAndWaitTimeOut: 2 seconds.
		^ process isSuccess ]
	on: Error 
	do: [ ^ false ]! !
!PhLProcessWrapper methodsFor: 'building'!
addArgument: aString
	arguments add: aString! !
!PhLProcessWrapper methodsFor: 'building'!
addArguments: aString
	self addArguments: aString separator: Character space! !
!PhLProcessWrapper methodsFor: 'building'!
addArguments: aString separator: aCharacter
	(aCharacter split: aString)
		do: [ :arg | self addArgument: arg ]! !
!PhLProcessWrapper methodsFor: 'accessing'!
arguments
	"On Linux and OS X, we give an array of arguments to the process. 
	If the command is a shell, then pathes HAVE TO be protected with double quotes.
	It the command is pharo-vm, then pathes SHOULD NOT be surrounded by double quotes, else they are interpreted as part of the argument. This is not true on Windows because arguments is a String with all arguments. It means we MUST keep double quotes for windows pathes.
	We assume that arguments are already protected (user knows what to protect, we cannot guess)."
	(isShellCommand or: [ Smalltalk os isWindows ])
		ifTrue: [ ^ arguments asArray ].
	^ arguments
		collect:	[ :arg | 
			(arg first = $" and: [ arg last = $" ])
				ifTrue: [ arg allButFirst allButLast ]
				ifFalse: [ arg ] ]
		as: Array! !
!PhLProcessWrapper methodsFor: 'accessing'!
command 
	^ command! !
!PhLProcessWrapper methodsFor: 'building'!
command: apathString
	command := apathString! !
!PhLProcessWrapper methodsFor: 'querying'!
commandLineString
	^ PhLProcessWrapperCommandStringGenerator new 
		processWrapper: self;
		visit! !
!PhLProcessWrapper methodsFor: 'accessing'!
exitCode
	^ Smalltalk os isWindows
		ifTrue: [ process exitCode ] 
		ifFalse: [ process exitStatus ]! !
!PhLProcessWrapper methodsFor: 'initialization'!
initialize
	super initialize.
	arguments := OrderedCollection new.
	isShellCommand := false.
	useLoginShell := false! !
!PhLProcessWrapper methodsFor: 'testing'!
isRunning
	^ Smalltalk os isWindows
		ifTrue: [ process isRunning not ] 
		ifFalse: [ process isComplete not ]! !
!PhLProcessWrapper methodsFor: 'testing'!
isShellCommand
	^ isShellCommand! !
!PhLProcessWrapper methodsFor: 'testing'!
isSuccess
	^ Smalltalk os isWindows
		ifTrue: [ process isRunning not and: [ process exitCode == 0 ] ] 
		ifFalse: [ process isSuccess ]! !
!PhLProcessWrapper methodsFor: 'building'!
loginShellCommand 
	self shellCommand.
	useLoginShell := true.! !
!PhLProcessWrapper methodsFor: 'private'!
prepareProcess
	"I am an OSPlatform visitor. Running the visit will actually configure thr process dependending on the Operating System"
	self visit! !
!PhLProcessWrapper methodsFor: 'private'!
process: aProcessWrapper 
	process := aProcessWrapper! !
!PhLProcessWrapper methodsFor: 'running'!
runAndWait
	self prepareProcess.
	process runAndWait.
	
	process isSuccess ifFalse: [
		self error: 'command ', self commandLineString ,' failed' ].
! !
!PhLProcessWrapper methodsFor: 'running'!
runAndWaitTimeOut: aDuration
	Smalltalk os isWindows
		ifTrue: [ self runOnWindowsAndWaitTimeOut: aDuration ]
		ifFalse: [ self runOnLinuxAndWaitTimeOut: aDuration ]! !
!PhLProcessWrapper methodsFor: 'running'!
runOnLinuxAndWaitTimeOut: aDuration
	self prepareProcess.
	[ process 
		run;
		waitForExitWithTimeout: aDuration ]
	on: OSSTimeout
	do: [ PhLProcessTimeOut signal ].! !
!PhLProcessWrapper methodsFor: 'running'!
runOnWindowsAndWaitTimeOut: aDuration
	self prepareProcess.
	process runAndWaitTimeOut: aDuration asMilliSeconds.
	
	process hasTimedOut
		ifTrue: [ PhLProcessTimeOut signal ].
! !
!PhLProcessWrapper methodsFor: 'running'!
runUnwatch
	self prepareProcess.
	Smalltalk os isWindows
		ifTrue: [ process runUnwatch. ]
		ifFalse: [ process run. ]! !
!PhLProcessWrapper methodsFor: 'building'!
shellCommand 
	isShellCommand := true.! !
!PhLProcessWrapper methodsFor: 'accessing'!
stderrString
	^ Smalltalk os isWindows
		ifTrue: [ 'Std error not available on Windows' ]
		ifFalse: [ (process stderrStream upToEndOfFile ifNil: [ '' ]) trimBoth ]! !
!PhLProcessWrapper methodsFor: 'terminating'!
terminate 
	process terminate! !
!PhLProcessWrapper methodsFor: 'private'!
visitMacOS: aPlatform
	self visitUnix: aPlatform! !
!PhLProcessWrapper methodsFor: 'private'!
visitUnix: aPlatform
	process := OSSUnixSubprocess new
		workingDirectory: workingDirectory;
		"redirectStderr;" "Waiting for https://github.com/pharo-contributions/OSSubprocess/issues/58 to be fixed"
		yourself.
	isShellCommand 
		ifTrue: [ | commandLine |
			commandLine := Character space join: self arguments.
			useLoginShell 
				ifTrue: [ process loginShellCommand: commandLine ]
				ifFalse: [ process shellCommand: commandLine ] ] 
		ifFalse: [ process command: command.
					process arguments: self arguments. ].! !
!PhLProcessWrapper methodsFor: 'private'!
visitWindows: aPlatform
	process := OSWSWinProcess new
		workingDirectory: workingDirectory;
		yourself.
	isShellCommand 
		ifTrue: [ process shellCommand ] 
		ifFalse: [ process command: command ].
	process arguments: self arguments.! !
!PhLProcessWrapper methodsFor: 'accessing'!
workingDirectory 
	^ workingDirectory ! !
!PhLProcessWrapper methodsFor: 'building'!
workingDirectory: apathString
	workingDirectory := apathString! !
!PhLProcessWrapperCommandStringGenerator methodsFor: 'accessing'!
processWrapper: aPhLProcessWrapper
	processWrapper := aPhLProcessWrapper ! !
!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!
visitGeneric: aPlatform
	| commandLine |
	commandLine := processWrapper workingDirectory 
		ifNil: [ '' ]
		ifNotNil: [ 'cd ' ,  processWrapper workingDirectory surroundedByDoubleQuotes, sequenceSeparator ].
	 processWrapper isShellCommand 
		ifFalse: [ commandLine := commandLine ,  processWrapper command surroundedByDoubleQuotes, ' ' ].
	commandLine := commandLine , (Character space join:  processWrapper arguments).
	^  processWrapper isShellCommand 
		ifTrue: [ shellCommandBlock value: commandLine ]
		ifFalse: [ commandLine ]
! !
!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!
visitMacOS: aPlatform
	^ self visitUnix: aPlatform! !
!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!
visitUnix: aPlatform
	sequenceSeparator := ' && '.
	shellCommandBlock := [ :commandLine | 'bash -c ''{1}''' format: { commandLine } ].
	^ self visitGeneric: aPlatform! !
!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!
visitWindows: aPlatform
	sequenceSeparator := ' & '.
	shellCommandBlock := [ :commandLine | 'C:\Windows\System32\cmd.exe /C ', commandLine surroundedByDoubleQuotes ].
	^ self visitGeneric: aPlatform! !
!PhLArchitectureMismatchWarning class methodsFor: 'signalling'!
signalLauncherArch: launcherArchitecture imageArch: imageArchitecure 
	^ self new
		initializeWith: launcherArchitecture imageArch: imageArchitecure;
		signal! !
!PhLArchitectureMismatchWarning methodsFor: 'initialization'!
initializeWith: launcherArch imageArch: imageArch
	launcherArchitecture := launcherArch.
	imageArchitecture := imageArch.! !
!PhLArchitectureMismatchWarning methodsFor: 'accessing'!
longDescription
	^ String streamContents: [ :stream |
		stream
			nextPutAll: 'Warning!! You are trying to launch a ';
			nextPutAll: imageArchitecture;
			nextPutAll: ' image requiring a ';
			nextPutAll: imageArchitecture;
			nextPutAll: ' VM.';
			nextPut: Character cr;
			nextPutAll: 'Your Pharo Launcher architecture is ';
			nextPutAll: launcherArchitecture;
			nextPutAll: '. You may need to install additional librairies to your system.';
			nextPut: Character cr;
			nextPutAll: 'See https://pharo.org/gnu-linux-installation for more information.' ]! !
!PhLArchitectureMismatchWarning methodsFor: 'accessing'!
name
	^ 'Architecture Mismatch!! Continue?'! !
!PharoCommandLineHandler methodsFor: '*PharoLauncher-Core' prior: 55497280!
runPreferences
	"When Pharo Launcher is deployed, ignore Pharo preferences. Pharo preferences will only be loaded when Pharo Launcher is in developer mode."
	"PhLSettingBrowser startup action is in charge of loading launcher preferences."
	PharoLauncherApplication isDeployed ifTrue: [ ^ self ].
	
	Smalltalk at: #SystemSettingsPersistence ifPresent: [:persistence | 
		persistence resumeSystemSettings ].
	Smalltalk at: #StartupPreferencesLoader ifPresent: [:loader |
		loader default loadFromDefaultLocations ].! !
!ManifestPharoLauncherCore class methodsFor: 'meta data'!
rejectClasses
^ #()! !
!ManifestPharoLauncherCore class methodsFor: 'meta data'!
rejectRules
^ #()! !
!ManifestPharoLauncherCore class methodsFor: 'meta data'!
ruleAbstractClassRuleV1FalsePositive
^ #(#(#(#RGClassDefinition #(#PhLError)) #'2013-06-27T15:21:58.6527+02:00') )! !
!ManifestPharoLauncherCore class methodsFor: 'meta data'!
ruleImplementedNotSentRuleV1FalsePositive
^ #(#(#(#RGMethodDefinition #(#'PhLJenkinsServer class' #inriaPharo #true)) #'2013-06-27T17:14:56.694694+02:00') )! !
!ManifestPharoLauncherCore class methodsFor: 'meta data'!
ruleInconsistentMethodClassificationRuleV1FalsePositive
^ #(#(#(#RGMethodDefinition #(#PhLImage #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLAbstractTemplateGroup #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLError #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLAbstractTemplate #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLJenkinsArtifact #name #false)) #'2013-06-27T17:14:57.998691+02:00') )! !
!ManifestPharoLauncherCore class methodsFor: 'meta data'!
ruleMissingYourselfRuleV1FalsePositive
^ #(#(#(#RGMethodDefinition #(#'PhLError class' #signalUrl: #true)) #'2013-06-27T15:21:58.5907+02:00') #(#(#RGMethodDefinition #(#PhLDownloadManager #downloadToPositionableStream:mimeType: #false)) #'2013-06-27T15:21:58.5907+02:00') )! !
!PhLDownloadManager class methodsFor: 'accessing'!
default
	^ Default ifNil: [ self setDefault: self new ]! !
!PhLDownloadManager class methodsFor: 'action'!
reset
	Default := nil! !
!PhLDownloadManager class methodsFor: 'accessing'!
setDefault: aDownloadManager
	^ Default := aDownloadManager! !
!PhLDownloadManager methodsFor: 'action'!
basicDownload: url toFile: destinationFile
	| tmpFile |
	tmpFile := destinationFile , UUIDGenerator  next asString.
	self displayProgressDuring: [ (self newHTTPClientForUrl: url) downloadTo: tmpFile ].
	destinationFile ensureDelete. 
	tmpFile renameTo: destinationFile basename.! !
!PhLDownloadManager methodsFor: 'private'!
displayProgressDuring: workBlock
	"Inform user about download progression"

	UIManager default
		informUserDuring: [ :bar | 
			workBlock
				on: HTTPProgress
				do: [ :progress | 
					bar label: progress printString.
					progress isEmpty
						ifFalse: [ bar current: progress percentage ].
					progress resume ] ]! !
!PhLDownloadManager methodsFor: 'action'!
download: url toFile: destinationFile
	[ self basicDownload: url toFile: destinationFile ]
	on: PhLDownloadError 
	do: [ :error |
			PhlRetryPresenter new
				explanation: error longDescription;
				retryBlock: [ self download: url toFile: destinationFile ];
				cancelBlock: [ error pass ];
				openModalWithSpec. ]! !
!PhLDownloadManager methodsFor: 'private'!
downloadFailureForUrl: url
	semaphore critical: [ errors add: url ].
	PhLDownloadError signalUrl: url! !
!PhLDownloadManager methodsFor: 'action'!
downloadToPositionableStream: url mimeType: mimeType
	"Unfortunately, Zinc (and HTTP in general) doesn't support positionable streams so well. So we have to get the whole content as a collection and stream over it."

	| client content |
	client := (self newHTTPClientForUrl: url)
		beOneShot;
		accept: mimeType;
		enforceAcceptContentType: true.
	self displayProgressDuring: [ content := client get ].
	^ content readStream! !
!PhLDownloadManager methodsFor: 'initialization'!
initialize
	super initialize.
	semaphore := Semaphore forMutualExclusion.
	errors := OrderedCollection new asValueHolder.
	self reset! !
!PhLDownloadManager methodsFor: 'private'!
newHTTPClientForUrl: url
	^ ZnClient new
		signalProgress: true;
		url: url;
		enforceHttpSuccess: true;
		ifFail: [ :exception | self downloadFailureForUrl: url ];
		yourself! !
!PhLDownloadManager methodsFor: 'accessing'!
numberOfErrors
	^ errors size! !
!PhLDownloadManager methodsFor: 'action'!
reset
	errors removeAll! !
!PhLDownloadManager methodsFor: 'announcements'!
whenErrorAddedDo: aBlock
	errors whenChangedDo: aBlock 
! !
!PhLImageDescriptionUpdater class methodsFor: 'accessing'!
default 
	^ Default ifNil: [ Default := self new ]! !
!PhLImageDescriptionUpdater class methodsFor: 'instance creation'!
image: aPhLImage description: aString
	^ self default 
		image: aPhLImage description: aString;
		yourself! !
!PhLImageDescriptionUpdater class methodsFor: 'initialization'!
reset 
	Default := nil.! !
!PhLImageDescriptionUpdater methodsFor: 'saving'!
doSave
	"Will trigger the write of metadata on disk"
	image description: description! !
!PhLImageDescriptionUpdater methodsFor: 'initialization'!
image: aPhLImage description: aString
	(aPhLImage isNil or: [ aPhLImage location = '' ]) ifTrue: [ ^ self ].
	
	self terminateProcess.
	"image changed, no more edition of description, save it without delay"	
	(image isNotNil and: [ image file path ~= aPhLImage file path ])
		ifTrue: [ self doSave ].
		
	image := aPhLImage.
	description := aString.
	image description = description 
		ifFalse: [ self newProcess ].! !
!PhLImageDescriptionUpdater methodsFor: 'private'!
newProcess
	process := 
		[ self waitDelay wait. "Avoid to save description at each key stroke"
		self doSave ] 
			forkNamed: 'Pharo Launcher image description save process'.! !
!PhLImageDescriptionUpdater methodsFor: 'private'!
terminateProcess 
	process ifNotNil: [ process terminate ]! !
!PhLImageDescriptionUpdater methodsFor: 'accessing'!
waitDelay
	^ 3 seconds! !
!PhLJenkinsArtifact class methodsFor: 'protected'!
jsonFields
	^ #('relativePath')! !
!PhLJenkinsArtifact class methodsFor: 'protected'!
jsonFieldsQuery
	^ $, join: self jsonFields! !
!PhLJenkinsArtifact class methodsFor: 'protected'!
jsonName
	^ 'artifacts'! !
!PhLJenkinsArtifact class methodsFor: 'instance creation'!
newWithProperties: json 
	^ self new
		setProperties: json;
		yourself! !
!PhLJenkinsArtifact methodsFor: 'converting'!
asTemplate
	^ PhLRemoteTemplate name: self fullName url: self url! !
!PhLJenkinsArtifact methodsFor: 'accessing'!
fileExtension
	^ self url lastPathSegment copyAfterLast: $.! !
!PhLJenkinsArtifact methodsFor: 'accessing'!
fullName
	^ self options isEmpty
		ifTrue: [ self name ]
		ifFalse: [ String
		streamContents: [ :s | 
			s
				<< $(;
				<< self url lastPathSegment;
				<< $);
				space;
				<< self name.
			self options
				keysAndValuesDo: [ :key :value | 
					s space
						<< key;
						<< '=';
						<< value ] ] ]! !
!PhLJenkinsArtifact methodsFor: 'testing'!
isPotentialTemplate
	^ self fileExtension = 'zip' "In a better world we would distinguish potential images differently"! !
!PhLJenkinsArtifact methodsFor: 'accessing'!
name
	^ self relativePath! !
!PhLJenkinsArtifact methodsFor: 'accessing'!
options
	"Return a dictionary of the options used to build this artifact (typically the version of the image, the version of the project...)."

	"Because Jenkins doesn't store this information properly, we have to parse it from the url"
	^ parent url jenkinsOptions! !
!PhLJenkinsArtifact methodsFor: 'accessing'!
parent: aBuildOrRun
	parent := aBuildOrRun! !
!PhLJenkinsArtifact methodsFor: 'accessing'!
relativePath
	^ properties at: 'relativePath'! !
!PhLJenkinsArtifact methodsFor: 'initialization'!
setProperties: json
	properties := json! !
!PhLJenkinsArtifact methodsFor: 'accessing'!
url
	"Jenkins JSON API does not assign urls to artifacts. You have to get the url of build or run that defines the artifact (i.e., the artifact's parent)."
	^ parent url / 'artifact' / self relativePath! !
!PhLLaunchConfiguration class methodsFor: 'instance creation'!
defaultName
	^ 'Default'! !
!PhLLaunchConfiguration class methodsFor: 'instance creation'!
defaultWithImage: anImage

	^ (self withImage: anImage)
		name: self defaultName;
		yourself! !
!PhLLaunchConfiguration class methodsFor: 'settings'!
launchInALoginShell
	^ LaunchInALoginShell ifNil: [ LaunchInALoginShell := true ]! !
!PhLLaunchConfiguration class methodsFor: 'settings'!
launchInALoginShell: aBoolean
	LaunchInALoginShell := aBoolean! !
!PhLLaunchConfiguration class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #launchInALoginShell)
		label: 'Launch image from a login shell' translated;
		parent: #pharoLauncher;
		target: self;
		order: 31;
		description: 'When enabled, Pharo Launcher will start a Shell and launch the image from it. ' , String cr , 'It allows to inherit from the Shell environment variables.'! !
!PhLLaunchConfiguration class methodsFor: 'serialization'!
stonAllInstVarNames
	^ super stonAllInstVarNames reject: [ :varName | varName = #usePharoSettings ]! !
!PhLLaunchConfiguration class methodsFor: 'instance creation'!
withImage: anImage

	^ self new
		initializeWithImage: anImage;
		yourself! !
!PhLLaunchConfiguration methodsFor: 'comparing'!
= anObject

	self == anObject
		ifTrue: [ ^ true ].
	self class = anObject class
		ifFalse: [ ^ false ].

	^ self name = anObject name! !
!PhLLaunchConfiguration methodsFor: 'querying'!
commandString
	^ self launchProcess commandLineString! !
!PhLLaunchConfiguration methodsFor: 'querying'!
defaultVm
	self image ensurePharoVersion.
	^ self image vmManager virtualMachine! !
!PhLLaunchConfiguration methodsFor: 'configuring'!
doNotUseSettings
	self useSettings: false! !
!PhLLaunchConfiguration methodsFor: 'comparing'!
hash 
	^ self name hash! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
image
	^ image! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
imageArguments
	^ imageArguments ifNil: [ OrderedCollection new ]! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
imageArguments: aCollection 
	imageArguments := aCollection! !
!PhLLaunchConfiguration methodsFor: 'initialization'!
initializeWithImage: anImage

	self initialize.
	image := anImage.
	name := 'new configuration...'.
	usePharoSettings := true.
	imageArguments := OrderedCollection new.! !
!PhLLaunchConfiguration methodsFor: 'testing'!
isNullConfiguration
	^ false! !
!PhLLaunchConfiguration methodsFor: 'testing'!
isUsingPharoSettings
	^ usePharoSettings ifNil: [ usePharoSettings := true ]! !
!PhLLaunchConfiguration methodsFor: 'querying'!
launchProcess
	self vm isValidAfterUpdate
		ifFalse: [ PhLMissingVirtualMachineError signalVm: self vm ].
	^ PhLLaunchImageProcessConfigurator new 
		launchConfiguration: self;
		launchInALoginShell: self class launchInALoginShell;
		visit.! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
name
	^ name! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
name: aString 
	name := aString! !
!PhLLaunchConfiguration methodsFor: 'printing'!
printOn: aStream
	aStream << self class name << '(' << self name << ')'! !
!PhLLaunchConfiguration methodsFor: 'configuring'!
useSettings: aBoolean
	"Cannot skip Pharo settings before Pharo 3.0"
	self image ensurePharoVersion < '30' ifTrue: [ ^ self ].

	usePharoSettings := aBoolean.! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
vm
	^ vm ifNil: [ self vm: self defaultVm. vm ]
! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
vm: aPhLVirtualMachine 
	vm := aPhLVirtualMachine.
	vm manager: self image vmManager.! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
vmArguments
	^ vmArguments ifNil: [ OrderedCollection new ]! !
!PhLLaunchConfiguration methodsFor: 'accessing'!
vmArguments: aCollection 
	vmArguments := aCollection! !
!PhLLaunchedImagesWatcher class methodsFor: 'initialization'!
process: aPhLProcess image: aPhLImage
	^ self new 
		process: aPhLProcess image: aPhLImage;
		yourself ! !
!PhLLaunchedImagesWatcher methodsFor: 'private'!
basicCheckProcess
	| timeout pollingDelay failed |

	timeout := 5 seconds.
	pollingDelay := 500 milliSeconds.
	failed := false.
	[ timeout isZero or: [ failed ] ]
		whileFalse: [
			timeout := timeout - pollingDelay.
			pollingDelay wait.
			failed := self hasProcessFailed ].
	failed ifTrue: [ PhLLaunchError signalProcess: process image: image ]! !
!PhLLaunchedImagesWatcher methodsFor: 'initialization'!
check
	"process ifNil: [ ^ self ]."
	
	[ self basicCheckProcess ]
		forkAt: self priority named: self name! !
!PhLLaunchedImagesWatcher methodsFor: 'testing'!
hasProcessFailed
	process isRunning ifTrue: [ ^ false ].
	^ process isSuccess not! !
!PhLLaunchedImagesWatcher methodsFor: 'private'!
name
	^ 'Pharo Launcher launched images watcher'! !
!PhLLaunchedImagesWatcher methodsFor: 'private'!
priority
	^ 20! !
!PhLLaunchedImagesWatcher methodsFor: 'initialization'!
process: aPhLProcess image: aPhLImage
	process := aPhLProcess.
	image := aPhLImage.! !
!PhLNetworkSettings class methodsFor: 'settings'!
networkSettingsOn: aBuilder
	<pharoLauncherSettings>
	(aBuilder setting: #useHTTPProxy)
		label: 'Use HTTP proxy' translated;
		parent: #pharoLauncher;
		target: NetworkSystemSettings;
		order: 10;
		description:
				'If checked then the you will be able to set a port number and a server name. If unchecked, then no http proxy is used.'
						translated;
		with: [ 
					(aBuilder setting: #httpProxyPort)
						label: 'Port' translated;
						target: NetworkSystemSettings;
						description: 'The HTTP proxy port'.
					(aBuilder setting: #httpProxyServer)
						label: 'Server' translated;
						target: NetworkSystemSettings;
						description: 'The HTTP proxy server (i.e. proxy.univ-brest.fr)'.
					(aBuilder setting: #manageHttpProxyExceptions)
						label: 'Exceptions' translated;
						target: NetworkSystemSettings;
						description: 'Domains to avoid to proxy (separated by ;)' ]! !
!PhLAbstractTemplate methodsFor: 'actions'!
extractTo: aDirectory
	"Extract myself to aDirectory, making sure to name the resulting image after me"

	"In most cases, you probably want to call #extractTo:named: and let the user choose the new name for the image."

	self extractTo: aDirectory named: self name! !
!PhLAbstractTemplate methodsFor: 'actions'!
extractTo: aDirectory named: aString
	"Extract myself to aDirectory. Name the resulting image aString"

	| extractionDirectory |
	extractionDirectory := self extractZipArchive: self zipArchive to: aDirectory.
	self relocateImageFilesFrom: extractionDirectory to: aDirectory withName: aString.
	extractionDirectory deleteAll.
	"Will serialize image metadata with the template information"
	^ (PhLImage location: aDirectory / aString , 'image') 
		originTemplate: self.! !
!PhLAbstractTemplate methodsFor: 'private'!
extractZipArchive: zipFile to: aDirectory
	"Unzip zipFile inside a temporary subdirectory of aDirectory. Return a reference to the subdirectory. The subdirectory can and must be deleted by the caller"
	| tempDirectory |
	"We have to go through a temporary directory because we don't know where the interesting files are in the archive (maybe at the root or maybe in a subdirectory)"
	tempDirectory := aDirectory / DateAndTime millisecondClockValue asString.
	tempDirectory createDirectory. "will crash if directory already exists. And that's good :-)"
	[ ZipArchive new
		readFrom: zipFile;
		extractAllTo: tempDirectory ]
	on: Error
	do: [ :error | 
		error messageText = 'can''t find EOCD position'
			ifTrue: [ PhLCorruptedTemplateError signal ]
			ifFalse: [ error pass ] ].
	^ tempDirectory! !
!PhLAbstractTemplate methodsFor: 'testing'!
hasChildren
	^ false! !
!PhLAbstractTemplate methodsFor: 'testing'!
isTemplate
	^ true! !
!PhLAbstractTemplate methodsFor: 'accessing'!
name
	^ name! !
!PhLAbstractTemplate methodsFor: 'printing'!
printOn: aStream
	aStream
		nextPutAll: 'Image template (';
		nextPutAll: name;
		nextPutAll: ')'! !
!PhLAbstractTemplate methodsFor: 'private'!
relocateImageFilesFrom: extractionDirectory to: targetDirectory withName: targetName
	"Move the image files from anywhere within extractionDirectory (even subdirectories) to aDirectory and give the image the name aString"

	| imageFile changesFile sourcesFile versionFile |
	imageFile := extractionDirectory allFiles detect: [ :aFile | '*.image' match: aFile basename ].	"A changes file must have the same name and be in the same directory as the image file:"
	changesFile := imageFile parent / imageFile basenameWithoutExtension , 'changes'.
	sourcesFile := imageFile parent / imageFile basenameWithoutExtension , 'sources'.
	versionFile := imageFile parent / PhLImage versionFileName.
	imageFile = (targetDirectory / targetName , 'image')
		ifTrue: [ ^ self "no need to relocate" ].
	imageFile moveTo: targetDirectory / targetName , 'image'.
	changesFile moveTo: targetDirectory / targetName , 'changes'.
	sourcesFile exists 
		ifTrue: [ sourcesFile moveTo: targetDirectory / sourcesFile basename ]
		ifFalse: [ "ugly hack to handle Pharo 7 - 64 bits images not following the naming scheme"
			extractionDirectory allFiles 
				detect: [ :aFile | '*.sources' match: aFile basename ]
				ifFound: [ :aFile | aFile moveTo: targetDirectory / aFile basename ] ].
	versionFile exists 
		ifTrue: [ versionFile moveTo: targetDirectory / versionFile basename ]! !
!PhLAbstractTemplate methodsFor: 'actions'!
renameTo: aString
	name := aString! !
!PhLAbstractTemplate methodsFor: 'testing'!
shouldComputeChildrenLazily 
	^ false! !
!PhLAbstractTemplate methodsFor: 'querying'!
suggestedImageName
	^ self name! !
!PhLAbstractTemplate methodsFor: 'accessing'!
zipArchive
	"Return a reference to the archive file representing this template"
	^ self subclassResponsibility! !
!PhLLocalTemplate class methodsFor: 'serialization'!
fromSton: stonReader
	| template |
	template := super fromSton: stonReader.
	template setName: template name zipFile: template zipArchive asFileReference.
	^ template
! !
!PhLLocalTemplate class methodsFor: 'instance creation'!
name: aString zipFile: aFileReference
	^ self new 
		setName: aString zipFile: aFileReference;
		yourself
		! !
!PhLLocalTemplate methodsFor: 'comparing'!
= anObject
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	^ name = anObject name 
		and: [ zipFile = anObject zipArchive ]! !
!PhLLocalTemplate methodsFor: 'comparing'!
hash
	^ name hash bitXor: zipFile hash! !
!PhLLocalTemplate methodsFor: 'testing'!
isLocalTemplate
	^ true! !
!PhLLocalTemplate methodsFor: 'actions'!
renameTo: aString 
	super renameTo: aString.
	zipFile renameTo: aString, '.zip'! !
!PhLLocalTemplate methodsFor: 'initialization'!
setName: aString zipFile: aFile 
	name := aString.
	zipFile := aFile! !
!PhLLocalTemplate methodsFor: 'accessing'!
url
	^ ''! !
!PhLLocalTemplate methodsFor: 'accessing'!
zipArchive
	^ zipFile! !
!PhLRemoteTemplate class methodsFor: 'example'!
example 
	^ self name: 'Pharo Mooc' url: 'https://mooc.pharo.org/image/PharoWeb.zip'! !
!PhLRemoteTemplate class methodsFor: 'instance creation'!
name: aString url: anUrl
	^ self new
		setName: aString url: anUrl;
		yourself! !
!PhLRemoteTemplate class methodsFor: 'instance creation'!
name: aString url: anUrl username: anotherString password: yetAnotherString
	^ (self name: aString url: anUrl)
		  username: anotherString;
		  password: yetAnotherString;
		  yourself! !
!PhLRemoteTemplate methodsFor: 'comparing'!
= anObject
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	^ name = anObject name 
		and: [ url = anObject url ]! !
!PhLRemoteTemplate methodsFor: 'comparing'!
hash
	^ name hash bitXor: url hash! !
!PhLRemoteTemplate methodsFor: 'accessing'!
password
	^ url password! !
!PhLRemoteTemplate methodsFor: 'accessing'!
password: aString
	url password: aString! !
!PhLRemoteTemplate methodsFor: 'initialization'!
setName: aName url: anUrl
	name := aName.
	url := anUrl! !
!PhLRemoteTemplate methodsFor: 'querying'!
suggestedImageName
	| rxMatcher |
	rxMatcher := '(\((\w+).zip\)).*' asRegex.
	^ (rxMatcher matches: self name)
		ifTrue: [ rxMatcher subexpression: 3 "extract zip filename" ]
		ifFalse: [ self name ]! !
!PhLRemoteTemplate methodsFor: 'accessing'!
url
	^ url! !
!PhLRemoteTemplate methodsFor: 'accessing'!
username
	^ url username! !
!PhLRemoteTemplate methodsFor: 'accessing'!
username: aString
	url username: aString! !
!PhLRemoteTemplate methodsFor: 'accessing'!
zipArchive
	"The local template group takes care of cashing downloaded templates."
	^ PhLDownloadedTemplateGroup default downloadAndStoreFile: url forTemplate: self! !
!PhLAbstractTemplateGroup methodsFor: 'accessing'!
children
	^ [ self templatesAndGroups ]
		on: PhLDownloadError
		do: [ :error | | children |
			PhlRetryPresenter new
				explanation: error longDescription;
				retryBlock: [ children := self children ];
				cancelBlock: [ children := #() ];
				openModalWithSpec.
			children ]! !
!PhLAbstractTemplateGroup methodsFor: 'accessing'!
icon 
	"icon used to display the group"
	self subclassResponsibility ! !
!PhLAbstractTemplateGroup methodsFor: 'testing'!
isHighlighted
	^ isHighlighted ifNil: [ isHighlighted := false ]! !
!PhLAbstractTemplateGroup methodsFor: 'accessing'!
isHighlighted: aBoolean
	isHighlighted := aBoolean! !
!PhLAbstractTemplateGroup methodsFor: 'testing'!
isTemplateGroup
	^ true! !
!PhLAbstractTemplateGroup methodsFor: 'accessing'!
name
	^ self subclassResponsibility! !
!PhLAbstractTemplateGroup methodsFor: 'printing'!
printOn: aStream
	aStream nextPutAll: self name; nextPutAll: ' Template group'! !
!PhLAbstractTemplateGroup methodsFor: 'actions'!
refresh
	"Clear any cached data - this is a noop for non caching groups"! !
!PhLAbstractTemplateGroup methodsFor: 'testing'!
shouldComputeChildrenLazily
	^ false! !
!PhLAbstractTemplateGroup methodsFor: 'accessing'!
templatesAndGroups
	"Return a collection of all the templates and subgroups I contain"
	^ self subclassResponsibility! !
!PhLCacheTemplateGroup class methodsFor: 'instance creation'!
group: aTemplateGroup
	^ self new
		setGroup: aTemplateGroup;
		yourself! !
!PhLCacheTemplateGroup methodsFor: 'accessing'!
icon
	^ delegate icon! !
!PhLCacheTemplateGroup methodsFor: 'testing'!
isHighlighted
	^ delegate isHighlighted! !
!PhLCacheTemplateGroup methodsFor: 'accessing'!
name
	^ delegate name! !
!PhLCacheTemplateGroup methodsFor: 'actions'!
refresh
	templatesAndGroups := nil! !
!PhLCacheTemplateGroup methodsFor: 'initialization'!
setGroup: templateGroup
	delegate := templateGroup.! !
!PhLCacheTemplateGroup methodsFor: 'accessing'!
templatesAndGroups
	^ templatesAndGroups
		ifNil: [ templatesAndGroups := delegate templatesAndGroups ]
		! !
!PhLDownloadedTemplateGroup class methodsFor: 'accessing'!
default
	^ Default ifNil: [ Default := self new ]! !
!PhLDownloadedTemplateGroup class methodsFor: 'instance creation'!
named: aName
	^ Default := self new 	
		setName: aName;
		yourself! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
baseDirectory
	^ baseDirectory! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
baseDirectory: aDirectory
	baseDirectory := aDirectory ensureCreateDirectory! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
cacheFile	
	^ (self baseDirectory / 'cache', 'json') ensureCreateFile! !
!PhLDownloadedTemplateGroup methodsFor: 'private'!
dictionary
	^ self cacheFile
		readStreamDo: [ :aStream | 
			aStream atEnd
				ifTrue: [ Dictionary new ]
				ifFalse: [ STONJSON fromStream: aStream ] ]! !
!PhLDownloadedTemplateGroup methodsFor: 'action'!
downloadAndStoreFile: anUrl forTemplate: aRemoteTemplate
	"Download the file at anUrl (hopefully a zip archive), put it in my cache, and update the meta-data file (using information from aRemoteTemplate). If everything went well, a reference to the downloaded file is returned"
	| destinationFile fileExtension |
	"We want to keep the same extension..."
	fileExtension := anUrl lastPathSegment copyAfterLast: $..
	"...but change the file name to be the one of aRemoteTemplate"
	destinationFile := self baseDirectory / aRemoteTemplate name , fileExtension.
	destinationFile ensureDelete.
	PhLDownloadManager default download: anUrl toFile: destinationFile.
	self register: aRemoteTemplate withZip: destinationFile.
	^ destinationFile! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
icon
	^ self iconNamed: #home! !
!PhLDownloadedTemplateGroup methodsFor: 'initialization'!
initialize 
	super initialize.
	baseDirectory := (FileLocator preferences / 'pharo' / 'templateCache') ensureCreateDirectory! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
name
	^ name! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
pharoStableImagePath
	| img |
	img := (self resourcesPath  / 'images' / 'pharo-stable.zip') asFileReference.
	^ img exists 
		ifTrue: [ img ]
		ifFalse: [ nil ]! !
!PhLDownloadedTemplateGroup methodsFor: 'private'!
register: aRemoteTemplate withZip: aZipFile
	"Update my cache file by adding information about a new zip file as described in aRemoteTemplate"
	| aDictionary templateDescription |
	aDictionary := self dictionary.
	templateDescription := aDictionary at: aRemoteTemplate name ifAbsentPut: [ Dictionary new ].
	self updateTemplateDescription: templateDescription with: aRemoteTemplate.
	self saveToFile: aDictionary! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
resourcesPath
	| vmDirectory |
	
	vmDirectory := Smalltalk vm binary parent.

	Smalltalk os isMacOSX ifTrue: [ ^ vmDirectory parent / 'Resources' ].
	Smalltalk os isUnix ifTrue: [ ^ vmDirectory parent/ 'shared' ].
	Smalltalk os isWindows ifTrue: [ ^ vmDirectory ].! !
!PhLDownloadedTemplateGroup methodsFor: 'private'!
saveToFile: aDictionary
	self cacheFile writeStreamDo: [ :aStream | 	STONJSON put: aDictionary onStream: aStream ] ! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
setName: aString 
	name := aString! !
!PhLDownloadedTemplateGroup methodsFor: 'accessing'!
templatesAndGroups
	"Read the cache file to answer a list of already downloaded templates"
	| aDictionary templates |
	templates := SortedCollection sortBlock: [ :e1 :e2 | e1 name < e2 name ].
	aDictionary := self dictionary.
	aDictionary valuesDo: [ :value | 
		(self baseDirectory / (value at: #name), 'zip') exists 
			ifTrue: [ templates add:
			(PhLLocalTemplate 
				name: (value at: #name)
				zipFile: self baseDirectory / (value at: #name), 'zip')  ]
			ifFalse: [ self flag:'TODO remove non existing stuff' ].
		].
	self pharoStableImagePath ifNotNil: [:image | 
		templates add: 
			(PhLLocalTemplate 
				name: 'Pharo image (stable)'
				zipFile: image)
		].
	^ templates! !
!PhLDownloadedTemplateGroup methodsFor: 'private'!
updateTemplateDescription: templateDescription with: aRemoteTemplate
	templateDescription at: 'url' put: aRemoteTemplate url asString.
	templateDescription at: 'name' put: aRemoteTemplate name.
	templateDescription at: 'downloadDate' put: DateAndTime now asString! !
!PhLFixedURLsTemplateGroup methodsFor: 'adding'!
addTemplate: aTemplate
	templates add: aTemplate! !
!PhLFixedURLsTemplateGroup methodsFor: 'accessing'!
icon
	^ self iconNamed: #remote! !
!PhLFixedURLsTemplateGroup methodsFor: 'accessing'!
name
	^ name! !
!PhLFixedURLsTemplateGroup methodsFor: 'initialization'!
setName: aString Templates: aCollection
	name := aString.
	templates := aCollection! !
!PhLFixedURLsTemplateGroup methodsFor: 'accessing'!
templatesAndGroups
	^ templates! !
!PhLHTTPListingTemplateGroup class methodsFor: 'defaults'!
defaultFilterPattern
	"Returns the default filter pattern (Pharo6). The parenthesis here are important because this is what we want to extract for each match. The #subexpression must correspond to the index of this pair of parenthesis"
	^'href="([^"]*.zip)"' ! !
!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!
name: aString url: anUrl
	^ self new
		setName: aString url: anUrl;
		yourself! !
!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!
name: aString url: anUrl filterPattern: aPatternString
	^ self new
		setName: aString url: anUrl filterPattern: aPatternString;
		yourself! !
!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!
name: aString url: anUrl filterPattern: aPatternString templateNameFormat: aNameFormat username: anotherString password: yetAnotherString
	^ (self name: aString url: anUrl filterPattern: aPatternString)
		  username: anotherString;
		  password: yetAnotherString;
		  templateNameFormat: aNameFormat;
		  yourself! !
!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!
name: aString url: anUrl filterPattern: aPatternString username: anotherString password: yetAnotherString
	^ (self name: aString url: anUrl filterPattern: aPatternString)
		  username: anotherString;
		  password: yetAnotherString;
		  yourself! !
!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!
name: aString url: anUrl username: anotherString password: yetAnotherString
	^ (self name: aString url: anUrl)
		  username: anotherString;
		  password: yetAnotherString;
		  yourself! !
!PhLHTTPListingTemplateGroup class methodsFor: 'accessing'!
regexCache
	"Cache the regex per version so that we don't recompute it all the time"
	^ RegexCache ifNil: [ RegexCache := Dictionary new ]! !
!PhLHTTPListingTemplateGroup class methodsFor: 'accessing'!
subexpression
	"Index of the #regex subexpression (delimited by parenthesis) we are interested in. See 'usage' documentation at RxParser"
	^ 2! !
!PhLHTTPListingTemplateGroup methodsFor: 'private'!
createTemplateFromHref: filename addingTo: templates
	| templateName urlFile |
	templateNameFormat 
		ifNil: [ templateName := filename copyUpToLast: $..
			urlFile := url / filename ]
		ifNotNil: [ templateName := templateNameFormat formatTemplateName: filename. 
			urlFile := url clearPath / filename ].
	templates add: (PhLRemoteTemplate name: templateName url: urlFile)! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
icon
	^ self iconNamed: #remote! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
name
	^ name! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
password
	^ url password! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
password: aString
	^ url password: aString! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
regex
	^ self class regexCache at: self name asSymbol ! !
!PhLHTTPListingTemplateGroup methodsFor: 'initialization'!
setName: aName url: anUrl
	name := aName.
	url := anUrl.
	self class regexCache at: aName asSymbol put: (RxParser parse: self class defaultFilterPattern) ! !
!PhLHTTPListingTemplateGroup methodsFor: 'initialization'!
setName: aName url: anUrl filterPattern: aPatternString
	name := aName.
	url := anUrl.
	self class regexCache at: aName asSymbol put: (RxParser parse: aPatternString)! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
subexpression
	^ self class subexpression! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
templateNameFormat
	^ templateNameFormat! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
templateNameFormat: anObject
	templateNameFormat := anObject! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
templatesAndGroups
	| content matcher templates |
	content := PhLDownloadManager default downloadToPositionableStream: url mimeType: ZnMimeType textHtml. 
	matcher := RxMatcher for: self regex.
	templates := OrderedCollection new.
	[ matcher searchStream: content ] whileTrue: 
		[ self createTemplateFromHref: (matcher subexpression: self subexpression)  addingTo: templates ].
	^ templates
	! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
username
	^ url username! !
!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!
username: aString
	url username: aString! !
!PhLJenkins2BuildGroup class methodsFor: 'instance creation'!
name: aString builds: aCollection 
	^ self new
		setName: aString builds: aCollection;
		yourself! !
!PhLJenkins2BuildGroup methodsFor: 'accessing'!
builds
	^ builds! !
!PhLJenkins2BuildGroup methodsFor: 'accessing'!
name
	^ name! !
!PhLJenkins2BuildGroup methodsFor: 'initialization'!
setName: aString builds: aCollection 
	name := aString.
	builds := aCollection! !
!PhLJenkins2BuildGroup methodsFor: 'accessing'!
templatesAndGroups
	^ self builds sorted: [ :b1 :b2 | b1 number > b2 number ]! !
!PhLJenkins2Entity class methodsFor: 'testing'!
isAbstract
	^ self = PhLJenkins2Entity! !
!PhLJenkins2Entity class methodsFor: 'protected'!
jsonFields
	^ self subclassResponsibility! !
!PhLJenkins2Entity class methodsFor: 'protected'!
jsonFieldsQuery
	^ $, join: self jsonFields! !
!PhLJenkins2Entity class methodsFor: 'protected'!
jsonName
	^ self subclassResponsibility ! !
!PhLJenkins2Entity class methodsFor: 'instance creation'!
newWithProperties: json 
	^ self new
		setProperties: json;
		yourself! !
!PhLJenkins2Entity methodsFor: 'accessing'!
children
	"Since we need to request the network to get children, it is better to cache them.
	In the current use of the launcher, the jenkins entities are recreated each time we want to create a new image. Thus, we can cache the children, the probability of the jenkins been updated meanwhile."

	^ childrenCache ifNil: [ childrenCache := super children ]! !
!PhLJenkins2Entity methodsFor: 'accessing'!
icon 
	"(Base64MimeConverter mimeEncode: 'jenkins.png' asFileReference binaryReadStream) contents"

	^ (Form fromBase64String: 
'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAACBj
SFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAAL
EwEAmpwYAAACC2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4
PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJE
RiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1u
cyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4
bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0
aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0
aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9y
aWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0
cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgog
ICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KD0Uq
kwAACPlJREFUWAmVVwtQVOcV/u6+lwVWdmURWJ6u4gMUqA+MImmjURMdNRpfmWTaTDJTk4xJ
OtXJTKdpptNO0zbTSSedaTOBVtvG6BjHWG2MqAV1iiIkgjyDiLAssLzZ93tvz/+Tiyig9uzc
e/f+j3O+8/6vIBLhMYgtEwQB0WgUHXfacfFSJbo7u2CIk4/vVmhgMmdg3fr1SDaZ+DqZTPZI
zsLjAJCE93TbcK2qCuVfXUJRQSY2r1sNfZwGUQLndbrQ1m7Fmcs12P2j17B0SR6NRyETHg7i
kQCYxkyThvp6VF6oQCDow6anC7AwzQjR64Uv4EEwEoFCroRGo4XXH0DpZ19i24sHYLFkP9IS
D4UnRkUuvL/PjsNlpXD5AshflIGFqUZ4RsfQ1DkM27APSqWaC3J5nJDLFEhNTcdPDv4M4VCI
78dDvDwjAG52mYAAafRJaSkyLfPg8vshhD2IBr2ov2NH7a0WiJEQBOZpEqJQKOElq6zIy8aW
lWa03m7nMcBcNBM9FADbZLf3wjfqQDAQxNe1DVDLogiFw9ApQ9i1qQhpJj38AT8UgpLAyBCj
VsJsisO64kJ4HaMzyZ0Ynx4AAZaC53zFFXTZrWhpbUF6ymwkmcj3kTAsGWZESXtoDOgeJMvI
BVh7++HzhREUtWjssGN4oI8LYtkzE00LIIoomF1PnDiBGy//EPpYLRYvsKCn14ZwlExOrmFW
ECnC65vuoLyyHsMuF7SxOtQ1d1I23IXLG8HZo4dRefkKT99INDIthikAeNQT46raajh37cL2
bc9hw4ankGkywJyaiMEhJ1lHwf0uCCKSDWpsX1+A2BgtzEY9wrIQfB4XtqxfjiJjAk49WYLO
7l4KTjlP1wdR3AeABR5LOZfPh6/e/wgbU/UY1aphSTYgOSaEn/94B3JzMuAPBvg6MSIiaXYc
UubE8uiXE7eSFflo7Bogtw3AGBbxHEk8+tcyLldGrmAyJtMUAGyyqroGK09+CkXhKgQ+O4um
u63Iz8+FWhmkfCcGIjHiP1CqRaGIymAfcOHbHgfqmtqRm21C0O1D+FY7Mn9QArz3Lhra2rjc
GQFI2oep8DSdO4esRD2G3A6sXDYXPX86hrd+XYrugRDkChWiFB8CuUkglQOCHI137ahvbsPF
yhp0dPejb9CN9o5B6JpqIKgUWESia65e5QAeDMcJC0iG6R8Zge5yJXTZ8+APhQG1ClvVCpiP
kEViY8kKSoyOOODxhqAkMH6PG539Dqg0sciaMwtZKQlUhhdj5JtGJBoNcAcjyMgywl59nfix
AJ4QyQHde/vONyPDw0igxeEYNVRUCQPRIPwk9Pswoq6uDjKlBjEqLRparQh6g0gx6HlZDofc
lAUa5C9cgMaGW4j/5DD08xbA73UifnYqFHVVGHU6uVDWIyRSSH+kp9fjAetvUbkCkagfcezp
dsOao8ORPx7H6uV5yKbis5hMdvnWHXxvXjJy5s5BdloypZ6DmlEV9v2tCq+sKkbmgB2zdVSo
KD2VFdeoT/jHxTBzf+eLKQDYCoZPIJQapRydhPrfYizKi7ZilqDHgXc/xqEDL0JDvu04ew7/
sg7C8vQaZM9JRUXNTXjK/o6XN+/BhcQ8fNtyDb8MupGuHRcjleTJcTAFgFqthoMAREQ5yh0u
fJxkgTKnEBmiDEGnA40+NU5dbYWeYJqPnYEpOw+uD8/g2rO5yO8dQcyKNXi/thzz1u5EhXkh
epurkB4jR2iuBVqViulHdA/CFAAJBgMGF8yHzzmCv+jTMSe3CGJvDwZcY+QWOdLpsPHRzdvY
PGpDQ+4inG5qxhuGWAT60vCNTItPb1QgKIuHLuDDstEBZMfr4BmxI7jiCcyKi39QPiYASPU6
yWhEqOQpCOePYmeSFsfdXiRS2YVKCbmgQjDkxSqdCk4tWabRhkwxgmPJmSh9/U1YFmUh9fwm
dI958Y8rNXiVAthI2tuudyHh1bcRq9XwrinJYmgmskA6bmnITIs3bIC104EiuR9tzmEodXFU
cQgEUYQaUIiCyEs1oFUtYP1P38Obv/kzaru6oBJDSMpaRJnDgPqQL0QQF6dHPe0rXLOG75fi
gL/QbQIAG5CQFZcUo2pJAUx0+tnpHsEImZ5lBhVAWiRHrN5AQaiC2bIMoVCAwAUQSUim1LyD
IVsnLld/jSfjYmAZ7Ma10+dg3fcSVuQXMhETMvgLe6cKKNUgPiYdwc5+eR5dz26Ed8vz+MCY
grl0JvBQ+VWTwHCMATcbOsgMlFbdlXxf3jN7kaahRuTyosLmQA5lwK59O5C/fTcGqbhtIqum
Z6TzXiApyjZOAcBrPGESKOo//P1vcfqdd6B45SDGBochp1bs7buL1SuXYWGOhU6/idBRdVQo
5HA5xnD2zDkcudGGX7y0EalJKVhaWIj5WdmIkPsuXLqIPXv2TAEwEYRcDYaIfrxOkHNef+tt
DLs9OF7fC5NGBoVShxvDiTjxxn4soEx5kMIROY7881cE8AmkpZqhJNd1W62YP5+yyuuDnwqR
RkOBOInuiwFpnLXNCJ10VdQHnt+2Fe3UlGI0MRDYoaKqDw7SllGYNGMui9AlRqh8RVmg1qPH
asNAfz+cVEF1Oh1GR0e55tN9J0yxAOdMN8lPgpIwVnyO5uIdKLCYgeWz0UfMGTGGk5kq1Uwf
I0598QVeeGEv7x1snVKhIHcUQEWBy0JO4s3m2MD0FKWEIQoEA+J/r14V9+9/jTyTwbwj/u6D
P/A50p4/x29R8T8Xy8XNz2wTT35+kg+FgkHRbreLQ0NDk9bd/3dKEHJU09xC1EpbmpvR2tpE
120cPHQIWq32nkYErbamlk7RfUijaF+6dOm9uWn4SUPTxoA0Of4UuZ+V1JKXENNdu/eheO1a
2Gw2Ps1ihV2svLPDr4sOpy0tLXyOdOUg2HMmegwAwvj5j5hwQcQpMzMT7e3tnKeC/CunaGfE
QF6/fh1FRUX8nflauvjANLfHdsHkvSzyy8rKOKCsrCwueIw+1W5UV2PP3r3IL8jncxKwyXsf
/P9/A5DMyWKir68Pbko1ZhmW3/HU7UyJifzYxb4dHof+Bz/cTBmvnojyAAAAAElFTkSuQmCC') magnifyBy: 0.5! !
!PhLJenkins2Entity methodsFor: 'protected'!
jsonQuery: query
	| queryUrl |
	queryUrl := self url / 'api' / 'json' ? ('tree' -> query).
	^ STONJSON
		fromStream: (PhLDownloadManager default downloadToPositionableStream: queryUrl mimeType: ZnMimeType applicationJson)! !
!PhLJenkins2Entity methodsFor: 'accessing'!
parent: aPhLEntity
	parent := aPhLEntity! !
!PhLJenkins2Entity methodsFor: 'accessing'!
password
	^ parent password! !
!PhLJenkins2Entity methodsFor: 'accessing'!
properties
	^ properties! !
!PhLJenkins2Entity methodsFor: 'protected'!
query: jenkinsType
	| query |
	query := jenkinsType jsonName , '[' , jenkinsType jsonFieldsQuery , ']'.
	^ ((self jsonQuery: query) at: jenkinsType jsonName ifAbsent: [nil])
		ifNil: [ #() ]
		ifNotNil: [ :jsonObjects | 
			jsonObjects
				collect: [ :json | 
					(jenkinsType newWithProperties: json)
						parent: self;
						yourself ] ]! !
!PhLJenkins2Entity methodsFor: 'initialization'!
setProperties: json 
	properties := json! !
!PhLJenkins2Entity methodsFor: 'testing'!
shouldComputeChildrenLazily
	"to know if the group has children, we need to send an ReST request. It can take a lot of time.
	It is better to do it lazily"
	^ true! !
!PhLJenkins2Entity methodsFor: 'accessing'!
url
	"We get the URL from the json sent by Jenkins. In case of a secure Jenkins, we need to set the username and token to the URL we get."

	| url |
	url := (properties at: 'url') asUrl.
	self username ifNotNil: [ :username | url username: username ].
	self password ifNotNil: [ :token | url password: token ].
	^ url! !
!PhLJenkins2Entity methodsFor: 'accessing'!
username
	^ parent username! !
!PhLJenkins2Job class methodsFor: 'protected'!
jsonFields
	^ {'name'.
	'url'.
	('lastSuccessfulBuild[' , PhLJenkins2Build jsonFieldsQuery , ']')}! !
!PhLJenkins2Job class methodsFor: 'protected'!
jsonName
	^ 'jobs'! !
!PhLJenkins2Job methodsFor: 'accessing'!
builds
	"Pipelines define jobs whereas standard jobs define builds"
	^ (self query: PhLJenkins2Build)
		ifEmpty: [ self query: PhLJenkins2Job ]! !
!PhLJenkins2Job methodsFor: 'accessing'!
lastSuccessfulBuild
	^ (PhLJenkins2Build
		newWithProperties:
			(Dictionary new
				at: 'number' put: self lastSuccessfulBuildNumber;
				at: 'url' put: (self url / 'lastSuccessfulBuild') printString;
				yourself))
		parent: self;
		yourself! !
!PhLJenkins2Job methodsFor: 'accessing'!
lastSuccessfulBuildNumber
	^ properties at: 'lastSuccessfulBuild'
		ifPresent: [ :dict | dict ifNil: [nil] ifNotNil: [dict at: 'number' ifPresent: [:num | num ] ifAbsent: [ nil ] ]]
		ifAbsent: [ nil ]! !
!PhLJenkins2Job methodsFor: 'accessing'!
name
	^ properties at: 'name'! !
!PhLJenkins2Job methodsFor: 'accessing'!
templatesAndGroups
	| builds |
	builds := self builds.
	self lastSuccessfulBuildNumber ifNil: [ ^ builds ].
	^ {(self lastSuccessfulBuild).
	(PhLJenkins2BuildGroup name: 'All builds' builds: builds)}! !
!PhLJenkins2Server class methodsFor: 'protected'!
jsonFields
	"Because the server is the root of the jenkins model"

	^ self shouldNotImplement! !
!PhLJenkins2Server class methodsFor: 'protected'!
jsonName
	"Because the server is the root of the jenkins model"

	^ self shouldNotImplement! !
!PhLJenkins2Server class methodsFor: 'instance creation'!
name: aString url: anUrl
	^ self new
		setName: aString url: anUrl;
		yourself! !
!PhLJenkins2Server class methodsFor: 'instance creation'!
name: aString url: anUrl username: anotherString password: yetAnotherString
	^ (self name: aString url: anUrl)
		  username: anotherString;
		  password: yetAnotherString;
		  yourself! !
!PhLJenkins2Server methodsFor: 'accessing'!
jobs
	^ self query: PhLJenkins2Job! !
!PhLJenkins2Server methodsFor: 'accessing'!
name
	^ name! !
!PhLJenkins2Server methodsFor: 'accessing'!
password
	^ url password! !
!PhLJenkins2Server methodsFor: 'accessing'!
password: aString
	url password: aString! !
!PhLJenkins2Server methodsFor: 'initialization'!
setName: aString url: aZnUrl 
	name := aString.
	url := aZnUrl! !
!PhLJenkins2Server methodsFor: 'accessing'!
templatesAndGroups
	^ self jobs! !
!PhLJenkins2Server methodsFor: 'accessing'!
url
	^ url! !
!PhLJenkins2Server methodsFor: 'accessing'!
username
	^ url username! !
!PhLJenkins2Server methodsFor: 'accessing'!
username: aString
	url username: aString! !
!PhLJenkins2Build class methodsFor: 'protected'!
jsonName
	^ 'builds'! !
!PhLJenkins2Build methodsFor: 'testing'!
isLastSuccessful
	^ self url lastPathSegment = 'lastSuccessfulBuild'! !
!PhLJenkins2Build methodsFor: 'accessing'!
name
	^ String streamContents: [:str |
		self isLastSuccessful 
			ifTrue: [ str nextPutAll: 'Latest sucessful build: ' ].
		str 
			nextPut: $#;
		 	print: self number]! !
!PhLJenkins2Build methodsFor: 'private'!
propagateLastSuccessfulTagTo: aRun 
	| url |
	url := aRun url copy.
	url isDirectoryPath ifTrue: [ url := url removeLastPathSegment ].
	url := url removeLastPathSegment.
	url := url / 'lastSuccessfulBuild'.
	url closePath.
	aRun properties at: 'url' put: url! !
!PhLJenkins2Build methodsFor: 'accessing'!
runs
	|runs|
	runs := self query: PhLJenkins2Run.
	^ self isLastSuccessful
	ifTrue: [ runs do: [ :run | self propagateLastSuccessfulTagTo: run ] ]
	ifFalse: [ runs ]! !
!PhLJenkins2Build methodsFor: 'accessing'!
templatesAndGroups
	^ super templatesAndGroups , self runs! !
!PhLJenkins2Run class methodsFor: 'protected'!
jsonName
	^ 'runs'! !
!PhLJenkins2Run methodsFor: 'accessing'!
name
	^ String streamContents: [ :stream | self url jenkinsOptions printElementsOn: stream ]! !
!PhLJenkins2WithArtifactsEntity class methodsFor: 'protected'!
jsonFields
	^ #('number' 'url')! !
!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!
artifactTemplates
	^ self artifacts
		inject: OrderedCollection new
		into: [ :templates :artifact | 
			artifact isPotentialTemplate
				ifTrue: [ templates add: artifact asTemplate ].
			templates ]! !
!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!
artifacts
	^ self query: PhLJenkinsArtifact! !
!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!
name
	^ '#', self number printString! !
!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!
number
	^ properties at: 'number'! !
!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!
templatesAndGroups
	^ self artifactTemplates! !
!PhLImage class methodsFor: 'accessing'!
descriptionFileName
	^ 'description.txt'! !
!PhLImage class methodsFor: 'example'!
example
	| fsRoot imageFile |
	fsRoot := FileSystem memory root.
	imageFile := fsRoot / 'foo64.image'.
	imageFile binaryWriteStreamDo: 
		[ :stream | 
		(ZnEndianessReadWriteStream on: stream ) nextLittleEndianNumber: 4 put: PhLVirtualMachineManager imageFormat64bits ].
	^ self location: imageFile! !
!PhLImage class methodsFor: 'example'!
example32
	| fsRoot imageFile |
	fsRoot := FileSystem memory root.
	imageFile := fsRoot / 'foo32.image'.
	imageFile binaryWriteStreamDo: 
		[ :stream | 
		(ZnEndianessReadWriteStream on: stream ) nextLittleEndianNumber: 4 put: PhLVirtualMachineManager imageFormat32bits ].
	^ self location: imageFile! !
!PhLImage class methodsFor: 'instance creation'!
imageFromMetadata: imageFileReference
	"Will recreate the image object from its STON serialized version if possible"

	imageFileReference parent / self metadataFileName
		readStreamDo: [ :stream | 
			| object |
			object := (self stonReader on: stream) next.
			(object isKindOf: PhLImage) ifTrue: [ ^ object ].
			(object isKindOf: Dictionary)
				ifTrue: [ "old metadata file format"
					^ self new
						privOriginTemplate: (object at: #template);
						yourself ].
			PhLError signal: 'Unrecognized metadata format' ]
		ifAbsent: [ ^ self new ]! !
!PhLImage class methodsFor: 'initialization'!
initialize
	SessionManager default registerUserClassNamed: self name! !
!PhLImage class methodsFor: 'instance creation'!
location: imageFileReference
	^ (self imageFromMetadata: imageFileReference)
		setLocation: imageFileReference;
		yourself! !
!PhLImage class methodsFor: 'accessing'!
metadataFileName
	^ 'meta-inf.ston'! !
!PhLImage class methodsFor: 'system startup'!
startUp: isImageStarting
	isImageStarting ifTrue: [ reader := nil ]! !
!PhLImage class methodsFor: 'serialization'!
stonAllInstVarNames
	^ super stonAllInstVarNames reject: [ :varName | varName = #file ]! !
!PhLImage class methodsFor: 'accessing'!
stonReader
	"The ston reader is building caches when reading a file. Since we read *a lot* of files, we cache a reader with all the built caches."

	^ reader 
		ifNil: [ reader := STONReader new ]
		ifNotNil: [ reader reset; yourself ]! !
!PhLImage class methodsFor: 'accessing'!
versionFileName
	^ 'pharo.version'! !
!PhLImage methodsFor: 'configuring'!
addLaunchConfiguration: aPhLLaunchConfiguration
	launchConfigurations 
		detect: [ :each | each name = aPhLLaunchConfiguration name ]
		ifFound: [ PhLError signal: 'Cannot add configuration!! A configuration with the same name already exists.' ]
		ifNone: [ launchConfigurations add: aPhLLaunchConfiguration ]! !
!PhLImage methodsFor: 'accessing'!
architecture
	^ architecture ifNil: [ self computeArchitecture. "Always be able to display image architecture" ]! !
!PhLImage methodsFor: 'testing'!
canBeLaunched
	^ self architecture = '32' 
		ifTrue: [ self os canRun32bitApp ]
		ifFalse: [ true "we do not manage the case where a 64-bit image want to be launched on a 32-bit OS"]! !
!PhLImage methodsFor: 'accessing'!
changesFile
	^ self file parent / self file basenameWithoutExtension , 'changes'! !
!PhLImage methodsFor: 'computing'!
computeArchitecture
	self computeFormatNumber.
	((PhLVirtualMachineManager is32bits: formatNumber)
		or: [ PhLVirtualMachineManager isPreSpur: formatNumber ])
		ifTrue: [ ^ architecture := '32' ].
	(PhLVirtualMachineManager is64bits: formatNumber)
		ifTrue: [ ^ architecture :='64' ].
	^ architecture := 	'N/A'! !
!PhLImage methodsFor: 'computing'!
computeFormatNumber
	formatNumber := PhLVirtualMachineManager imageFormatNumberFromFile: file! !
!PhLImage methodsFor: 'computing'!
computePharoVersion
	pharoVersion := self vmManager imageVersion.
	self computeArchitecture.
	self serializeMetadata.
	^ pharoVersion! !
!PhLImage methodsFor: 'accessing'!
defaultLaunchConfiguration
	^ launchConfigurations 
		detect: [ :each | each name = PhLLaunchConfiguration defaultName ]
		ifNone: [ PhLLaunchConfiguration defaultWithImage: self ]! !
!PhLImage methodsFor: 'accessing'!
defaultLaunchConfigurationName
	^ 'Default'! !
!PhLImage methodsFor: 'accessing'!
description
	^ description ifNil: [ self descriptionFromFile ]! !
!PhLImage methodsFor: 'accessing'!
description: aString
	description := aString ifNotNil: #asString. "ensure we do not get Text"
	self serializeMetadata.! !
!PhLImage methodsFor: 'accessing'!
descriptionFromFile
	| descriptionFile |
	self flag: 'This method is there for backward compatibility. description.txt file has been superseded by the metainformation file meta-inf.ston'.
	descriptionFile := file parent / self class descriptionFileName.
	
	^ descriptionFile exists
		ifTrue: [ descriptionFile contents withNoLineLongerThan: 80 ]
		ifFalse: [ 'There is no description' ]! !
!PhLImage methodsFor: 'configuring'!
doNotRunInitializationScript
	self shouldRunInitializationScript: false.! !
!PhLImage methodsFor: 'computing'!
ensurePharoVersion
	(self pharoVersion isNil or: [ self pharoVersion = '' ])
		ifFalse: [ self vmManager imageVersion: self pharoVersion.
					^ self pharoVersion ].
	^ self computePharoVersion.
	! !
!PhLImage methodsFor: 'accessing'!
file 
	^file! !
!PhLImage methodsFor: 'accessing'!
formatNumber
	^ formatNumber! !
!PhLImage methodsFor: 'testing'!
hasChildren
	^ false! !
!PhLImage methodsFor: 'accessing'!
imageFile
	^ self file! !
!PhLImage methodsFor: 'accessing'!
initializationScript
	^ initializationScript ifNotNil: [ :script | script asFileReference ]! !
!PhLImage methodsFor: 'accessing'!
initializationScript: aFileReference
	initializationScript := aFileReference.
	self serializeMetadata! !
!PhLImage methodsFor: 'initialization'!
initialize
	super initialize.
	launchConfigurations := OrderedCollection new.
	shouldRunInitializationScript := true! !
!PhLImage methodsFor: 'testing'!
isHighlighted
	^ false! !
!PhLImage methodsFor: 'testing'!
isImage
	^ true! !
!PhLImage methodsFor: 'accessing'!
lastModification
	^ self file modificationTime! !
!PhLImage methodsFor: 'action'!
launch
	^ self launchWithConfiguration: self defaultLaunchConfiguration ! !
!PhLImage methodsFor: 'accessing'!
launchConfigurations
	^ launchConfigurations
		ifEmpty: [ launchConfigurations 
						add: self defaultLaunchConfiguration;
						yourself ]! !
!PhLImage methodsFor: 'accessing'!
launchConfigurations: aCollection 
	launchConfigurations := aCollection! !
!PhLImage methodsFor: 'action'!
launchWithConfiguration: aPhLLaunchConfiguration
	| architectureWarningEnabled continue |
	
	self canBeLaunched
		ifFalse: [ PhLArchitectureError signalImage: self. ^ self ].

	architectureWarningEnabled := true.
	continue := true.
	[ [ | processWrapper|
		processWrapper := (aPhLLaunchConfiguration launchProcess) runUnwatch.
		self doNotRunInitializationScript. "Just run, image already initialized"
		^ processWrapper ]
		on: PhLImageVersionDeterminationError
		do: [ :error |  error uiAlert ] ]
		on: PhLArchitectureMismatchWarning
		do: [ :warning | |  |
			(PhLLaunchImageCommand warnOnArchMismatch and: [ architectureWarningEnabled  ])
				ifTrue: [ 
					architectureWarningEnabled := false. "only raise one warning"
					continue := YesNoDialogWithTickBoxWindow confirm: warning longDescription label: warning name. ].
			continue ifTrue: [ warning resume ]. ]! !
!PhLImage methodsFor: 'accessing'!
location 
	^ file fullName! !
!PhLImage methodsFor: 'accessing'!
name
	^ file basenameWithoutExtension! !
!PhLImage methodsFor: 'accessing'!
originTemplate

	^ originTemplate! !
!PhLImage methodsFor: 'accessing'!
originTemplate: aPhLTemplate
	
	self privOriginTemplate: aPhLTemplate.
	self serializeMetadata.! !
!PhLImage methodsFor: 'accessing'!
originTemplateName

	^ self originTemplate 
		ifNotNil: [ :template | template name ] 
		ifNil: [ #unknown ]! !
!PhLImage methodsFor: 'accessing'!
originTemplateUrl

	^ self originTemplate 
		ifNotNil: [ :template | template url asString ] 
		ifNil: [ #unknown ]! !
!PhLImage methodsFor: 'private - accessing'!
os
	^ OSPlatform current! !
!PhLImage methodsFor: 'accessing'!
pharoVersion
	^ pharoVersion ifNil: [ self pharoVersionFromFile ]! !
!PhLImage methodsFor: 'accessing'!
pharoVersionFromFile
	file ifNil: [ ^ '' ].
	^ self versionFile exists
		ifTrue: [ pharoVersion := self versionFile contents trim ]
		ifFalse: [ '' ]! !
!PhLImage methodsFor: 'printing'!
printOn: aStream
	aStream
		nextPutAll: 'Image (';
		nextPutAll: self name;
		nextPutAll: ')'! !
!PhLImage methodsFor: 'accessing'!
privOriginTemplate: aPhLTemplate
	
	originTemplate := aPhLTemplate.! !
!PhLImage methodsFor: 'serialization'!
serializeMetadata
	file exists ifFalse: [ "image deleted" ^ self ].

	(file parent / self class metadataFileName)
		writeStreamDo: [ :stream | stream nextPutAll: self stonString ]! !
!PhLImage methodsFor: 'initialization'!
setLocation: aFile 
	file := aFile.! !
!PhLImage methodsFor: 'accessing'!
shouldRunInitializationScript
	^ shouldRunInitializationScript! !
!PhLImage methodsFor: 'configuring'!
shouldRunInitializationScript: aBoolean
	shouldRunInitializationScript := aBoolean.
	self serializeMetadata.! !
!PhLImage methodsFor: 'printing'!
showNativeFolder
	PhLFileBrowser openOn: file! !
!PhLImage methodsFor: 'accessing'!
sourcesFile
	^ self file parent files 
		detect: [ :fileRef | fileRef extension = 'sources' ]! !
!PhLImage methodsFor: 'serialization'!
stonString
	^ STON toStringPretty: self! !
!PhLImage methodsFor: 'printing'!
summaryInfo
	^ String
		streamContents: [ :s | 
			s nextPutAll: 'Last modified: '.
			self file modificationTime printOn: s.
			s
				cr;
				nextPutAll: self file parent fullName;
				cr;
				cr;
				nextPutAll: self description ]! !
!PhLImage methodsFor: 'accessing'!
versionFile
	^ self file parent / self class versionFileName! !
!PhLImage methodsFor: 'private - accessing'!
vmManager
	^ vmManager ifNil: [ vmManager := PhLVirtualMachineManager forImage: self file ]! !
!PhLObject methodsFor: 'accessing'!
children
	^ #()! !
!PhLObject methodsFor: 'testing'!
hasChildren
	^ true! !
!PhLObject methodsFor: 'testing'!
isImage
	^ false! !
!PhLObject methodsFor: 'testing'!
isLocalTemplate
	^ false! !
!PhLObject methodsFor: 'testing'!
isTemplate
	^ false! !
!PhLObject methodsFor: 'testing'!
isTemplateGroup
	^ false! !
!PhLROCheckStartup class methodsFor: 'initialization'!
initialize
	"Must be run before any write acess to the file system.
	UI should already be usable!!"
	"SessionManager default 
		register: (ClassSessionHandler forClassNamed: self name)
		inCategory: SessionManager default toolsCategory
		atPriority: 1"! !
!PhLROCheckStartup class methodsFor: 'system startup'!
startUp
	[ (FileLocator workingDirectory / 'phl-canwrite') asFileReference  
			ensureDelete; 
			createDirectory;
			ensureDelete. ]
	on: Error
	do: [ :error |  
		UIManager default 
			alert: 'PharoLauncher cannot be run from a read-only filesystem. Please move it to a place where you have write permissions!!' 
			title: 'Cannot run PharoLauncher!!'.
		Smalltalk quitPrimitive ].! !
!PhLDirectoryBasedImageRepository class methodsFor: 'instance creation'!
default
	^ Default ifNil: [ Default := self new ]! !
!PhLDirectoryBasedImageRepository class methodsFor: 'defaults'!
defaultLocation
	^ FileLocator launcherUserFilesLocation / 'images' ! !
!PhLDirectoryBasedImageRepository class methodsFor: 'instance creation'!
forDirectory: aDirectory
	^ self new
		setBaseDirectory: aDirectory;
		yourself! !
!PhLDirectoryBasedImageRepository class methodsFor: 'initialization'!
initialize

	PhLStartupManager addToLauncherStartUpList: self! !
!PhLDirectoryBasedImageRepository class methodsFor: 'system startup'!
launcherStartUp
	"Fix the Location because the platform or computer can have changed"

	(Location notNil and: [ Location exists not ])
		ifTrue: [ 
			"We could probably always set to nil without the previous checks, but I'm not sure because it may depend on #startUp order of classes (e.g., if PhLSettingBrowser class>>#startUp is first, we may have a problem)."
			Location := nil ]! !
!PhLDirectoryBasedImageRepository class methodsFor: 'system startup'!
launcherStartUpPriority
	^ 1! !
!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!
location
	^ Location ifNil: [ Location := self defaultLocation ]! !
!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!
location: directory
	self location resolve = directory resolve ifTrue: [ ^ self ].
	self migrateFrom: self location to: directory.
	Location := directory.
	self default contentsChanged! !
!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!
locationString
	^ self location pathString ! !
!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!
locationString: aDirectoryString
	^ self location: aDirectoryString asFileReference! !
!PhLDirectoryBasedImageRepository class methodsFor: 'private'!
migrateFrom: oldLocation to: newLocation
	(oldLocation exists and: [ (self forDirectory: oldLocation) hasImages ])
		ifTrue: 
			[ PhLRelocateImageDirectoryCommand new
				source: oldLocation;
				target: newLocation;
				execute ]! !
!PhLDirectoryBasedImageRepository class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #locationString)
		label: 'Location of your images' translated;
		type: #Directory;
		parent: #pharoLauncher;
		target: self;
		order: 40;
		description: 'A directory where all your Pharo images will be saved and launched'! !
!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!
baseDirectory
	^ (baseDirectory ifNil: [ self class location ]) ensureCreateDirectory! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
copyImage: anImage to: aString
	self copyImageNamed: anImage name to: aString! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
copyImageNamed: sourceName to: targetName
	| sourceDirectory targetDirectory |
	self ensureNoImageWithName: targetName.
	targetDirectory := self prepareForNewImageNamed: targetName.
	sourceDirectory := self directoryForImageNamed: sourceName.
	CopyVisitor copy: sourceDirectory to: targetDirectory.
	self renameImageInFolder: targetDirectory to: targetName.
	self contentsChanged! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
deleteImage: anImage
	self deleteImageNamed: anImage name! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
deleteImageNamed: aString
	(self directoryForImageNamed: aString) deleteAll.
	self contentsChanged.! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
deleteImages: someImages
	self dontNotifyDuring: [ someImages do: [ :image | self deleteImage: image ] ].
	self contentsChanged! !
!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!
directoryForImageNamed: aString
	^ self baseDirectory / aString! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
ensureNoImageWithName: anImageName
	(self hasImageNamed: anImageName)
		ifTrue: [ PhLNameNotAvailableError signalName: anImageName ]! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
extractTemplate: aTemplate to: anImageName
	| destination image |
	self ensureNoImageWithName: anImageName.
	destination := self prepareForNewImageNamed: anImageName.
	image := aTemplate extractTo: destination named: anImageName.
	self contentsChanged.
	^ image! !
!PhLDirectoryBasedImageRepository methodsFor: 'testing'!
hasImageNamed: aString 
	^ self includesImageNamedCaseInsensitive: aString! !
!PhLDirectoryBasedImageRepository methodsFor: 'testing'!
hasImages
	^ self images notEmpty! !
!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!
imageNames
	^ self withImagesFilesCollect: #basenameWithoutExtension! !
!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!
images
	"Creates instances of PhLImage representing the Pharo images the launcher can manage."

	^ self withImagesFilesCollect: [ :imageFile | PhLImage location: imageFile ]! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
importImage: sourceImageFileRef to: targetName
	| sourceDirectory targetDirectory imageLocalDirectory |
	self ensureNoImageWithName: targetName.
	sourceDirectory := sourceImageFileRef parent.
	targetDirectory := self prepareForNewImageNamed: targetName.
	{ sourceImageFileRef . sourceImageFileRef withoutExtension , 'changes' }
		do: [ :file | 
			| targetFilename |
			targetFilename := self newNameForFile: file whenRelocatingToImageNamed: targetName.
			file moveTo: targetDirectory / targetFilename ].
	imageLocalDirectory := (sourceDirectory / SystemResolver defaultLocalDirectoryName).
	imageLocalDirectory exists 
		ifTrue: [ imageLocalDirectory moveTo: targetDirectory / imageLocalDirectory basename ].
	sourceDirectory hasChildren 
		ifFalse: [ sourceDirectory delete ].
	self contentsChanged.! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
importImageNamed: imagePath andSiblingFilesto: targetName
	| sourceDirectory |
	imagePath asFileReference exists ifFalse: [ ^ self ].
	
	sourceDirectory := imagePath asFileReference parent.
	self moveImage: sourceDirectory to: targetName! !
!PhLDirectoryBasedImageRepository methodsFor: 'testing'!
includesImageNamedCaseInsensitive: anImageName
	"Windows OS doesnt care about case for folder names."
	| lowercaseImageName |
	lowercaseImageName := anImageName asLowercase.
	^ self imageNames anySatisfy: [ :imageName | imageName asLowercase = lowercaseImageName ]! !
!PhLDirectoryBasedImageRepository methodsFor: 'testing'!
isNewImageNameValid: aString 
	^ aString isEmptyOrNil not and: [ (self hasImageNamed: aString) not ]! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
makeUniqueImageName: baseImageName
	^ self makeUniqueImageName: baseImageName among: self imageNames.! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
makeUniqueImageName: baseImageName among: existingImageNames
	"Provide a reasonable default image name using the next incremental count for images with similar basenames"

	"See #testMakeUniqueImageName for samples"

	^ self makeUniqueName: baseImageName among: existingImageNames! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
moveImage: sourceDirectory to: newName
	| targetDirectory |
	self ensureNoImageWithName: newName.
	targetDirectory := self directoryForImageNamed: newName.	"Do not create a new directory to ensure that the moveTo will succeed"
	sourceDirectory moveTo: targetDirectory.
	self renameImageInFolder: targetDirectory to: newName.
	self contentsChanged! !
!PhLDirectoryBasedImageRepository methodsFor: 'private'!
newNameForFile: file whenRelocatingToImageNamed: targetName
	"Return the name that should be given to file when the file is going to be moved or copied to the image targetName. The file name is kept intact unless it must reflect the image name."
	^ (#('image' 'changes') includes: file extension)
		ifTrue: [ targetName , '.' , file extension ]
		ifFalse: [ file basename ]! !
!PhLDirectoryBasedImageRepository methodsFor: 'private'!
prepareForNewImageNamed: aString
	^ (self directoryForImageNamed: aString) ensureCreateDirectory! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
recreateImage: anImage
	anImage originTemplate 
		ifNil: [ PhLCommandError signal ].
		
	self 
		deleteImage: anImage; 
		extractTemplate: anImage originTemplate to: anImage name.
! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
renameImage: anImage to: newName
	self renameImageNamed: anImage name to: newName! !
!PhLDirectoryBasedImageRepository methodsFor: 'private'!
renameImageInFolder: targetDirectory to: newName
	targetDirectory children
		do: [ :file | 
			| targetFilename |
			targetFilename := self
				newNameForFile: file
				whenRelocatingToImageNamed: newName.
			file basename = targetFilename
				ifFalse: [ file renameTo: targetFilename ] ]! !
!PhLDirectoryBasedImageRepository methodsFor: 'action'!
renameImageNamed: oldName to: newName
	| sourceDirectory |
	(self isNewImageNameValid: newName)
		ifFalse: [ PhLCommandError signal ].
	sourceDirectory := self directoryForImageNamed: oldName.
	self moveImage: sourceDirectory to: newName ! !
!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!
roots
	^ self images sorted: [ :image1 :image2 | image1 name asUppercase < image2 name asUppercase ]! !
!PhLDirectoryBasedImageRepository methodsFor: 'initialization'!
setBaseDirectory: aLocation
	baseDirectory := aLocation! !
!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!
withImagesFilesCollect: aBlock
	"I iterate over all the folders in the launcher image directory. If this directory contains one image and one change file, I execute the block provided by the user and I return the list of results obtained."

	^ self baseDirectory directories
		inject: OrderedCollection new
		into: [ :collection :aDirectory | 
			| imageName imageFiles |
			imageName := aDirectory basename.
			imageFiles := aDirectory filesMatching: imageName , '.image'.
			(imageFiles size = 1 and: [ (aDirectory filesMatching: imageName , '.changes') size = 1 ])
				ifTrue: [ collection add: (aBlock value: imageFiles first) ].
			collection ]! !
!PhLRepository methodsFor: 'announcements'!
contentsChanged
	"Called me to announce that I changed"

	wantNotification
		ifTrue: [ announcer announce: ValueChanged new ]! !
!PhLRepository methodsFor: 'private'!
dontNotifyDuring: aBlock
	| wantNotificationBackup |
	[ 
	wantNotificationBackup := wantNotification.
	wantNotification := false.
	aBlock value ]
		ensure: [ wantNotification := wantNotificationBackup ]! !
!PhLRepository methodsFor: 'initialization'!
initialize
	super initialize.
	announcer := Announcer new.
	wantNotification := true.! !
!PhLRepository methodsFor: 'action'!
makeUniqueName: baseName among: existingNames
	"Provide a reasonable default name using the next incremental count for items with similar basenames"

	"See #testMakeUniqueImageName for samples"

	| similarbaseImageNames existingUniquifiers nextUniquifier separator |
	separator := '-'.
	similarbaseImageNames := existingNames select: [ :imageName | imageName beginsWith: baseName ].
	existingUniquifiers := similarbaseImageNames
		collect: [ :imageName | 
			| suffix |
			suffix := imageName allButFirst: baseName size.
			(suffix beginsWith: separator)
				ifTrue: [ (suffix allButFirst: separator size) initialIntegerOrNil ]
				ifFalse: 0 ]
		thenSelect: #notNil.
	existingUniquifiers ifEmpty: [ ^ baseName ].
	nextUniquifier := existingUniquifiers max + 1.
	^ baseName , separator , (nextUniquifier printPaddedWith: $0 to: 2)! !
!PhLRepository methodsFor: 'accessing'!
roots
	^ self subclassResponsibility! !
!PhLRepository methodsFor: 'announcements'!
unsubscribe: aReceiver
	announcer unsubscribe: aReceiver! !
!PhLRepository methodsFor: 'announcements'!
whenChangedSend: aSelector to: aReceiver
	announcer when: ValueChanged send: aSelector to: aReceiver! !
!PhLTemplateGroupRepository class methodsFor: 'instance creation'!
default
	^ self newFromGroups: PhLTemplateGroupsBuilder build! !
!PhLTemplateGroupRepository class methodsFor: 'instance creation'!
newFromGroups: aCollection
	^ self new
		setGroups: aCollection;
		yourself! !
!PhLTemplateGroupRepository methodsFor: 'private'!
addGroup: aGroup
	| cache |
	cache := PhLCacheTemplateGroup group: aGroup. "wrap all groups inside a cache."
	groupCaches addLast: cache.! !
!PhLTemplateGroupRepository methodsFor: 'action'!
createLocalTemplateFrom: anImage named: aString
	aString ifEmpty: [ PhLCommandError signal: 'Cannot give an empty name to a template' ].
	(self hasLocalTemplateNamed: aString)
		ifTrue: [ PhLError signal: 'A local template with the same name already exists' ].
	self createZipArchiveFrom: anImage named: aString.
	self createLocalTemplateNamed: aString.
	self refresh! !
!PhLTemplateGroupRepository methodsFor: 'action'!
createLocalTemplateNamed: aString
	| localTemplate |
	localTemplate := PhLLocalTemplate name: aString zipFile: self localTemplatesDirectory / aString , 'zip'.
	self localTemplatesGroup register: localTemplate withZip: localTemplate zipArchive! !
!PhLTemplateGroupRepository methodsFor: 'action'!
createZipArchiveFrom: anImage named: aString
	| archive |
	archive := ZipArchive new.
	archive
		addFile: anImage imageFile as: aString , '.image';
		addFile: anImage changesFile as: aString , '.changes'.
	[ archive addFile: anImage sourcesFile as: anImage sourcesFile basename ]
		on: NotFound 
		do: [ :e | "ignore the file" ].
	anImage versionFile exists
		ifTrue: [ archive addFile: anImage versionFile as: anImage versionFile basename ].
	archive writeToFile: (self localTemplatesDirectory / aString , 'zip')! !
!PhLTemplateGroupRepository methodsFor: 'action'!
deleteTemplate: aTemplate 
	aTemplate zipArchive delete.
	self refresh.! !
!PhLTemplateGroupRepository methodsFor: 'action'!
deleteTemplates: someTemplates 
	self dontNotifyDuring: [ someTemplates do: [ :template | self deleteTemplate: template ] ].
	self refresh! !
!PhLTemplateGroupRepository methodsFor: 'testing'!
hasLocalTemplateNamed: aString
	^ self localTemplates
		anySatisfy: [ :each | each name = aString ]! !
!PhLTemplateGroupRepository methodsFor: 'accessing'!
localTemplateNamed: aString
	^ self localTemplates detect: [ :each | each name = aString ]! !
!PhLTemplateGroupRepository methodsFor: 'accessing'!
localTemplateNames
	^ self localTemplates collect: #name! !
!PhLTemplateGroupRepository methodsFor: 'accessing'!
localTemplates
	^ self localTemplatesGroup templatesAndGroups! !
!PhLTemplateGroupRepository methodsFor: 'accessing'!
localTemplatesDirectory
	^ self localTemplatesGroup baseDirectory! !
!PhLTemplateGroupRepository methodsFor: 'accessing'!
localTemplatesGroup
	^ PhLDownloadedTemplateGroup default! !
!PhLTemplateGroupRepository methodsFor: 'action'!
makeUniqueTemplateName: aString
	^ self makeUniqueTemplateName: aString among: self localTemplateNames! !
!PhLTemplateGroupRepository methodsFor: 'action'!
makeUniqueTemplateName: baseTemplateName among: existingTemplateNames
	"Provide a reasonable default template name using the next incremental count for images with similar basenames"

	"See #testMakeUniqueImageName for samples"

	^ self makeUniqueName: baseTemplateName among: existingTemplateNames! !
!PhLTemplateGroupRepository methodsFor: 'action'!
refresh
	groupCaches do: #refresh.
	self contentsChanged.! !
!PhLTemplateGroupRepository methodsFor: 'updating'!
rename: aPhLLocalTemplate to: aString
	aPhLLocalTemplate renameTo: aString.
	self localTemplatesGroup register: aPhLLocalTemplate withZip: aPhLLocalTemplate zipArchive.! !
!PhLTemplateGroupRepository methodsFor: 'accessing'!
roots
	^ groupCaches! !
!PhLTemplateGroupRepository methodsFor: 'initialization'!
setGroups: aCollection
	| names |
	names := Set new.
	groupCaches := OrderedCollection new.
	aCollection
		do: [ :group | 
			(names includes: group name)
				ifTrue: [ PhLError signal: '2 groups must not have the same name' ]
				ifFalse: [ self addGroup: group ] ]! !
!PhLStartupManager class methodsFor: 'actions'!
addToLauncherStartUpList: aClass
	(self startUpClasses includes: aClass)
		ifFalse: [ self startUpClasses add: aClass ]
! !
!PhLStartupManager class methodsFor: 'initialization'!
initialize

	SessionManager default registerToolClassNamed: self name! !
!PhLStartupManager class methodsFor: 'actions'!
removeFromStartupList: aClass
	self startUpClasses remove: aClass! !
!PhLStartupManager class methodsFor: 'actions'!
resetStartUpClasses
	StartUpClasses := nil! !
!PhLStartupManager class methodsFor: 'system startup'!
startUp
	self startUpClasses do: [ :c | c ifNotNil: [ c launcherStartUp ] ]! !
!PhLStartupManager class methodsFor: 'accessing'!
startUpClasses
	^ StartUpClasses
		ifNil: [ StartUpClasses := SortedCollection sortBlock: [ :c1 :c2 | c1 launcherStartUpPriority < c2 launcherStartUpPriority ] ]! !
!PhLTemplateGroupsBuilder class methodsFor: 'instance creation'!
build
	^ self buildFrom: PhLTemplateSources defaultSources! !
!PhLTemplateGroupsBuilder class methodsFor: 'instance creation'!
buildFrom: aPhLTemplateSourcesList
	^ self new 
		initializeWithSources: aPhLTemplateSourcesList;
		build! !
!PhLTemplateGroupsBuilder methodsFor: 'building'!
build
	^ groups := sources
		collect: [ :source | 
			source asTemplateGroup 
				in: [ :group |
					source templatesDo: [ :templateSource | group addTemplate: templateSource asTemplate ] ];
			yourself ]! !
!PhLTemplateGroupsBuilder methodsFor: 'initialization'!
initializeWithSources: aListOfTemplateSource 
	sources := aListOfTemplateSource.
	groups := OrderedCollection new.! !
!PhLTemplateSource class methodsFor: 'instance creation - cache'!
cacheGroup
	^ self new 	
		type: self cacheType;
		name: 'Templates';
		yourself! !
!PhLTemplateSource class methodsFor: 'types'!
cacheType
	^ #Cache! !
!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!
deprecatedDistributionsGroup
	^ self new 	
		type: self urlGroupType;
		name: 'Deprecated distributions';
		templates: { self pharo40 .
				self pharo30 .
				self pharo20 .
				self moose51 .
				self moose50 };
		yourself! !
!PhLTemplateSource class methodsFor: 'types'!
httpListingType
	^ #HttpListing! !
!PhLTemplateSource class methodsFor: 'instance creation - jenkins'!
inriaMoose
	^ self new 	
		type: self jenkinsServerType;
		name: 'Moose Jenkins';
		url: 'https://ci.inria.fr/moose';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - jenkins'!
inriaPharoContribution
	^ self new 	
		type: self jenkinsServerType;
		name: 'Pharo Contribution Jenkins';
		url: 'https://ci.inria.fr/pharo-contribution';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - jenkins'!
inriaRmod
	^ self new 	
		type: self jenkinsServerType;
		name: 'RMoD Jenkins';
		url: 'https://ci.inria.fr/rmod';
		yourself! !
!PhLTemplateSource class methodsFor: 'types'!
jenkinsServerType
	^ #JenkinsServer! !
!PhLTemplateSource class methodsFor: 'instance creation - url mooc'!
moocGroup
	^ self new 	
		type: self urlGroupType;
		name: 'Pharo Mooc';
		templates: { self pharoMooc };
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!
moose50
	^ self new 	
		type: self urlType;
		name: 'Moose Suite 5.0';
		url: 'http://moosetechnology.org/res/download/moose_image_5_0.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!
moose51
	^ self new 	
		type: self urlType;
		name: 'Moose Suite 5.1 (old stable)';
		url: 'https://ci.inria.fr/moose/job/moose-5.1/lastSuccessfulBuild/artifact/moose-5.1.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
moose60
	^ self new 	
		type: self urlType;
		name: 'Moose Suite 6.0 (stable)';
		url: 'https://ci.inria.fr/moose/job/moose-6.0/lastSuccessfulBuild/artifact/moose-6.0.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
moose61
	^ self new 	
		type: self urlType;
		name: 'Moose Suite 6.1 (beta)';
		url: 'https://ci.inria.fr/moose/job/moose-6.1/lastSuccessfulBuild/artifact/moose-6.1.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
officialDistributionsGroup
	^ self new 	
		type: self urlGroupType;
		name: 'Official distributions';
		templates: { self pharo70x32 .
				self pharo70x64 .
				self pharo60x32 .
				self pharo60x64 .
				self pharo50 .
				self moose61 .
				self moose60 };
		expanded: true;
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!
pharo20
	^ self new 	
		type: self urlType;
		name: 'Pharo 2.0';
		url: 'http://files.pharo.org/image/20/latest.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!
pharo30
	^ self new 	
		type: self urlType;
		name: 'Pharo 3.0';
		url: 'http://files.pharo.org/image/30/latest.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!
pharo40
	^ self new 	
		type: self urlType;
		name: 'Pharo 4.0';
		url: 'http://files.pharo.org/image/40/latest.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
pharo50
	^ self new 	
		type: self urlType;
		name: 'Pharo 5.0';
		url: 'http://files.pharo.org/image/50/latest.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - http listing'!
pharo60
	^ self new 	
		type: self httpListingType;
		name: 'Pharo 6.0 (stable)'; 
		url: 'http://files.pharo.org/image/60/';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
pharo60x32
	^ self new 	
		type: self urlType;
		name: 'Pharo 6.1 - 32bit (stable)';
		url: 'http://files.pharo.org/image/60/latest.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
pharo60x64
	^ self new 	
		type: self urlType;
		name: 'Pharo 6.1 - 64bit (tech preview)';
		url: 'http://files.pharo.org/image/60/latest-64.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - http listing'!
pharo70
	^ self new 	
		type: self httpListingType;
		name: 'Pharo 7.0 (development version)'; 
		url: 'http://files.pharo.org/image/70/';
		filterPattern: 'href="(Pharo-?7.0.0-(alpha|rc\d+).build.[^"]*.zip)"';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
pharo70x32
	^ self new 	
		type: self urlType;
		name: 'Pharo 7.0 - 32bit (development version)';
		url: 'http://files.pharo.org/image/70/latest.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url official'!
pharo70x64
	^ self new 	
		type: self urlType;
		name: 'Pharo 7.0 - 64bit (development version)';
		url: 'http://files.pharo.org/image/70/latest-64.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'instance creation - url mooc'!
pharoMooc
	^ self new
		type: self urlType;
		name: 'Pharo Mooc';
		url: 'http://mooc.pharo.org/image/PharoWeb.zip';
		yourself! !
!PhLTemplateSource class methodsFor: 'types'!
urlGroupType
	^ #URLGroup! !
!PhLTemplateSource class methodsFor: 'types'!
urlType
	^ #URL! !
!PhLTemplateSource methodsFor: 'comparing'!
= anObject
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	^ name = anObject name
		and: [ type = anObject type 
		and: [ url = anObject url
		and: [ filterPattern = anObject filterPattern
		and: [ templates = anObject templates
		and: [ self expanded = anObject expanded ] ] ] ] ]! !
!PhLTemplateSource methodsFor: 'converting'!
asBasicTemplateGroup
	type == self class httpListingType
		ifTrue: [ | pattern |
					pattern := filterPattern ifNil: [ PhLHTTPListingTemplateGroup defaultFilterPattern ].
					^ PhLHTTPListingTemplateGroup
						name: name
						url: url asZnUrl
						filterPattern: pattern templateNameFormat: templateNameFormat username: username password: password].
	type == self class jenkinsServerType 
		ifTrue: [ ^ PhLJenkins2Server name: name url: url asZnUrl username: username password: password ].
	type == self class urlGroupType
		ifTrue: [ ^ PhLFixedURLsTemplateGroup new 
						setName: name Templates: OrderedCollection new;
						yourself ].
	type == self class cacheType 
		ifTrue: [ ^ PhLDownloadedTemplateGroup named: name ].
		
	self error: 'Group type not supported!!'! !
!PhLTemplateSource methodsFor: 'converting'!
asTemplate
	type == self class urlType ifTrue: [ 
		^ PhLRemoteTemplate
			  name: name
			  url: url asUrl
			  username: username
			  password: password ].
	self error: 'Template type not supported!!'! !
!PhLTemplateSource methodsFor: 'converting'!
asTemplateGroup
	^ self asBasicTemplateGroup 
		isHighlighted: expanded;
		yourself! !
!PhLTemplateSource methodsFor: 'accessing'!
expanded
	^ expanded notNil & expanded! !
!PhLTemplateSource methodsFor: 'accessing'!
expanded: aBoolean
	"when source is a group, tell if it should be expanded as default"
	expanded := aBoolean! !
!PhLTemplateSource methodsFor: 'accessing'!
filterPattern
	^ filterPattern! !
!PhLTemplateSource methodsFor: 'accessing'!
filterPattern: aString 
	filterPattern := aString! !
!PhLTemplateSource methodsFor: 'accessing'!
name
	^ name! !
!PhLTemplateSource methodsFor: 'accessing'!
name: aString 
	name := aString! !
!PhLTemplateSource methodsFor: 'accessing'!
password
	^ password! !
!PhLTemplateSource methodsFor: 'accessing'!
password: anObject
	password := anObject! !
!PhLTemplateSource methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.
	aStream 
		nextPut: $(;
		nextPutAll: name;
		nextPut: $)! !
!PhLTemplateSource methodsFor: 'accessing'!
templateNameFormat
	^ templateNameFormat! !
!PhLTemplateSource methodsFor: 'accessing'!
templateNameFormat: anObject
	templateNameFormat := anObject! !
!PhLTemplateSource methodsFor: 'accessing'!
templates
	^ templates! !
!PhLTemplateSource methodsFor: 'accessing'!
templates: aListOfTemplates
	templates := aListOfTemplates.! !
!PhLTemplateSource methodsFor: 'iterating'!
templatesDo: aBlockClosure 
	templates ifNotNil: [ templates do: aBlockClosure ]! !
!PhLTemplateSource methodsFor: 'accessing'!
type
	^ type! !
!PhLTemplateSource methodsFor: 'accessing'!
type: aString 
	type := aString! !
!PhLTemplateSource methodsFor: 'accessing'!
url
	^ url! !
!PhLTemplateSource methodsFor: 'accessing'!
url: aString 
	url := aString! !
!PhLTemplateSource methodsFor: 'accessing'!
username
	^ username! !
!PhLTemplateSource methodsFor: 'accessing'!
username: anObject
	username := anObject! !
!PhLCompositeTemplateSources class methodsFor: 'instance creation'!
fromFile
	self shouldNotImplement! !
!PhLCompositeTemplateSources methodsFor: 'initialization'!
initializeWith: aListOfTemplateSources
	templateSources := aListOfTemplateSources! !
!PhLCompositeTemplateSources methodsFor: 'accessing'!
sources
	^ templateSources flatCollect: #sources! !
!PhLPharoTemplateSources class methodsFor: 'accessing'!
announcer
	^ SourcesAnnouncer ifNil: [ SourcesAnnouncer := Announcer new ]! !
!PhLPharoTemplateSources class methodsFor: 'updating'!
checkForUpdates

	self fromFile checkForUpdates! !
!PhLPharoTemplateSources class methodsFor: 'accessing'!
defaultSources
	^ OrderedCollection new 
		add: PhLTemplateSource cacheGroup;
		add: PhLTemplateSource moocGroup;
		add: PhLTemplateSource officialDistributionsGroup;
		add: PhLTemplateSource deprecatedDistributionsGroup;
		add: PhLTemplateSource inriaPharoContribution;
		add: PhLTemplateSource inriaMoose;
		add: PhLTemplateSource pharo60;
		add: PhLTemplateSource pharo70;
		yourself! !
!PhLPharoTemplateSources class methodsFor: 'accessing'!
defaultSourcesUrl

	^ 'https://files.pharo.org/pharo-launcher/sources.list'! !
!PhLPharoTemplateSources class methodsFor: 'private'!
downloadedSourcesFileLock
	^  DownloadedSourcesFileLock ifNil: [ DownloadedSourcesFileLock := Semaphore forMutualExclusion ].! !
!PhLPharoTemplateSources class methodsFor: 'accessing'!
fromFile
	^ self withFile: self sourcesFile! !
!PhLPharoTemplateSources class methodsFor: 'reseting'!
resetSourcesUrl
	self sourcesUrl: self defaultSourcesUrl! !
!PhLPharoTemplateSources class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #sourcesUrl)
		label: 'Template sources Url' translated;
		parent: #pharoLauncher;
		target: self;
		order: 38;
		default: self defaultSourcesUrl;
		description: 'Url for downloading the template list'! !
!PhLPharoTemplateSources class methodsFor: 'accessing'!
sourcesFile
	"File with the list of default templates sources for Pharo Launcher"
	^ self launcherCoreDir / 'sources.list'! !
!PhLPharoTemplateSources class methodsFor: 'accessing'!
sourcesUrl
	"Url of the file with the list of default templates sources for Pharo Launcher"

	^ SourcesUrl ifNil: [ SourcesUrl := self defaultSourcesUrl ]! !
!PhLPharoTemplateSources class methodsFor: 'accessing'!
sourcesUrl: aUrl

	| oldUrl |
	oldUrl := SourcesUrl.
	SourcesUrl := aUrl.
	
	oldUrl = SourcesUrl ifTrue: [ ^ self "ok" ].
	self checkForUpdates! !
!PhLPharoTemplateSources methodsFor: 'actions'!
checkForUpdates
	| downloadedSources |
	file exists ifFalse: [ ^ self ensureSourcesFile ].
	self lockDownloadedSourcesFileDuring: 
		[ self downloadedSourcesFile ensureDelete.
		self fetchSourcesFile.
		downloadedSources := self downloadedSources. ].
	
	self sources = downloadedSources
		ifFalse: [ self class announcer announce: (PhLSourcesFileUpdateAvailable sources: downloadedSources) ].! !
!PhLPharoTemplateSources methodsFor: 'reading'!
downloadedSources
	| sources |
	self downloadedSourcesFile readStreamDo: [ :stream |
		 sources := STON fromStream: stream].
	^ sources! !
!PhLPharoTemplateSources methodsFor: 'accessing'!
downloadedSourcesFile
	^ file parent / (file basename, '.dl')! !
!PhLPharoTemplateSources methodsFor: 'accessing'!
downloadedSourcesFileLock
	"downloadedSourcesFileLock is a class variable because it points to a file that can only be used by one instance at a time."
	^ self class downloadedSourcesFileLock! !
!PhLPharoTemplateSources methodsFor: 'accessing'!
downloadedSourcesFileLockFile
	^ file parent / (file basename, '.dl.lock')! !
!PhLPharoTemplateSources methodsFor: 'actions'!
ensureSourcesFile
	file exists ifTrue: [ ^ file ].
	
	self fetchSourcesFile.
	self downloadedSourcesFile exists 
		ifFalse: [ PhLUIInformation new 
						message: 'Cannot fetch Pharo Launcher template sources file: {1}'. ].
	self replaceSourcesFileWithDownloaded.! !
!PhLPharoTemplateSources methodsFor: 'actions'!
fetchSourcesFile
	"Avoid to have a retry dialog"
	PhLDownloadManager default
		basicDownload: self sourcesUrl
		toFile: self downloadedSourcesFile. 
	! !
!PhLPharoTemplateSources methodsFor: 'accessing'!
file
	^ file! !
!PhLPharoTemplateSources methodsFor: 'private'!
lockDownloadedSourcesFileDuring: aBlock
	self downloadedSourcesFileLockFile exists
		ifTrue: [ | lockDate |
			lockDate := DateAndTime fromString: self downloadedSourcesFileLockFile contents.
			(DateAndTime now - lockDate > 1 day)
				ifTrue: [ self downloadedSourcesFileLockFile ensureDelete "there was probably a problem during the update" ]
				ifFalse: [ ^ self "File already locked, do not execute the block" ] ]. 
	
	"Ensure file is locked if another Launcher instance (another image) is open".
	self downloadedSourcesFileLockFile 
		writeStreamDo: [ :stream | stream nextPutAll: DateAndTime now asString ]. 
	"Lock working for this image."
	[ self downloadedSourcesFileLock critical: aBlock ]
	ensure: [ self downloadedSourcesFileLockFile ensureDelete ]! !
!PhLPharoTemplateSources methodsFor: 'actions'!
replaceSourcesFileWithDownloaded
	file ensureDelete.
	self downloadedSourcesFile moveTo: file ! !
!PhLPharoTemplateSources methodsFor: 'accessing'!
sources
	self ensureSourcesFile.
	^ super sources! !
!PhLPharoTemplateSources methodsFor: 'accessing'!
sourcesUrl

	^ self class sourcesUrl! !
!PhLPharoTemplateSources methodsFor: 'actions'!
updateSourcesFile
	self downloadedSourcesFile exists ifFalse: [ ^ self "nothing to update" ].
	
	self replaceSourcesFileWithDownloaded! !
!PhLTemplateSources class methodsFor: 'accessing'!
defaultSources 
	^ PhLCompositeTemplateSources new 
			initializeWith: { PhLPharoTemplateSources fromFile . PhLUserTemplateSources fromFile };
			yourself! !
!PhLTemplateSources class methodsFor: 'example'!
example
	^ self withFile: PhLPharoTemplateSources sourcesFile! !
!PhLTemplateSources class methodsFor: 'serializing'!
flush: aListOfPhLTemplateSource in: aFileReference
	aFileReference writeStreamDo: [ :stream |
		STON 
			put: aListOfPhLTemplateSource
			onStreamPretty: stream ].
	^ aFileReference ! !
!PhLTemplateSources class methodsFor: 'serializing'!
flushIn: aFileReference
	self flush: self defaultSources in: aFileReference
	! !
!PhLTemplateSources class methodsFor: 'instance creation'!
fromFile
	self subclassResponsibility! !
!PhLTemplateSources class methodsFor: 'serializing'!
generateSourcesFile
	self flushIn: self sourcesFile! !
!PhLTemplateSources class methodsFor: 'accessing'!
launcherCoreDir
	^ (LauncherCoreDir ifNil: [ LauncherCoreDir := FileLocator launcherUserFilesLocation ]) ensureCreateDirectory! !
!PhLTemplateSources class methodsFor: 'accessing'!
launcherCoreDir: aFileUrl
	LauncherCoreDir := aFileUrl asFileReference.
	LauncherCoreDir ensureCreateDirectory! !
!PhLTemplateSources class methodsFor: 'accessing'!
launcherCoreDirString
	" Used to display a nice file url in settings browser"
	^ self launcherCoreDir pathString ! !
!PhLTemplateSources class methodsFor: 'accessing'!
launcherCoreDirString: aFileUrl
	" Used to display a nice file url in settings browser"
	self launcherCoreDir: aFileUrl
! !
!PhLTemplateSources class methodsFor: 'updating'!
resetLauncherCoreDir
	LauncherCoreDir := nil! !
!PhLTemplateSources class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #launcherCoreDirString)
		label: 'Location of template sources file' translated;
		type: #Directory;
		parent: #pharoLauncher;
		target: self;
		order: 37;
		default: FileLocator launcherUserFilesLocation;
		description:
			'Path to the directory that will contain Pharo Launcher template sources file.' , String cr
				, 'You must have the read/write rights on this folder.' , String cr
				, 'NOTE: This path might need to escape some whitespace characters.' translated.! !
!PhLTemplateSources class methodsFor: 'instance creation'!
withFile: aSourcesFile
	^ self new 
		initializeWith: aSourcesFile;
		yourself! !
!PhLTemplateSources class methodsFor: 'instance creation'!
withTemplateList: aListOfPhLTemplateSource
	| file |
	file := FileSystem memory / 'sources.list'.
	self flush: aListOfPhLTemplateSource in: file.
	^ self withFile: file! !
!PhLTemplateSources methodsFor: 'iterating'!
collect: aBlock
	^ self sources collect: aBlock! !
!PhLTemplateSources methodsFor: 'initialization'!
initializeWith: aSourcesFile
	file := aSourcesFile.! !
!PhLTemplateSources methodsFor: 'accessing'!
sources
	| sources |
	file exists 
		ifFalse: [ ^ #() ].
	
	[ file readStreamDo: [ :stream |
		 sources := STON fromStream: stream] ]
	on: STONReaderError, InstanceVariableNotFound  
	do: [ sources := #() ].
	^ sources! !
!PhLUserTemplateSources class methodsFor: 'example'!
example 
	^ self withTemplateList:  
		{ PhLTemplateSource new 	
			type: PhLTemplateSource httpListingType;
			name: 'User-defined http listing'; 
			url: 'http://myserver.org/myimages/';
			yourself }! !
!PhLUserTemplateSources class methodsFor: 'accessing'!
fromFile
	^ self withFile: self sourcesFile! !
!PhLUserTemplateSources class methodsFor: 'accessing'!
sourcesFile
	"File with the list of user-defined templates sources for Pharo Launcher"
	^ self launcherCoreDir / 'mysources.list'! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'initialization'!
initialize
	super initialize.
	PhLStartupManager addToLauncherStartUpList: self! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'launcher startup'!
launcherStartUp
	self run! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'launcher startup'!
launcherStartUpPriority
	^ 500! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'running'!
run
	self shouldRun ifFalse: [ ^ self ].
	
	self uniqueInstance run
	
	! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #shouldRun)
		label: 'Check for template sources update?' translated;
		parent: #pharoLauncher;
		target: self;
		order: 55;
		description: 'Check if Pharo Launcher Template sources has an update available (needs internet access)' translated! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'settings'!
shouldRun
	^ ShouldRun ifNil: [ ShouldRun := true ]! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'settings'!
shouldRun: aBoolean
	ShouldRun := aBoolean.
	ShouldRun 
		ifTrue: [ self run ]
		ifFalse: [ self terminate ].! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'running'!
terminate
	self uniqueInstance terminate
	
	! !
!PhLTemplateSourcesUpdateChecker class methodsFor: 'running'!
uniqueInstance
	^ UniqueInstance ifNil: [ UniqueInstance := self new ]! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!
basicUpdateTemplateSources
	PhLPharoTemplateSources fromFile updateSourcesFile.
	PharoLauncherApplication resetTemplateRepository.
	PharoLauncherApplication default resetTemplateRepository.! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'accessing'!
check
	[ PhLPharoTemplateSources fromFile checkForUpdates ]
	on: PhLDownloadError 
	do: [ :e | "ignore. No internet connection available" ]! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'accessing'!
name
	^ 'Launcher sources update checker'! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'accessing'!
priority
	^ 20! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!
registerOnTemplateSourcesUpdate
	PhLPharoTemplateSources announcer weak
		when: PhLSourcesFileUpdateAvailable
		send: #updateTemplateSources:
		to: self.! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'actions'!
run
	self terminate.
	self registerOnTemplateSourcesUpdate.
	process := [ [ self check.
		self wait ] repeat ]
	forkAt: self priority named: self name! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'actions'!
terminate
	self unregisterFromTemplateSourcesUpdate.
	process ifNotNil: [ process isTerminating ifFalse: [ process terminate ] ]! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!
unregisterFromTemplateSourcesUpdate
	PhLPharoTemplateSources announcer
		unsubscribe: self.! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!
updateTemplateSources: announcement
	| applyUpdate |
	applyUpdate := UIManager default
		confirm: 'Update available for Pharo Launcher templates sources!!'
		trueChoice: 'Update'
		falseChoice: 'Remind me later'.
	applyUpdate ifNil: [ ^ self ].
	applyUpdate ifFalse: [ ^ self ].
	
	self basicUpdateTemplateSources! !
!PhLTemplateSourcesUpdateChecker methodsFor: 'actions'!
wait
	24 hours wait.! !
!PhLTreeSelection class methodsFor: 'instance creation'!
with: aCollection
	^self new 
		selections: aCollection;
		yourself! !
!PhLTreeSelection methodsFor: 'accessing'!
anyOne
	^self leafNodes anyOne! !
!PhLTreeSelection methodsFor: 'accessing'!
anySatisfy: aBlockOrSymbol
	^ self leafNodes anySatisfy: aBlockOrSymbol! !
!PhLTreeSelection methodsFor: 'accessing'!
leafNodes
	^ self selections collect: [ :each | each content]! !
!PhLTreeSelection methodsFor: 'private'!
pathFor: treeNodeModel on: collection
	| content |
	treeNodeModel parentNode ifNotNil: [ :node | self pathFor: node on: collection ].
	content := treeNodeModel content.
	collection
		add:
			(content isString
				ifTrue: [ content printString ]
				ifFalse: [ content name ])! !
!PhLTreeSelection methodsFor: 'private'!
pathNameFor: treeNodeModel on: writeStream
	| content |
	treeNodeModel parentNode
		ifNotNil: [ :node | 
			self pathNameFor: node on: writeStream.
			writeStream nextPut: $- ].
	content := treeNodeModel content.
	writeStream
		nextPutAll:
			(content isString
				ifTrue: [ content printString ]
				ifFalse: [ content name ])! !
!PhLTreeSelection methodsFor: 'accessing'!
pathNames
	^ self selections collect: [ :path | 
			| result |
			result := WriteStream on: String new.
			
			self pathNameFor: path on: result.
			
			result contents asFileName ]
		! !
!PhLTreeSelection methodsFor: 'accessing'!
pathes
	^ self selections collect: [ :path | 
			| result |
			result := OrderedCollection new: 5.
			self pathFor: path on: result.
			result ]
		! !
!PhLTreeSelection methodsFor: 'accessing'!
select: aBlockOrSymbol
	^self leafNodes select: aBlockOrSymbol! !
!PhLTreeSelection methodsFor: 'accessing'!
selections
	^ selections! !
!PhLTreeSelection methodsFor: 'accessing'!
selections: anObject
	selections := anObject! !
!PhLTreeSelection methodsFor: 'accessing'!
size 
	^self selections size! !
!PhLUIConfirmation methodsFor: 'action'!
confirm
	^ UIManager default confirm: message! !
!PhLUIConfirmation methodsFor: 'accessing'!
message: aString 
	message := aString! !
!PhLUIFileRequest methodsFor: 'action'!
chooseFile
	^ UIManager default
		chooseExistingFileReference: title
		extensions: extensionsToShow
		path: path
		preview: false.! !
!PhLUIFileRequest methodsFor: 'accessing'!
extensionsToShow: anObject
	extensionsToShow := anObject! !
!PhLUIFileRequest methodsFor: 'accessing'!
path: anObject
	path := anObject! !
!PhLUIFileRequest methodsFor: 'accessing'!
title: anObject
	title := anObject! !
!PhLUIInformation methodsFor: 'action'!
abort
	UIManager default abort: message! !
!PhLUIInformation methodsFor: 'action'!
alert
	UIManager default alert: message! !
!PhLUIInformation methodsFor: 'action'!
deny
	UIManager default deny: message! !
!PhLUIInformation methodsFor: 'action'!
denyWithTitle: titleString
	UIManager default deny: message title: titleString! !
!PhLUIInformation methodsFor: 'action'!
inform
	UIManager inform: message! !
!PhLUIInformation methodsFor: 'accessing'!
message: aMessage
	message := aMessage! !
!PhLUIRequest methodsFor: 'action'!
chooseFrom: aListOfChoices
	^ UIManager default 
		chooseFrom: aListOfChoices
		lines: #()
		title: title! !
!PhLUIRequest methodsFor: 'accessing'!
initialAnswer: aString 
	initialAnswer := aString! !
!PhLUIRequest methodsFor: 'action'!
request
	| answer |
	[ answer := UIManager default request: title initialAnswer: initialAnswer ]
		doWhileTrue: [ answer isNotNil and: [ validationBlock isNotNil and: [ (validationBlock value: answer) not ] ] ].
		"answer is nil when the user press cancels. That's a possible answer we have to accept."
	^ answer! !
!PhLUIRequest methodsFor: 'accessing'!
title: aString 
	title := aString! !
!PhLUIRequest methodsFor: 'accessing'!
validateAnswer: aBlock
	validationBlock := aBlock! !
!PhLPrivateVirtualMachine methodsFor: 'querying'!
downloadUrl
	^ self manager compatibleVmUrls 
		at: self name asInteger! !
!PhLPrivateVirtualMachine methodsFor: 'accessing'!
vmStore
	^ self manager privateVmStore! !
!PhLVirtualMachine class methodsFor: 'instance creation'!
directory: aFileReference
	^ self 
		directory: aFileReference
		private: false! !
!PhLVirtualMachine class methodsFor: 'instance creation'!
directory: aFileReference private: isPrivateVm
	| targetClass |
	targetClass := isPrivateVm ifTrue: [ PhLPrivateVirtualMachine ] ifFalse: [ self ].
	^ targetClass new 
		initializeOn: aFileReference;
		yourself ! !
!PhLVirtualMachine class methodsFor: 'accessing'!
elfMagicNumber
	^ ByteArray newFrom: #(127 69 76 70)! !
!PhLVirtualMachine class methodsFor: 'querying'!
executableName
	^ PlatformResolver forCurrentPlatform vmExecutableName! !
!PhLVirtualMachine class methodsFor: 'accessing'!
headlessOptionString
	^ '--headless'! !
!PhLVirtualMachine class methodsFor: 'instance creation'!
id: aString

	^ self new
		id: aString;
		initializeExecutableRef;
		yourself! !
!PhLVirtualMachine methodsFor: 'comparing'!
= aVM
	self class = aVM class 
		ifFalse: [ ^ false ]. 
	
	^ aVM id = self id! !
!PhLVirtualMachine methodsFor: 'querying'!
archPath
	arch ifNotNil: [ ^ arch ].
	
	^ (self id last: 3) = 'x64'
		ifTrue: [ '64' ]
		ifFalse: [ '' ]! !
!PhLVirtualMachine methodsFor: 'initialization'!
basicInitializeOn: aFolder
	id := aFolder basename.! !
!PhLVirtualMachine methodsFor: 'initialization'!
be64bits
	arch := '64'! !
!PhLVirtualMachine methodsFor: 'initialization'!
beHeadless

	"Set the flavour to attach to the vm download url"
	flavour := self headlessFlavour! !
!PhLVirtualMachine methodsFor: 'initialization'!
beLatest
	blessing := 'latest'! !
!PhLVirtualMachine methodsFor: 'accessing'!
blessing
	^ blessing! !
!PhLVirtualMachine methodsFor: 'querying'!
downloadUrl
	^ self manager vmUrlTemplate
		format: { self pharoVersion . self archPath . self manager downloadPathOSTypeSegment . self flavour . self blessing }! !
!PhLVirtualMachine methodsFor: 'updating'!
ensureExecutionRights
	"Unzipping with Pharo does not preserve unix rights and so, the pahro VM executable does not have the execution permission.
	We have to set it explicitely on Unix and OS X."

	Smalltalk os isWindows ifTrue: [ ^ self ].

	PhLProcessWrapper new
		shellCommand;
		addArguments: 'chmod u+x';
		in: [ :command | self executablesToEnsure do: [ :file | command addArgument: file fullName surroundedByDoubleQuotes ] ];
		runAndWaitTimeOut: 5 seconds! !
!PhLVirtualMachine methodsFor: 'setting'!
executable: aPathOrfileReference
	executableRef := aPathOrfileReference asFileLocatorOrReference! !
!PhLVirtualMachine methodsFor: 'accessing'!
executableFolderPath
	^ executableRef parent fullName! !
!PhLVirtualMachine methodsFor: 'accessing'!
executablePath
	^ executableRef fullName! !
!PhLVirtualMachine methodsFor: 'accessing'!
executablesToEnsure
	| vmFolder |
	vmFolder := self vmStore / self id.
	^ vmFolder exists ifTrue: [ (vmFolder allChildrenMatching: self class executableName) select: #isFile ] ifFalse: [ #() ]! !
!PhLVirtualMachine methodsFor: 'accessing'!
flavour
	^ flavour! !
!PhLVirtualMachine methodsFor: 'comparing'!
hash

	^ self id hash! !
!PhLVirtualMachine methodsFor: 'accessing'!
headlessFlavour
	^ '-headless'! !
!PhLVirtualMachine methodsFor: 'accessing'!
id
	^ id! !
!PhLVirtualMachine methodsFor: 'accessing'!
id: aString
	id := aString.
	(aString includesAll: '-x64')
		ifTrue: [ self be64bits ].! !
!PhLVirtualMachine methodsFor: 'testing'!
ifValid: aBlockClosure 
	self isValid
		ifTrue: [ aBlockClosure value ]! !
!PhLVirtualMachine methodsFor: 'initialization'!
initialize
	super initialize.
	flavour := ''. "No flavour means heafull vm, it will be used to fetch the vm"
	blessing := 'stable'.! !
!PhLVirtualMachine methodsFor: 'initialization'!
initializeExecutableRef
	
	executableRef ifNil: [ | vmFolder |
		vmFolder := self vmStore / self id.
		vmFolder exists ifTrue: [ self initializeExecutableRefFrom: vmFolder ] ]! !
!PhLVirtualMachine methodsFor: 'initialization'!
initializeExecutableRefFrom: aFolder
	| executables vmFolder |
	vmFolder := aFolder asFileReference. "ensure we compare file references and not locators"
	executables := vmFolder allChildrenMatching: self class executableName.
	Smalltalk os isUnix
		ifTrue: [ "On linux, either the VM exe is at the top level or a bash script at the top level has to be used"
			executableRef := executables
				detect: [ :fileRef | fileRef parent = vmFolder ]
				ifNone: [ PhLExecutableNotFoundError signalKind: 'executable' inPath: vmFolder fullName ].
			vmBinaryRef := executables
				detect: [ :fileRef | fileRef binaryReadStreamDo: [ :stream | (stream next: 4) = self class elfMagicNumber ] ]
				ifNone: [ PhLExecutableNotFoundError signalKind: 'VM binary' inPath: vmFolder fullName ] ]
		ifFalse: [ executableRef := vmBinaryRef := executables 
			detect: #isFile 
			ifNone: [ PhLExecutableNotFoundError signalKind: 'executable' inPath: vmFolder fullName ] ].
	executableRef := executableRef asFileLocatorOrReference.
	vmBinaryRef := vmBinaryRef asFileLocatorOrReference.! !
!PhLVirtualMachine methodsFor: 'initialization'!
initializeOn: aFolder
	self basicInitializeOn: aFolder.
	self initializeExecutableRefFrom: aFolder.! !
!PhLVirtualMachine methodsFor: 'testing'!
isHeadless 
	^ flavour = self headlessFlavour! !
!PhLVirtualMachine methodsFor: 'testing'!
isValid
	^ executableRef isNotNil
		and: [ vmBinaryRef isNotNil ]! !
!PhLVirtualMachine methodsFor: 'testing'!
isValidAfterUpdate
	self isValid ifTrue: [ ^ true ].
	
	self updateFromUrl.
	^ self isValid! !
!PhLVirtualMachine methodsFor: 'querying'!
lastUpdateTime
	^ executableRef modificationTime! !
!PhLVirtualMachine methodsFor: 'querying'!
lastUpdateTimeDescription
	
	| timestamp |
	self isValid ifFalse: [ ^ 'Not available' ].
	timestamp := self lastUpdateTime.
	^ timestamp asDate yyyymmdd, ' ', timestamp asTime print24! !
!PhLVirtualMachine methodsFor: 'updating'!
manager
	^ manager ifNil: [ manager := PhLVirtualMachineManager new ]! !
!PhLVirtualMachine methodsFor: 'accessing'!
manager: aPhLVirtualMachineManager 
	manager := aPhLVirtualMachineManager! !
!PhLVirtualMachine methodsFor: 'accessing'!
name
	^ self id! !
!PhLVirtualMachine methodsFor: 'querying'!
pharoVersion
	^ ($- split: self id) first! !
!PhLVirtualMachine methodsFor: 'printing'!
printOn: aStream
	super printOn: aStream.
	aStream
		nextPut: $(;
		nextPutAll: self id;
		nextPut: $)! !
!PhLVirtualMachine methodsFor: 'actions'!
removeFromSystem
	| vmFolder zipFile |
	vmFolder := self vmStore / self name.
	vmFolder exists
		ifTrue: [ vmFolder ensureDeleteAll ].
	zipFile := self vmStore / (self name, '.zip').
	zipFile exists
		ifTrue: [ zipFile ensureDelete ].
! !
!PhLVirtualMachine methodsFor: 'actions'!
showInFolder
	PhLFileBrowser openOn: self vmStore / self id! !
!PhLVirtualMachine methodsFor: 'ston persistence'!
stonOn: stonWriter
	stonWriter writeObject: self streamMap: [ :mapWriter |
		self class stonAllInstVarNames 
			do: [ :each | | value | 
				value := self stonValueOf: each.
				value ifNotNil: [ mapWriter at: each put: value ] ] ].! !
!PhLVirtualMachine methodsFor: 'ston persistence'!
stonValueOf: anInstVarName
	anInstVarName = #executableRef 
		ifTrue: [ ^ executableRef ifNotNil: [ executableRef asFileLocatorOrReference ] ].
	anInstVarName = #vmBinaryRef 
		ifTrue: [ ^ vmBinaryRef ifNotNil: [ vmBinaryRef asFileLocatorOrReference ] ].
	^ self instVarNamed: anInstVarName! !
!PhLVirtualMachine methodsFor: 'updating'!
updateFromUrl
	"fetch a new version of this Virtual Machine if available"

	self manager class fetch: self downloadUrl to: self vmStore / (self id , '.zip').

	self initializeExecutableRefFrom: self vmStore / self id.
	self ensureExecutionRights! !
!PhLVirtualMachine methodsFor: 'accessing'!
validityDescription
	
	^ self isValid
		ifTrue: [ 'VM available' ]
		ifFalse: [ 'VM not available' ]! !
!PhLVirtualMachine methodsFor: 'setting'!
vmBinary: aPathOrFileReference
	vmBinaryRef := aPathOrFileReference asFileReference! !
!PhLVirtualMachine methodsFor: 'accessing'!
vmFolder
	^ vmBinaryRef parent! !
!PhLVirtualMachine methodsFor: 'accessing'!
vmFolderPath
	^ self vmFolder fullName! !
!PhLVirtualMachine methodsFor: 'accessing'!
vmStore
	^ self manager vmStore! !
!PhLVirtualMachineManager class methodsFor: 'unzipping'!
canUseSytemZip
	^ PhLProcessWrapper isCommandAvailable: 'unzip'! !
!PhLVirtualMachineManager class methodsFor: 'private'!
fetch: aVmUrl to: targetFile
	PhLDownloadManager default 
		download: aVmUrl
		toFile: targetFile.
	self
		unzip: targetFile
		to: (targetFile parent / targetFile basenameWithoutExtension)! !
!PhLVirtualMachineManager class methodsFor: 'instance creation'!
forImage: aPharoImagePathOrFileReference
	^ self new 
		imageFile: aPharoImagePathOrFileReference asFileReference;
		yourself
		
		! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
imageFormat32bits
	^ 6521! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
imageFormat64bits
	^ 68021! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
imageFormat6504
	^ 6504! !
!PhLVirtualMachineManager class methodsFor: 'querying'!
imageFormatNumberFromFile: anImagePath
	| imageFile |
	imageFile := anImagePath asFileReference.
	imageFile exists ifFalse: [
		self error: imageFile fullName, ' does not exist.' ].
	^ imageFile binaryReadStreamDo: [ :stream | self imageFormatNumberFromStream: stream ].
! !
!PhLVirtualMachineManager class methodsFor: 'private'!
imageFormatNumberFromStream: aStream
	| number |
	number := aStream nextLittleEndianNumber: 4.
	aStream close.
	^ number! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
imageFormatPreSpur
	^ 6505! !
!PhLVirtualMachineManager class methodsFor: 'testing'!
is32bits: anImageFormatVersion
	"32 bits Spur image format"

	^ anImageFormatVersion = self imageFormat32bits! !
!PhLVirtualMachineManager class methodsFor: 'testing'!
is64bits
	^ self is64bits: Smalltalk image imageFormatVersion! !
!PhLVirtualMachineManager class methodsFor: 'testing'!
is64bits: anImageFormatVersion
	"64 bits Spur image format"

	^ anImageFormatVersion = self imageFormat64bits! !
!PhLVirtualMachineManager class methodsFor: 'testing'!
isPreSpur: anImageFormatVersion
	"Pre-Spur image format"

	^ anImageFormatVersion = self imageFormatPreSpur! !
!PhLVirtualMachineManager class methodsFor: 'unzipping'!
pharoUnzip: aZipFileReference to: outputDirectory
	UIManager default informUserDuring: 
		[ :bar | 
		ZipArchive new
			readFrom: aZipFileReference;
			extractAllTo: outputDirectory informing: bar overwrite: true ]
	! !
!PhLVirtualMachineManager class methodsFor: 'private'!
privateVmStore
	"The private store is used to fetch one VM per image format and open image to determine their pharo version number (e.g. 6.0, 7.0, etc.). Then we download the latest stable VM for the given Pharo image version."
	^ (self vmStore / 'private') ensureCreateDirectory! !
!PhLVirtualMachineManager class methodsFor: 'initialization'!
reset
	<script>
	vmStore := nil! !
!PhLVirtualMachineManager class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #vmStoreString)
		label: 'VMs Directory' translated;
		type: #Directory;
		parent: #pharoLauncher;
		target: self;
		order: 50;
		default: (FileLocator launcherUserFilesLocation / 'vms');
		description:
			'Path to the directory containing all the VMs to launch your Pharo images.' , String cr
				, 'You must have the read/write rights on this folder.' , String cr
				, 'NOTE: This path might need to escape some whitespace characters e.g. "/Pharo\ 3.0/Pharo".' translated! !
!PhLVirtualMachineManager class methodsFor: 'unzipping'!
systemUnzip: aZipFileReference to: outputDirectory
	PhLProcessWrapper new 
		shellCommand;
		addArguments: 'unzip -o -d';
		addArgument: outputDirectory fullName surroundedByDoubleQuotes;
		addArgument: aZipFileReference fullName surroundedByDoubleQuotes;
		in: [ :process |
				"on Windows, unzip logs can corrupt extracted files. 
				See https://github.com/pharo-project/pharo-launcher/issues/349"
				OSPlatform current isWindows
					ifTrue: [ process addArgument: ' > nul' ] ];
		runAndWait.! !
!PhLVirtualMachineManager class methodsFor: 'unzipping'!
unzip: aZipFileReference to: outputDirectory
	outputDirectory ensureCreateDirectory.
	self canUseSytemZip
		ifTrue: [ self systemUnzip: aZipFileReference to: outputDirectory ]
		ifFalse: [ self pharoUnzip: aZipFileReference to: outputDirectory ]! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
vmStore
	^ vmStore ifNil: [ vmStore := (FileLocator launcherUserFilesLocation / 'vms') ensureCreateDirectory ]! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
vmStore: anObject
	vmStore := anObject asFileReference.
	vmStore ensureCreateDirectory! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
vmStoreString
	" Used to display a nice file url in settings browser"
	^ self vmStore pathString ! !
!PhLVirtualMachineManager class methodsFor: 'accessing'!
vmStoreString: aFileUrl
	" Used to display a nice file url in settings browser"
	self vmStore: aFileUrl
! !
!PhLVirtualMachineManager methodsFor: 'querying'!
availableVirtualMachines
	^ self availableVirtualMachinesIn: self vmStore! !
!PhLVirtualMachineManager methodsFor: 'querying'!
availableVirtualMachinesByImageFormat
	^ [ self availableVirtualMachinesIn: self privateVmStore] 
		on: PhLExecutableNotFoundError 
		do: [ :ex | ex path asFileReference ensureDeleteAll. ex retry ]! !
!PhLVirtualMachineManager methodsFor: 'private'!
availableVirtualMachinesIn: aFileReference
	| vmsOnDisk |
	vmsOnDisk := Dictionary new.
	aFileReference ensureCreateDirectory.
	aFileReference directories
		reject: [ :entry | entry basename = 'private' ]
		thenDo: [ :entry | | vm |
			vm := PhLVirtualMachine directory: entry private: (aFileReference = self privateVmStore).
			vm ifValid: [ vmsOnDisk at: entry basename put: vm ] ].
	^ vmsOnDisk! !
!PhLVirtualMachineManager methodsFor: 'private'!
checkImageArchitecture
	"Only warn on 64-bit Linux"
	Smalltalk os isUnix64 ifFalse: [ ^ self ]. 
	
	" Most OS are now 64-bits. Do not warn if a Pharo Launcher 32-bit tries to run a 64-bit image. "	
	(self class is64bits and: [ self class is32bits: self imageFormatNumber ])
		ifTrue: [ PhLArchitectureMismatchWarning signalLauncherArch: '64-bit' imageArch: '32-bit' ]! !
!PhLVirtualMachineManager methodsFor: 'private'!
compatibleVm
	"Do not get the exact VM for the given image but only an image able to run the image to get its version number"

	^ self availableVirtualMachinesByImageFormat
		at: self imageFormatNumber asString
		ifAbsent: [ self fetchCompatibleVm.
			self fetchSourcesFileForCompatibleVm.
			self availableVirtualMachinesByImageFormat at: self imageFormatNumber asString ]! !
!PhLVirtualMachineManager methodsFor: 'private'!
compatibleVmUrl
	^ self compatibleVmUrls at: self imageFormatNumber! !
!PhLVirtualMachineManager methodsFor: 'private'!
compatibleVmUrls
	"50-preSpur stable is not the latest stable pre-Spur VM. 40 vm is the latest stable pre-Spur"
	^ Dictionary newFromPairs: { 
		self class imageFormat6504 . self vmUrlTemplate format: { '13' . '' . self downloadPathOSTypeSegment . ''. 'stable' } .
		self class imageFormatPreSpur . self vmUrlTemplate format: { '40' . '' . self downloadPathOSTypeSegment . ''. 'stable' } .
		self class imageFormat32bits . self vmUrlTemplate format: { '70' . '' . self downloadPathOSTypeSegment . ''. 'stable' } .
		self class imageFormat64bits . self vmUrlTemplate format: { '70' . '64' . self downloadPathOSTypeSegment . ''. 'stable' }
	}! !
!PhLVirtualMachineManager methodsFor: 'querying'!
defaultVirtualMachines
	^ { 
		(PhLVirtualMachine id: '90-x64-headless')
			beHeadless;
			beLatest;
			be64bits;
			yourself.
		(PhLVirtualMachine id: '90-x64')
			be64bits;
			yourself.
		(PhLVirtualMachine id: '90-x86')
			yourself.
		(PhLVirtualMachine id: '80-x64-headless')
			beHeadless;
			beLatest;
			be64bits;
			yourself.
		(PhLVirtualMachine id: '80-x64')
			be64bits;
			yourself.
		(PhLVirtualMachine id: '80-x86')
			yourself.
		(PhLVirtualMachine id: '70-x64')
			be64bits;
			yourself.
		(PhLVirtualMachine id: '70-x86')
			yourself
	}! !
!PhLVirtualMachineManager methodsFor: 'private'!
downloadPathOSTypeSegment
	| os |
	os := Smalltalk os.
	(os isMacOS or: [ os isMacOSX ]) ifTrue: [ ^ 'mac' ].	
	os isUnix ifTrue: [ ^ 'linux' ].
	os isWindows ifTrue: [ ^ 'win' ].
! !
!PhLVirtualMachineManager methodsFor: 'private'!
fetchCompatibleVm
	[ self class 
		fetch: self compatibleVmUrl
		to: self privateVmStore / (self imageFormatNumber asString , '.zip') ]
	on: KeyNotFound
	do: [ self error: 'No Virtual Machine available for ' , self imageFormatNumber asString, ' image format. Maybe you need to update known formats?' ]! !
!PhLVirtualMachineManager methodsFor: 'private'!
fetchSourcesFileForCompatibleVm
	" We need to fetch the sources file to be able to determine the Pharo version of an image for Pharo versions < 2.0.
	Indeed, a blocking warning (about missing sources file) prevents the execution of any command line evaluation ..."
	(self imageFormatNumber = self class imageFormatPreSpur or: [ self imageFormatNumber = self class imageFormat6504 ])
		ifTrue: [ self 
			fetchSourcesFilesFor: '14' 
			in: self privateVmStore / self imageFormatNumber asString ]! !
!PhLVirtualMachineManager methodsFor: 'private'!
fetchSourcesFiles
	| previousVersion |
	"Do not download sources for Pharo versions > 70 as they come along with the image."
	self imageVersion asInteger >= 70
		ifTrue: [ ^ self ].
	self fetchSourcesFilesFor: self imageVersion.
	self imageVersion = '11' 
		ifTrue: [  ^ self ]. "No support for Pharo versions < 1.1"
	"Images for alpha/beta versions (Pharo < 70) require sources for the previous version of Pharo"
	previousVersion := self imageVersion asNumber - 10.
	"But the previous version for 61 is 50, not 51"
	self imageVersion = '61'
		ifTrue: [ previousVersion := 50 ].
	"Pharo 1.0 does not exists: 2.0 => 1.4 => 1.3 => 1.2 => 1.1"
	self imageVersion = '20'
		ifTrue: [ previousVersion := 14 ].
	previousVersion < 10
		ifTrue: [ previousVersion := previousVersion + 9 ]. "bad - 10, should have done -1"
	self fetchSourcesFilesFor: previousVersion asString! !
!PhLVirtualMachineManager methodsFor: 'private'!
fetchSourcesFilesFor: anImageVersionString
	| vmFolder |
	
	vmFolder := anImageVersionString asInteger < 30
		ifTrue: [ self vmStore / self vmId ]
		ifFalse: [ (self availableVirtualMachines at: self vmId) vmFolder ].
	self fetchSourcesFilesFor: anImageVersionString in: vmFolder
! !
!PhLVirtualMachineManager methodsFor: 'private'!
fetchSourcesFilesFor: anImageVersionString in: folder
	[ | sourcesZip |
	sourcesZip := folder / ('sourcesV' , anImageVersionString , '.zip').
	PhLDownloadManager default
		download: (self sourcesFileUrlFor: anImageVersionString)
		toFile: sourcesZip.
	self class
		unzip: sourcesZip
		to: folder ]
		on: KeyNotFound
		do: [ self error: 'No Sources file available for ' , anImageVersionString , ' image.' ]! !
!PhLVirtualMachineManager methodsFor: 'private'!
fetchVm
	[ self class 
		fetch: self vmUrl 
		to: self vmStore / (self vmId , '.zip') ]
	on: KeyNotFound
	do: [ self error: 'No Virtual Machine available for ' , self imageVersion , ' image.' ]! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageFile: anImagePathOrFileReference
	imageFile := anImagePathOrFileReference asFileLocatorOrReference! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageFormatNumber
	^ imageFormatNumber
		ifNil: [ imageFormatNumber := self class imageFormatNumberFromFile: imageFile ]! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageFormatNumber: anInteger 
	imageFormatNumber := anInteger! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageVersion
	"get the Pharo version of the image"

	^ imageVersion ifNil: 
		[ [ self imageVersionFromFile ]
			on: PhLImageVersionDeterminationError
			do: [ "no version file, generate it"
					[ self imageVersionFromFileWith: (self imageVersionCommandWithPreferences: false) ]
						on: PhLImageVersionDeterminationError, PhLProcessTimeOut
						do: [ "Command probably failed, try to run without --no-default-preferences option (only available since Pharo 3.0)"
								self imageVersionFromFileWith: (self imageVersionCommandWithPreferences: true) ] ] ]! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageVersion: aString 
	imageVersion := aString! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageVersionCommandWithPreferences: shouldUsePreferences
	| process |
	process := PhLProcessWrapper new.
	process workingDirectory: self compatibleVm executableFolderPath.
	Smalltalk os isUnix
			ifTrue: [ process 
							shellCommand;
							addArguments: 'export SQUEAK_PLUGINS="" && ';
							addArgument: self compatibleVm executablePath surroundedByDoubleQuotes. ]
			ifFalse: [ process command: self compatibleVm executablePath ].
	process 
		addArgument: (Smalltalk os isUnix
			ifTrue: [ '--nodisplay' ]
			ifFalse: [ '--headless' ]);
		addArgument: imageFile fullName surroundedByDoubleQuotes.
	shouldUsePreferences ifFalse: [ process addArgument: '--no-default-preferences' ].
	process addArgument: self imageVersionDeterminationScriptPath surroundedByDoubleQuotes.
	^ process! !
!PhLVirtualMachineManager methodsFor: 'private'!
imageVersionDeterminationScript
	| imageFolder |

	SystemVersion current major isNil "Pharo 1.1"
		ifTrue: [ SystemVersion current major: 1. 
					SystemVersion current minor: 1 ]. 

	(SystemVersion current major = 1 and: [ SystemVersion current minor < 4 ])
		ifTrue: [ imageFolder := (Smalltalk at: #FileDirectory) on: Smalltalk imagePath.
			imageFolder forceNewFileNamed: 'pharo.version' do: [ :stream |
				stream 
					<< SystemVersion current major;
					<< SystemVersion current minor ] ]
		ifFalse: [ imageFolder := Smalltalk imagePath asFileReference. 
			SystemVersion current major = 1
				ifFalse: [ imageFolder := imageFolder parent ].
			imageFolder / 'pharo.version' 
				writeStreamDo: [ :stream | |major minor|
					major := SystemVersion current major.
					minor := SystemVersion current minor.
					"Pharo 6 images >= 60509 need 61 VM, even though the image states 60"
					(major = 6 and: [ SystemVersion current highestUpdate >= 60509 ])
						ifTrue: [ minor := 1 ].
					stream 
						<< major asString;
						<< minor asString ] ].
	Smalltalk snapshot: false andQuit: true! !
!PhLVirtualMachineManager methodsFor: 'private'!
imageVersionDeterminationScriptFile
	^ self vmStore parent / 'pharo-version.st'! !
!PhLVirtualMachineManager methodsFor: 'private'!
imageVersionDeterminationScriptFileNeedsUpdate
	| file |
	file := self imageVersionDeterminationScriptFile.
	^ (file exists and: [ file contents = self imageVersionDeterminationScriptSourceCode ]) not! !
!PhLVirtualMachineManager methodsFor: 'private'!
imageVersionDeterminationScriptPath
	| file |
	file := self imageVersionDeterminationScriptFile.
	self imageVersionDeterminationScriptFileNeedsUpdate
		ifTrue: [ file 
						ensureDelete;
						writeStreamDo: [ :stream | stream << self imageVersionDeterminationScriptSourceCode ] ].
	^ file fullName! !
!PhLVirtualMachineManager methodsFor: 'private'!
imageVersionDeterminationScriptSourceCode
	^ (self class >> #imageVersionDeterminationScript) sourceCode
		allButFirst: #imageVersionDeterminationScript size	"remove method name"! !
!PhLVirtualMachineManager methodsFor: 'private'!
imageVersionFile
	^ imageFile parent / PhLImage versionFileName! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageVersionFromFile
	self imageVersionFile 
			readStreamDo: [ :stream | imageVersion := stream contents asInteger asString ]
			ifAbsent: [ PhLImageVersionDeterminationError signal: 
				('Cannot determine image version: image version file "{1}" not found!!' format: { self imageVersionFile pathString }) ].
	^ imageVersion! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
imageVersionFromFileWith: aPhLProcessWrapperCommand
	aPhLProcessWrapperCommand runAndWaitTimeOut: 10 seconds.
	self imageVersionFile 
			readStreamDo: [ :stream | imageVersion := stream contents asInteger asString ]
			ifAbsent: [ PhLImageVersionDeterminationError signalCommand: aPhLProcessWrapperCommand printString ].
	^ imageVersion! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
privateVmStore
	^ self class privateVmStore! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
sourcesFileUrlFor: anImageVersionString
	"$1: IMAGE_VERSION"
	^ 'https://files.pharo.org/get-files/{1}/sources.zip'
		format: {anImageVersionString}! !
!PhLVirtualMachineManager methodsFor: 'querying'!
virtualMachine
	^ self virtualMachines
		detect: [ :vm | vm id = self vmId ]
		ifNone: [ PhLVirtualMachine id: self vmId ]! !
!PhLVirtualMachineManager methodsFor: 'querying'!
virtualMachines
	| vmsInVmStore defaultVms |
	defaultVms := self defaultVirtualMachines.
	vmsInVmStore := self availableVirtualMachines values reject: [ :vm | defaultVms anySatisfy: [ :diskVM | diskVM id = vm id ] ].
	^ vmsInVmStore , defaultVms! !
!PhLVirtualMachineManager methodsFor: 'querying'!
vm
	| vm |
	UIManager default
		informUserDuring: [ :bar | 
			bar label: 'Determining Image version'.
			vm := self availableVirtualMachines 
				at: self vmId 
				ifAbsent: 
					[ bar 
						label: 'Fetching VM to run Pharo ', self imageVersion , ' images';
						current: 25.
					self fetchVm.
					vm := self availableVirtualMachines at: self vmId.
					bar 
						label: 'Fetching sources files for Pharo ', self imageVersion;
						current: 50.
					self fetchSourcesFiles.
					bar 
						label: 'Running the image';
						current: 100.
					vm ]. ].
	^ vm executablePath! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
vmId
	| architecture pharoVersion |
	self checkImageArchitecture.
	architecture := (self class is64bits: self imageFormatNumber)
		ifTrue: [ 'x64' ]
		ifFalse: [ 'x86' ].
	pharoVersion  := ((self class isPreSpur: self imageFormatNumber) and: [ self imageVersion = '50' ])
		ifTrue: [ '50-preSpur' ]
		ifFalse: [ self imageVersion ].
	^ pharoVersion , '-' , architecture.! !
!PhLVirtualMachineManager methodsFor: 'accessing'!
vmStore
	^ self class vmStore! !
!PhLVirtualMachineManager methodsFor: 'private'!
vmUrl
	| architecture pharoVersion |
	architecture := (self class is64bits: imageFormatNumber) ifTrue: [ '64' ] ifFalse: [ '' ].
	pharoVersion  := ((self class isPreSpur: imageFormatNumber) and: [ self imageVersion = '50' ])
		ifTrue: [ '50-preSpur' ]
		ifFalse: [ self imageVersion ].
	^ self vmUrlTemplate
		format: { pharoVersion . architecture . self downloadPathOSTypeSegment . '' . 'stable' }! !
!PhLVirtualMachineManager methodsFor: 'private'!
vmUrlTemplate
	"$1: IMAGE_VERSION (11 .. 70, 80)
	 $2: VM_ARCH (32 or 64)
	 $3: OS (win mac or linux)
	 $4: FLAVOUR? (-headless or empty)
	 $5: VM_STATUS (stable or latest)"
	^ 'https://files.pharo.org/get-files/{1}/pharo{2}-{3}{4}-{5}.zip'! !
!PhLVirtualMachinesDataSource class methodsFor: 'accessing'!
default 
	| vmsBlock privateVmsBlock |
	vmsBlock := [ PhLVirtualMachineManager new virtualMachines 
		asSortedCollection: [ :vm1 :vm2 | vm1 id > vm2 id ] ].
	privateVmsBlock := [ PhLVirtualMachineManager new availableVirtualMachinesByImageFormat 
		asSortedCollection: [ :vm1 :vm2 | vm1 id > vm2 id ] ].
	^ self vmsBlock: vmsBlock privateVmsBlock: privateVmsBlock ! !
!PhLVirtualMachinesDataSource class methodsFor: 'instance creation'!
vmsBlock: aBlock
	^ self new 
		vmsBlock: aBlock;
		yourself! !
!PhLVirtualMachinesDataSource class methodsFor: 'instance creation'!
vmsBlock: vmsBlock privateVmsBlock: privateVmsBlock
	^ (self vmsBlock: vmsBlock)
		privateVmsBlock: privateVmsBlock;
		yourself! !
!PhLVirtualMachinesDataSource methodsFor: 'querying'!
privateVirtualMachines 
	^ privateVmsBlock 
		ifNil: [ #() ]
		ifNotNil: [ privateVmsBlock value ]! !
!PhLVirtualMachinesDataSource methodsFor: 'accessing'!
privateVmsBlock: aBlock
	privateVmsBlock := aBlock! !
!PhLVirtualMachinesDataSource methodsFor: 'querying'!
virtualMachines 
	^ vmsBlock value! !
!PhLVirtualMachinesDataSource methodsFor: 'accessing'!
vmsBlock: aBlock
	vmsBlock := aBlock! !
!PharoLauncherModel class methodsFor: 'settings'!
deactivateDeployed
	IsDeployed := false! !
!PharoLauncherModel class methodsFor: 'settings'!
isDeployed
	^ IsDeployed ifNil: [ IsDeployed := false ]! !
!PharoLauncherModel class methodsFor: 'settings'!
makeDeployed
	IsDeployed := true! !
!PharoLauncherModel class methodsFor: 'instance creation'!
selection: aSelection imageRepository: imageRepository templateRepository: templateRepository
	^ self new
		setSelection: aSelection imageRepository: imageRepository templateRepository: templateRepository;
		yourself! !
!PharoLauncherModel methodsFor: 'private'!
ensure: aBoolean
	aBoolean
		ifFalse: [ PhLCommandError signal ]! !
!PharoLauncherModel methodsFor: 'testing selection'!
hasAtLeastOneImageSelected
	^ selection anySatisfy: #isImage! !
!PharoLauncherModel methodsFor: 'testing selection'!
hasAtLeastOneTemplateGroupSelected
	^ selection anySatisfy: #isTemplateGroup! !
!PharoLauncherModel methodsFor: 'testing'!
hasImageNamed: aString 
	^ imageRepository hasImageNamed: aString! !
!PharoLauncherModel methodsFor: 'testing selection'!
hasNoSelection
	^ selection size = 0! !
!PharoLauncherModel methodsFor: 'testing selection'!
hasSingleImageSelected
	^ (selection size = 1) and: [ selection anyOne isImage ]! !
!PharoLauncherModel methodsFor: 'testing selection'!
hasSingleLocalTemplateSelected
	^ (selection size = 1) and: [ selection anyOne isLocalTemplate ]! !
!PharoLauncherModel methodsFor: 'testing selection'!
hasSingleTemplateSelected
	^ (selection size = 1) and: [ selection anyOne isTemplate ]! !
!PharoLauncherModel methodsFor: 'testing'!
hasTemplateNamed: aString 
	^ templateRepository hasLocalTemplateNamed: aString! !
!PharoLauncherModel methodsFor: 'accessing'!
imageRepository
	^ imageRepository! !
!PharoLauncherModel methodsFor: 'announcements'!
imageRepositoryChanged
	self imageRepository contentsChanged! !
!PharoLauncherModel methodsFor: 'testing'!
isNewImageNameValid: aString 
	^ aString isEmptyOrNil not and: [ (self hasImageNamed: aString) not ]! !
!PharoLauncherModel methodsFor: 'testing'!
isNewLocalTemplateNameValid: aString 
	^ aString isEmptyOrNil not and: [ (self hasTemplateNamed: aString) not ]! !
!PharoLauncherModel methodsFor: 'action'!
makeUniqueImageName
	self shouldBeImplemented.! !
!PharoLauncherModel methodsFor: 'accessing'!
makeUniqueImageName: aString
	^ imageRepository makeUniqueImageName: aString! !
!PharoLauncherModel methodsFor: 'accessing'!
makeUniqueTemplateName: aString
	^ templateRepository makeUniqueTemplateName: aString! !
!PharoLauncherModel methodsFor: 'user interaction'!
newConfirmation
	^ PhLUIConfirmation new! !
!PharoLauncherModel methodsFor: 'user interaction'!
newInformation
	^ PhLUIInformation new! !
!PharoLauncherModel methodsFor: 'user interaction'!
newRequest
	^ PhLUIRequest new! !
!PharoLauncherModel methodsFor: 'user interaction'!
requestNewImageName: aString 
	^ self newRequest
		title: 'Image name?';
		initialAnswer: aString;
		validateAnswer: [ :answer | (self hasImageNamed: answer) not ];
		request! !
!PharoLauncherModel methodsFor: 'user interaction'!
requestNewTemplateName: aString 
	^ self newRequest
		title: 'Template name?';
		initialAnswer: (self makeUniqueTemplateName: aString);
		validateAnswer: [ :answer | 
			(self hasTemplateNamed: answer) 
				ifTrue: [ UIManager default confirm: 'Do you want to override exisiting template?' ]
				ifFalse: [ true ] ];
		request! !
!PharoLauncherModel methodsFor: 'selection'!
selectedImages
	^ selection select: #isImage! !
!PharoLauncherModel methodsFor: 'selection'!
selectedTemplateGroups
	^ selection select: #isTemplateGroup! !
!PharoLauncherModel methodsFor: 'selection'!
selectedTemplates
	^ selection select: #isTemplate! !
!PharoLauncherModel methodsFor: 'initialization'!
setSelection: aSelection imageRepository: anImageRepository templateRepository: aTemplateRepository
	selection := aSelection. 
	imageRepository := anImageRepository.
	templateRepository := aTemplateRepository.! !
!PharoLauncherModel methodsFor: 'selection'!
singleImage
	self
		ensure: self hasSingleImageSelected.
	^ selection anyOne! !
!PharoLauncherModel methodsFor: 'selection'!
singleImageName
	self
		ensure: self hasSingleImageSelected.
		
	^ selection pathNames anyOne! !
!PharoLauncherModel methodsFor: 'selection'!
singleTemplate
	self
		ensure: self hasSingleTemplateSelected.
	^ selection anyOne! !
!PharoLauncherModel methodsFor: 'selection'!
singleTemplateName
	"returns the project name and cuts out text between parentheses"
	self
		ensure: self hasSingleTemplateSelected.
	^ (selection pathes first second splitOn: '-(') first ! !
!PharoLauncherModel methodsFor: 'accessing'!
templateRepository
	^ templateRepository! !
!PharoLauncherModel methodsFor: 'announcements'!
templateRepositoryChanged
	self templateRepository contentsChanged! !
!PharoLauncherModel methodsFor: 'copying'!
withNewSelection: aSelection
	^ self copy
		setSelection: aSelection imageRepository: imageRepository templateRepository: templateRepository;
		yourself! !
!UnixResolver methodsFor: '*PharoLauncher-Core'!
launcherUserFilesLocation
	"Documents folder is not a standard on Unix. Put files in the $HOME directory"
	^ self home / 'Pharo'! !
!UnixResolver methodsFor: '*PharoLauncher-Core'!
vmExecutableName
	^ 'pharo'! !
!FileLocator class methodsFor: '*PharoLauncher-Core'!
launcherImagesLocation
	^ self origin: #launcherImagesLocation! !
!FileLocator class methodsFor: '*PharoLauncher-Core'!
launcherUserFilesLocation
	^ self origin: #launcherUserFilesLocation! !
!FileLocator class methodsFor: '*PharoLauncher-Core'!
launcherVMsLocation
	^ self origin: #launcherVMsLocation! !
!FileLocator class methodsFor: '*PharoLauncher-Core' prior: 25830562!
supportedOrigins
	| origins current |
	origins := IdentitySet new.
	current := Resolver.
	[current notNil] whileTrue:
		[origins addAll: current supportedOrigins.
		current := current next].
	^ origins
		remove: #vmDirectory ifAbsent: [  ];
		remove: #vmBinary ifAbsent: [  ];
		remove: #localDirectory ifAbsent: [  ];
		remove: #imageDirectory ifAbsent: [  ];
		yourself! !

"PharoLauncher-Core"!
!TPhLInteractionTrait commentStamp: '' prior: 0!
This behavior should be handled in Spec. Onde done, this trait could be removed.

This trait provides an abstraction to provide user interaction (confirm, inform, etc.)!
!PhLAbstractDateDisplayStrategy commentStamp: '' prior: 0!
Description
--------------------

I am an abstract class to manage the display of dates in the Pharo launcher UI. 

My subclasses should each implement a different format strategy.!
!PhLDateAndTimeDisplayStrategy commentStamp: '' prior: 0!
Description
--------------------

Display date with the date and time. 

Example:

2018-07-03 10:37:53!
!PhLTimeUntilNowStrategy commentStamp: '' prior: 0!
Description
--------------------

Display date by its delta with the current date.

Example:

1 year ago
2 weeks ago
3 days ago!
!PhLAppearanceSettings commentStamp: '' prior: 0!
I provide Appearance seetings
for the PhLSettingsBrowser (pragma pharoLauncherSettings).!
!PhLDeploymentScript commentStamp: '' prior: 0!
I'm responsible for preparing the image to be a Pharo Launcher image. Namely, I make sure that

- one Pharo Launcher window is open and centered
- this window can't be closed easily
- the user-defined startup scripts are not executed!
!PhLNullImage commentStamp: '' prior: 0!
Null pattern for a PhLImage.
Used to display information when no image is selected.!
!PhLNullLaunchConfiguration commentStamp: '' prior: 0!
Null pattern for a PhLLaunchConfiguration.
Used to display information when no launch configuration is selected.!
!PharoLauncherApplication commentStamp: '' prior: 0!
Application that allows users to choose a template from a set of templates (potentially on the web). From a template, the user can create a Pharo image and launch it. This application also list the existing images.

PharoLauncherApplication open!
!YesNoDialogWithTickBoxWindow commentStamp: '' prior: 0!
Yes - No Dialog window with a tick box used to disable warnings by example.

self confirm: 'Is this widget fine?' label: 'Title'!
!PhLImageCreationPresenter commentStamp: '' prior: 0!
I'm the view displayed to create an image from a template.

Implementation points:

To give feedback to the user, we display an icon helping the user to know if he already has an image of the same name or not.
At each keystroke in the image title field we check if we already have an image with this name. If we have, we display a red cross to the user.!
!PhLImageDetailPresenter commentStamp: '' prior: 0!
Presenter of a Pharo image detail : description, template, VM, etc.

I'm part of the main Pharo Launcher window.

To open me:
(self on: PhLImage example) openWithSpec!
!PhLImagesPresenter commentStamp: '' prior: 0!
Pharo Launcher main window presenting the list of managed images as well as a toolbar and a status bar.

To open me:
	(self on: PhLDirectoryBasedImageRepository default) openWithSpec!
!PhLScriptPresenter commentStamp: '' prior: 0!
I present a list of scripts and allow to edit, remove or add a new script.!
!PhLTemplatesPresenter commentStamp: '' prior: 0!
Pharo Launcher templates window presenting the list of available templates.
Templates are used to create images.

To open me:
	self example!
!PhLVMPresenter commentStamp: '' prior: 0!
A simple UI to show locally available Virtual Machines to launch Pharo images.!
!PhLAboutPresenter commentStamp: '' prior: 0!
Pharo Launcher About dialog UI.

Example: 
	self example!
!PhLLaunchConfigurationPresenter commentStamp: '' prior: 0!
Window used to present the list of launch configurations of an image.
You can edit it, add a new one or remove a configuration.

To open me:
	self example!
!PhlRetryPresenter commentStamp: '' prior: 0!
A simple presenter to allow to retry or cancel an action. You can provide an explanation text.!
!TPhLInteractionTrait methodsFor: 'user interaction'!
newConfirmation
	^ PhLUIConfirmation new! !
!TPhLInteractionTrait methodsFor: 'user interaction'!
newFileRequest
	^ PhLUIFileRequest new! !
!TPhLInteractionTrait methodsFor: 'user interaction'!
newInformation
	^ PhLUIInformation new! !
!TPhLInteractionTrait methodsFor: 'user interaction'!
newRequest
	^ PhLUIRequest new! !
!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!
allStrategies
	^ self allSubclasses reject: #isAbstract! !
!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!
allStrategiesWithNames
	^ self allStrategies collect: [ :each | each label -> each ]! !
!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!
displayStringOf: aDateAndTime
	"Takes as parameter a DateAndTime and return a Text describing this date and time to the user."
	
	^ self subclassResponsibility! !
!PhLAbstractDateDisplayStrategy class methodsFor: 'testing'!
isAbstract
	^ self = PhLAbstractDateDisplayStrategy! !
!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!
label
	^ self subclassResponsibility! !
!PhLDateAndTimeDisplayStrategy class methodsFor: 'accessing'!
displayStringOf: aDateAndTime
	^ (String
		streamContents: [ :s | 
			s
				nextPutAll: aDateAndTime asDate yyyymmdd;
				space.
			aDateAndTime asTime print24: true on: s ]) asText! !
!PhLDateAndTimeDisplayStrategy class methodsFor: 'accessing'!
label
	^ 'Date and time'! !
!PhLTimeUntilNowStrategy class methodsFor: 'accessing'!
displayStringOf: aDateAndTime
	^ (DateAndTime now - aDateAndTime) simpleTimeAgo asText! !
!PhLTimeUntilNowStrategy class methodsFor: 'accessing'!
label
	^ 'Time since now'! !
!PhLAppearanceSettings class methodsFor: 'settings'!
appearanceSettingsOn: aBuilder 
	<pharoLauncherSettings>
	(aBuilder group: #appearance)
		label: 'Appearance' ;  
		description: 'All settings concerned with the look''n feel of your system';
		target: PolymorphSystemSettings;
		with: [
			(aBuilder pickOne: #uiThemeClass)
				label: 'User interface theme';
				target: self;
				default: UITheme standardThemeClass;
				order: 1;
				domainValues: PolymorphSystemSettings uiThemeClassChoices. ]! !
!PhLAppearanceSettings class methodsFor: 'settings'!
standardFontsSettingsOn: aBuilder
	<pharoLauncherSettings>
	(aBuilder group: #standardFonts)
		label: 'Standard fonts';
		target: StandardFonts;
		dialog: [GraphicFontSettings fontSizeRow];
		parent: #appearance;
		order: 4.! !
!PhLAppearanceSettings class methodsFor: 'morphic'!
uiThemeClass
	^ PolymorphSystemSettings uiThemeClass! !
!PhLAppearanceSettings class methodsFor: 'morphic'!
uiThemeClass: aUIThemeClass
	PolymorphSystemSettings uiThemeClass: aUIThemeClass.
	"force UI re-creation to adopt new theme. Spec is not yet ready to react to theme changes."
	PharoLauncherApplication 
		reset;
		openFull.! !
!PhLDeploymentScript class methodsFor: 'actions'!
activateDeprecationWarnings
	Deprecation raiseWarning: true! !
!PhLDeploymentScript class methodsFor: 'actions'!
activateErrorCatching
	DefaultDebugger := Smalltalk tools debugger.
	Smalltalk tools debuggerTool: PhLErrorDialogPresenter.! !
!PhLDeploymentScript class methodsFor: 'actions'!
activateLostChangesDetector
	EpLostChangesDetector initialize! !
!PhLDeploymentScript class methodsFor: 'actions'!
activateStartupActions
	StartupPreferencesLoader allowStartupScript: true.! !
!PhLDeploymentScript class methodsFor: 'actions'!
addToStartupList
	PhLStartupManager addToLauncherStartUpList: self! !
!PhLDeploymentScript class methodsFor: 'actions'!
askForConfirmationWhenQuitting
	self flag: 'TODO'.
	"Since UserManager is now over, there is no clean way to avoid warning when we juast ask to quit the image. More general, there should be a way to have an image in read/only mode"
	Save := true! !
!PhLDeploymentScript class methodsFor: 'actions'!
closeAllWindows
	"We make sure we always close without asking for confirmation. It looks like #closeAllWindowsDiscardingChanges doesn't work as a startup action."
	[ World closeAllWindowsDiscardingChanges ]
		on: ProvideAnswerNotification
		do: [ :err | err return: false ].
	PharoLauncherApplication default closeAllWindows.! !
!PhLDeploymentScript class methodsFor: 'actions'!
closeWindowsAndOpenDevelopmentEnvironment
	PanelMorph allInstancesDo: [  :pm | pm delete ].
	self closeAllWindows.
	TaskbarMorph reset.
	Smalltalk tools workspace openContents: 'PharoLauncherApplication open.'.

	"PanelMorph comes from use of #openWorldWithSpec"! !
!PhLDeploymentScript class methodsFor: 'actions'!
closeWindowsAndOpenLauncher
	self 
		closeAllWindows;
		openLauncher! !
!PhLDeploymentScript class methodsFor: 'actions'!
deactivateDeprecationWarnings
	Deprecation raiseWarning: false! !
!PhLDeploymentScript class methodsFor: 'actions'!
deactivateErrorCatching
	Smalltalk tools debuggerTool: DefaultDebugger! !
!PhLDeploymentScript class methodsFor: 'actions'!
deactivateLostChangesDetector
	SessionManager default unregisterClassNamed: #EpLostChangesDetector! !
!PhLDeploymentScript class methodsFor: 'actions'!
deactivateStartupActions
	StartupPreferencesLoader allowStartupScript: false.! !
!PhLDeploymentScript class methodsFor: 'settings'!
developmentEnvironmentEnabled
	^ self isDeployed not! !
!PhLDeploymentScript class methodsFor: 'settings'!
developmentEnvironmentEnabled: aBoolean
	aBoolean 
		ifTrue: 
		[	self undoAll.  	
			self closeWindowsAndOpenDevelopmentEnvironment 
		]
		ifFalse: 
		[ 	self doAll. 
			self closeWindowsAndOpenLauncher.
			self isDeployed ifFalse: [ Smalltalk snapshot: true andQuit: false "save deployed mode" ]
		].! !
!PhLDeploymentScript class methodsFor: 'public'!
doAll
	self
		closeAllWindows;
		removeAllMorphs;
		setTheme;
		deactivateStartupActions;
		dontRaiseWarningForMissingChangesOrSourcesFiles;
		deactivateDeprecationWarnings;
		deactivateLostChangesDetector;
		activateErrorCatching;
		makeDeployed;
		addToStartupList;
		dontAskForConfirmationWhenQuitting;
		setProgressBarSizeAndPosition! !
!PhLDeploymentScript class methodsFor: 'actions'!
doRaiseWarningForMissingChangesOrSourcesFiles
	PharoFilesOpener default setInformAboutReadOnlyChanges.! !
!PhLDeploymentScript class methodsFor: 'actions'!
dontAskForConfirmationWhenQuitting
	self flag: 'TODO'.
	"Since UserManager is now over, there is no clean way to avoid warning when we juast ask to quit the image. More general, there should be a way to have an image in read/only mode"
	Save := false! !
!PhLDeploymentScript class methodsFor: 'actions'!
dontRaiseWarningForMissingChangesOrSourcesFiles
	PharoFilesOpener default unsetInformAboutReadOnlyChanges.! !
!PhLDeploymentScript class methodsFor: 'initialization'!
initialize
	Save := false! !
!PhLDeploymentScript class methodsFor: 'public'!
initializeLibgit
	LGitLibrary uniqueInstance initializeLibGit2! !
!PhLDeploymentScript class methodsFor: 'settings'!
isDeployed
	^ PharoLauncherApplication isDeployed! !
!PhLDeploymentScript class methodsFor: 'system startup'!
launcherStartUp
	self isDeployed
		ifTrue: [ self closeWindowsAndOpenLauncher ]! !
!PhLDeploymentScript class methodsFor: 'system startup'!
launcherStartUpPriority
	^ 300! !
!PhLDeploymentScript class methodsFor: 'settings'!
makeDeployed
	PharoLauncherApplication beDeployed! !
!PhLDeploymentScript class methodsFor: 'settings'!
makeUndeployed
	PharoLauncherApplication beUndeployed! !
!PhLDeploymentScript class methodsFor: 'actions'!
openLauncher
	PharoLauncherApplication openFull! !
!PhLDeploymentScript class methodsFor: 'actions'!
quitSession
	self flag: 'TODO'.
	"Since UserManager is now over, there is no clean way to avoid warning when we juast ask to quit the image. More general, there should be a way to have an image in read/only mode"
	Save 
		ifTrue: [Smalltalk snapshot: true andQuit: true] 
		ifFalse: [Smalltalk snapshot: false andQuit: true]
 ! !
!PhLDeploymentScript class methodsFor: 'actions'!
removeAllMorphs 
	" Don't keep unnecessary stuff.
	  Also there is a bug popping with FT2 when trying to send #changed to the MenuBar. Removing morphs will workaround this problem"
	World removeAllMorphs! !
!PhLDeploymentScript class methodsFor: 'actions'!
removeFromStartupList
	[ PhLStartupManager removeFromStartupList: self ]
		on: NotFound 
		do: [ :e | "Not there, just ignore!!" ]! !
!PhLDeploymentScript class methodsFor: 'actions'!
resetPharoLauncherIcebergRepositoryLocation
	| phLCorePackage |
	phLCorePackage := RPackageOrganizer default packageNamed: 'PharoLauncher-Core'.
	(IceRepository registeredRepositoryIncludingPackage: phLCorePackage)
		name: 'pharo-launcher';
		location: nil! !
!PhLDeploymentScript class methodsFor: 'actions'!
setProgressBarSizeAndPosition
	"increase size and reposition progress bar to the middle of screen to make it more visible"
	SystemProgressMorph uniqueInstance
		minWidth: 600;
		minHeight: 50;
		layoutInset: 30 @ 20;
		position: 150 @ 200	! !
!PhLDeploymentScript class methodsFor: 'actions'!
setTheme
	PharoLightTheme beCurrent.
! !
!PhLDeploymentScript class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder setting: #developmentEnvironmentEnabled) 
		parent: #pharoLauncher;
		target: self;
		order: 60;
		label: 'Enable development environment' translated;
		description: 'Missing a feature?  Hey come join in!!  Add your custom feature.
When enabled, exits the Launcher application into the Pharo development environment.
When disabled, closes all windows and locks Launcher as the only running application. ' translated.! !
!PhLDeploymentScript class methodsFor: 'public'!
undoAll
	self
		activateStartupActions;
		doRaiseWarningForMissingChangesOrSourcesFiles;
		activateDeprecationWarnings;
		activateLostChangesDetector;
		deactivateErrorCatching;
		makeUndeployed;
		removeFromStartupList;
		askForConfirmationWhenQuitting;
		initializeLibgit! !
!PhLNullImage methodsFor: 'accessing'!
architecture
	
	^ ''! !
!PhLNullImage methodsFor: 'accessing'!
description
	
	^ '<no description given>'! !
!PhLNullImage methodsFor: 'accessing'!
initializationScript
	^ nil! !
!PhLNullImage methodsFor: 'accessing'!
lastModification
	
	^ 'N/A'! !
!PhLNullImage methodsFor: 'accessing'!
location

	^ ''! !
!PhLNullImage methodsFor: 'accessing'!
name
	^ 'No image selected'! !
!PhLNullImage methodsFor: 'accessing'!
originTemplateName
	
	^ ''! !
!PhLNullImage methodsFor: 'accessing'!
originTemplateUrl
	
	^ ''! !
!PhLNullImage methodsFor: 'accessing'!
shouldRunInitializationScript
	^ false! !
!PhLNullLaunchConfiguration methodsFor: 'accessing'!
imageArguments 
	^ #()! !
!PhLNullLaunchConfiguration methodsFor: 'testing'!
isNullConfiguration
	^ true! !
!PhLNullLaunchConfiguration methodsFor: 'accessing'!
name
	^ ''! !
!PhLNullLaunchConfiguration methodsFor: 'accessing'!
vm
	^ nil! !
!PhLNullLaunchConfiguration methodsFor: 'accessing'!
vmArguments 
	^ #()! !
!PharoLauncherApplication class methodsFor: 'testing'!
beDeployed
	IsDeployed := true! !
!PharoLauncherApplication class methodsFor: 'testing'!
beUndeployed
	IsDeployed := false! !
!PharoLauncherApplication class methodsFor: 'accessing'!
default
	^ Default ifNil: [ Default := self new ]! !
!PharoLauncherApplication class methodsFor: 'settings'!
defaultInitializationScriptLocation
	^ FileLocator launcherUserFilesLocation / 'scripts' ! !
!PharoLauncherApplication class methodsFor: 'settings'!
hardResetPersistanceState
	^false! !
!PharoLauncherApplication class methodsFor: 'settings'!
hardResetPersistanceState: isClickedFromSettings 
	|packages|
	
	isClickedFromSettings ifFalse: [ ^ self ]. "Important: this code should not be run when loading stored preferences, else PharoLauncher deployment mode is set to not deployed!!"
	
	SystemWindow allSubInstances do:[ :window | window delete].
	self inform: 'PharoLauncher state reset'.
	World doOneCycle.
	500 milliSeconds wait. "To help user perception that *something* was reset"
		
	packages := RPackageOrganizer default packages select:[ :package | 
		(package name includesSubstring: 'PharoLauncher') ].
	packages do: 
		[ :package | 
		package definedClasses 
			reject: [ :class | class = PhLStartupManager ] "Do not reset this class, else Pharo settings will not be loaded at startup and repository location couldbe wrong!!"
			thenDo: [ :class | class classPool keys do: [ :key | class classPool at: key put: nil ] ] ].

	self openFull.! !
!PharoLauncherApplication class methodsFor: 'accessing'!
initializationScriptsDirectory
	^ self default scriptsDirectory! !
!PharoLauncherApplication class methodsFor: 'accessing'!
initializationScriptsDirectory: aFileUrl
	| directory |
	directory := aFileUrl asFileReference.
	self default scriptsDirectory: directory.
	^ directory ensureCreateDirectory
	! !
!PharoLauncherApplication class methodsFor: 'settings'!
initializationScriptsLocation
	" Used to display a nice file url in settings browser"
	^ self initializationScriptsDirectory pathString 
	! !
!PharoLauncherApplication class methodsFor: 'settings'!
initializationScriptsLocation: aFileUrl
	" Used to display a nice file url in settings browser"
	^ self initializationScriptsDirectory: aFileUrl! !
!PharoLauncherApplication class methodsFor: 'testing'!
isDeployed
	^ IsDeployed ifNil: [ IsDeployed := false ]! !
!PharoLauncherApplication class methodsFor: 'world menu'!
menuCommandOn: aBuilder 
	<worldMenu> 

	(aBuilder item: #'Pharo Launcher')
		icon: self pharoIcon16x16;
		parent: #Tools;
		order: 110;
		action: [ self open ];
		withSeparatorAfter! !
!PharoLauncherApplication class methodsFor: 'opening'!
open
	<script>
	^ self default
		openAsWorld: false;
		run! !
!PharoLauncherApplication class methodsFor: 'opening'!
openFull 
	<script>
	^ self default 
		beOpenedAsWorld;
		run! !
!PharoLauncherApplication class methodsFor: 'world menu'!
pharoIcon16x16

	^ pharoIcon 
		ifNil: [ pharoIcon := (self iconNamed: #pharo) scaledToSize: 16@16 ].
! !
!PharoLauncherApplication class methodsFor: 'opening'!
reset
	<script>
	^ Default := nil! !
!PharoLauncherApplication class methodsFor: 'initialization'!
resetTemplateRepository
	TemplateRepository := nil! !
!PharoLauncherApplication class methodsFor: 'settings'!
settingsOn: aBuilder
	<systemsettings>
	<pharoLauncherSettings>
	(aBuilder group: #pharoLauncher)
		label: 'Pharo Launcher' translated;
		description: 'General application settings' translated;
		with: [ 
					(aBuilder setting: #templatesClearedOnStartup)
						label: 'Templates cleared at startup' translated;
						order: 20;
						target: self;
						description:
								'When enabled, Launcher startup clears the Templates List. ' , String cr
										, 'When disabled, Launcher startup retains the Templates List from last run.' translated.
		
					(aBuilder setting: #initializationScriptsLocation)
						label: 'Location of your image initialization scripts' translated;
						type: #Directory;
						parent: #pharoLauncher;
						target: self;
						order: 40;
						description: 'A directory where all your Pharo images initialization scripts will be saved (executed once at image creation)'.
		
					(aBuilder setting: #hardResetPersistanceState)
						label: 'Hard reset persistent state' translated;
						target: self;
						order: 70;
						description:
								'When PharoLauncher is updated through Monticello ' , 
								'sometimes you need to clear persistent state to pick up new changes.' , String cr, 
								'Clicking this box is a one-shot action, i.e. this state is also reset.', String cr, 
								'Note, all open windows are clsoed and the application restarted.'
								translated 
		
		]! !
!PharoLauncherApplication class methodsFor: 'accessing'!
templatesClearedOnStartup
	^ TemplatesClearedOnStartup ifNil: [ TemplatesClearedOnStartup := false ].! !
!PharoLauncherApplication class methodsFor: 'settings'!
templatesClearedOnStartup: aBoolean 
	TemplatesClearedOnStartup := aBoolean! !
!PharoLauncherApplication methodsFor: 'configuring'!
beOpenedAsWorld
	self openAsWorld: true! !
!PharoLauncherApplication methodsFor: 'accessing'!
imageRepository
	^ imageRepository! !
!PharoLauncherApplication methodsFor: 'accessing'!
imageRepository: aPhlImageRepository
	imageRepository := aPhlImageRepository! !
!PharoLauncherApplication methodsFor: 'announcements'!
imageRepositoryChanged
	imagesPresenter ifNotNil: #refresh! !
!PharoLauncherApplication methodsFor: 'announcements'!
imageRepositoryChanged: newImage
	self imageRepositoryChanged.
	imagesPresenter ifNotNil: [ imagesPresenter selectImage: newImage ].! !
!PharoLauncherApplication methodsFor: 'initialization'!
initialize 
 	super initialize.
	openAsWorld := false.
	imageRepository :=  PhLDirectoryBasedImageRepository default.
	self templatesClearedOnStartup 
		ifTrue: [ self class resetTemplateRepository ].
	self resetTemplateRepository! !
!PharoLauncherApplication methodsFor: 'private'!
initializeImagesPresenter
	^ imagesPresenter := PhLImagesPresenter
		newApplication: self
		model: imageRepository! !
!PharoLauncherApplication methodsFor: 'events'!
launchConfigurationEdited: aLaunchConfiguration
	"set the last edited launch configuration in the toolbar "

	imagesPresenter refreshLaunchConfigurationList.
	aLaunchConfiguration isNullConfiguration 
		ifFalse: [ imagesPresenter selectConfiguration: aLaunchConfiguration ].! !
!PharoLauncherApplication methodsFor: 'configuring'!
openAsWorld: aBoolean
	openAsWorld := aBoolean! !
!PharoLauncherApplication methodsFor: 'initialization'!
resetTemplateRepository
	templateRepository := TemplateRepository 
		ifNil: [ TemplateRepository := PhLTemplateGroupRepository default ] ! !
!PharoLauncherApplication methodsFor: 'running'!
run
	| presenterClass |
	self initializeImagesPresenter.
	presenterClass := openAsWorld
		ifTrue: [ SpWorldPresenter ]
		ifFalse: [ imagesPresenter defaultWindowPresenterClass ].
	self
		open: imagesPresenter
		withSpecLayout: imagesPresenter defaultSpec
		using: presenterClass! !
!PharoLauncherApplication methodsFor: 'accessing'!
scriptsDirectory
	^ (scriptsDirectory ifNil: [ 
		   self class initializationScriptsDirectory: self class defaultInitializationScriptLocation ])
		  ensureCreateDirectory! !
!PharoLauncherApplication methodsFor: 'accessing'!
scriptsDirectory: aFileReference
	scriptsDirectory := aFileReference! !
!PharoLauncherApplication methodsFor: 'accessing'!
templateRepository
	^ templateRepository! !
!PharoLauncherApplication methodsFor: 'accessing'!
templateRepository: aPhLTemplateGroupRepository
	templateRepository := aPhLTemplateGroupRepository! !
!PharoLauncherApplication methodsFor: 'accessing'!
templatesClearedOnStartup
	^ self class templatesClearedOnStartup! !
!YesNoDialogWithTickBoxWindow class methodsFor: 'ui requests'!
confirm: description label: title
	^ (UIManager default modalMorph openModal: (
		(self newWithTheme: Smalltalk ui theme)
			textFont: Smalltalk ui theme textFont;
			title: title;
			text: description)) answer! !
!YesNoDialogWithTickBoxWindow methodsFor: 'accessing'!
checkBoxBallonText
	^ PhLLaunchImageCommand archMismatchSettingDescription! !
!YesNoDialogWithTickBoxWindow methodsFor: 'accessing'!
checkBoxLabel
	^ PhLLaunchImageCommand archMismatchSettingLabel! !
!YesNoDialogWithTickBoxWindow methodsFor: 'accessing'!
checkBoxSelector
	^ #warnOnArchMismatch! !
!YesNoDialogWithTickBoxWindow methodsFor: 'accessing'!
checkBoxSetterSelector
	^ #warnOnArchMismatch:! !
!YesNoDialogWithTickBoxWindow methodsFor: 'instance creation'!
newMainPanel
	| panel |
	panel := super  newMainPanel.
	self newTickBoxRow ifNotNil: [:m | panel addMorphBack: m ].
	^ panel! !
!YesNoDialogWithTickBoxWindow methodsFor: 'instance creation'!
newTickBoxRow
	"Answer a new tick box row."

	| row checkBox |
	checkBox := CheckboxMorph
		on: PhLLaunchImageCommand
		selected: self checkBoxSelector
		changeSelected: self checkBoxSetterSelector.
	checkBox
		label: self checkBoxLabel;
		vResizing: #shrinkWrap;
		hResizing: #shrinkWrap;
		setBalloonText: self checkBoxBallonText.
	row := Morph new
		color: Color transparent;
		changeTableLayout;
		cellInset: 8;
		listDirection: #rightToLeft;
		listCentering: #bottomRight;
		hResizing: #spaceFill;
		vResizing: #shrinkWrap.
	row addMorphBack: checkBox.
	^ row! !
!SpToolBarPresenter methodsFor: '*PharoLauncher-Spec2'!
addItemLeft: aToolbarItem afterIndex: anIndex
	
	aToolbarItem owner: self.
	leftItems add: aToolbarItem afterIndex: anIndex.
	self notifyPropertyChanged: #leftItems.! !
!PhLImageCreationPresenter class methodsFor: 'specs'!
defaultSpec
	^ SpBoxLayout newVertical
		spacing: 5;
		add: 'Image name:' expand: false;
		add: (SpBoxLayout newHorizontal 
			add: #imageName;
			add: #imageNameCheck expand: false;
			yourself)
			expand: false;
		add: 'Image description:' expand: false;
		add: #descriptionText height: 60;
		add: 'Initialization script:' expand: false;
		add: (SpBoxLayout newHorizontal 
			add: #initScript;
			add: #editInitScriptButton expand: false;
			yourself)
			expand: false;
		add: #initScriptText height: 100;
		add: #createButton expand: false;
		yourself! !
!PhLImageCreationPresenter class methodsFor: 'example'!
example
	(self 
		newApplication: PharoLauncherApplication new
		model: {PhLRemoteTemplate example}) openWithSpec! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
checkNewName: name
	"If the image name is taken we display a red cross. Else we display a validation sign. 
	I am called to validate the image displayed is in the right state. If not, I update it. 
	I use a variable to know the state during the last validation."

	| isValid |
	isValid := name isEmpty or: [ reservedImagesNamesCache ifNotNil: [ reservedImagesNamesCache includes: name asLowercase ] ].

	"Image already in the right state. We skip."
	isNameOk = isValid ifTrue: [ ^ self ].

	(isNameOk := isValid) ifTrue: [ self showNameError ] ifFalse: [ self showNameOk ]! !
!PhLImageCreationPresenter methodsFor: 'closing'!
close 
	self window ifNotNil: [ :window | window close ]! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
connectPresenters
	imageName whenTextChangedDo: [ :name | self checkNewName: name ]! !
!PhLImageCreationPresenter methodsFor: 'accessing'!
description
	^ descriptionText text asString! !
!PhLImageCreationPresenter methodsFor: 'configuring'!
disable
	createButton disable.	
	imageName text: ''! !
!PhLImageCreationPresenter methodsFor: 'configuring'!
enable
	createButton enable.! !
!PhLImageCreationPresenter methodsFor: 'accessing'!
imageName
	^ imageName text! !
!PhLImageCreationPresenter methodsFor: 'accessing'!
initializationScript
	^ initScript selectedItem! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
initializationScriptItems
	^ self initializationScripts copyWithFirst: self noInitializationScriptItem! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
initializationScripts
	^ self application scriptsDirectory files 
		select: [ :file | file extension = 'st' ]! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
initialize
	super initialize.
	reservedImagesNamesCache := self application imageRepository imageNames collect: #asLowercase! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
initializePresenters
	imageName := self newTextInput.
	imageNameCheck := self newImage.
	initScriptText := self newText
								disable;
								yourself.
	initScript := self newDropList
		              items: self initializationScriptItems;
		              display: [ :file | file basename ];
		              whenSelectionChangedDo: [ :selection |
								selection selectedItem ifNotNil: [ :item |
									initScriptText text: item model contents ] ];
		              yourself.
	descriptionText := self newText.
	editInitScriptButton := self newButton
		                        addStyle: 'small';
		                        action: [ self openScriptPresenter ];
		                        icon: (self iconNamed: #edit);
		                        yourself.
	(PhLCreateImageFromTemplateCommand forSpecContext: owner) 
		in: [ 	:createImageCommand | 
		createButton := createImageCommand asButtonPresenter.
		createButton action: [ 
			[ createImageCommand execute.
			self close. ]
				on: PhLNameNotAvailableError 
				do: [ PhLUIInformation new 
						message: 'An image with the same name already exists!! Please choose a new one.';
						alert ] ] ]! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
modelChanged 
	self template ifNil: [ ^ self ].
	self template isTemplate
		ifTrue: [ self enable.
			imageName text: self template suggestedImageName ]
		ifFalse: [ self disable ]! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
noInitializationScriptItem
	^ (FileSystem memory root / 'No initialization script') ensureCreateFile! !
!PhLImageCreationPresenter methodsFor: 'action'!
openScriptPresenter
	^ (PhLScriptPresenter 
		newApplication: self application 
		model: self application scriptsDirectory )
		whenScriptListChanged: [ self refreshInitializationScriptList ];
		openWithSpec;
		yourself! !
!PhLImageCreationPresenter methodsFor: 'refreshing'!
refreshInitializationScriptList
	initScript items: self initializationScriptItems.! !
!PhLImageCreationPresenter methodsFor: 'private'!
showNameError
	imageNameCheck 
		image: (self iconNamed: #smallError);
		help: 'An image with the same name already exists!!'! !
!PhLImageCreationPresenter methodsFor: 'private'!
showNameOk
	imageNameCheck 
		image: (self iconNamed: #smallOk);
		help: 'Image name is valid!!'! !
!PhLImageCreationPresenter methodsFor: 'initialization'!
template
	"Multiple selection is allowed in templates pane => we get a list of templates"
	
	^ self model isEmptyOrNil 
		ifTrue: [ nil ]
		ifFalse: [ self model first ]! !
!PhLImageDetailPresenter class methodsFor: 'specs'!
defaultSpec
	^ SpBoxLayout newVertical
		add: #imageLabel
			withConstraints: [ :constraints | constraints height: self labelHeight * 1.5 ];
		add:
			(SpBoxLayout newHorizontal
				add: 'description:' withConstraints: self labelConstraintsBlock;
				add: #description;
				yourself);
		add:
			(SpBoxLayout newHorizontal
				add: 'Origin template:' withConstraints: self labelConstraintsBlock;
				add: #template;
				yourself)
			height: self labelHeight;
		add:
			(SpBoxLayout newHorizontal
				add: '' withConstraints: self labelConstraintsBlock;
				add: #templateUrl;
				yourself)
			height: self labelHeight;
		add:
			(SpBoxLayout newHorizontal
				add: 'Initialization script:' withConstraints: self labelConstraintsBlock;
				add: #initializationScript expand: false;
				add: #shouldRunInitializationScript expand: false;
				yourself)
			height: self labelHeight;
		add:
			(SpBoxLayout newHorizontal
				add: 'Location:' withConstraints: self labelConstraintsBlock;
				add: #location;
				yourself)
			height: self labelHeight;
		yourself! !
!PhLImageDetailPresenter class methodsFor: 'specs'!
labelConstraintsBlock
	^ [ :constraints | 
	constraints
		height: self labelHeight;
		width: self labelWidth ]! !
!PhLImageDetailPresenter class methodsFor: 'labelled-presenters'!
labelWidth
	^ 110! !
!PhLImageDetailPresenter methodsFor: 'initialization'!
connectPresenters
	description
		whenTextChangedDo: [ :text | PhLImageDescriptionUpdater image: self image description: text ].
	shouldRunInitializationScript 
		whenChangedDo: [ :state | self image shouldRunInitializationScript: state ].! !
!PhLImageDetailPresenter methodsFor: 'accessing'!
description
	^ description! !
!PhLImageDetailPresenter methodsFor: 'accessing'!
image 
	^ self model! !
!PhLImageDetailPresenter methodsFor: 'accessing'!
imageLabel
	^ imageLabel! !
!PhLImageDetailPresenter methodsFor: 'initialization'!
initializePresenters
	imageLabel := self newLabel.
	description := self newText.
	template := self newLabel.
	templateUrl := self newLabel.
	initializationScript := self newLabel.
	shouldRunInitializationScript := self newCheckBox
		help: 'Run the initialization script at next launch?';
		disable.
	location := self newLabel.
	vm := self newTextInput.! !
!PhLImageDetailPresenter methodsFor: 'accessing'!
location
	^ location! !
!PhLImageDetailPresenter methodsFor: 'updating'!
modelChanged 
	| image |
	image := self image ifNil: [ PhLNullImage new ].
	
	imageLabel label: image name asText allBold, ' image, last edited ', image lastModification asString.
	description text: image description.
	template label: image originTemplateName.
	templateUrl label: image originTemplateUrl.
	image initializationScript 
		ifNil: [ initializationScript label: '<none>'.
			shouldRunInitializationScript disable. ] 
		ifNotNil: [:script | 
			initializationScript label: script basename.
			shouldRunInitializationScript 
				enable;
				state: image shouldRunInitializationScript. ].
	location label: image location.
	vm text: 'N/A'"self image vm".! !
!PhLImageDetailPresenter methodsFor: 'accessing'!
template
	^ template! !
!PhLImageDetailPresenter methodsFor: 'accessing'!
templateUrl
	^ templateUrl! !
!PhLImageDetailPresenter methodsFor: 'accessing'!
vm
	^ vm! !
!PhLImagesPresenter class methodsFor: 'commands'!
buildCommandsGroupWith: anImagesPresenter forRoot: rootCommandGroup
	rootCommandGroup
		register: (self buildToolbarGroup);
		register: (self buildContextualMenuGroup)! !
!PhLImagesPresenter class methodsFor: 'commands'!
buildContextualMenuGroup
	^ (CmCommandGroup named: 'Context Menu') asSpecGroup
		description: 'Images table contextual menu';
		register: ((CmCommandGroup named: 'launch') asSpecGroup
			register: PhLLaunchImageCommand forSpec;
			register: (PhLLaunchImageCommand new asSpecLaunchWithoutSettingsCommand
						name: 'Launch without settings';
						yourself);
			beDisplayedAsGroup;
			yourself);
		register: ((CmCommandGroup named: 'edition') asSpecGroup
			register: PhLRenameImageCommand forSpec;
			register: PhLCopyImageCommand forSpec;
			register: PhLDeleteImageCommand forSpec;
			beDisplayedAsGroup;
			yourself);
		register: PhLRecreateImageCommand forSpec;
		register: PhLShowImageInFolderCommand forSpec;
		register: PhLCopyPathname forSpec;
		register: PhLCopyLaunchCommand forSpec;
		register: PhLCreateTemplateFromImageCommand forSpec;
		register: PhLCreateTemplateFromImageCommand new asSpecCommandWithImageRemoval;
		register: ((CmCommandGroup named: 'extra') asSpecGroup
			register: PhLInspectCommand forSpec;
			yourself);
		beDisplayedAsGroup;
		yourself! !
!PhLImagesPresenter class methodsFor: 'commands'!
buildToolbarGroup
	^ (CmCommandGroup named: 'Toolbar') asSpecGroup
		description: 'Pharo Launcher toolbar';
		register: PhLOpenNewImageWindowCommand forSpec;
		register: PhLLaunchImageCommand forSpec;
		register: PhLLaunchImageCommand new asSpecLaunchWithoutSettingsCommand;
		register: PhLLaunchImageFromDiskCommand forSpec;
		register: PhLImportImageCommand forSpec;
		register: PhLRefreshImageRepositoryCommand forSpec;
		register:
			(PhLShowImageInFolderCommand forSpec
				name: 'Show';
				yourself);
		register: PhLDeleteImageCommand forSpec;
		register:
			(PhLQuitCommand forSpec
				beDisplayedOnRightSide;
				yourself);
		register:
			(PhLAboutCommand forSpec
				beDisplayedOnRightSide;
				yourself);
		register:
			(PhLOpenSettingsCommand forSpec
				name: 'Settings';
				beDisplayedOnRightSide;
				yourself);
		register:
			(PhLOpenVmManagerCommand forSpec
				name: 'VMs';
				beDisplayedOnRightSide;
				yourself);
		beDisplayedAsGroup;
		yourself! !
!PhLImagesPresenter class methodsFor: 'specs'!
defaultSpec

	^ SpBoxLayout newVertical
		add: #imageFilter expand: false;
		add: (SpPanedLayout newVertical
			position: 66 percent;
			add: #imageTable;
			add: #descriptionPanel;
			yourself);
		yourself! !
!PhLImagesPresenter methodsFor: 'initialization'!
connectPresenters

	super connectPresenters.
	
	imageTable whenSelectionChangedDo: [ :selection |
		self 
			refreshLaunchConfigurationList;
			updateToolbarCommandsAvailability ].
		
	imageTable 
		transmitTo: descriptionPanel
		transform: [ :images | 		
						images size = 1
							ifTrue: [ images first ]
							ifFalse: [ PhLNullImage new ] ]! !
!PhLImagesPresenter methodsFor: 'api - actions'!
createLocalTemplateFromSelectionNamed: aString
	^ self templateRepository createLocalTemplateFrom: self singleImage named: aString! !
!PhLImagesPresenter methodsFor: 'private'!
editLaunchConfigurations
	^ (PhLOpenLaunchConfigurationEditorCommand forContext: self) execute! !
!PhLImagesPresenter methodsFor: 'private'!
ensure: aBoolean
	aBoolean
		ifFalse: [ PhLCommandError signal ]! !
!PhLImagesPresenter methodsFor: 'private'!
filter: regexMatcher

	| images |
	images := regexMatcher
		ifNil: [ self imageRepository images ]
		ifNotNil: [ self imageRepository images
				select: [ :each | regexMatcher search: each name asString asLowercase ] ].
	imageTable items: images! !
!PhLImagesPresenter methodsFor: 'api - selection'!
hasSingleImageSelected
	^ (imageTable selectedItems size = 1) and: [ imageTable selectedItems first notNil ]! !
!PhLImagesPresenter methodsFor: 'api - accessing'!
imageRepository
	^ self model! !
!PhLImagesPresenter methodsFor: 'initialization'!
initializePresenters
	imageFilter := self newTextInput
		placeholder: 'Enter image name filter ...';
		whenTextChangedDo: [ :filterString | self filter: filterString asLowercase ];
		yourself.
	imageTable := self newTable
		items: self imageRepository images;
		sortingBlock: #lastModification descending;
		whenActivatedDo: [ | cmd |
			cmd := self toolbarGroup commandOrGroupNamed: 'Launch'.
			cmd execute ];
		whenBuiltDo: [ :tree | tree widget alternateRowsColor ];
		addColumn:
			((SpStringTableColumn title: 'Name' evaluated: #name)
				width: 350;
				yourself);
		addColumn:
			((SpStringTableColumn title: 'Architecture' evaluated: #architecture)
				width: 80;
				yourself);
		addColumn:
			((SpStringTableColumn title: 'Pharo Version' evaluated: #pharoVersion)
				width: 80;
				yourself);
		addColumn:
			((SpStringTableColumn
				title: 'Last modified'
				evaluated: [ :image | self readableDateFor: image lastModification ])
				sortFunction: #lastModification descending;
				yourself);
		contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ];
		beResizable;
		beMultipleSelection;
		yourself.
	descriptionPanel := self
		instantiate: PhLImageDetailPresenter
		on: PhLNullImage new.
	self imageRepository whenChangedSend: #refresh to: self.
	self whenDisplayDo: 
		[ self imageRepository hasImages
				ifTrue: [ self selectImageAt: 1 ] ].! !
!PhLImagesPresenter methodsFor: 'initialization'!
initializeWindow: aWindowPresenter
	aWindowPresenter
		title: 'Pharo Launcher';
		initialExtent: 700 @ 500;
		toolBar: self toolbarGroup asToolbarPresenter;
		centered;
		whenClosedDo: [ self imageRepository unsubscribe: self ].
	self rootCommandsGroup installShortcutsIn: aWindowPresenter.
	aWindowPresenter toolBar 
		addItemLeft: self newLaunchConfigurationDropList afterIndex: 1.! !
!PhLImagesPresenter methodsFor: 'initialization'!
newLaunchConfigurationDropList
	^ launchConfigurationList := SpDropListPresenter new
			items: #();
			yourself! !
!PhLImagesPresenter methodsFor: 'private'!
readableDateFor: aDateAndTime 
	
	^ PhLTimeUntilNowStrategy displayStringOf: aDateAndTime! !
!PhLImagesPresenter methodsFor: 'updating'!
refresh 
	imageTable items: self imageRepository images.
	self refreshLaunchConfigurationList! !
!PhLImagesPresenter methodsFor: 'updating'!
refreshLaunchConfigurationList
	| image items |
	[ image := self singleImage ]
	on: PhLCommandError
	do: [ self resetLaunchConfigurationList.
			^ self].
	
	items := image launchConfigurations collect: [ :each | 
			SpDropListItem new
				model: each;
				display: [ :config | config name ];
				icon: (self iconNamed: #configuration);
				yourself ].
	items addFirst: (SpDropListItem new
				model: 'Edit configurations ...';
				action: [ self 
					editLaunchConfigurations;
					refreshLaunchConfigurationList ];
				icon: (self iconNamed: #edit);
				yourself ).
	launchConfigurationList
		resetSelection;
		dropListItems: items.
	[ launchConfigurationList selectItem: image defaultLaunchConfiguration ]
		on: NotFound "Default configuration has been deleted but there are still other configurations"
		do: [ launchConfigurationList selectIndex: 2 ]! !
!PhLImagesPresenter methodsFor: 'updating'!
resetLaunchConfigurationList
	launchConfigurationList
				resetSelection;
				items: #() "no image selected".! !
!PhLImagesPresenter methodsFor: 'initialization'!
rootCommandsGroup 
	^ rootCommandsGroup ifNil: [ rootCommandsGroup := super rootCommandsGroup ]! !
!PhLImagesPresenter methodsFor: 'api - selection'!
selectConfiguration: aPhLLaunchConfiguration
	launchConfigurationList selectItem: aPhLLaunchConfiguration.! !
!PhLImagesPresenter methodsFor: 'api - selection'!
selectImage: aPhLImage
	imageTable items 
		detect: [ :image | image name = aPhLImage name ]
		ifFound: [ :item | imageTable selectItem: item ]! !
!PhLImagesPresenter methodsFor: 'api - selection'!
selectImageAt: anIndex
	imageTable selectIndex: anIndex! !
!PhLImagesPresenter methodsFor: 'api - selection'!
selectedImages
	^ imageTable selectedItems! !
!PhLImagesPresenter methodsFor: 'api - accessing'!
selectedLaunchConfiguration
	^ launchConfigurationList selectedItem! !
!PhLImagesPresenter methodsFor: 'api - selection'!
singleImage
	self ensure: self hasSingleImageSelected.
	^ imageTable selection selectedItems first! !
!PhLImagesPresenter methodsFor: 'api - selection'!
singleImageName
	^ self singleImage name! !
!PhLImagesPresenter methodsFor: 'api - accessing'!
templateRepository
	^ self application templateRepository! !
!PhLImagesPresenter methodsFor: 'accessing'!
toolbarGroup
	^ self rootCommandsGroup / 'Toolbar'! !
!PhLImagesPresenter methodsFor: 'updating'!
updateToolbarCommandsAvailability
	self withToolbarDo: [ :toolbar |
		self toolbarGroup allCommands do: #updateEnableStatus ]
! !
!PhLImagesPresenter methodsFor: 'private'!
withToolbarDo: aBlock
	self withWindowDo: [ :window | aBlock value: window toolBar ]! !
!PhLScriptPresenter class methodsFor: 'example'!
defaultSpec
	^ SpPanedLayout newHorizontal
		position: 30 percent;
		add: #scriptTable
			withConstraints: [ :constraints | 
				constraints 
					spec: #withoutOrderingBar"; 
					width: 200" ];
		add: (SpBoxLayout newVertical
			add: #fileEditor;
			add: #saveButton expand: false;
			yourself);
		yourself! !
!PhLScriptPresenter class methodsFor: 'example'!
example
	| fs |
	fs := FileSystem memory.
	fs root / 'loadSpec.st'
		writeStreamDo: [ :s | s nextPutAll: 'Metacello new
    baseline: ''Iceberg'';
    repository: ''filetree://./'';
    load.' ].
	fs root / 'icebergLoadExample.st'
		writeStreamDo: [ :s | s nextPutAll: self icebergLoadExample ].
	^ (self newApplication: PharoLauncherApplication new 
		model: fs root) 
		openWithSpec;
		yourself! !
!PhLScriptPresenter class methodsFor: 'example'!
icebergLoadExample
	^ 'Metacello new
  baseline: ''Tonel'';
  repository: ''github://pharo-vcs/tonel:v1.0.12'';
  load.'! !
!PhLScriptPresenter methodsFor: 'initialization'!
initializePresenters 
	scriptTable := (self instantiate: SpEditableListPresenter)
		items: self scripts;
		display: [ :file | file basename ];
		whenSelectionChangedDo: [ :selection | 
			selection isEmpty
				ifTrue: [ fileEditor 
								text: '' ;
								disable. ]
				ifFalse: [ fileEditor 
								text: selection selectedItem contents;
								enable. ] ];
		addItemBlock: [ self newScript ];
		removeItemBlock: [ :item | self removeScript: item ]
		yourself.
	fileEditor := self newCode
		disable;
		yourself.
	saveButton := self newButton
		label: 'Save';
		icon: (self iconNamed: #smallSave);
		action: [ self saveSelectedScript ];
		yourself.! !
!PhLScriptPresenter methodsFor: 'initialization'!
initializeWindow: aWindowPresenter
	aWindowPresenter
		title: 'Available initialization scripts';
		initialExtent: 800@550.! !
!PhLScriptPresenter methodsFor: 'action'!
newScript
	| newName |
	newName := self application newRequest
			title: 'New script name?';
			validateAnswer: [ :answer | (self scriptDirectory / answer) exists not ];
			request.
	^ self newScriptNamed: newName! !
!PhLScriptPresenter methodsFor: 'action'!
newScriptNamed: aName
	| file |
	aName ifNil: [ ^ nil ].
	
	file := self scriptDirectory / aName.
	file extension = 'st'
		ifFalse: [ file := file, 'st' ].
	file ensureCreateFile.
	self scriptListChanged.
	^ file! !
!PhLScriptPresenter methodsFor: 'action'!
removeScript: aFileReference 
	
	aFileReference ifNil: [ ^ self ].
	(self application newConfirmation 
		message: 'Do you want to remove ', aFileReference fullName, ' script?';
		confirm) ifFalse: [ ^ self ].
		
	aFileReference ensureDelete.
	scriptTable	removeItem: aFileReference.
	self scriptListChanged.
! !
!PhLScriptPresenter methodsFor: 'action'!
saveSelectedScript
	| file |
	file := scriptTable selectedItem.
	file ifNil: [ ^ self application newInformation
		message: 'Cannot save: no script selected!!';
		inform ].
	file
		ensureDelete;
		writeStreamDo: [ :stream | stream nextPutAll: fileEditor text asString ]! !
!PhLScriptPresenter methodsFor: 'accessing'!
scriptDirectory
	^ self model ! !
!PhLScriptPresenter methodsFor: 'action'!
scriptListChanged
	scriptTable refresh.
	scriptListChangedBlock ifNotNil: [ scriptListChangedBlock cull: self ].! !
!PhLScriptPresenter methodsFor: 'accessing'!
scripts
	^ (self scriptDirectory files 
		select: [ :file | file extension = 'st' ])
			asSortedCollection ! !
!PhLScriptPresenter methodsFor: 'action'!
selectScript: aFileReference
	^ scriptTable selectItem: aFileReference! !
!PhLScriptPresenter methodsFor: 'events'!
whenScriptListChanged: aBlock 
	scriptListChangedBlock := aBlock.! !
!PhLTemplatesPresenter class methodsFor: 'commands'!
buildCommandsGroupWith: anImagesPresenter forRoot: rootCommandGroup
	rootCommandGroup
		register: (self buildContextualMenuGroup)! !
!PhLTemplatesPresenter class methodsFor: 'commands'!
buildContextualMenuGroup
	^ (CmCommandGroup named: 'Context Menu') asSpecGroup
		description: 'Templates tree contextual menu';
		register: PhLRenameTemplateCommand forSpec;
		register: PhLRemoveTemplateCommand forSpec;
		beDisplayedAsGroup;
		yourself! !
!PhLTemplatesPresenter class methodsFor: 'specs'!
defaultSpec
	^ SpPanedLayout newHorizontal
		add: (SpPanedLayout newHorizontal
			add: (SpBoxLayout newVertical 
				add: '1. Choose a template category:' height: self labelHeight;
				add: #categoryTable;
				yourself);
			add: (SpBoxLayout newVertical 
				add: '2. Choose a template:' height: self labelHeight;
				add: #templateTable;
				yourself);
			yourself);
		add: (SpBoxLayout newVertical 
			add: #descriptionPanel;
			yourself);
		yourself		! !
!PhLTemplatesPresenter class methodsFor: 'example'!
example
	| app |
	app := PharoLauncherApplication new 
		imageRepository: (PhLDirectoryBasedImageRepository forDirectory: FileSystem memory root);
		yourself.

	^ (self 
			newApplication: app
			model: PhLTemplateGroupRepository default)
		openWithSpec;
		yourself! !
!PhLTemplatesPresenter methodsFor: 'initialization'!
connectPresenters

	super connectPresenters.
	categoryTable 
		transmitTo: templateTable 
		transform: [ :group | 
			group 
				ifNil: [ #() ]
				ifNotNil: [ group children ] ].
	templateTable transmitTo: descriptionPanel.! !
!PhLTemplatesPresenter methodsFor: 'accessing'!
description
	^ descriptionPanel description! !
!PhLTemplatesPresenter methodsFor: 'api - selection'!
hasLocalTemplateSelected
	| items |
	items := templateTable selectedItems.
	^ items size = 1
		and: [ items first isLocalTemplate ]! !
!PhLTemplatesPresenter methodsFor: 'api - selection'!
hasLocalTemplatesSelected
	| items |
	items := templateTable selectedItems.
	^ items size > 0 
		and: [ items allSatisfy: #isLocalTemplate ]! !
!PhLTemplatesPresenter methodsFor: 'api - selection'!
hasSingleTemplateSelected
	^ (templateTable selection selectedItems size = 1) 
			and: [ templateTable selectedItem isTemplate ]! !
!PhLTemplatesPresenter methodsFor: 'api -  accessing'!
imageName 
	^ descriptionPanel imageName! !
!PhLTemplatesPresenter methodsFor: 'api -  accessing'!
imageRepository
	^ self application imageRepository! !
!PhLTemplatesPresenter methodsFor: 'accessing'!
initializationScript
	^ descriptionPanel initializationScript! !
!PhLTemplatesPresenter methodsFor: 'initialization'!
initializePresenters
	categoryTable := self newTable
			items: self templateRepository roots;
			addColumn: ((SpImageTableColumn evaluated: #icon) width: 30);
			addColumn: (SpStringTableColumn evaluated: #name);
			yourself.
	templateTable := self newTreeTable
		children: #children;
		addColumn: (SpStringTableColumn evaluated: #name);
		contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ];
		beMultipleSelection; "bulk delete templates for example"
		whenBuiltDo: [ :tree | tree widget alternateRowsColor ];
		whenRootsChangedDo: [ :roots | 
			templateTable lazilyComputeChildren: (roots anySatisfy: #shouldComputeChildrenLazily) ];
		whenSelectionChangedDo: [ :selection | 
			selection isEmpty 
				ifTrue: [ descriptionPanel disable ]
				ifFalse: [ descriptionPanel enable ] ]
		yourself.
	descriptionPanel := self
		instantiate: PhLImageCreationPresenter
		on: nil.
	descriptionPanel disable.! !
!PhLTemplatesPresenter methodsFor: 'initialization'!
initializeWindow: aWindowPresenter
	aWindowPresenter
		title: 'Pharo Launcher - Image creation';
		initialExtent: 800 @ 400;
		"toolBar: (self rootCommandsGroup / 'Toolbar') asToolbarPresenter;"
		centered.	
	"self rootCommandsGroup installShortcutsIn: aWindowPresenter"! !
!PhLTemplatesPresenter methodsFor: 'updating'!
refresh
	| selectedCategory |
	selectedCategory := categoryTable selection selectedItem.
	self templateRepository refresh. "refresh caches"
	categoryTable items: categoryTable items.
	categoryTable selectItem: selectedCategory! !
!PhLTemplatesPresenter methodsFor: 'reseting'!
refreshInitializationScriptList
	descriptionPanel refreshInitializationScriptList! !
!PhLTemplatesPresenter methodsFor: 'api - selection'!
selectCategory: anIndex
	categoryTable selectIndex: anIndex! !
!PhLTemplatesPresenter methodsFor: 'api - selection'!
selectedTemplateCategory
	^ categoryTable selection selectedItem! !
!PhLTemplatesPresenter methodsFor: 'api - selection'!
selectedTemplates
	^ templateTable selectedItems! !
!PhLTemplatesPresenter methodsFor: 'api - selection'!
singleTemplate
	self hasSingleTemplateSelected
		ifFalse: [ PhLCommandError  signal: 'Only one template must be selected!!' ].
	^ templateTable selectedItems first "multiple selection enabled, always return a collection"! !
!PhLTemplatesPresenter methodsFor: 'api -  accessing'!
templateRepository
	^ self model! !
!PhLVMPresenter class methodsFor: 'commands'!
buildCommandsGroupWith: anImagesPresenter forRoot: rootCommandGroup
	rootCommandGroup
		register: (self buildToolbarGroup);
		register: (self buildContextualMenuGroup)! !
!PhLVMPresenter class methodsFor: 'commands'!
buildContextualMenuGroup
	^ (CmCommandGroup named: 'Context Menu') asSpecGroup
		register: PhLUpdateVmCommand forSpec;
		register: PhLShowVmInFolderCommand forSpec;
		register: PhLDeleteVmCommand forSpec;
		yourself
! !
!PhLVMPresenter class methodsFor: 'commands'!
buildToolbarGroup
	^ (CmCommandGroup named: 'Toolbar') asSpecGroup
		description: 'Pharo Launcher VM Manager toolbar';
		register: PhLUpdateVmCommand forSpec;
		register:
			(PhLShowVmInFolderCommand forSpec
				name: 'Show';
				yourself);
		register: PhLDeleteVmCommand forSpec;
		register: PhLToggleVmPrivateVmCommand forSpec;
		beDisplayedAsGroup;
		yourself! !
!PhLVMPresenter class methodsFor: 'specs'!
defaultSpec
	^ SpBoxLayout newVertical
		add: #vmTable;
		yourself! !
!PhLVMPresenter class methodsFor: 'examples'!
example
	<example>
	(self on: PhLVirtualMachinesDataSource default) openWithSpec! !
!PhLVMPresenter methodsFor: 'initialization'!
connectPresenters
	super connectPresenters.
	shouldShowPrivateVms := false.
	
! !
!PhLVMPresenter methodsFor: 'accessing'!
datasource
	^ self model! !
!PhLVMPresenter methodsFor: 'initialization'!
initializePresenters
	vmTable := self newTable
		whenActivatedDo: [ PhLShowVmInFolderCommand new
									context: self;
									execute  ];
		whenBuiltDo: [ :tree | tree widget alternateRowsColor ];
		addColumn: ((SpImageTableColumn title: '' evaluated: 
			[ :vm | | icon |
			icon := vm isValid
				ifTrue: [ self iconNamed: #testGreen ]
				ifFalse: [ self iconNamed: #testNotRun ].
			icon asMorph
				setBalloonText: vm validityDescription;
				yourself.
			]) 
			width: 20);
		addColumn: ((SpStringTableColumn title: 'Name' evaluated: #name) width: 100; yourself);
		addColumn: ((SpStringTableColumn 
			title: 'Last update' 
			evaluated: #lastUpdateTimeDescription) width: 120; yourself);
		addColumn: (SpStringTableColumn title: 'Download URL' evaluated: #downloadUrl);
		showColumnHeaders;
		contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ];
		beResizable;
		beMultipleSelection;
		items: self datasource virtualMachines;
		yourself! !
!PhLVMPresenter methodsFor: 'initialization'!
initializeWindow: aWindowPresenter
	aWindowPresenter
		title: 'Locally available Virtual Machines';
		initialExtent: 720 @ 300;
		toolBar: (self rootCommandsGroup / 'Toolbar') asToolbarPresenter;
		centered.
	self rootCommandsGroup installShortcutsIn: aWindowPresenter.
	self privateVmsTogglePresenter
		whenUnselectedDo: [ self privateVmsTogglePresenter
				label: 'public';
				icon: (self iconNamed: #remote) ];
		whenSelectedDo: [ self privateVmsTogglePresenter
				label: 'private';
				icon: (self iconNamed: #smallLock) ];
		beUnselected! !
!PhLVMPresenter methodsFor: 'initialization'!
privateVmsTogglePresenter
	^ (self rootCommandsGroup / 'Toolbar') allCommands last presenter! !
!PhLVMPresenter methodsFor: 'private'!
readableDateFor: aTimestamp
	^ aTimestamp asDate yyyymmdd , ' ' , aTimestamp asTime print24
! !
!PhLVMPresenter methodsFor: 'accessing'!
refresh 
	| vms |
	vms := shouldShowPrivateVms
		ifTrue: [ self datasource privateVirtualMachines ]
		ifFalse: [ self datasource virtualMachines ].
	vmTable
		items: vms";
		updatePresenter".! !
!PhLVMPresenter methodsFor: 'initialization'!
rootCommandsGroup 
	^ rootCommandsGroup ifNil: [ rootCommandsGroup := super rootCommandsGroup ]! !
!PhLVMPresenter methodsFor: 'accessing'!
selectedVms
	^ vmTable selectedItems! !
!PhLVMPresenter methodsFor: 'configuring'!
showPrivateVms
	shouldShowPrivateVms := true.
	self refresh.! !
!PhLVMPresenter methodsFor: 'configuring'!
showVms
	shouldShowPrivateVms := false.
	self refresh.! !
!PhLVMPresenter methodsFor: 'configuring'!
toggleShowVmPrivateVm
	shouldShowPrivateVms := shouldShowPrivateVms not.
	self refresh! !
!PhLAboutPresenter class methodsFor: 'specs'!
defaultSpec
	^ SpBoxLayout newHorizontal
		add: #icon width: 90;
		add: 
			(SpBoxLayout newVertical
				spacing: 15;
				add: #description;
				add: #documentationLink expand: false;
			yourself);
		yourself! !
!PhLAboutPresenter class methodsFor: 'instance creation'!
example
	| text |
	text := PhLAboutCommand new aboutText.
	
	(self text: text iconName: #pharo) openDialogWithSpec! !
!PhLAboutPresenter class methodsFor: 'instance creation'!
text: aText iconName: anIconName
	^ self new 
		text: aText;
		iconName: anIconName;
		yourself! !
!PhLAboutPresenter class methodsFor: 'specs'!
title 
	^ 'About'! !
!PhLAboutPresenter methodsFor: 'accessing'!
description 
	^ description! !
!PhLAboutPresenter methodsFor: 'accessing'!
icon 
	^ icon! !
!PhLAboutPresenter methodsFor: 'accessing'!
iconName: anIconName
	iconName := anIconName! !
!PhLAboutPresenter methodsFor: 'initialization'!
initializeDialogWindow: aDialogWindow
	self initializeWindow: aDialogWindow.
	aDialogWindow addButton: 'Ok'
		do: [ :presenter | presenter close ].! !
!PhLAboutPresenter methodsFor: 'initialization'!
initializePresenters 
	description := self newText.
	icon := self newImage.
	documentationLink := self newLink
		url: 'https://pharo-project.github.io/pharo-launcher';
		label: 'Open Pharo Launcher documentation (web)';
		yourself.
! !
!PhLAboutPresenter methodsFor: 'initialization'!
initializeWindow: aWindow
	description 
		text: text;
		disable.
   icon image: (self iconNamed: iconName).! !
!PhLAboutPresenter methodsFor: 'accessing'!
text: aText
	text := aText! !
!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!
configurationDetailSpec
	^ SpBoxLayout newVertical
		spacing: 5;
		add:
			(SpBoxLayout newHorizontal
				add: 'Configuration name:' withConstraints: self labelConstraintsBlock;
				add: #selectedConfigurationNameField;
				yourself)
			height: self inputTextHeight;
		add:
			(SpBoxLayout newHorizontal
				add: 'VM:' withConstraints: self labelConstraintsBlock;
				add: #vmList;
				yourself)
			height: self inputTextHeight;
		add:
			(SpBoxLayout newHorizontal
				add: 'VM arguments:' withConstraints: self labelConstraintsBlock;
				add: #vmArgumentList;
				yourself)
			height: 200"80";
		add:
			(SpBoxLayout newHorizontal
				add: 'Image arguments:' withConstraints: self labelConstraintsBlock;
				add: #imageArgumentList;
				yourself)
			height: 200"150";
		add: 
			(SpBoxLayout newHorizontal
				add: ''; "work-around to center the button"
				add: #applyChangesButton expand: false;
				add: '   ' expand: false;
				add: #saveAndSelectsButton expand: false;
				add: '  '; "work-around to center the button"
				yourself)
			height: self buttonHeight;
		yourself! !
!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!
defaultSpec
	^ SpBoxLayout newHorizontal
		spacing: 5;
		add: #configurationTable 
			withConstraints: [ :constraints | 
				constraints 
					spec: #withoutOrderingBar; 
					width: 200 ];
		add: self configurationDetailSpec;
		yourself! !
!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!
example
	| image |
	image := PhLImage example.
	image versionFile 
		writeStreamDo: [ :stream | stream nextPutAll: '70' ].
	(self 
		newApplication: PharoLauncherApplication new 
		model: image) openWithSpec! !
!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!
labelConstraintsBlock
	^ [ :constraints | 
	constraints
		height: self labelHeight;
		width: self labelWidth ]! !
!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!
labelWidth
	^ 120! !
!PhLLaunchConfigurationPresenter methodsFor: 'private'!
addInteractiveImageArgument
	| interactiveFlag |
	interactiveFlag := '--interactive'.
	(imageArgumentList items includes: interactiveFlag)
		ifTrue: [ ^ self ].
	imageArgumentList items add: interactiveFlag.
	imageArgumentList refresh.! !
!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!
configurationName
	^ selectedConfigurationNameField text! !
!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!
connectPresenters
	configurationTable selectIndex: 1! !
!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!
image
	^ image! !
!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!
imageArguments
	^ imageArgumentList items! !
!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!
initializePresenters
	configurationTable := (self instantiate: SpEditableListPresenter)
		addItemBlock: [ self newConfiguration ];
		label: 'Launch configurations';
		items: self image launchConfigurations;
		display: [ :each | each name ];
		whenSelectionChangedDo: [ :selection | 
			selectedConfiguration := selection selectedItem ifNil: [ PhLNullLaunchConfiguration new ].
			self selectedConfigurationChanged ];
		yourself.
	selectedConfigurationNameField := self newTextInput
		disable;
		yourself.
	vmList := self newDropList
		sortingBlock: [ :a :b | a model id > b model id ];
		display: [ :each | each id ];
		whenSelectedItemChangedDo: [ :vm | 
			vm ifNotNil: 
				[ vm isHeadless 
					ifTrue: [ self addInteractiveImageArgument ] ] ];
		yourself.
	"Run in a separate process to do not block UI. Can take some seconds."
	[ self initializeVmListContent ] fork.
	vmArgumentList := (self instantiate: SpEditableListPresenter)
		addItemBlock: [ self application newRequest
				title: 'New VM argument?';
				request ];
		yourself.
	imageArgumentList := (self instantiate: SpEditableListPresenter)
		addItemBlock: [ self application newRequest
				title: 'New image argument?';
				request ];
		yourself.
	applyChangesButton := self newButton
		label: 'Apply';
		icon: (self iconNamed: #scriptManager);
		action: [ self saveSelectedConfiguration ];
		yourself.
	saveAndSelectsButton := self newButton
		label: 'Save & select';
		icon: (self iconNamed: #smallSave);
		action: [ self saveSelectedConfiguration.
			self delete ];
		yourself! !
!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!
initializeVmListContent
	vmList items: image vmManager virtualMachines.
	self setVmFromConfiguration.! !
!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!
initializeWindow: aWindowPresenter
	aWindowPresenter
		title: self image name, ' image launch configurations';
		initialExtent: 800@550;
		whenClosedDo: [ self application launchConfigurationEdited: self selectedConfiguration ].! !
!PhLLaunchConfigurationPresenter methodsFor: 'action'!
newConfiguration
	| newName configuration |
	newName := self application newRequest
			title: 'New Launch configuration name?';
			validateAnswer: [ :answer | 
				self image launchConfigurations noneSatisfy: [ :each | each name = answer ] ];
			request.
	newName ifNil: [ ^ nil ].
	
	configuration := (PhLLaunchConfiguration  withImage: self image)
		name: newName;
		yourself.
	^ configuration! !
!PhLLaunchConfigurationPresenter methodsFor: 'action'!
saveSelectedConfiguration
	| config |
	config := self selectedConfiguration.
	config isNullConfiguration ifTrue: [ ^ self ].
	
	config imageArguments: imageArgumentList items.
	config vmArguments: vmArgumentList items.
	config vm: vmList selectedItem.
	self image serializeMetadata.
	self application launchConfigurationEdited: config.! !
!PhLLaunchConfigurationPresenter methodsFor: 'action'!
selectImageArgumentAt: anIndex
	imageArgumentList selectIndex: anIndex! !
!PhLLaunchConfigurationPresenter methodsFor: 'action'!
selectVMArgumentAt: anIndex
	vmArgumentList selectIndex: anIndex! !
!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!
selectedConfiguration
	^ selectedConfiguration! !
!PhLLaunchConfigurationPresenter methodsFor: 'updating'!
selectedConfigurationChanged
	selectedConfigurationNameField text: self selectedConfiguration name.
	self setVmFromConfiguration.
	vmArgumentList items: self selectedConfiguration vmArguments.
	imageArgumentList items: self selectedConfiguration imageArguments.
	self selectImageArgumentAt: 1.
	self selectVMArgumentAt: 1.! !
!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!
setModelBeforeInitialization: aPhLImage
	image := aPhLImage ! !
!PhLLaunchConfigurationPresenter methodsFor: 'updating'!
setVmFromConfiguration
	| vm |
	vm := self selectedConfiguration 
		ifNil: [ ^ self "abort if no launch configuration selected" ]
		ifNotNil: [ :config | config vm ].
	[ vmList selectItem: vm ]
		on: NotFound
		do: [ vmList
				addItemLabeled: vm do: [ "no action" ];
				selectItem: vm ]! !
!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!
vmArguments
	^ vmArgumentList items! !
!PhlRetryPresenter class methodsFor: 'specs'!
defaultSpec 
	^ SpBoxLayout newHorizontal
		"add: (self iconNamed: #smallUpdate) expand: false;"
		add:  #explanationText;
		yourself! !
!PhlRetryPresenter class methodsFor: 'example'!
example
	(self new
		explanation: 'Download error (probably a network error)';
		retryBlock: [ "nothing" ];
		cancelBlock: [ #() ]
	) openModalWithSpec! !
!PhlRetryPresenter methodsFor: 'accessing'!
cancelBlock: aBlock
	cancelBlock := aBlock! !
!PhlRetryPresenter methodsFor: 'accessing'!
explanation: aString 
	explanationText label: aString! !
!PhlRetryPresenter methodsFor: 'initialization'!
initializeDialogWindow: aWindowPresenter
	aWindowPresenter
		title: 'Retry?';
		initialExtent: 400 @ 120;
		addButton: 'Retry' do: [ :presenter | presenter close. retryBlock value. ];
		addButton: 'Cancel' do: [ :presenter | presenter beCancel; close. cancelBlock value. ];
		centered.
	! !
!PhlRetryPresenter methodsFor: 'initialization'!
initializePresenters
	explanationText := self newLabel.! !
!PhlRetryPresenter methodsFor: 'accessing'!
retryBlock: aBlock
	retryBlock := aBlock! !
!SettingDeclaration methodsFor: '*PharoLauncher-Spec2' prior: 61695760!
inputWidgetForFileOrDirectoryWithAction: aSymbol
	"Small update from the original version to get text auto-accepted as default"
	| list button |
	list := EditableDropListMorph
		on: self
		list: #list
		selected: #index
		changeSelected: #index:
		useIndex: true
		addToList: #addToList:
		class: String
		getEnabled: #enabled
		default: self defaultValue.
	list
		ghostText: self ghostHelp;
		hResizing: #rigid;
		width: 450;
		wantsFrameAdornments: true.
	list contentMorph autoAccept.
	button := self theme
		newButtonIn: self currentWorld
		for: self
		getState: nil
		action: aSymbol
		arguments: nil
		getEnabled: nil
		label:
			(AlphaImageMorph new
				image: (self iconNamed: #smallOpenIcon))
		help: 'Open directory chooser dialog' translated.
	^ self theme
		newRowIn: self currentWorld
		for:
			{list.
			button}! !
!SpWorldPresenter methodsFor: '*PharoLauncher-Spec2'!
close
	self application windowClosed: self.
	"We could remove all morphs from the world but it is already done by PhLDeploymentScript
	self adapter ifNotNil: [ :adapter | adapter removeSubWidgets ]"! !
!SpWorldPresenter methodsFor: '*PharoLauncher-Spec2' prior: 33962455!
title: aString
	titleHolder := aString.
	self adapter ifNotNil: [ :worldAdapter | worldAdapter title: self title ]! !
!Duration methodsFor: '*PharoLauncher-Spec2'!
simpleTime: aString ago: aCount
	^ aCount asFloat floor asString , ' ' , (aString asPluralBasedOn: aCount) , ' ago'! !
!Duration methodsFor: '*PharoLauncher-Spec2'!
simpleTimeAgo
	"Maybe there is a better way to do that, but for now I'll let it like this."
	
	self days > 365
		ifTrue: [ ^ 'more than a year ago' ].
	self days > 30
		ifTrue: [ ^ self simpleTime: 'month' ago: self days / 30 ].
	self days > 14
		ifTrue: [ ^ self simpleTime: 'week' ago: self days / 7 ].
	self days > 7
		ifTrue: [ ^ 'last week' ].
	self days > 1
		ifTrue: [ ^ self simpleTime: 'day' ago: self days ].
	self days = 1
		ifTrue: [ ^ 'yesterday' ].
	self hours > 1
		ifTrue: [ ^ self simpleTime: 'hour' ago: self hours ].
	self hours = 1
		ifTrue: [ ^ 'an hour ago' ].
	self minutes > 1
		ifTrue: [ ^ self simpleTime: 'minute' ago: self minutes ].
	self minutes = 1
		ifTrue: [ ^ 'a minute ago' ].
	
	^ 'just now'! !
!WorldState class methodsFor: '*PharoLauncher-Spec2' prior: 87250086!
quitSession
	self flag: 'TODO'.
	"Since UserManager is now over, there is no clean way to avoid warning when we just ask to quit the image. More general, there should be a way to have an image in read/only mode" 
	PhLDeploymentScript quitSession! !
!SettingTreeBuilder methodsFor: '*PharoLauncher-Spec2'!
pharoLauncherSettings
	"Process a <pharoLauncherSettings> pragma"
	self systemsettings! !

"PharoLauncher-Spec2"!
!PhLPluggableTemplateGroup commentStamp: '' prior: 0!
I'm a kind of template group that is completely defined by my instance variables. Useful for testing.!
!PhLImageDescriptionUpdaterMock commentStamp: '' prior: 0!
I override the save method to remember the number of time the real ImageDescriptionUpdater would have saved the image metadata.!
!PhLImageDescriptionUpdaterTest commentStamp: '' prior: 0!
A PhLImageDescriptionUpdaterTest is a test class for testing the behavior of PhLImageDescriptionUpdater!
!PhLAbstractTemplateTest commentStamp: '' prior: 0!
Give me unit tests and I will make sure they are run for all subclasses of PhLAbstractTemplate!
!PhLDirectoryBasedImageRepositoryTest commentStamp: '' prior: 0!
A PhLDirectoryBasedImageGroupTest is a test class for testing the behavior of PhLDirectoryBasedImageGroup!
!ManifestPharoLauncherTests commentStamp: '' prior: 0!
I stores metadata on true and false positive critics. These meta data are used by the SmalllintManifestChecker and the critics Browser!
!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!
name: aString
	^ self name: aString templates: #() groups: #()! !
!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!
name: aString groups: anotherCollection
	^ self new
		setName: aString templates: #() groups: anotherCollection;
		yourself! !
!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!
name: aString templates: aCollection
	^ self name: aString templates: aCollection groups: #()! !
!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!
name: aString templates: aCollection groups: anotherCollection
	^ self new
		setName: aString templates: aCollection groups: anotherCollection;
		yourself! !
!PhLPluggableTemplateGroup methodsFor: 'accessing'!
groups
	^ groups! !
!PhLPluggableTemplateGroup methodsFor: 'accessing'!
name
	^ name! !
!PhLPluggableTemplateGroup methodsFor: 'initialization'!
setName: aString templates: aCollection groups: anotherCollection
	name := aString.
	templates := aCollection.
	groups := anotherCollection.! !
!PhLPluggableTemplateGroup methodsFor: 'accessing'!
templates
	^ templates! !
!PhLPluggableTemplateGroup methodsFor: 'accessing'!
templatesAndGroups
	^ self templates, self groups! !
!PhLImageDescriptionUpdaterMock methodsFor: 'saving'!
doSave
	saves add: { image name -> description }! !
!PhLImageDescriptionUpdaterMock methodsFor: 'initialization'!
initialize
	super initialize.
	saves := OrderedCollection new.
	nbProcessKilled := 0.! !
!PhLImageDescriptionUpdaterMock methodsFor: 'accessing'!
nbProcessKilled
	^ nbProcessKilled! !
!PhLImageDescriptionUpdaterMock methodsFor: 'accessing'!
nbSave
	^ saves size! !
!PhLImageDescriptionUpdaterMock methodsFor: 'private'!
terminateProcess 
	super terminateProcess.
	process ifNotNil: [ nbProcessKilled := nbProcessKilled + 1 ].! !
!PhLImageDescriptionUpdaterMock methodsFor: 'accessing'!
waitDelay
	^ 100 milliSeconds! !
!PhLFileBrowserTest methodsFor: 'tests'!
testCanOpenAFileBrowserOnImageFolder
	| path |
	path := Smalltalk image imageDirectory fullName.
	PhLFileBrowser openOn: path.! !
!PhLImageDescriptionUpdaterTest methodsFor: 'running'!
setUp
	super setUp.
	updater := PhLImageDescriptionUpdaterMock
		reset;
		default.
	rootFs := FileSystem memory root.
	image := PhLImage location: rootFs / 'one'.
	image2 := PhLImage location: rootFs / 'two'! !
!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!
testDoNotSaveNullImage
	updater image: PhLNullImage new description: 'desc'.
	
	self assert: updater nbSave equals: 0! !
!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!
testDoNotSaveWhenImageIsNil
	updater image: nil description: 'desc'.
	
	self assert: updater nbSave equals: 0! !
!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!
testNoSaveWhenDescriptionIsTheSame
	image description: 'desc'.
	updater image: image description: 'desc'.
	updater image: image description: 'desc'.
	self waitUpdate.
	
	self assert: updater nbSave equals: 0.! !
!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!
testSaveBothImagesWhenUpdatingDescriptionOfTwoDifferentImages
	updater image: image description: 'desc'.
	updater image: image2 description: 'desc imag2'.
	self waitUpdate.
	
	self assert: updater nbSave equals: 2! !
!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!
testSaveOnceWhenDescriptionChangeOnce
	updater image: image description: 'desc'.
	self waitUpdate.
	
	self assert: updater nbSave equals: 1! !
!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!
testSaveOnceWhenDescriptionChangesManyTimesWithDelayShorterThanWaitDelay
	3 timesRepeat: 
		[ updater image: image description: 'desc'.
		 (updater waitDelay / 5) wait ].
	self waitUpdate.
	
	self assert: updater nbSave equals: 1! !
!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!
testSaveTwiceWhenDescriptionChangesManyTimesWithDelayLongerThanWaitDelay
	3 timesRepeat: 
		[ updater image: image description: 'desc'.
		 self waitUpdate. ].
	
	self assert: updater nbSave equals: 3! !
!PhLImageDescriptionUpdaterTest methodsFor: 'utilities'!
waitUpdate
	(updater waitDelay + 100 milliSeconds) wait.! !
!PhLImageTest methodsFor: 'running'!
setUp
	super setUp.
	fs := FileSystem memory root.
	imageFileRef := fs / 'foo.image'.
	imageFileRef binaryWriteStreamDo: [ :stream | (ZnEndianessReadWriteStream on: stream) nextLittleEndianNumber: 4 put: 68021 ].
	image := PhLImage location: imageFileRef! !
!PhLImageTest methodsFor: 'tests'!
testCanGetDefaultLaunchConfigurationWhenNoLaunchConfiguration
	| config |

	config := image defaultLaunchConfiguration.
	
	self 
		assert: config name
		equals: 'Default'.! !
!PhLImageTest methodsFor: 'tests'!
testCanInitializeImageFromMetadatafile
	| deserializedImage |
	image 
		description: 'An image for testing purpose';
		computeArchitecture;
		originTemplate: (PhLRemoteTemplate name: 'Foo test template' url: 'https://foo.bar.org/abc/foo.zip' asZnUrl).
		
	deserializedImage := PhLImage location: fs / 'foo.image'.

	self 
		assert: deserializedImage description
		equals: image description.
	self 
		assert: deserializedImage architecture
		equals: image architecture.
	self 
		assert: deserializedImage formatNumber 
		equals: image formatNumber.
	self 
		assert: deserializedImage pharoVersion
		equals: image pharoVersion.
	self 
		assert: deserializedImage originTemplate name
		equals: image originTemplate name.
	self 
		assert: deserializedImage originTemplate url asString
		equals: image originTemplate url asString.! !
!PhLImageTest methodsFor: 'tests'!
testCanSerializeAndDeserializeImageLaunchConfigurationMetadata
	| deserializedImage launchConfig deserializedLaunchConfig |
	image 	launchConfigurations. "Add default launch ocnfig to the list of configurations"
	launchConfig := image defaultLaunchConfiguration 
		imageArguments: #('foo');
		vmArguments: #(1 2);
		yourself.
		
	deserializedImage := STON fromString: image stonString.
	deserializedLaunchConfig := deserializedImage defaultLaunchConfiguration.

	self
		assert: deserializedLaunchConfig name 
		equals: launchConfig name.
	self
		assertCollection: deserializedLaunchConfig imageArguments  
		hasSameElements: launchConfig imageArguments.
	self
		assertCollection: deserializedLaunchConfig vmArguments  
		hasSameElements: launchConfig vmArguments.
! !
!PhLImageTest methodsFor: 'tests'!
testCanSerializeAndDeserializeImageMetadata
	| deserializedImage |
	image 
		description: 'An image for testing purpose';
		computeArchitecture;
		originTemplate: (PhLRemoteTemplate name: 'Foo test template' url: 'https://foo.bar.org/abc/foo.zip' asZnUrl).
		
	deserializedImage := STON fromString: image stonString.

	self 
		assert: deserializedImage description
		equals: image description.
	self 
		assert: deserializedImage architecture
		equals: image architecture.
	self 
		assert: deserializedImage formatNumber 
		equals: image formatNumber.
	self 
		assert: deserializedImage pharoVersion
		equals: image pharoVersion.
	self 
		assert: deserializedImage originTemplate name
		equals: image originTemplate name.
	self 
		assert: deserializedImage originTemplate url asString
		equals: image originTemplate url asString.! !
!PhLImageTest methodsFor: 'tests'!
testDefaultLaunchConfigurationIsRetrievedFromConfigurationListWhenAvailable
	| config |

	config := image defaultLaunchConfiguration.
	config imageArguments: #( #foo ).
	image launchConfigurations: { config }.
		
	self 
		assert: image defaultLaunchConfiguration
		equals: config.
		
	self 
		assert: image defaultLaunchConfiguration imageArguments
		equals: #( #foo ).! !
!PhLImageTest methodsFor: 'tests'!
testDescriptionIsSetWhenNoDescriptionInMetadataButDescriptionFileExists
	| desc |
	image description: nil.
	desc := 'A description from description file description.txt'.
	fs / PhLImage descriptionFileName 
		writeStreamDo: [ :stream | stream nextPutAll: desc ].

	self 
		assert: image description
		equals: desc.! !
!PhLImageTest methodsFor: 'tests'!
testPhLImageSerialization
	| stonString |
	(image file parent / image class versionFileName)
		writeStreamDo: [ :stream | stream nextPutAll: '80' ].
	image launchConfigurations.
	self assert: image defaultLaunchConfiguration vm isValidAfterUpdate.
	image vmManager imageFile: FileLocator launcherImagesLocation / (image name , '.image'). "do not serialize a memory FS"
	
	stonString := image stonString.
	
	"ensure we get a file locator"
	self assert: (stonString includesSubstring: '#executableRef : FileLocator {
					#origin : #launcherVMsLocation,
					#path : RelativePath [ ''80-x64''').
	self assert: (stonString includesSubstring: '#imageFile : FileLocator {
			#origin : #launcherImagesLocation,
			#path : RelativePath [ ''foo.image'' ]
		}').
	"ensure VM manager is a reference"
	self assert: (stonString includesSubstring: '#manager : @2,').! !
!PhLImageTest methodsFor: 'tests'!
testPharoVersionIsSetWhenNoVersionInMetadataButPharoVersionFileExists
	| version |
	
	version := '60'.
	image versionFile 
		writeStreamDo: [ :stream | stream nextPutAll: version ].

	self 
		assert: image pharoVersion
		equals: version.! !
!PhLImageTest methodsFor: 'tests'!
testTemplateIsSetWhenMetadataFileInOldFormat
	"Old metadata file was a STON file with a dictionary with only one entry:
		template -> ston representation of the template
	"
	| oldMetadataString template |
	
	image originTemplate: nil.
	oldMetadataString := '{''template'':PhLRemoteTemplate{#name:''Pharo 7.0 (development version)'',#url:ZnUrl{#scheme:#http,#host:''files.pharo.org'',#segments:OrderedCollection[''image'',''70'',''latest.zip'']}}}'.
	fs / PhLImage metadataFileName writeStreamDo: [ :stream | stream nextPutAll: oldMetadataString ].
	template := (STON fromString: oldMetadataString) at: #template.

	image := PhLImage location: fs / 'foo.image'.
	
	self 
		assert: image originTemplate class
		equals: template class.
	self 
		assert: image originTemplate name
		equals: template name.
	self 
		assert: image originTemplate url
		equals: template url.! !
!PhLLaunchConfigurationTest methodsFor: 'helper'!
pharo80HeadlessVm
	^ PhLVirtualMachineManager new virtualMachines
		detect: [ :each | each id = '80-x64-headless' ]
		ifFound: [ :vm | vm isValidAfterUpdate. vm ]
		ifNone: [ self fail: 'cannot find VM!!' ]! !
!PhLLaunchConfigurationTest methodsFor: 'running'!
setUp
	super setUp.
	(fs / 'pharo.version')
		binaryWriteStreamDo: [ :stream | stream nextPutAll: '70' ].
	
! !
!PhLLaunchConfigurationTest methodsFor: 'helper'!
stripExportFrom: arguments 
	^ arguments first = 'export'
		ifTrue: [ self stripExportFrom: (arguments allButFirst: 3) "export foo=bar &&" ]
		ifFalse: [ arguments ]! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testCanGetDefaultVm
	| launchConfig vm |
	launchConfig := PhLLaunchConfiguration defaultWithImage: image.
	
	vm := launchConfig vm.
	
	self assert: (vm isKindOf: PhLVirtualMachine).
	self 
		assert: vm id
		equals: '70-x64'.! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testCanGetDefaultVmWhenVMNotListedInVmManager
	| launchConfig vm |
	launchConfig := PhLLaunchConfiguration defaultWithImage: image.
	(fs / 'pharo.version')
		binaryWriteStreamDo: [ :stream | stream nextPutAll: '770' ].

	vm := launchConfig vm.
	
	self assert: (vm isKindOf: PhLVirtualMachine).
	self 
		assert: vm id
		equals: '770-x64'.! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testCanSerializeLaunchConfiguration
	| launchConfig deserializedConfig |
	launchConfig := PhLLaunchConfiguration defaultWithImage: image.
	launchConfig vm executable: 'pharo'.
	launchConfig
		vmArguments: #(1 2 3);
		imageArguments: #(#A #B).
	
	deserializedConfig := STON fromString: (STON toStringPretty: launchConfig).
	
	self
		assert: deserializedConfig name 
		equals: launchConfig name.
	self
		assertCollection: deserializedConfig vmArguments
		hasSameElements: launchConfig vmArguments.
	self
		assertCollection: deserializedConfig imageArguments
		hasSameElements: launchConfig imageArguments.
	self 
		assert: deserializedConfig vm
		equals: launchConfig vm! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchProcessDoesNotHaveInitializationScriptArgumentsIfInitializationScriptIsNil
	| command launchConfig arguments |
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].
	launchConfig := image defaultLaunchConfiguration.
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	arguments := self stripExportFrom: command arguments.
	
	self 
		assert: arguments size
	 	equals: 2.
	self deny: (arguments includes: 'eval').! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchProcessDoesNotHaveInitializationScriptArgumentsIfInitializationScriptShouldNotBeRun
	| command launchConfig arguments |
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].
	image 
		initializationScript: (FileSystem memory root / 'foo.st') asFileReference;
		doNotRunInitializationScript.
	launchConfig := image defaultLaunchConfiguration.
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	arguments := self stripExportFrom: command arguments.
	
	self 
		assert: arguments size
	 	equals: 2.
	self deny: (arguments includesAny: #('eval' '"/foo.st')).! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchProcessHasImageArguments
	| command launchConfig |
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].
	launchConfig := image defaultLaunchConfiguration.
	launchConfig imageArguments: #( 1 2 3 ).
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	
	self assert: (command arguments includesAll: #( 1 2 3 )).! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchProcessHasInitializationScriptArgumentsIfInitializationScriptNotNil
	| command launchConfig |
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].
	image initializationScript: (FileSystem memory root / 'foo.st') asFileReference.
	launchConfig := image defaultLaunchConfiguration.
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	
	self 
		assertCollection: (command arguments last: 2) "remove vm and image argument (and possible exports)"
	 	hasSameElements: #('eval' '"/foo.st"').! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchProcessHasVmArguments
	| command launchConfig |
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].
	launchConfig := image defaultLaunchConfiguration.
	launchConfig 
		doNotUseSettings;
		vm: self pharo80HeadlessVm.
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	
	self assert: (command arguments includes: PhLVirtualMachine headlessOptionString)! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchWitSettingsDoesNotHaveNoPreferencesFlag
	| image command launchConfig |
	image := PhLImage example.
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '70' ].
	launchConfig := image defaultLaunchConfiguration.
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	
	self deny: (command arguments includes: '--no-default-preferences')! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchWithoutSettingsDoesNotHavePreferencesFlagIfNotSupportedByImage
	| image command launchConfig |
	image := PhLImage example32.
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '20' ].
	launchConfig := image defaultLaunchConfiguration.
	launchConfig doNotUseSettings.
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	
	self deny: (command arguments includes: '--no-default-preferences')! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testImageLaunchWithoutSettingsHasNoPreferencesFlag
	| image command launchConfig |
	image := PhLImage example.
	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '70' ].
	launchConfig := image defaultLaunchConfiguration.
	launchConfig doNotUseSettings.
	launchConfig vm executable: 'pharo'.
	
	[ command := launchConfig launchProcess ]
	on: PhLMissingVirtualMachineError 
	do: [ :error | error resume. "ignore. We are just testing command arguments" ].
	
	self assert: (command arguments includes: '--no-default-preferences')! !
!PhLLaunchConfigurationTest methodsFor: 'tests'!
testVmHasSameVmManagerAsImage
	| launchConfig |
	launchConfig := PhLLaunchConfiguration defaultWithImage: image.
	launchConfig vm executable: 'pharo'.
	
	self 
		assert: launchConfig image vmManager
		identicalTo: launchConfig vm manager! !
!PhLStringTest methodsFor: 'tests'!
testCanformatTemplateNameFromComplexUrl
	| result |
	result := '{6} ({5})' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip'.
	
	self
		assert: result
		equals: 'Pharo7.0-32bit-TelePharo (v0.4.2)'! !
!PhLStringTest methodsFor: 'tests'!
testCanformatTemplateNameFromComplexUrl2
	| result |
	result := '{1}-{2}-{3}-{5}' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip'.
	
	self
		assert: result
		equals: 'pharo-ide-TelePharo-releases-v0.4.2'! !
!PhLStringTest methodsFor: 'tests'!
testCanformatTemplateNameFromSimpleUrl
	| result |
	result := '{1}' formatTemplateName: '/foo.zip'.
	
	self
		assert: result
		equals: 'foo'! !
!PhLStringTest methodsFor: 'tests'!
testFormatTemplateNameDoesNotSubsituteWhenNoSubstitutionPatternFound
	| result |
	result := 'foo-bar-1' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip'.
	
	self
		assert: result
		equals: 'foo-bar-1'! !
!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!
testCanBuildListWhenNoSourceTemplate
	| list sources |
	sources := PhLTemplateSources withTemplateList: #().
	
	list := PhLTemplateGroupsBuilder buildFrom: sources.
	
	self 
		assert: list size 
		equals: 0! !
!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!
testCanBuildListWithFixedUrlGroup
	| groups group sources |
	sources := PhLTemplateSources withTemplateList: { PhLTemplateSource officialDistributionsGroup }.
	
	groups := PhLTemplateGroupsBuilder buildFrom: sources.
	
	self 
		assert: groups size
		equals: 1.
	group := groups anyOne.
	
	self assert: group isTemplateGroup.
	self 
		assert: group class
		equals: PhLFixedURLsTemplateGroup! !
!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!
testCanBuildListWithFixedUrlTemplate
	| groups group sources |
	
	group := PhLTemplateSource officialDistributionsGroup.
	group templates: { PhLTemplateSource pharo70x64 }.
	sources := PhLTemplateSources withTemplateList: { group }.

	groups := PhLTemplateGroupsBuilder buildFrom: sources.
	
	self 
		assert: groups size
		equals: 1.
	group := groups anyOne.
	
	self assert: group templatesAndGroups size
		equals: 1.
	self assert: group templatesAndGroups first class
		equals: PhLRemoteTemplate.! !
!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!
testCanBuildListWithHttpListingGroup
	| groups group sources |
	sources := PhLTemplateSources withTemplateList: { PhLTemplateSource pharo70 }.
	
	groups := PhLTemplateGroupsBuilder buildFrom: sources.
	
	self 
		assert: groups size
		equals: 1.
	group := groups anyOne.
	
	self assert: group isTemplateGroup.
	self 
		assert: group class
		equals: PhLHTTPListingTemplateGroup! !
!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!
testCanBuildListWithJenkinsGroup
	| groups group sources |
	sources := PhLTemplateSources withTemplateList: { PhLTemplateSource inriaPharoContribution }.
		
	groups := PhLTemplateGroupsBuilder buildFrom: sources.
	
	self 
		assert: groups size
		equals: 1.
	group := groups anyOne.
	
	self assert: group isTemplateGroup.
	self 
		assert: group class
		equals: PhLJenkins2Server! !
!PhLTemplateSourcesTest methodsFor: 'running'!
setUp
	super setUp.
	sourcesFile := FileSystem memory / 'templates-sources.test'! !
!PhLTemplateSourcesTest methodsFor: 'running'!
tearDown
	PhLPharoTemplateSources resetSourcesUrl.
	super tearDown! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testAlmostIdenticalTemplateSourcesAreDifferent
	| templatesSources1 templatesSources2 |
	templatesSources1 := (PhLPharoTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.
	templatesSources2 := (PhLPharoTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.
	templatesSources2 second templates first name: 'changed'.

	self deny: templatesSources1 equals: templatesSources2! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testCanCreateInstanceFromAListOfTemplateSource
	| tplSources sources |
	
	tplSources := PhLTemplateSources withTemplateList: { PhLTemplateSource officialDistributionsGroup }.
	sources := tplSources sources.
	
	self 
		assert: sources size
		equals: 1
	! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testCanFetchSourcesFileWhenAbsent
	self deny: sourcesFile exists.
	
	(PhLPharoTemplateSources withFile: sourcesFile) ensureSourcesFile. 
	
	self assert: sourcesFile exists! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testGivenUserSourcesFileAbsentWhenAskingUserSourcesThenGetEmptyCollection
	| sources |
	self deny: sourcesFile exists.

	sources := (PhLUserTemplateSources withFile: sourcesFile) sources.

	self assertEmpty: sources! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testGivenUserSourcesFileWithErrorsWhenAskingUserSourcesThenGetEmptyCollection
	| sources |
	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: 'foobar' ].

	sources := (PhLTemplateSources withFile: sourcesFile) sources.

	self assertEmpty: sources! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testGivenUserSourcesFileWithReferencesToUnknownVariablesWhenAskingUserSourcesThenGetEmptyCollection
	| sources |
	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: '[PhLHTTPListingTemplateGroup{#nonexistingiv:''http://foo.org'',#name:''foo''}]' ].

	self shouldnt: [ sources := (PhLTemplateSources withFile: sourcesFile) sources ] raise: InstanceVariableNotFound.

	self assertEmpty: sources! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testIdenticalTemplateSourcesAreEquals
	| templatesSources1 templatesSources2 |
	templatesSources1 := (PhLTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.
	templatesSources2 := (PhLTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.
	
	self 
		assert: templatesSources1
		equals: templatesSources2
	! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testNoUpdateAnnouncedWhenDownloadedSourcesIsSameAsSources
	| announcements sources |
	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: (STON toString: true) ].

	announcements := OrderedCollection new.
	ZnClientTest new
		withServerDo: [ :server | 
			server onRequestRespond: [ :request | ZnResponse ok: (ZnEntity text: (STON toString: true)) ].

			sources := PhLPharoTemplateSources withFile: sourcesFile.
			PhLPharoTemplateSources sourcesUrl: server localUrl.

			PhLPharoTemplateSources announcer weak when: PhLSourcesFileUpdateAvailable send: #add: to: announcements.

			sources checkForUpdates.

			self assertEmpty: announcements ]! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testSourcesFileNotFetchIfPresentWhenCallingEnsureSourcesFile
	sourcesFile ensureCreateFile.	
	
	(PhLPharoTemplateSources withFile: sourcesFile) ensureSourcesFile. 
	
	self 
		assert: sourcesFile parent children size
		equals: 1! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testSourcesFileNotUpdatedWhenDownloadedSourcesFileIsAbsent
	| sources sourcesFileModificationTime |
	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: 'foobar' ].
	sourcesFileModificationTime := sourcesFile modificationTime.

	sources := PhLPharoTemplateSources withFile: sourcesFile.
	sources downloadedSourcesFile ensureDelete.
	
	sources updateSourcesFile.
	
	self 
		assert: sources file modificationTime 
		equals: sourcesFileModificationTime! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testSourcesFileUpdateAvailableIsAnnouncedWhenDownloadedSourcesDifferentFromSources
	| announcements sources |
	
	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: (STON toString: true) ].
	
	announcements := OrderedCollection new. 
	ZnClientTest new 
	withServerDo: [ :server |
		server onRequestRespond: [ :request | 
			ZnResponse ok: (ZnEntity text: (STON toString: false)) ].
		
	sources := PhLPharoTemplateSources withFile: sourcesFile.
	PhLPharoTemplateSources sourcesUrl: server localUrl.
	
	PhLPharoTemplateSources announcer weak
		when: PhLSourcesFileUpdateAvailable
		send: #add:
		to: announcements.

	sources checkForUpdates.

	self 
		assert: announcements size 
		equals: 1 ].! !
!PhLTemplateSourcesTest methodsFor: 'tests'!
testUserTemplatesAreListedAfterPharoTemplates
	| userSources pharoSources sources |
	userSources := PhLUserTemplateSources example.
	pharoSources := PhLPharoTemplateSources fromFile.
	
	sources := (PhLCompositeTemplateSources new initializeWith: { pharoSources . userSources }) sources.
	
	self 
		assert: sources size
		equals: pharoSources sources size + 1.
	self 
		assert: sources last
		equals: userSources sources last! !
!PhLAbstractTemplateTest class methodsFor: 'testing'!
isAbstract
	^ self name = #PhLAbstractTemplateTest! !
!PhLAbstractTemplateTest methodsFor: 'instance creation'!
newTemplate
	^ self subclassResponsibility! !
!PhLAbstractTemplateTest methodsFor: 'running'!
setUp
	super setUp.
	root := FileSystem memory workingDirectory! !
!PhLAbstractTemplateTest methodsFor: 'tests'!
testHandleEOCDErrorWhenTemplateIsCorrupted
	| template archive |
	template := self newTemplate.
	"simulate a broken zip archive)"
	archive := (ByteArray readHexFrom: ((1 to: 50) collect: [ :x| '0123456789ABCDEF' atRandom ])) readStream.

	self 
		should: [ template extractZipArchive: archive to: root ]
		raise: PhLCorruptedTemplateError ! !
!PhLAbstractTemplateTest methodsFor: 'tests'!
testNoEOCDErrorWhenTemplateIsOk
	| template archive archiveFile |
	template := self newTemplate.
	archiveFile := root / 'phl-abstract-template-test-no-eocd-error-arch.zip'.
	archive := ZipArchive new.
	archive addDeflateString: 'foo' as: 'bar'.

	archiveFile asFileReference binaryWriteStreamDo: [ :stream |
		archive writeTo: stream ].
	
	self 
		shouldnt: [ template extractZipArchive: archiveFile to: root ]
		raise: PhLCorruptedTemplateError! !
!PhLAbstractTemplateTest methodsFor: 'tests'!
testRelocateImageFilesFromToWithName
	| template source destination imageName |
	template := self newTemplate.
	source := (root / 'old') ensureCreateDirectory.
	destination := (root / 'new') ensureCreateDirectory.
	(source / 'file.image') ensureCreateFile.
	(source / 'file.changes') ensureCreateFile.
	imageName := 'new'.
	self deny: (destination / imageName , 'image') exists.
	self deny: (destination / imageName , 'changes') exists.
	template relocateImageFilesFrom: source to: destination withName: imageName.
	self assert: (destination / imageName , 'image') exists.
	self assert: (destination / imageName , 'changes') exists! !
!PhLLocalTemplateTest methodsFor: 'coverage'!
classToBeTested
	^ PhLLocalTemplate ! !
!PhLLocalTemplateTest methodsFor: 'instance creation'!
newTemplate
	^ PhLLocalTemplate name: 'Test' zipFile: root / 'Test.zip'! !
!PhLLocalTemplateTest methodsFor: 'tests'!
testDeserializationGivesAFileReferenceToTheTemplate
	| template |
	template := STON fromString: 'PhLLocalTemplate{#name:''Test'',#zipFile:''/phl-abstract-template-test-template-extraction.zip''}'.
	
	self assert: (template zipArchive isKindOf: FileReference).! !
!PhLLocalTemplateTest methodsFor: 'tests'!
testSerializationDoesNotIncludeZipFileButAFileReferenceToIt
	| template zipFile stonString |
	zipFile := '/phl-abstract-template-test-template-extraction.zip' asFileReference.
	template := PhLLocalTemplate name: 'Test' zipFile: zipFile.
	
	stonString := STON toString: template.
	
	self assert: stonString equals: 'PhLLocalTemplate{#name:''Test'',#zipFile:FILE[''/phl-abstract-template-test-template-extraction.zip'']}'.! !
!PhLLocalTemplateTest methodsFor: 'tests'!
testTemplateExtractionGenerateImageMetadata
	| template destination archive zipFile metadataFile |
	zipFile := root / 'phl-abstract-template-test-template-extraction.zip'.
	template := PhLLocalTemplate name: 'Test' zipFile: zipFile.
	archive := ZipArchive new.
	archive
		addDeflateString: 'foo' as: 'bar.image';
		addDeflateString: 'foo' as: 'bar.changes'.
	template zipArchive asFileReference
		binaryWriteStreamDo: [ :stream | archive writeTo: stream ].
	destination := (root / 'new') ensureCreateDirectory.
	
	template extractTo: destination named: 'new'.
	
	metadataFile := destination / PhLImage metadataFileName.
	self assert: metadataFile exists.
	self assert: (metadataFile contents includesSubstring: zipFile basename).
	zipFile ensureDelete.! !
!PhLRemoteTemplateTest methodsFor: 'coverage'!
classToBeTested
	^ PhLRemoteTemplate ! !
!PhLRemoteTemplateTest methodsFor: 'instance creation'!
newTemplate
	^ self classToBeTested name: 'Test' url: 'http://foo.example.com/Test.zip'! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'coverage'!
classToBeTested
	^ PhLDirectoryBasedImageRepository! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'instance creation'!
emptyGroup
	^ self classToBeTested forDirectory: FileSystem memory workingDirectory! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'instance creation'!
newGroupWithAnImage
	| group baseDirectory |
	group := self emptyGroup.
	baseDirectory := group baseDirectory.
	(baseDirectory / 'test') ensureCreateDirectory.
	(baseDirectory / 'test' / 'test.image') ensureCreateFile.
	(baseDirectory / 'test' / 'test.changes') ensureCreateFile.
	^ group! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!
testCopyImageNamedTo
	| group |
	group := self newGroupWithAnImage.
	self assert: group imageNames asSet equals: #('test') asSet.
	group copyImageNamed: 'test' to: 'test2'.
	self assert: group imageNames asSet equals: #('test' 'test2') asSet.
	! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!
testDeleteImageNamed
	| group |
	group := self newGroupWithAnImage.
	self assert: group imageNames asSet equals: #('test') asSet.
	group deleteImageNamed: 'test'.
	self assertEmpty: group imageNames! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests'!
testDirectoryForImageNamed
	| group |
	group := self emptyGroup.
	self assertEmpty: group images.
	self assertEmpty: group imageNames! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests'!
testEmptyByDefault
	| group |
	group := self emptyGroup.
	self assertEmpty: group images.
	self assertEmpty: group imageNames! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests'!
testIgnoreNonConformDirectories
	| group baseDirectory |
	group := self emptyGroup.
	baseDirectory := group baseDirectory.
	self assert: group images size equals: 0.
	(baseDirectory / 'foo1') ensureCreateDirectory.
	self assert: group images size equals: 0.
	(baseDirectory / 'foo1' / 'foo.txt') ensureCreateFile.
	self assert: group images size equals: 0.
	(baseDirectory / 'foo1' / 'foo1.image') ensureCreateFile.
	self assert: group images size equals: 0.
	(baseDirectory / 'foo1' / 'foo1.image') delete.
	(baseDirectory / 'foo1' / 'foo1.changes') ensureCreateFile.
	self assert: group images size equals: 0.
	(baseDirectory / 'foo1' / 'foo1.image') ensureCreateFile.
	self assert: group images size equals: 1.! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!
testImageNames
	| group |
	group := self newGroupWithAnImage.
	self assert: group imageNames asSet equals: #('test') asSet.! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!
testImages
	| group |
	group := self newGroupWithAnImage.
	self assert: group images size equals: 1.
	self assert: group images anyOne name equals: 'test'! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!
testMakeUniqueImageName
	
	{ 
	"	{ basename . 	expectedResult .	{existingNames} } "	
		{ '30444' .		'30444' . 			{ } } .
	 	{ '30444' .		'30444' . 			{ 'test' } } .
		{ '30444' .		'30444-01' .		{ 'test' . '30444' } } .
		{ '30444' .		'30444-02' .		{ 'test' . '30444' . '30444-01' } } .
		{ '30444' .		'30444-03' .		{ 'test' . '30444' . '30444-01' . '30444-02' } } .
		{ '30444' .		'30444-10' .		{ 'test' . '30444' . '30444-01' . '30444-09' } } .
		{ '30444' .		'30444-12' .		{ 'test' . '30444' . '30444-11' . '30444-09' } } .
		{ '30444' . 		'30444-12' .		{ 'test' . '30444' . '30444-11' . '30444-09' . '30444-test' . '30644-Case12954' } } .		
	} do:
	[ 	:testdata |  
		| basename expectedResult existingNames result |
		basename := testdata first.
		expectedResult := testdata second. 
		existingNames := testdata third.
		
		result := self emptyGroup makeUniqueImageName: basename among: existingNames.
		self assert: result equals: expectedResult.
	]
 

! !
!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!
testRenameImageNamedTo
	| group |
	group := self newGroupWithAnImage.
	self assert: group imageNames asSet equals: #('test') asSet.
	group renameImageNamed: 'test' to: 'test2'.
	self assert: group imageNames asSet equals: #('test2') asSet.
	! !
!ManifestPharoLauncherTests class methodsFor: 'meta data'!
rejectClasses
^ #()! !
!ManifestPharoLauncherTests class methodsFor: 'meta data'!
rejectRules
^ #()! !

"PharoLauncher-Tests-Core"!
!PhLTemplateGroupTestRepository commentStamp: '' prior: 0!
TemplateGroupRepository used for test purposes.
I override the default location of templates.!
!PhLTestTemplatesPresenter commentStamp: '' prior: 0!
A presenter for Pharo Launcher templates used for test purposes!
!PhLTestImagesPresenter commentStamp: '' prior: 0!
A presenter for Pharo Launcher images used for test purposes!
!PhLTestVirtualMachineManager commentStamp: '' prior: 0!
Virtual Machine manager for test purposes.
I mock network calls.!
!PhLTestConfirmation commentStamp: '' prior: 0!
Mock for a user confirmation interaction!
!PhLTestRequest commentStamp: '' prior: 0!
Mock for a user request interaction!
!PhLTestVmPresenter commentStamp: '' prior: 0!
A presenter for Pharo Launcher VMs used for test purposes!
!PhLTemplateGroupTestRepository methodsFor: 'initialization'!
initialize 
	super initialize.
	fileSystem := FileSystem memory.
	localTemplateGroup := self newLocalTemplatesGroup.
	remoteTemplatesGroup := self newRemoteTemplatesGroup.
	self setGroups: { localTemplateGroup . remoteTemplatesGroup }.! !
!PhLTemplateGroupTestRepository methodsFor: 'accessing'!
localTemplatesGroup
	^ localTemplateGroup! !
!PhLTemplateGroupTestRepository methodsFor: 'accessing'!
newLocalTemplatesGroup
	^ PhLDownloadedTemplateGroup new 
		baseDirectory: fileSystem root;
		setName: 'Local test templates';
		yourself! !
!PhLTemplateGroupTestRepository methodsFor: 'accessing'!
newRemoteTemplatesGroup
	^ PhLFixedURLsTemplateGroup new 
			setName: 'Remote test templates' Templates: OrderedCollection new;
			yourself! !
!PhLTemplateGroupTestRepository methodsFor: 'accessing'!
remoteTemplatesGroup
	^ remoteTemplatesGroup! !
!PhLTestTemplatesPresenter methodsFor: 'user interaction'!
clickOnCreateButton
	self createButton click! !
!PhLTestTemplatesPresenter methodsFor: 'private'!
createButton
	^ descriptionPanel instVarNamed: 'createButton'! !
!PhLTestTemplatesPresenter methodsFor: 'accessing'!
createButtonEnabled
	^ self createButton isEnabled! !
!PhLTestTemplatesPresenter methodsFor: 'configuring'!
createLocalTemplateNamed: aName
	| zipFile |
	zipFile := self localTemplatesGroup baseDirectory / (aName , '.zip').
	self localTemplatesGroup
		register: (PhLLocalTemplate name: aName zipFile: zipFile)
		withZip: zipFile.
	self newZipArchive: zipFile.
	self refresh.! !
!PhLTestTemplatesPresenter methodsFor: 'configuring'!
createRemoteTemplateNamed: aName
	self remoteTemplatesGroup
		addTemplate: (PhLRemoteTemplate name: aName url: 'http://', aName, '.foo').
	self refresh.! !
!PhLTestTemplatesPresenter methodsFor: 'api - accessing'!
imageName
	^ 'TestCreateImage'! !
!PhLTestTemplatesPresenter methodsFor: 'api - accessing'!
imageRepository
	^ imageRepository ifNil: [ imageRepository := PhLDirectoryBasedImageRepository forDirectory: FileSystem memory root ]
	! !
!PhLTestTemplatesPresenter methodsFor: 'initialization'!
initialize
	self model: (PhLTemplateGroupTestRepository new).
	self application: (PharoLauncherApplication new
		scriptsDirectory: FileSystem memory root;
		yourself).
	request := PhLTestRequest new.
	templates := OrderedCollection new.
	
	super initialize.! !
!PhLTestTemplatesPresenter methodsFor: 'accessing'!
localTemplatesGroup
	^ self templateRepository localTemplatesGroup! !
!PhLTestTemplatesPresenter methodsFor: 'user interaction'!
newConfirmation
	^ PhLTestConfirmation new! !
!PhLTestTemplatesPresenter methodsFor: 'user interaction'!
newRequest
	^ request! !
!PhLTestTemplatesPresenter methodsFor: 'private'!
newZipArchive: aFileReference
	| archive |
	archive := ZipArchive new.
	archive
		addDeflateString: 'foo' as: 'bar.image';
		addDeflateString: 'foo' as: 'bar.changes'.
	aFileReference
		binaryWriteStreamDo: [ :stream | archive writeTo: stream ].
! !
!PhLTestTemplatesPresenter methodsFor: 'accessing'!
remoteTemplatesGroup
	^ self templateRepository remoteTemplatesGroup! !
!PhLTestTemplatesPresenter methodsFor: 'configuring'!
requestAnswer: answer
	request answer: answer! !
!PhLTestTemplatesPresenter methodsFor: 'configuring'!
selectInitializationScript: anIndex
	descriptionPanel selectInitializationScript: anIndex! !
!PhLTestTemplatesPresenter methodsFor: 'configuring'!
selectLocalGroup
	self selectCategory: 1! !
!PhLTestTemplatesPresenter methodsFor: 'configuring'!
selectRemoteGroup
	self selectCategory: 2! !
!PhLTestTemplatesPresenter methodsFor: 'configuring'!
selectTemplateNamed: aTemplateName
	templateTable selectItem: (self templates detect: [ :each | each name = aTemplateName ])
! !
!PhLTestTemplatesPresenter methodsFor: 'accessing'!
templateNames
	^ self templates collect: #name! !
!PhLTestTemplatesPresenter methodsFor: 'accessing'!
templateRoots
	^ templateTable roots! !
!PhLTestTemplatesPresenter methodsFor: 'accessing'!
templates
	^ self localTemplatesGroup templatesAndGroups asOrderedCollection, self remoteTemplatesGroup templatesAndGroups! !
!PhLAboutCommandTest methodsFor: 'accessing'!
application
    ^ SpMockApplication new! !
!PhLAboutCommandTest methodsFor: 'running'!
tearDown
	presenter window 
		ifNotNil: [ :window | window close].
	super tearDown! !
!PhLAboutCommandTest methodsFor: 'tests'!
testCanOpenAboutDialog
	| command |
	command := PhLAboutCommand forContext: self.
	
	presenter := command execute.

	self assert: (presenter description text includesSubstring: 'Pharo Launcher')! !
!PhLCopyImageCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLCopyImageCommandTest methodsFor: 'tests'!
testCanCopyImageLaunchCommand
	| image config |
	presenter selectImageAt: 1.
	image := presenter singleImage.
	config := image defaultLaunchConfiguration
		          doNotUseSettings;
		          yourself.
	image launchConfigurations: { config }.
	presenter 
		selection: image;
		requestAnswer: 'foo'.
	
	PhLCopyImageCommand new
		context: presenter;
		execute.
		
	self assert: (presenter imageRepository hasImageNamed: 'foo').! !
!PhLCopyLaunchCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLCopyLaunchCommandTest methodsFor: 'tests'!
testCanCopyImageLaunchCommand
	| image config commandString |
	presenter selectImageAt: 1.
	image := presenter singleImage.
	config := image defaultLaunchConfiguration
		          doNotUseSettings;
		          yourself.
	image launchConfigurations: { config }.
	presenter selection: image.
	
	PhLCopyLaunchCommand new
		context: presenter;
		execute.
		
	commandString := Clipboard clipboardText asString.
	self assert:
		(commandString beginsWith: 'bash -c ''cd "/TestImage" && ').
	self assert: (commandString endsWith:
			 ' "/TestImage/TestImage.image" --no-default-preferences''')! !
!PhLCopyPathnameCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLCopyPathnameCommandTest methodsFor: 'tests'!
testCanCopyImagePathname
	presenter selectImageAt: 1.
	PhLCopyPathname new
		context: presenter;
		execute.
	
	self
		assertCollection: Clipboard clipboardText asString
		equals: '"/TestImage/TestImage.image"'.! !
!PhLCreateImageFromTemplateCommandTest methodsFor: 'helper'!
createInitScriptNamed: aString 
	presenter application scriptsDirectory / aString
		writeStreamDo: [ :s | s nextPutAll: 'Transcript show: ''init done!!''' ].
	presenter refreshInitializationScriptList.! !
!PhLCreateImageFromTemplateCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestTemplatesPresenter new! !
!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!
testCanCreateAnImageWhenSingleTemplateSelected
	| command images |
	command := PhLCreateImageFromTemplateCommand new.
	command context: presenter.
	presenter 
		createLocalTemplateNamed: 'Foo';
		selectCategory: 1;
		selectTemplateNamed: 'Foo'.
		
	command execute.
	
	images := presenter imageRepository imageNames.
	self 
		assert: images size 
		equals: 1.
	self 
		assertCollection: images
		hasSameElements: #('TestCreateImage').! !
!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!
testCanCreateAnImageWithAnInitializationScript
	| command image |
	command := PhLCreateImageFromTemplateCommand new.
	command context: presenter.
	self createInitScriptNamed: 'foo-init.st'.
	
	presenter 
		createLocalTemplateNamed: 'Foo';
		selectCategory: 1;
		selectTemplateNamed: 'Foo';
		selectInitializationScript: 2.
		
	image := command execute.
	
	self
		assert: image initializationScript basename
		equals: 'foo-init.st'.
		
	self assert: image shouldRunInitializationScript.! !
!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!
testCannotCreateAnImageWhenManyTemplatesSelected
	| command |
	command := PhLCreateImageFromTemplateCommand new.
	command context: presenter.
	presenter 
		createLocalTemplateNamed: 'Foo';
		createLocalTemplateNamed: 'Bar';
		selectTemplateNamed: 'Foo';
		selectTemplateNamed: 'Bar'.
		
	self 
		should: [ command execute ]
		raise: PhLCommandError! !
!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!
testCannotCreateAnImageWhenNoTemplateSelected
	| command |
	command := PhLCreateImageFromTemplateCommand new.
	command context: presenter.

	self
		should: [ command execute ]
		raise: PhLCommandError! !
!PhLCreateTemplateFromImageCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLCreateTemplateFromImageCommandTest methodsFor: 'tests'!
testCanCreateATemplateAndRemoveImageWhenSingleImageSelected
	| command templates |
	command := PhLCreateTemplateFromImageCommand new
		willRemoveImage;
		yourself.
	command context: presenter.
	presenter
		selectImageAt: 1;
		requestAnswer: 'TestTemplate'.

	self assertEmpty: presenter templateRepository localTemplates.
	self assert: (presenter imageRepository hasImageNamed: 'TestImage').
	command execute.

	templates := presenter templateRepository localTemplateNames.
	self assert: templates size equals: 1.
	self assertCollection: templates hasSameElements: #('TestTemplate').
	self deny: (presenter imageRepository hasImageNamed: 'TestImage')! !
!PhLCreateTemplateFromImageCommandTest methodsFor: 'tests'!
testCanCreateATemplateWhenSingleImageSelected
	| command templates |
	command := PhLCreateTemplateFromImageCommand new.
	command context: presenter.
	presenter
		selectImageAt: 1;
		requestAnswer: 'TestTemplate'.

	self assertEmpty: presenter templateRepository localTemplates.
	command execute.

	templates := presenter templateRepository localTemplateNames.
	self assert: templates size equals: 1.
	self assertCollection: templates hasSameElements: #('TestTemplate')! !
!PhLDeleteImageCommandTest methodsFor: 'as yet unclassified'!
createMoreImagesAndEnableSorting
	presenter createImageNamed: 'Zoo'.
	presenter createImageNamed: 'Abc'.
	presenter application imageRepositoryChanged.
	presenter 
	   openWithSpec;
		selectImageAt: 1.
		
	presenter 
		clickOnColumnHeaderAt: 1;
		selectImageAt: 3. "Zoo"! !
!PhLDeleteImageCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLDeleteImageCommandTest methodsFor: 'running'!
tearDown
	presenter delete.
	super tearDown! !
!PhLDeleteImageCommandTest methodsFor: 'tests'!
testCanDeleteAnImage
	| command images |
	command := PhLDeleteImageCommand new.
	command context: presenter.
	presenter 
		createImageNamed: 'Foo';
		selectImageAt: 1.
		
	command execute.
	
	images := command imagesPresenter imageNames.
	self
		assertCollection: images
		hasSameElements: #('Foo').! !
!PhLDeleteImageCommandTest methodsFor: 'tests'!
testDeleteTheRightImageIfImagesSortingIsNotTheDefaultOne
	| command images |
	command := PhLDeleteImageCommand new.
	command context: presenter.
	self createMoreImagesAndEnableSorting. "xx image is selected"

	command execute.

	images := command imagesPresenter imageNames.
	self deny: (images includes: 'Zoo')! !
!PhLDeleteImageCommandTest methodsFor: 'tests'!
testImagesPresenterIsRefreshedWhenImageDeleted
	| command images |
	command := PhLDeleteImageCommand new.
	command context: presenter.
	presenter
		openWithSpec;
		selectImageAt: 1.

	command execute.

	images := command imagesPresenter imageNames.
	self
		assertEmpty: images;
		assert: (presenter imageLabel beginsWith: 'No image selected')! !
!PhLDeleteVmCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestVmPresenter new! !
!PhLDeleteVmCommandTest methodsFor: 'running'!
tearDown
	PhLTestVirtualMachineManager reset.	"reset vm store to use for tests"
	super tearDown! !
!PhLDeleteVmCommandTest methodsFor: 'tests'!
testCanDeleteAPrivateVM
	| command vms |		
	command := PhLDeleteVmCommand new.
	command context: presenter.
	presenter 
		showPrivateVms;
		createVmNamed: 'Bar' private: true;
		selection: { presenter vmFor: 'Bar' private: true }.
	
	command execute.
	
	vms := command vmsPresenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #().! !
!PhLDeleteVmCommandTest methodsFor: 'tests'!
testCanDeleteAVM
	| command vms |
	command := PhLDeleteVmCommand new.
	command context: presenter.
	presenter createVmNamed: 'Foo'.
	
	command execute.
	
	vms := command vmsPresenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('Foo').! !
!PhLDeleteVmCommandTest methodsFor: 'tests'!
testCanDeleteManyPrivateVms
	| command vms |		
	command := PhLDeleteVmCommand new.
	command context: presenter.
	presenter 
		showPrivateVms;
		createVmNamed: 'Foo' private: true;
		createVmNamed: 'Bar' private: true;
		createVmNamed: 'Zee' private: true;
		selection: { presenter vmFor: 'Foo' private: true .
						presenter vmFor: 'Bar' private: true }.
	
	command execute.
	
	vms := command vmsPresenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('Zee').! !
!PhLDeleteVmCommandTest methodsFor: 'tests'!
testCanDeleteManyVms
	| command vms |		
	command := PhLDeleteVmCommand new.
	command context: presenter.
	presenter createVmNamed: 'Foo'.
	vms := #('Foo' 'TestVM')
		collect: [:each | presenter vmFor: each private: false ].
	presenter selection: vms.
	
	command execute.
	
	vms := command vmsPresenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #().! !
!PhLImportImageCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLImportImageCommandTest methodsFor: 'tests'!
testCanImportAnImage
	| command images |
	command := PhLImportImageCommand new.
	command context: presenter.
	presenter 
		createImageNamed: 'foo' in: presenter fileSystem / 'tmp';
		requestAnswer:  presenter fileSystem / 'tmp' / 'foo.image'.
	
	command execute.
	
	images := presenter imageRepository imageNames.
	self 
		assert: images size 
		equals: 2.
	self 
		assertCollection: images
		hasSameElements: #('TestImage' 'foo').! !
!PhLLaunchImageCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new.
	imageDir := FileLocator temp / 'pharo-launcher-tests-launch-image-command' , UUIDGenerator next asString.
	imageDir ensureCreateDirectory! !
!PhLLaunchImageCommandTest methodsFor: 'running'!
tearDown
	imageDir ensureDeleteAll.
	(process isNotNil and: [ process isRunning ]) ifTrue: [ process terminate ].
	super tearDown! !
!PhLLaunchImageCommandTest methodsFor: 'tests'!
testCanLaunchImage
	| command image |
	command := PhLLaunchImageCommand new.
	command context: presenter.
	FileLocator image copyTo: imageDir / FileLocator image basename.
	image := PhLImage location: imageDir / FileLocator image basename.
	image versionFile 
		writeStreamDo: [ :stream | 
			SystemVersion current major asString putOn: stream.
			SystemVersion current minor asString putOn: stream ].
	presenter selection: image.
	image addLaunchConfiguration: 
		(image defaultLaunchConfiguration 
			vmArguments: #('--headless');  "be able to run test without X session"
			imageArguments: #('--no-quit');
			yourself).

	process := command execute.
	2 seconds wait. "let time to the image to be opened by the VM"
	
	self assert: process isRunning.! !
!PhLLaunchImageFromDiskCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new.
	imageDir := FileLocator temp / 'pharo-launcher-tests-launch-image-from-disk-command' , UUIDGenerator next asString.
	imageDir ensureCreateDirectory! !
!PhLLaunchImageFromDiskCommandTest methodsFor: 'running'!
tearDown
	imageDir ensureDeleteAll.
	presenter delete.
	(process isNotNil and: [ process isRunning ]) ifTrue: [ process terminate ].
	super tearDown! !
!PhLLaunchImageFromDiskCommandTest methodsFor: 'tests'!
testCanLaunchImageFromDisk
	| command image |
	command := PhLLaunchImageFromDiskCommand new.
	command context: presenter.
	FileLocator image copyTo: imageDir / FileLocator image basename.
	image := PhLImage location: imageDir / FileLocator image basename.
	image versionFile 
		writeStreamDo: [ :stream | 
			SystemVersion current major asString putOn: stream.
			SystemVersion current minor asString putOn: stream ].
	presenter requestAnswer: image file.
	presenter openWithSpec.
	image addLaunchConfiguration: 
		(image defaultLaunchConfiguration 
			vmArguments: #('--headless');  "be able to run test without X session"
			imageArguments: #('--no-quit');
			yourself).

	process := command launchImage: image. "allow to specify arguments to the default configuration for test purposes"
	2 seconds wait. "let time to the image to be opened by the VM"
	
	self assert: process isRunning.! !
!PhLOpenNewImageWindowTest methodsFor: 'running'!
setUp
	| imagesDirectory app repository |
	super setUp.
	fs := FileSystem memory.
	imagesDirectory := (fs root / 'images') ensureCreateDirectory.
	repository := PhLDirectoryBasedImageRepository forDirectory: imagesDirectory.
	app := PharoLauncherApplication new
		imageRepository: repository;
		yourself.
	imagesPresenter := PhLImagesPresenter newApplication: app model: repository! !
!PhLOpenNewImageWindowTest methodsFor: 'running'!
tearDown
	presenter ifNotNil: [ presenter window close ].
	super tearDown! !
!PhLOpenNewImageWindowTest methodsFor: 'tests'!
testOfficialTemplatesCategoryIsSelectedWhenOpeningPresenter
	presenter := PhLOpenNewImageWindowCommand new 
		context: imagesPresenter;
		execute.

	self 
		assert: presenter selectedTemplateCategory name
		equals: 'Official distributions'! !
!PhLOpenNewImageWindowTest methodsFor: 'tests'!
testTemplatesPresenterOpenWhenClickingOnNewImage
	presenter := PhLOpenNewImageWindowCommand new 
		context: imagesPresenter;
		execute.

	self 
		assert: presenter className
		equals: #PhLTemplatesPresenter.! !
!PhLOpenSettingsCommandTest methodsFor: 'running'!
tearDown
	settingsBrowser ifNotNil: [ settingsBrowser close ].
	super tearDown! !
!PhLOpenSettingsCommandTest methodsFor: 'tests'!
testCanOpenSettingsBrowser
	settingsBrowser := PhLOpenSettingsCommand new execute.

	self assert: (settingsBrowser model isKindOf: PhLSettingBrowser)! !
!PhLRecreateImageCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLRecreateImageCommandTest methodsFor: 'tests'!
testCanRecreateAnImage
	| command images archive zipFile image |
	command := PhLRecreateImageCommand new.
	command context: presenter.
	presenter selectImageAt: 1.
	images := presenter selectedImages.
	archive := ZipArchive new.
	archive addDeflateString: 'foo' as: 'bar.image'.
	archive addDeflateString: 'foo' as: 'bar.changes'.
	zipFile := presenter fileSystem / 'template.zip'. 
	zipFile binaryWriteStreamDo: [ :stream | archive writeTo: stream ].
	images do: [ :img | img originTemplate: (PhLLocalTemplate name: 'Foo test template' zipFile: zipFile)].
	presenter selection: images.
	
	command execute.
	
	images := command imagesPresenter imageNames.
	self
		assertCollection: images
		hasSameElements: #('TestImage').
	image := presenter fileSystem / 'TestImage' /'TestImage.image'.
	self assert: image exists.
	self assert: image contents equals: 'foo'.! !
!PhLRecreateImageCommandTest methodsFor: 'tests'!
testErrorRaiseWhenImageTemplateNotSet
	| command |
	command := PhLRecreateImageCommand new.
	command context: presenter.
	presenter selectImageAt: 1.
	
	self
		should: [ command execute ]
		raise: PhLError 
	
	! !
!PhLRefreshImagerepositoryCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLRefreshImagerepositoryCommandTest methodsFor: 'tests'!
testCanRefreshImageList
	| command images |
	command := PhLRefreshImageRepositoryCommand new.
	command context: presenter.
	images := presenter imageRepository imageNames.
	presenter createImageNamed: 'Foo'.
	
	command execute.
	
	self 
		assertCollection: presenter imageNames
		hasSameElements: (images copyWith: 'Foo').
	! !
!PhLRemoveTemplateCommandTest methodsFor: 'accessing'!
removeTemplateMenuItem
	| menu menuItems |
	menu := (presenter rootCommandsGroup / 'Context Menu')
		asMenuPresenter.
	menuItems := menu menuGroups flatCollect: #menuItems.
	^ menuItems detect: [ :item | item name = 'Remove template' ]! !
!PhLRemoveTemplateCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestTemplatesPresenter new.
	presenter selectLocalGroup! !
!PhLRemoveTemplateCommandTest methodsFor: 'tests'!
testCanRemoveALocalTemplate
	| command |
	command := PhLRemoveTemplateCommand new.
	command context: presenter.
	presenter
		createLocalTemplateNamed: 'Foo';
		selectTemplateNamed: 'Foo'.

	command execute.

	self assertCollection: presenter templateNames hasSameElements: #().

	self assertEmpty: presenter templateRoots! !
!PhLRemoveTemplateCommandTest methodsFor: 'tests'!
testCanRemoveManyLocalTemplates
	| command |
	command := PhLRemoveTemplateCommand new.
	command context: presenter.
	presenter
		createLocalTemplateNamed: 'Foo';
		createLocalTemplateNamed: 'Bar';
		createLocalTemplateNamed: 'Zee';
		selectTemplateNamed: 'Foo';
		selectTemplateNamed: 'Bar'.
		
	command execute.
	
	self 
		assertCollection: presenter templateNames
		hasSameElements: #('Zee').
		
	self 
		assertCollection: (presenter templateRoots collect: #name)
		hasSameElements: #('Zee').! !
!PhLRemoveTemplateCommandTest methodsFor: 'tests'!
testCommandAvailableWhenThereIsALocalTemplateSelected
	| command |
	command := PhLRemoveTemplateCommand new.
	command context: presenter.
	presenter
		createLocalTemplateNamed: 'Foo';
		selectTemplateNamed: 'Foo'.
	
	self assert: self removeTemplateMenuItem isEnabled! !
!PhLRemoveTemplateCommandTest methodsFor: 'tests'!
testCommandHasNoEffectWhenNoTemplateSelected
	| command |
	command := PhLRemoveTemplateCommand new.
	command context: presenter.
	presenter createLocalTemplateNamed: 'Foo'. 

	command execute.
	
	self 
		assertCollection: presenter templateNames
		hasSameElements: #( #Foo )! !
!PhLRemoveTemplateCommandTest methodsFor: 'tests'!
testCommandNotAvailableWhenThereIsARemoteTemplateSelected
	| command |
	command := PhLRemoveTemplateCommand new.
	command context: presenter.
	presenter
	 	createRemoteTemplateNamed: 'Foo';
		selectRemoteGroup;
		selectTemplateNamed: 'Foo'. 
	
 	self deny: self removeTemplateMenuItem isEnabled! !
!PhLRemoveTemplateCommandTest methodsFor: 'tests'!
testCommandNotAvailableWhenThereIsNoTemplateSelected
	| command |
	command := PhLRemoveTemplateCommand new.
	command context: presenter.
	
 	self deny: self removeTemplateMenuItem isEnabled! !
!PhLRenameImageCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestImagesPresenter new! !
!PhLRenameImageCommandTest methodsFor: 'tests'!
testCanRenameAnImage
	| command images |
	command := PhLRenameImageCommand new.
	presenter 
		selectImageAt: 1;
		requestAnswer: 'TestRenameImage'.
	command context: presenter.
	command execute.
	
	images := command imagesPresenter imageNames.
	
	self
		assertCollection: images
		hasSameElements: #('TestRenameImage').! !
!PhLRenameImageCommandTest methodsFor: 'tests'!
testCannotRenameAnImageWithAnExistingName
	| command images |
	command := PhLRenameImageCommand new.
	presenter requestAnswer: 'TestImage'.
	command context: presenter.
	command execute.
	
	images := command imagesPresenter imageNames.
	
	self
		assertCollection: images
		hasSameElements: #('TestImage')! !
!PhLRenameTemplateCommandTest methodsFor: 'as yet unclassified'!
renameTemplateMenuItem
	| menu menuItems |
	menu := (presenter rootCommandsGroup / 'Context Menu')
		asMenuPresenter.
	menuItems := menu menuGroups flatCollect: #menuItems.
	^ menuItems detect: [ :item | item name = 'Rename template' ]! !
!PhLRenameTemplateCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestTemplatesPresenter new.
	presenter selectLocalGroup! !
!PhLRenameTemplateCommandTest methodsFor: 'tests'!
testCanRenameALocalTemplate
	| command |
	command := PhLRenameTemplateCommand new.
	command context: presenter.
	presenter
		createLocalTemplateNamed: 'Foo';
		selectTemplateNamed: 'Foo';
		requestAnswer: 'Bar'.
		
	command execute.
	
	self 
		assertCollection: presenter templateNames
		hasSameElements: #(Bar).
		
	self 
		assert: presenter templateRoots size
		equals: 1.! !
!PhLRenameTemplateCommandTest methodsFor: 'tests'!
testCommandAvailableWhenThereIsALocalTemplateSelected
	| command |
	command := PhLRenameTemplateCommand new.
	command context: presenter.
	presenter
		createLocalTemplateNamed: 'Foo';
		selectTemplateNamed: 'Foo'.
	
	self assert: self renameTemplateMenuItem isEnabled! !
!PhLRenameTemplateCommandTest methodsFor: 'tests'!
testCommandHasNoEffectWhenNoTemplateSelected
	| command |
	command := PhLRenameTemplateCommand new.
	command context: presenter.
	presenter createLocalTemplateNamed: 'Foo'. 

	self
		should: [ command execute ]
		raise: PhLCommandError.
	
	self 
		assertCollection: presenter templateNames
		hasSameElements: #( #Foo )! !
!PhLRenameTemplateCommandTest methodsFor: 'tests'!
testCommandNotAvailableWhenThereIsARemoteTemplateSelected
	| command |
	command := PhLRenameTemplateCommand new.
	command context: presenter.
	presenter
	 	createRemoteTemplateNamed: 'Foo';
		selectRemoteGroup;
		selectTemplateNamed: 'Foo'. 
	
 	self deny: self renameTemplateMenuItem isEnabled! !
!PhLRenameTemplateCommandTest methodsFor: 'tests'!
testCommandNotAvailableWhenThereIsNoTemplateSelected
	| command |
	command := PhLRenameTemplateCommand new.
	command context: presenter.
	
 	self deny: self renameTemplateMenuItem isEnabled! !
!PhLShowImageInFolderCommandTest methodsFor: 'tests'!
testCommandRaisesCommandErrorIfNoImageSelected
	| command |
	presenter := PhLTestImagesPresenter new.
	command := PhLShowImageInFolderCommand new.
	command context: presenter.

	self
		should: [ command execute ]
		raise: PhLCommandError! !
!PhLToggleVmPrivateVmCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestVmPresenter new! !
!PhLToggleVmPrivateVmCommandTest methodsFor: 'running'!
tearDown
	PhLTestVirtualMachineManager reset.
	super tearDown! !
!PhLToggleVmPrivateVmCommandTest methodsFor: 'tests'!
testPrivateVmsShownWhenButtonToggledOnce
	| command vms |
	command := PhLToggleVmPrivateVmCommand new.
	command context: presenter.
	presenter createVmNamed: 'PrivateTestVM' private: true.
	
	command execute.
	
	vms := command vmsPresenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('PrivateTestVM').! !
!PhLToggleVmPrivateVmCommandTest methodsFor: 'tests'!
testVmsShownAtStartup
	| command vms |
	command := PhLToggleVmPrivateVmCommand new.
	command context: presenter.
	presenter createVmNamed: 'PrivateTestVM' private: true.
	
	"NOOP we are testing the initial state"
	
	vms := command vmsPresenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('TestVM').! !
!PhLToggleVmPrivateVmCommandTest methodsFor: 'tests'!
testVmsShownWhenButtonToggledTwice
	| command vms |
	command := PhLToggleVmPrivateVmCommand new.
	command context: presenter.
	presenter createVmNamed: 'Foo'.
	presenter createVmNamed: 'PrivateTestVM' private: true.
	
	command
		execute;
		execute.
	
	vms := command vmsPresenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('TestVM' 'Foo').! !
!PhLUpdateVmCommandTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLTestVmPresenter new! !
!PhLUpdateVmCommandTest methodsFor: 'running'!
tearDown
	PhLTestVirtualMachineManager reset.
	super tearDown! !
!PhLUpdateVmCommandTest methodsFor: 'tests'!
testCanUpdateManyPrivateVms
	| command vms vmFolderEntries |
	command := PhLUpdateVmCommand new.
	command context: presenter.
	presenter 
		showPrivateVms;
		createVmNamed: '6504' private: true;
		createVmNamed: '68021' private: true;
		selection: { 
			presenter vmFor: '6504' private: true .
			presenter vmFor: '68021' private: true }.
	
	command execute.
	
	vms := presenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('68021' '6504').
	vmFolderEntries := (presenter selectedVms first vmStore / '68021') entries.
	self 
		assertCollection: (vmFolderEntries collect: #name)
		hasSameElements: #('pharo' 'Pharo.app' 'fetched!!').! !
!PhLUpdateVmCommandTest methodsFor: 'tests'!
testCanUpdateManyVms
	| command vms vmFolderEntries |
	command := PhLUpdateVmCommand new.
	command context: presenter.
	presenter createVmNamed: 'Foo'.
	vms := #('Foo' 'TestVM')
		collect: [:each | presenter vmFor: each private: false ].
	presenter selection: vms.
	
	command execute.
	
	vms := presenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('TestVM' 'Foo').
	presenter selectedVms do: [ :vm |
		vmFolderEntries := (vm vmStore / vm name) entries.
		self 
			assertCollection: (vmFolderEntries collect: #name)
			hasSameElements: #('pharo' 'Pharo.app' 'fetched!!'). ]
! !
!PhLUpdateVmCommandTest methodsFor: 'tests'!
testCanUpdateOneVm
	| command vms vmFolderEntries |
	command := PhLUpdateVmCommand new.
	command context: presenter.
	
	command execute.
	
	vms := presenter vmNames.
	self
		assertCollection: vms
		hasSameElements: #('TestVM').
	vmFolderEntries := (presenter selectedVms first vmStore / 'TestVM') entries.
	self 
		assertCollection: (vmFolderEntries collect: #name)
		hasSameElements: #('pharo' 'Pharo.app' 'fetched!!').! !
!PhLTestImagesPresenter methodsFor: 'sorting'!
clickOnColumnHeaderAt: anIndex
	imageTable clickOnColumnHeaderAt: anIndex! !
!PhLTestImagesPresenter methodsFor: 'configuring'!
createImageNamed: aName
	^ self createImageNamed: aName in:  (fileSystem root / aName)! !
!PhLTestImagesPresenter methodsFor: 'configuring'!
createImageNamed: aName in: aFolder
	| imageFile |
	imageFile := aFolder / (aName , '.image').
	aFolder ensureCreateDirectory.
	imageFile binaryWriteStreamDo: [:stream | stream nextPutAll: #(105 25 0 0)].
	(aFolder / (aName , '.changes')) ensureCreateFile.
	(aFolder / PhLImage versionFileName) writeStreamDo: [ :stream | stream nextPutAll: '70' ].
	^ imageFile! !
!PhLTestImagesPresenter methodsFor: 'private'!
fileSystem
	^ fileSystem! !
!PhLTestImagesPresenter methodsFor: 'api - selection'!
hasSingleImageSelected
	^ super hasSingleImageSelected or: [ selection notNil ]! !
!PhLTestImagesPresenter methodsFor: 'acccessing'!
imageLabel
	^ descriptionPanel imageLabel label! !
!PhLTestImagesPresenter methodsFor: 'acccessing'!
imageNames
	^ imageTable items collect: #name! !
!PhLTestImagesPresenter methodsFor: 'initialization'!
initialize
	fileSystem := FileSystem memory.
	self model: (PhLDirectoryBasedImageRepository forDirectory: fileSystem root).
	templateRepository := PhLTemplateGroupTestRepository new.
	self application: (PharoLauncherApplication new
		imageRepository: self model;
		instVarNamed: 'imagesPresenter' put: self;
		yourself).
	self createImageNamed: self singleImageName.
	super initialize.

	self createImageNamed: self singleImageName.
	self refresh.
	request := PhLTestRequest new.! !
!PhLTestImagesPresenter methodsFor: 'acccessing'!
launchConfigurations
	^ launchConfigurationList listItems allButFirst! !
!PhLTestImagesPresenter methodsFor: 'user interaction'!
newConfirmation
	^ PhLTestConfirmation new! !
!PhLTestImagesPresenter methodsFor: 'user interaction'!
newFileRequest
	^ request! !
!PhLTestImagesPresenter methodsFor: 'user interaction'!
newRequest
	^ request! !
!PhLTestImagesPresenter methodsFor: 'updating'!
refreshLaunchConfigurationList
	launchConfigurationList ifNotNil: [ super refreshLaunchConfigurationList ]! !
!PhLTestImagesPresenter methodsFor: 'configuring'!
requestAnswer: answer
	request answer: answer! !
!PhLTestImagesPresenter methodsFor: 'selection'!
selectedLaunchConfiguration
	^ launchConfigurationList 
		ifNil: [ self singleImage defaultLaunchConfiguration ]
		ifNotNil: [ launchConfigurationList selectedItem ]! !
!PhLTestImagesPresenter methodsFor: 'configuring'!
selection: aListOfImages
	selection := aListOfImages! !
!PhLTestImagesPresenter methodsFor: 'configuring'!
selectionNames: aListOfImageNames
	selection := aListOfImageNames collect: [ :name | PhLImage location: fileSystem root / name ].! !
!PhLTestImagesPresenter methodsFor: 'api - accessing'!
singleImage 
	^ [ super singleImage ]
		on: SubscriptOutOfBounds "no selection in real presenter"
		do: [ :error |
			 selection 
				ifNil: [ error pass ]
				ifNotNil: [ selection ] ]! !
!PhLTestImagesPresenter methodsFor: 'selection'!
singleImageName
	^ 'TestImage'! !
!PhLTestImagesPresenter methodsFor: 'api - accessing'!
templateRepository 
	^ templateRepository! !
!PhLTestImagesPresenter methodsFor: 'selecting'!
unselectAll
	imageTable unselectAll.! !
!PhLTestVirtualMachineManager class methodsFor: 'private'!
fetch: aVmUrl to: targetFile
	| vmFolder |
	vmFolder := targetFile parent / targetFile basenameWithoutExtension.
	vmFolder ensureCreateDirectory.
	(vmFolder / 'fetched!!') ensureCreateFile.! !
!PhLTestVirtualMachineManager class methodsFor: 'private'!
vmStore
	^ vmStore ifNil: [ vmStore := FileSystem memory root ]! !
!PhLTestConfirmation methodsFor: 'action'!
confirm
	^ true! !
!PhLTestConfirmation methodsFor: 'accessing'!
message: aString 
	self noop! !
!PhLTestConfirmation methodsFor: 'private'!
noop
	"nothing to do"! !
!PhLTestRequest methodsFor: 'accessing'!
answer
	^ answer! !
!PhLTestRequest methodsFor: 'accessing'!
answer: anObject
	answer := anObject! !
!PhLTestRequest methodsFor: 'accessing'!
chooseFile
	^ answer! !
!PhLTestRequest methodsFor: 'accessing'!
chooseFrom: aCollection 
	^ 1! !
!PhLTestRequest methodsFor: 'noop'!
extensionsToShow: aCollection 
	"noop"! !
!PhLTestRequest methodsFor: 'accessing'!
initialAnswer: aString 
	self noop! !
!PhLTestRequest methodsFor: 'private'!
noop
	"do nothing"! !
!PhLTestRequest methodsFor: 'noop'!
path: aFileLocator 
	"noop"! !
!PhLTestRequest methodsFor: 'accessing'!
request
	^ (validationBlock value: self answer)
		ifTrue: [ self answer ]
		ifFalse: [ nil ]! !
!PhLTestRequest methodsFor: 'accessing'!
title: aString 
	self noop! !
!PhLTestRequest methodsFor: 'accessing'!
validateAnswer: aBlock
	validationBlock := aBlock! !
!PhLTestVmPresenter methodsFor: 'adding'!
createVmNamed: aName
	self createVmNamed: aName private: false! !
!PhLTestVmPresenter methodsFor: 'adding'!
createVmNamed: aName private: isPrivateVm
	| vmDirectory appDir root |
	root := isPrivateVm 
		ifTrue: [ vmStoreRoot / 'private' ] 
		ifFalse: [ vmStoreRoot ].
	vmDirectory := root / aName.
	vmDirectory ensureCreateDirectory.
	"needed on OS X"
	appDir := (vmDirectory / 'Pharo.app') ensureCreateDirectory.
	(appDir / 'Pharo') ensureCreateFile.
	"needed on Linux"
	(vmDirectory / 'pharo') binaryWriteStreamDo: [ :stream | stream nextPutAll: PhLVirtualMachine elfMagicNumber ].
	 ! !
!PhLTestVmPresenter methodsFor: 'initialization'!
initialize
	| datasource |
	vmManager := PhLTestVirtualMachineManager new.
	vmStoreRoot := vmManager vmStore.
	(vmStoreRoot / 'private') ensureCreateDirectory.
	datasource := PhLVirtualMachinesDataSource
		vmsBlock:
			[ vmStoreRoot directoryNames reject: [ :name | name = 'private' ] ]
		privateVmsBlock: [ (vmStoreRoot / 'private') directoryNames ].
	self model: datasource.
	self createVmNamed: self singleVmName.
	super initialize! !
!PhLTestVmPresenter methodsFor: 'user interaction'!
newConfirmation
	^ PhLTestConfirmation new! !
!PhLTestVmPresenter methodsFor: 'accessing'!
selectedVms
	^ selection 
		ifNotNil: [ selection ]
		ifNil: [ { self vmFor: self singleVmName private: false } ]! !
!PhLTestVmPresenter methodsFor: 'configuring'!
selection: aListOfVms
	selection := aListOfVms! !
!PhLTestVmPresenter methodsFor: 'initialization'!
singleVmName
	^ 'TestVM'! !
!PhLTestVmPresenter methodsFor: 'private'!
vmFor: aName private: isPrivateVm
	| root vm |
	root := isPrivateVm 
		ifTrue: [ vmStoreRoot / 'private' ] 
		ifFalse: [ vmStoreRoot ].
	vm := PhLVirtualMachine
		directory: root / aName
		private: isPrivateVm.
	vm manager: PhLTestVirtualMachineManager new.
	^ vm! !
!PhLTestVmPresenter methodsFor: 'querying'!
vmNames
	^ shouldShowPrivateVms 
		ifTrue:[ self datasource privateVirtualMachines ]
		ifFalse: [ self datasource virtualMachines ]! !

"PharoLauncher-Tests-Commands"!
!PhLErrorDialogPresenter commentStamp: '' prior: 0!
A small presenter to catch errors and present them nicely to the user.
I provide an acknowledge button ('ok') and a debug button that will open the Pharo debugger.

To use me, install me as the default debugger tool.
I use GTGenericStackDebugger debugger as default.

To try me:

currentDebugger := Smalltalk tools debugger.
Smalltalk tools debuggerTool: PhLErrorDialogPresenter.
[ NotFound signal: 'foo'.
	self inform: 'execution not aborted' ]
on: Error 
do: [ :e | UIManager default handleError: e].
Smalltalk tools debuggerTool: currentDebugger.!
!PhLTreeSelectionTest commentStamp: '' prior: 0!
A PhLTreeSelectionTest is a test class for testing the behavior of PhLTreeSelection!
!PhLTestApplication commentStamp: '' prior: 0!
A spec application used for test purposes.
I can answer pre-arranged responses to UI requests.!
!PhLScriptPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
clickAddScriptButton
	scriptTable addButton click! !
!PhLScriptPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
clickRemoveScriptButton
	scriptTable removeButton click! !
!PhLScriptPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
fileEditor
	^ fileEditor! !
!PhLTestTemplatesPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
imageName: aString
	descriptionPanel imageName: aString! !
!PhLErrorDialogPresenter class methodsFor: 'specs'!
defaultSpec

	^ SpBoxLayout newVertical
		add: #description;
		yourself! !
!PhLErrorDialogPresenter class methodsFor: 'opening api'!
openDebuggerOn: debugSession
	GTGenericStackDebugger
		openOn: debugSession
		withFullView: true
		andNotification: ''! !
!PhLErrorDialogPresenter class methodsFor: 'opening api'!
openOn: debugSession withFullView: bool andNotification: notificationString
	PharoLauncherApplication isDeployed
		ifTrue: [ (self on: debugSession) openDialogWithSpec ]
		ifFalse: [ self openDebuggerOn: debugSession ]! !
!PhLErrorDialogPresenter methodsFor: 'accessing'!
debugSession 
	^ debugSession! !
!PhLErrorDialogPresenter methodsFor: 'initialization'!
initializeDialogWindow: aDialogWindowPresenter
	super initializeDialogWindow: aDialogWindowPresenter.
	aDialogWindowPresenter buttons
		detect: [ :button | button label = 'Ok' ]
		ifFound: [ :button | button label: 'Debug' ].
	aDialogWindowPresenter buttons
		detect: [ :button | button label = 'Cancel' ]
		ifFound: [ :button | button label: 'Ignore' ].
	aDialogWindowPresenter
		cancelAction: [ self debugSession terminate ];
		okAction: [ self class openDebuggerOn: self debugSession ]! !
!PhLErrorDialogPresenter methodsFor: 'initialization'!
initializePresenters 
	description := self newText
		beNotEditable;
		text: self debugSession name;
		yourself.! !
!PhLErrorDialogPresenter methodsFor: 'initialization'!
initializeWindow: aWindowPresenter
	super initializeWindow: aWindowPresenter.
	aWindowPresenter 
		title: 'An error occured!!';
		initialExtent: 390 @ 167.! !
!PhLErrorDialogPresenter methodsFor: 'initialization'!
setModelBeforeInitialization: aDebugSession
	debugSession := aDebugSession! !
!PhLImageCreationPresenterTest methodsFor: 'running'!
setUp
	super setUp.
	presenter := PhLImageCreationPresenter
		newApplication:
			(PharoLauncherApplication new
				scriptsDirectory: FileSystem memory root;
				yourself)! !
!PhLImageCreationPresenterTest methodsFor: 'tests'!
testInitializationScriptListUpdatedWhenScriptPresenterDoChange
	| scriptPresenter |
	self
		assert: presenter initializationScriptItems size
		equals: 1. "No script"
		
	scriptPresenter := presenter openScriptPresenter.
	scriptPresenter newScriptNamed: 'foo.st'.
		
	self
		assert: presenter initScriptPresenter listItems size
		equals: 2.
	self
		assert: presenter initScriptPresenter listItems second basename
		equals: 'foo.st'.
		
	scriptPresenter withWindowDo: #close.! !
!PhLImagesPresenterTest methodsFor: 'running'!
tearDown
	presenter window ifNotNil: #close.
	super tearDown! !
!PhLImagesPresenterTest methodsFor: 'tests'!
testFirstImageIsSelectedAtOpening
	presenter := PhLTestImagesPresenter new.
	presenter openWithSpec.
	
	self assert: presenter hasSingleImageSelected.
	self assert: presenter singleImage name equals: presenter singleImageName! !
!PhLImagesPresenterTest methodsFor: 'tests'!
testImageLaunchConfigurationsAreUpdatedAfterLaunchConfigurationEdition
	| launchConfigurationPresenter |
	presenter := PhLTestImagesPresenter new. 
	presenter 
		openWithSpec;
		selectImageAt: 1.
	
	self
		assert: presenter launchConfigurations size
		equals: 1.
	
	launchConfigurationPresenter := presenter editLaunchConfigurations.
	presenter singleImage 
		addLaunchConfiguration: (
			(PhLLaunchConfiguration withImage: presenter singleImage) 
				name: 'foo';
				yourself).
	launchConfigurationPresenter clickApplyChangesButton.
	launchConfigurationPresenter window close.
		
	self
		assert: presenter launchConfigurations size
		equals: 2.! !
!PhLImagesPresenterTest methodsFor: 'tests'!
testImageLaunchConfigurationsIsUpdatedAfterSortingOfImages
	presenter := PhLTestImagesPresenter new. 
	presenter createImageNamed: 'Zoo'.
	presenter application imageRepositoryChanged.
	presenter 
	   openWithSpec;
		selectImageAt: 1.
		
	presenter 
		clickOnColumnHeaderAt: 1;
		selectImageAt: 1.
		
	self
		assert: presenter singleImage name
		equals: 'TestImage'.
	self
		assert: presenter launchConfigurations first image name
		equals: 'TestImage'.! !
!PhLImagesPresenterTest methodsFor: 'tests'!
testImagesPresenterIsRefreshedWhenApplicationNotifyImageRepositoryChanged
	presenter := PhLTestImagesPresenter new. 
	presenter openWithSpec.
	
	presenter createImageNamed: 'Foo'.
	presenter application imageRepositoryChanged.
	
	self
		assertCollection: presenter imageNames
		hasSameElements: #('TestImage' 'Foo').! !
!PhLImagesPresenterTest methodsFor: 'tests'!
testLaunchCommandIsDisabledWhenNoSelection
	| enabled |
	presenter := PhLTestImagesPresenter new.
	presenter 
		openWithSpec;
		unselectAll.
		
	presenter
		withToolbarDo: [ :toolbar | 
			presenter toolbarGroup allCommands
				detect: [ :cmd | cmd name = 'Launch' ]
				ifFound: [ :cmd | enabled := cmd presenter isEnabled ] ].
	self deny: enabled! !
!PhLImagesPresenterTest methodsFor: 'tests'!
testNewImagesIsSelectedWhenNewImageJustCreated
	| image |
	presenter := PhLTestImagesPresenter new. 
	presenter openWithSpec.
	
	image := PhLImage location: (presenter createImageNamed: 'Foo').
	presenter application imageRepositoryChanged: image.
	
	self
		assert: presenter singleImage name
		equals: 'Foo'.! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'accessing'!
defaultTimeLimit
	^ 20 seconds! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!
setUp
	super setUp.
	image := PhLImage example.
	image versionFile writeStreamDo: [ :s | s nextPutAll: '80' ].
	self setUpPresenter! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!
setUpPresenter
	self setUpPresenterWithApplication: PhLTestApplication new.
! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!
setUpPresenterWithApplication: anSpApplication
	application := anSpApplication.
	presenter := PhLLaunchConfigurationPresenter
		             newApplication: anSpApplication
		             model: image! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!
tearDown
	presenter window ifNotNil: #close.
	super tearDown! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testCanOpenAPresenterWithVMNotInDefaultListNorOnDisk
	| config |
	config := (PhLLaunchConfiguration withImage: image)
				name: 'test config';
				vm: (PhLVirtualMachine id: '01-x86')
				yourself.
	image addLaunchConfiguration: config.
	self setUpPresenter.
	presenter initializeVmListContent.

	self assert: (presenter vmListItems noneSatisfy: [ :each | each id = config vm id]). "ensure we test with vm not listed in presenter"
	presenter selectConfiguration: config.
	
	self 
		assert: presenter selectedVm id 
		equals: config vm id
	
	! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testConfigurationDetailIsCleanedWhenConfigurationDeleted
	| config |
	self setUpPresenter.
	config := image defaultLaunchConfiguration.

	presenter
		selectConfiguration: config;
		clickDeleteConfigurationButton.

	self assertEmpty: presenter imageArguments.
	self assertEmpty: presenter vmArguments.
	self assertEmpty: presenter configurationName! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testEditingAndSavingAConfigurationSelectsItInImagesPresenterToolbar
	| config imagesPresenter |
	imagesPresenter := PhLTestImagesPresenter new.
	presenter application imagesPresenter: imagesPresenter.
	imagesPresenter 
		openWithSpec;
		selectImageAt: 1.
	image := imagesPresenter singleImage.
	config := (PhLLaunchConfiguration withImage: image)
				name: 'test config';
				yourself.
	image addLaunchConfiguration: config.
		
	self setUpPresenterWithApplication: imagesPresenter application.
	presenter connectPresenters. "Select first config"
	self 
		assert: imagesPresenter selectedLaunchConfiguration name
		equals: 'Default'.
			
	presenter selectConfiguration: config.
	presenter saveSelectedConfiguration.
	
	self 
		assert: imagesPresenter selectedLaunchConfiguration name
		equals: config name.
	imagesPresenter delete.! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testImageInteractiveArgumentIsAddedWhenHeadlessVMSelectedAndArgumentNotAlreadyPresent
	| headlessVm |
	headlessVm := presenter vmListItems anyOne beHeadless.
	
	presenter selectVm: headlessVm.
	
	self assert: (presenter imageArguments includes: '--interactive')! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testImageInteractiveArgumentIsNotAddedWhenHeadlessVMSelectedAndArgumentAlreadyPresent
	| headlessVm |
	headlessVm := presenter vmListItems anyOne beHeadless.
	presenter imageArguments add: '--interactive'.
	
	presenter selectVm: headlessVm.
	
	self 
		assert: (presenter imageArguments select: [ :arg | arg = '--interactive' ]) size 
		equals: 1! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testImageLaunchConfigurationsUpdatedWhenConfigurationAdded
	self setUpPresenter.
	application requestAnswer: 'foo'.
	self
		assert: image launchConfigurations size 
		equals: 1. "Default"
		
	presenter clickAddConfigurationButton.
		
	self
		assert: image launchConfigurations size 
		equals: 2. "Default foo"
	self
		assert: image launchConfigurations second name
		equals: 'foo'.! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testImageLaunchConfigurationsUpdatedWhenConfigurationRemoved
	| configuration |
	configuration := (PhLLaunchConfiguration withImage: presenter image)
		                 name: 'foo';
		                 yourself.
	image addLaunchConfiguration: configuration.
	self setUpPresenter.
	self
		assert: image launchConfigurations size 
		equals: 2. "Default + foo"

	presenter
		selectConfiguration: configuration;
		clickDeleteConfigurationButton.
		
	self
		assert: image launchConfigurations size 
		equals: 1.
	self
		assert: image launchConfigurations first name
		equals: PhLLaunchConfiguration defaultName.! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testRemoveImageArgument
	presenter imageArguments add: '--interactive'.
	self assert: presenter imageArguments size equals: 1.

	presenter selectImageArgumentAt: 1.
	presenter clickDeleteImageArgumentButton.

	self assertEmpty: presenter imageArguments! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testRemoveImageArgumentWithoutSelectionDoesNotThrowError
	presenter imageArguments add: '--interactive'.

	"Unselect"
	presenter selectImageArgumentAt: 0.

	self shouldnt: [ presenter clickDeleteImageArgumentButton ] raise: NotFound! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testRemoveVMArgument
	presenter vmArguments add: '--interactive'.
	self assert: presenter vmArguments size equals: 1.

	presenter selectVMArgumentAt: 1.
	presenter clickDeleteVMArgumentButton.

	self assertEmpty: presenter vmArguments! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testRemoveVMArgumentWithoutSelectionDoesNotThrowError
	presenter vmArguments add: '--interactive'.

	"Unselect"
	presenter selectVMArgumentAt: 0.

	self shouldnt: [ presenter clickDeleteVMArgumentButton ] raise: NotFound! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testSelectingAConfigurationAndClosingWindowSelectsItInImagesPresenterToolbar
	| config imagesPresenter window |
	imagesPresenter := PhLTestImagesPresenter new.
	imagesPresenter selectImageAt: 1.
	image := imagesPresenter singleImage.
	image launchConfigurations. "generate default configuration"
	config := (PhLLaunchConfiguration withImage: image)
				name: 'test config';
				yourself.
	image addLaunchConfiguration: config.
	presenter application imagesPresenter: imagesPresenter.
	imagesPresenter 
		openWithSpec;
		selectImageAt: 1.
	self setUpPresenterWithApplication: imagesPresenter application.
	
	window := presenter openWithSpec.		
	presenter selectConfiguration: config.
	window close.
	
	self 
		assert: imagesPresenter selectedLaunchConfiguration name
		equals: config name.
	imagesPresenter delete.! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testVmsAreSortedById
	| vms sortedVms |
	self setUpPresenter.
	presenter initializeVmListContent.
	
	vms := presenter vmListItems.
	sortedVms := vms sorted: [ :a :b | a id > b id ].
	
	vms withIndexDo: [ :vm :index |
		self assert: vm id equals: (sortedVms at: index) id ].! !
!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!
testWhenOpeningPresenterThenSelectedConfigurationIsDefaultConfiguration
	self setUpPresenter.

	self deny: presenter selectedConfiguration isNil.
	self 
		assert: presenter selectedConfiguration name
		equals: 'Default'! !
!PhLScriptPresenterTest methodsFor: 'running'!
setUp
	super setUp.
	scriptFolder := FileSystem memory root.
	self setUpPresenter! !
!PhLScriptPresenterTest methodsFor: 'running'!
setUpPresenter
	application := PhLTestApplication new.
	presenter := PhLScriptPresenter
		             newApplication: application
		             model: scriptFolder! !
!PhLScriptPresenterTest methodsFor: 'tests'!
testCanAddNewScript
	application requestAnswer: 'foo.st'.
	self
		assert: scriptFolder files size 
		equals: 0.
		
	presenter clickAddScriptButton.
		
	self
		assert: scriptFolder files size
		equals: 1.
	self assert: (scriptFolder / 'foo.st') exists.! !
!PhLScriptPresenterTest methodsFor: 'tests'!
testCanRemoveScript
	| file |
	file := (scriptFolder / 'foo.st') ensureCreateFile.
	self setUpPresenter.
	self
		assert: scriptFolder files size 
		equals: 1.
		
	presenter 
		selectScript: file;
		clickRemoveScriptButton.
		
	self
		assert: scriptFolder files size
		equals: 0.! !
!PhLScriptPresenterTest methodsFor: 'tests'!
testCanSaveScript
	| file |
	file := (scriptFolder / 'foo.st') ensureCreateFile.
	self setUpPresenter.
	presenter selectScript: file.
	presenter fileEditor text: 'bar'.
	
	presenter saveSelectedScript.
		
	self
		assert: file contents
		equals: 'bar'.! !
!PhLScriptPresenterTest methodsFor: 'tests'!
testCannotRemoveScriptIfNoneSelected
	(scriptFolder / 'foo') ensureCreateFile.
	self
		assert: scriptFolder files size 
		equals: 1.
		
	presenter clickRemoveScriptButton.
		
	self
		assert: scriptFolder files size
		equals: 1.! !
!PhLScriptPresenterTest methodsFor: 'tests'!
testNewScriptEndsWithStExtension
	application requestAnswer: 'foo'.
	self
		assert: scriptFolder files size 
		equals: 0.
		
	presenter clickAddScriptButton.
		
	self
		assert: scriptFolder files size
		equals: 1.
	self assert: (scriptFolder / 'foo.st') exists.! !
!PhLTemplatesPresenterTest methodsFor: 'running'!
setUp
	"Hooks that subclasses may override to define the fixture of test."
	super setUp.
	presenter := PhLTestTemplatesPresenter new.
! !
!PhLTemplatesPresenterTest methodsFor: 'running'!
tearDown
	presenter window ifNotNil: #close.
	super tearDown! !
!PhLTemplatesPresenterTest methodsFor: 'tests'!
testCanCreateImageIfOneTemplateSelected
	presenter 
		createLocalTemplateNamed: 'Foo';
		selectCategory: 1;
		selectTemplateNamed: 'Foo';
		imageName: 'foo'.
	
	presenter clickOnCreateButton.
	
	self assert: presenter createButtonEnabled.! !
!PhLTemplatesPresenterTest methodsFor: 'tests'!
testCannotCreateImageIfNoTemplateSelected
	presenter imageName: 'foo'.
	
	presenter clickOnCreateButton.
	
	self deny: presenter createButtonEnabled.! !
!PhLTemplatesPresenterTest methodsFor: 'tests'!
testTemplatesPresenterClosesWhenClickingOnCreateImage
	presenter 
		createLocalTemplateNamed: 'Foo';
		selectCategory: 1;
		selectTemplateNamed: 'Foo';
		openWithSpec.
		
	self assert: presenter window isOpen.
	presenter clickOnCreateButton.

	self deny: presenter window isOpen! !
!PhLTreeSelectionTest methodsFor: 'tests-misc'!
testPathNamesMultiSelectionPath
	| model  selection |
	
	model := Array
		with:
			(TreeNodePresenter new
				content: #NodeB1;
				parentNode: (TreeNodePresenter new content: #NodeA1);
				yourself)
		with:
			(TreeNodePresenter new
				content: #NodeB2;
				parentNode: (TreeNodePresenter new content: #NodeA2);
				yourself).
					
	selection := PhLTreeSelection with: model.
	
	self assert: selection pathNames last equals: '#NodeA2-#NodeB2'! !
!PhLTreeSelectionTest methodsFor: 'tests-misc'!
testPathNamesMultiValuedPath
	| model selection |
	
	model := Array
		with:
			(TreeNodePresenter new
				content: #NodeB;
				parentNode: (TreeNodePresenter new content: #NodeA);
				yourself).
				
	selection := PhLTreeSelection with: model.
	
	self assert: selection pathNames first equals: '#NodeA-#NodeB'! !
!PhLTreeSelectionTest methodsFor: 'tests-misc'!
testPathNamesSingleValuePath
	| model  selection |
	
	model := Array
		with:
			(TreeNodePresenter new
				content: #NodeA;
				yourself).
	
	selection := PhLTreeSelection with: model.
	
	self assert: selection pathNames first equals: '#NodeA'! !
!PhLTreeSelectionTest methodsFor: 'tests-misc'!
testPathesMultiSelectionPath
	| model  selection |
	
	model := Array
		with:
			(TreeNodePresenter new
				content: #NodeB1;
				parentNode: (TreeNodePresenter new content: #NodeA1);
				yourself)
		with:
			(TreeNodePresenter new
				content: #NodeB2;
				parentNode: (TreeNodePresenter new content: #NodeA2);
				yourself).
					
	selection := PhLTreeSelection with: model.

	self 
		assert: selection pathes last first
		equals: '#NodeA2'.
	self 
		assert: selection pathes last second
		equals: '#NodeB2'! !
!PhLTreeSelectionTest methodsFor: 'tests-misc'!
testPathesMultiValuedPath
	| model selection |
	
	model := Array
		with:
			(TreeNodePresenter new
				content: #NodeB;
				parentNode: (TreeNodePresenter new content: #NodeA);
				yourself).
				
	selection := PhLTreeSelection with: model.
	
	self 
		assert: selection pathes first first
		equals: '#NodeA'.
	self 
		assert: selection pathes first second
		equals: '#NodeB'! !
!PhLTreeSelectionTest methodsFor: 'tests-misc'!
testPathesSingleValuePath
	| model  selection |
	
	model := Array
		with:
			(TreeNodePresenter new
				content: #NodeA;
				yourself).
	
	selection := PhLTreeSelection with: model.
	
	self 
		assert: selection pathes first first
		equals: '#NodeA'! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
clickAddConfigurationButton
	configurationTable addButton click! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
clickApplyChangesButton
	applyChangesButton click! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
clickDeleteConfigurationButton
	configurationTable removeButton click! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
clickDeleteImageArgumentButton
	imageArgumentList removeButton click! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
clickDeleteVMArgumentButton
	vmArgumentList removeButton click! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
selectConfiguration: aPhLLaunchConfiguration
	configurationTable selectItem: aPhLLaunchConfiguration! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
selectVm: aPhLVirtualMachine
	vmList selectItem: aPhLVirtualMachine! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
selectedVm
	^ vmList selectedItem ! !
!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
vmListItems
	^ vmList listItems! !
!PhLImageCreationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
imageName: aString
	imageName text: aString! !
!PhLImageCreationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
initScriptPresenter
	^ initScript! !
!PhLImageCreationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!
selectInitializationScript: anIndex
	initScript selectIndex: anIndex! !
!PhLTestApplication methodsFor: 'confirmation'!
confirm
	^ true! !
!PhLTestApplication methodsFor: '*PharoLauncher-Tests-SpecUI'!
imagesPresenter: aPhLImagesPresenter
	imagesPresenter := aPhLImagesPresenter! !
!PhLTestApplication methodsFor: 'request'!
inform
	"do nothing"! !
!PhLTestApplication methodsFor: 'events'!
launchConfigurationEdited: aPhLLaunchConfiguration 
	"do nothing"! !
!PhLTestApplication methodsFor: 'confirmation'!
message: aString 
	"do nothing"! !
!PhLTestApplication methodsFor: 'confirmation'!
newConfirmation
	"do nothing"! !
!PhLTestApplication methodsFor: 'confirmation'!
newInformation
	"do nothing"! !
!PhLTestApplication methodsFor: 'request'!
newRequest
	"do nothing"! !
!PhLTestApplication methodsFor: 'request'!
request
	^ requestAnswer! !
!PhLTestApplication methodsFor: 'accessing'!
requestAnswer: aString
	requestAnswer := aString! !
!PhLTestApplication methodsFor: 'request'!
title: aString 
	"do nothing"! !
!PhLTestApplication methodsFor: 'request'!
validateAnswer: aBlockClosure 
	"do nothing"! !

"PharoLauncher-Tests-SpecUI"!
!PhLDownloadManagerMock commentStamp: '' prior: 0!
I have the same interface as PhLDownloadManager but I don't do anything. Useful for testing without relying on network.!
!TPhLVirtualMachineTestUtil methodsFor: 'tests'!
replaceOSByMacIn: url
	^ (url copyReplaceAll: 'linux' with: 'mac') copyReplaceAll: 'win' with: 'mac'! !
!PhLJenkins2BuildTest class methodsFor: 'instance creation'!
newInstance
	^ self newWithoutParent
		  parent: PhLJenkins2JobTest newInstance;
		  yourself! !
!PhLJenkins2BuildTest class methodsFor: 'instance creation'!
newSecureInstance
	^ self newWithoutParent
		  parent: PhLJenkins2JobTest newSecureInstance;
		  yourself! !
!PhLJenkins2BuildTest class methodsFor: 'instance creation'!
newWithoutParent
	^ PhLJenkins2Build newWithProperties: (STONJSON fromString:
			   '{"_class":"hudson.matrix.MatrixBuild","url":"https://ci.inria.fr/moose/job/ClassNamesAnalyzer/223/","number":223}')! !
!PhLJenkins2BuildTest methodsFor: 'helpers'!
artifactRelativePath
	^ 'foo.zip'! !
!PhLJenkins2BuildTest methodsFor: 'helpers'!
buildNumber
	^ 52! !
!PhLJenkins2BuildTest methodsFor: 'helpers'!
buildUrlString
	^ 'http://server/build'! !
!PhLJenkins2BuildTest methodsFor: 'instance creation'!
emptyBuild
	^ (PhLJenkins2Build newWithProperties: (Dictionary new
				    at: 'number' put: self buildNumber;
				    at: 'url' put: self buildUrlString;
				    yourself))
		  parent: PhLJenkins2JobTest newSecureInstance;
		  yourself! !
!PhLJenkins2BuildTest methodsFor: 'instance creation'!
emptyLastSuccessfulBuild
	^ (PhLJenkins2Build newWithProperties: (Dictionary new
				    at: 'number' put: self buildNumber;
				    at: 'url' put: self lastSuccessfulBuildUrlString;
				    yourself))
		  parent: PhLJenkins2JobTest newSecureInstance;
		  yourself! !
!PhLJenkins2BuildTest methodsFor: 'helpers'!
lastSuccessfulBuildUrlString
	^ 'http://server/lastSuccessfulBuild'! !
!PhLJenkins2BuildTest methodsFor: 'responses'!
oneArtifactResponse
	^ '{"artifacts" : [
		{ "relativePath" : "', self artifactRelativePath,'" }
		]}'! !
!PhLJenkins2BuildTest methodsFor: 'responses'!
oneRunResponse
	^ '{"runs" : [
		{ "number" : ',self runNumber printString,',
		   "url" : "', self runUrlString,'" }
		]}' ! !
!PhLJenkins2BuildTest methodsFor: 'helpers'!
runNumber
	^ 52! !
!PhLJenkins2BuildTest methodsFor: 'helpers'!
runUrlString
	^ 'http://server/run'! !
!PhLJenkins2BuildTest methodsFor: 'tests'!
testBuildWithArtifacts
	| artifact |
	self setUpResponse: self oneArtifactResponse.
	self assertEmpty: self emptyBuild runs.
	self assert: self emptyBuild artifacts size equals: 1.
	artifact := self emptyBuild artifacts first.
	self assert: artifact relativePath equals: self artifactRelativePath.
	self assert: artifact url equals: self buildUrlString asUrl / 'artifact' / self artifactRelativePath! !
!PhLJenkins2BuildTest methodsFor: 'tests'!
testBuildWithRuns
	| run |
	self setUpResponse: self oneRunResponse.
	self assertEmpty: self emptyBuild artifacts.
	self assert: self emptyBuild runs size equals: 1.
	run := self emptyBuild runs first.
	self assert: run number equals: self runNumber! !
!PhLJenkins2BuildTest methodsFor: 'tests'!
testEmptyBuild
	self setUpResponse: '{}'.
	self assertEmpty: self emptyBuild artifacts.
	self assertEmpty: self emptyBuild runs! !
!PhLJenkins2BuildTest methodsFor: 'tests'!
testLastSuccessfulBuildPropagateTag
	| run build |
	self setUpResponse: self oneRunResponse.
	build := self emptyLastSuccessfulBuild.
	self assert: build runs size equals: 1.
	run := build runs first.
	self assert: run url copy removeLastPathSegment lastPathSegment equals: 'lastSuccessfulBuild'! !
!PhLJenkins2EntityTest class methodsFor: 'testing'!
isAbstract
	^ self = PhLJenkins2EntityTest! !
!PhLJenkins2EntityTest class methodsFor: 'instance creation'!
newInstance
	^ self subclassResponsibility! !
!PhLJenkins2EntityTest class methodsFor: 'instance creation'!
newSecureInstance
	^ self subclassResponsibility! !
!PhLJenkins2EntityTest class methodsFor: 'testing'!
shouldInheritSelectors
	^ true! !
!PhLJenkins2EntityTest methodsFor: 'helpers'!
downloadManager
	| manager |
	manager := PhLDownloadManager default.
	"If this assertion fails, you probably need to add a setUp method which calls PhLDownloadManagerMock>>install."
	self assert: (manager isKindOf: PhLDownloadManagerMock).
	^ manager! !
!PhLJenkins2EntityTest methodsFor: 'instance creation'!
newInstance
	^ self class newInstance! !
!PhLJenkins2EntityTest methodsFor: 'instance creation'!
newSecureInstance
	^ self class newSecureInstance! !
!PhLJenkins2EntityTest methodsFor: 'running'!
setUp
	super setUp.
	PhLDownloadManagerMock install.! !
!PhLJenkins2EntityTest methodsFor: 'running'!
setUpResponse: aResponse
	"Setup the mock Jenkins server to answer ==aResponse==."
	self downloadManager defaultResponse: aResponse! !
!PhLJenkins2EntityTest methodsFor: 'running'!
tearDown
	PhLDownloadManagerMock remove.
	super tearDown! !
!PhLJenkins2EntityTest methodsFor: 'tests'!
testNonSecureJenkinsDoesNotIncludesIdentifiersInUrl
	self deny: self newInstance url hasUsername.
	self deny: self newInstance url hasPassword! !
!PhLJenkins2EntityTest methodsFor: 'tests'!
testSecureJenkinsIncludesIdentifiersInUrl
	self assert: self newSecureInstance url hasUsername.
	self assert: self newSecureInstance url hasPassword! !
!PhLJenkins2JobTest class methodsFor: 'helpers'!
newInstance
	^ self newWithoutParent
		  parent: PhLJenkins2ServerTest newInstance;
		  yourself! !
!PhLJenkins2JobTest class methodsFor: 'helpers'!
newSecureInstance
	^ self newWithoutParent
		  parent: PhLJenkins2ServerTest newSecureInstance;
		  yourself! !
!PhLJenkins2JobTest class methodsFor: 'helpers'!
newWithoutParent
	^ PhLJenkins2Job newWithProperties: (STONJSON fromString:
			   '{"_class":"hudson.matrix.MatrixBuild","url":"https://ci.inria.fr/pharo-contribution/job/A4BP/1304/","number":1304}')! !
!PhLJenkins2JobTest methodsFor: 'helpers'!
lastSuccessfulBuildNumber
	^ 52! !
!PhLJenkins2JobTest methodsFor: 'helpers'!
lastSuccessfulBuildUrlString
	^ 'http://server/build'! !
!PhLJenkins2JobTest methodsFor: 'instance creation'!
newJobWithNoSuccessfulBuild
	^ (PhLJenkins2Job newWithProperties: (Dictionary new
				    at: 'url' put: 'url' asUrl;
				    at: 'name' put: 'thejob';
				    yourself))
		  parent: PhLJenkins2ServerTest newInstance;
		  yourself! !
!PhLJenkins2JobTest methodsFor: 'instance creation'!
newJobWithNullSuccessfulBuild
	^ (PhLJenkins2Job newWithProperties: (Dictionary new
				    at: 'url' put: 'url' asUrl;
				    at: 'name' put: 'thejob';
				    at: 'lastSuccessfulBuild' put: nil;
				    yourself))
		  parent: PhLJenkins2ServerTest newInstance;
		  yourself! !
!PhLJenkins2JobTest methodsFor: 'instance creation'!
newJobWithSuccessfulBuild
	^ (PhLJenkins2Job newWithProperties: (Dictionary new
				    at: 'url' put: 'url' asUrl;
				    at: 'name' put: 'thejob';
				    at: 'lastSuccessfulBuild' put: (Dictionary newFromPairs: { 
								     'number'.
								     self lastSuccessfulBuildNumber.
								     'url'.
								     self lastSuccessfulBuildUrlString });
				    yourself))
		  parent: PhLJenkins2ServerTest newInstance;
		  yourself! !
!PhLJenkins2JobTest methodsFor: 'instance creation'!
newPipelineJob
	^ (PhLJenkins2Job newWithProperties: (Dictionary new
				    at: 'url' put: 'url' asUrl;
				    at: 'name' put: 'thejob';
				    yourself))
		  parent: PhLJenkins2ServerTest newInstance;
		  yourself! !
!PhLJenkins2JobTest methodsFor: 'responses'!
noBuildsResponse
	^ '{"builds" : []}'! !
!PhLJenkins2JobTest methodsFor: 'responses'!
oneBuildResponse
	^ '{"builds" : [
    {
      "number" : ',self lastSuccessfulBuildNumber printString,',
      "url" : "',self lastSuccessfulBuildUrlString,'"
    }]}'! !
!PhLJenkins2JobTest methodsFor: 'responses'!
pipelineResponse
	^ '{"jobs":[
		{
			"name":"1.1",
			"url":"https://server/job/pipeline-name/job/1.1/",
			"lastSuccessfulBuild":null
		}
		]}'! !
!PhLJenkins2JobTest methodsFor: 'tests'!
testJobWithNoSuccessfulBuild
	self setUpResponse: self noBuildsResponse.
	self assertEmpty: self newJobWithNoSuccessfulBuild builds! !
!PhLJenkins2JobTest methodsFor: 'tests'!
testJobWithNullSuccessfulBuild
	self setUpResponse: self noBuildsResponse.
	self assert: self newJobWithNullSuccessfulBuild lastSuccessfulBuildNumber isNil! !
!PhLJenkins2JobTest methodsFor: 'tests'!
testJobWithSuccessfulBuild
	| job lastSuccessfulBuild |
	self setUpResponse: self oneBuildResponse.
	job := self newJobWithSuccessfulBuild.
	self assert: job builds size equals: 1.
	self assert: job builds first number equals: self lastSuccessfulBuildNumber.
	self assert: job lastSuccessfulBuildNumber equals: self lastSuccessfulBuildNumber.
	lastSuccessfulBuild := job lastSuccessfulBuild.
	self assert: lastSuccessfulBuild number equals: self lastSuccessfulBuildNumber.
	
	"This assertion makes sure the url of the lastSuccessfulBuild will always refer to the latest successful build."
	self assert: lastSuccessfulBuild url lastPathSegment equals: 'lastSuccessfulBuild'! !
!PhLJenkins2JobTest methodsFor: 'tests'!
testPipelineJob
	| build |
	self setUpResponse: self pipelineResponse.
	
	self assert: self newPipelineJob builds size equals: 1.
	build := self newPipelineJob builds first.
	self
		assert: build url asString
		equals: 'https://server/job/pipeline-name/job/1.1/'! !
!PhLJenkins2RunTest class methodsFor: 'instance creation'!
newInstance
	^ self newWithoutParent
		  parent: PhLJenkins2BuildTest newInstance;
		  yourself! !
!PhLJenkins2RunTest class methodsFor: 'instance creation'!
newSecureInstance
	^ self newWithoutParent
		  parent: PhLJenkins2BuildTest newSecureInstance;
		  yourself! !
!PhLJenkins2RunTest class methodsFor: 'instance creation'!
newWithoutParent
	^ PhLJenkins2Run newWithProperties: (STONJSON fromString:
			   '{"url":"https://ci.inria.fr/pharo-contribution/job/MaterialDesignLite/PHARO=61,VERSION=development/1140/","number":1140}')! !
!PhLJenkins2ServerTest class methodsFor: 'instance creation'!
newInstance
	^ PhLJenkins2Server name: 'foo' url: 'bar' asUrl! !
!PhLJenkins2ServerTest class methodsFor: 'instance creation'!
newSecureInstance
	^ self newInstance
		username: 'BadetitouTheUnicorn';
		password: 'dkewjdcnriuwefjncreiuhf';
		yourself! !
!PhLJenkins2ServerTest methodsFor: 'responses'!
defaultJobName
	^ 'theJobName'! !
!PhLJenkins2ServerTest methodsFor: 'responses'!
defaultJobUrlString
	^ 'http://server/segment'! !
!PhLJenkins2ServerTest methodsFor: 'responses'!
noJobsResponse
	^ '{"jobs" : []}'! !
!PhLJenkins2ServerTest methodsFor: 'responses'!
oneJobResponse
	^ '{"jobs" : [
		{
			"name" : "',self defaultJobName,'",
			"url" : "' , self defaultJobUrlString, '"
		}
		]}'! !
!PhLJenkins2ServerTest methodsFor: 'tests'!
testNoJob
	self setUpResponse: self noJobsResponse.
	self assertEmpty: self newInstance jobs! !
!PhLJenkins2ServerTest methodsFor: 'tests'!
testWith1Job
	| job server |
	self setUpResponse: self oneJobResponse.
	server := self newInstance.
	self assert: server jobs size equals: 1.
	job := server jobs first.
	self assert: job name equals: self defaultJobName.
	self assert: job url equals: self defaultJobUrlString asUrl! !
!PhLVirtualMachineManagerTest class methodsFor: 'as yet unclassified'!
availaibleVirtualMachines
	Smalltalk vm imageVersionNumber! !
!PhLVirtualMachineManagerTest methodsFor: 'expected results'!
currentImageVersion
	
	"This test must be rewritten to a controlable version not depending on current image version"
	self skip. 

	^ (SystemVersion current major = 6
		and: [ SystemVersion current highestUpdate >= 60509 ])
		ifTrue: [ '61' ]
		ifFalse: [ SystemVersion current major asString
				, SystemVersion current minor asString ]! !
!PhLVirtualMachineManagerTest methodsFor: 'utilities'!
getImageHeader: anImageUrl
	| archive image |
	archive := ZipArchive new 
		readFrom: (ZnEasy get: anImageUrl) contents readStream.
	image:= archive members detect: [ :each | each  fileName endsWith: '.image' ].
	^ (image binaryContentsFrom: 1 to: 4) readStream
! !
!PhLVirtualMachineManagerTest methodsFor: 'input data'!
sixtyFourBitsHeader
	" too long to process this request
		^ self getImageHeader: 'http://files.pharo.org/image/60/latest-64.zip'
	"	
	" Retrieved with:
		'pharo64.image' asFileReference binaryReadStream next: 20
	"
	
	^ #[181 9 1 0 128 0 0 0 112 37 248 2 0 0 0 0 0 64 128 0] readStream "truncated image file"! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testCanDetect32BitsImage
	| version |
	self timeLimit: 60 seconds.
	version := PhLVirtualMachineManager imageFormatNumberFromStream: self thirtyTwoBitsHeader.
	self assert: (PhLVirtualMachineManager is32bits: version)! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testCanDetect64BitsImage
	| version |
	self timeLimit: 60 seconds.
	version := PhLVirtualMachineManager imageFormatNumberFromStream: self sixtyFourBitsHeader.
	self assert: (PhLVirtualMachineManager is64bits: version)! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testCanGetImageFormatNumber
	| version |
	version := PhLVirtualMachineManager imageFormatNumberFromFile: Smalltalk image lastImagePath.
		
	self assert: version isInteger.
	self
		assert: version
		equals: Smalltalk imageFormatVersion! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testCanGetImageVersionFromFile
	| vmManager |
	vmManager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.
	vmManager imageVersionFile writeStreamDo: [ :stream | stream << '60' ].
		
	self
		assert: vmManager imageVersionFromFile
		equals: '60'! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testGetExceptionWhenRunningImageVersionFromFileWhenFileIsAbsent
	| vmManager |
	vmManager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.
	vmManager imageVersionFile ensureDelete.
		
	self
		should: [ vmManager imageVersionFromFile ]
		raise: PhLImageVersionDeterminationError ! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testImageVersionDeterminationScriptIsUpdatedWhenFileContentDifferentFromScriptInImage
	| vmManager scriptPath |
	vmManager := PhLVirtualMachineManager new.
	scriptPath := vmManager imageVersionDeterminationScriptPath.
	
	scriptPath asFileReference
		ensureDelete;
		writeStreamDo: [ :stream | stream nextPutAll: 'foo' ].
	self 
		assert: scriptPath asFileReference contents 
		equals: 'foo'.	
	
	vmManager imageVersionDeterminationScriptPath. "Should update the file with right content"
	
	self deny: (scriptPath asFileReference contents includesSubstring: 'foo')! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testPharo50PreSpurImageUrlIsCorrect
	| url |
	url := PhLVirtualMachineManager new
		imageFormatNumber: PhLVirtualMachineManager imageFormatPreSpur;
		imageVersion: '50';
		vmUrl.
	self assert: (self replaceOSByMacIn: url) equals: 'https://files.pharo.org/get-files/50-preSpur/pharo-mac-stable.zip'! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testPharo60VmUrlIsCorrect
	| url |
	url := PhLVirtualMachineManager new
		imageFormatNumber: PhLVirtualMachineManager imageFormat32bits;
		imageVersion: '60';
		vmUrl.
	self assert: (self replaceOSByMacIn: url) equals: 'https://files.pharo.org/get-files/60/pharo-mac-stable.zip'! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testPharo70Vm64BitsUrlIsCorrect
	| url |
	url := (PhLVirtualMachineManager new 
		imageFormatNumber: PhLVirtualMachineManager imageFormat64bits;
		imageVersion: '70';
		vmUrl).
	self 
		assert: (self replaceOSByMacIn: url)
		equals: 'https://files.pharo.org/get-files/70/pharo64-mac-stable.zip' ! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testPharo70VmUrlIsCorrect
	| url |
	url := (PhLVirtualMachineManager new 
		imageFormatNumber: PhLVirtualMachineManager imageFormat32bits;
		imageVersion: '70';
		vmUrl).
	self 
		assert: (self replaceOSByMacIn: url)
		equals: 'https://files.pharo.org/get-files/70/pharo-mac-stable.zip' ! !
!PhLVirtualMachineManagerTest methodsFor: 'tests'!
testPreSpurImageUrlIsCorrect
	| url |
	url := (PhLVirtualMachineManager new 
		imageFormatNumber: PhLVirtualMachineManager imageFormatPreSpur;
		imageVersion: '40';
		vmUrl).
	self 
		assert: (self replaceOSByMacIn: url)
		equals: 'https://files.pharo.org/get-files/40/pharo-mac-stable.zip' ! !
!PhLVirtualMachineManagerTest methodsFor: 'input data'!
thirtyTwoBitsHeader
	" too long to process this request
		^ self getImageHeader: 'http://files.pharo.org/image/60/latest.zip'
	"	
	" Retrieved with:
		'pharo.image' asFileReference binaryReadStream next: 20
	"
	^ #[121 25 0 0 64 0 0 0 8 84 50 2 112 76 76 10 216 156 254 11] readStream "truncated image file"! !
!PhLDownloadManagerMock class methodsFor: 'actions'!
install
	PhLDownloadManager setDefault: self new! !
!PhLDownloadManagerMock class methodsFor: 'actions'!
remove
	PhLDownloadManager reset! !
!PhLDownloadManagerMock methodsFor: 'configuration'!
atUrl: anUrl answer: aDocument
	self documents at: anUrl put: aDocument! !
!PhLDownloadManagerMock methodsFor: 'accessing'!
defaultResponse
	^ defaultResponse! !
!PhLDownloadManagerMock methodsFor: 'accessing'!
defaultResponse: aString 
	defaultResponse := aString! !
!PhLDownloadManagerMock methodsFor: 'accessing'!
documents
	^ documents ifNil: [ documents := Dictionary new ]! !
!PhLDownloadManagerMock methodsFor: 'action'!
downloadToPositionableStream: anUrl
	^ self documents at: anUrl ifPresent: [:document | document readStream] ifAbsent: [ self defaultResponse readStream ]! !
!PhLDownloadManagerMock methodsFor: 'action'!
downloadToPositionableStream: anUrl mimeType: aMimeType 
	"Ignore mime type"
	^ self downloadToPositionableStream: anUrl! !

"PharoLauncher-Tests-Download"!
!TestMacOSXMojavePlatform commentStamp: '' prior: 0!
I'm used to represent a Mac OS X Mojave operating system for test purposes!
!PhLUnixSubprocessTest commentStamp: '' prior: 0!
This class contains tests to ensure we can expected behaviour from the library used!
!PhLAbstractTemplateGroupTest commentStamp: '' prior: 0!
Give me unit tests and I will make sure they are run for all subclasses of PhLAbstractTemplateGroup!
!PhLOsXMojaveTestImage commentStamp: '' prior: 0!
Class used for test purpose.
I override the default OS to return OS X Mojave 10.15 (used to test support of 32-bit app)!
!PhLVirtualMachineManagerFunctionalTest commentStamp: '' prior: 0!
A PhLVirtualMachineManagerTest is a test class for testing the behavior of PhLVirtualMachineManager!
!TestMacOSXMojavePlatform methodsFor: 'accessing'!
version 
	^ '1015.1'! !
!PhLCreateTemplateFromImageTest class methodsFor: 'accessing'!
defaultTimeLimit
	^ 1 minute! !
!PhLCreateTemplateFromImageTest methodsFor: 'running'!
tearDown
	template ifNotNil: [ template zipArchive ensureDelete ].
	super tearDown! !
!PhLCreateTemplateFromImageTest methodsFor: 'tests'!
testCanCreateATemplateFromImage
	| image templateName templateRepository zipMemberNames fs fileNames |
	
	templateName := 'newTemplate'.
	fs := FileSystem memory root.
	fileNames := {'a.image' . 'a.changes' . PhLImage versionFileName . 'a-23456ef.sources'}.
	fileNames do: [ :fileName | (fs / fileName) ensureCreateFile ].
	image := PhLImage location: fs / fileNames first.
	templateRepository := PhLTemplateGroupRepository newFromGroups: { PhLDownloadedTemplateGroup named: 'cache group' }.
	
	templateRepository createLocalTemplateFrom: image named: templateName.
	
	self assert: (templateRepository hasLocalTemplateNamed: templateName).
	template := templateRepository localTemplateNamed:templateName.
	zipMemberNames := (ZipArchive new readFrom: template zipArchive) memberNames.
	self 
		assertCollection: zipMemberNames 
	 	hasSameElements: {templateName , '.image' . templateName , '.changes'} , (fileNames allButFirst: 2).
	! !
!PhLLaunchImageTest methodsFor: 'tests'!
pharo80HeadlessVm
	^ PhLVirtualMachineManager new virtualMachines
		detect: [ :each | each id = '80-x64-headless' ]
		ifFound: [ :vm | vm isValidAfterUpdate. vm ]
		ifNone: [ self fail: 'cannot find VM!!' ]! !
!PhLLaunchImageTest methodsFor: 'tests'!
pharo80x86Vm
	^ PhLVirtualMachineManager new virtualMachines
		detect: [ :each | each id = '80-x86' ]
		ifFound: [ :vm | vm isValidAfterUpdate. vm ]
		ifNone: [ self fail: 'cannot find VM!!' ]! !
!PhLLaunchImageTest methodsFor: 'tests'!
prepare80imageIn: dir
	| imageFile |
	ZnClient new
		url: 'https://files.pharo.org/image/80/latest-minimal-64.zip';
		downloadTo: dir / '80.zip'.
	ZipArchive new
		readFrom: dir / '80.zip';
		extractAllTo: dir / '80'.
	imageFile := (dir / '80' childrenMatching: '*.image') first.
	dir / '80' / PhLImage versionFileName
		writeStreamDo: [ :s | s nextPutAll: '80' ].
	^ PhLImage location: imageFile.! !
!PhLLaunchImageTest methodsFor: 'running'!
setUp
	| uuid |
	super setUp.
	launchInALoginShellBackup := PhLLaunchConfiguration launchInALoginShell.
	PhLLaunchConfiguration launchInALoginShell: false.
	uuid := UUIDGenerator next asString.
	imageDir := FileLocator temp / 'Yann-Gaël Bérès' , uuid.
	self deny: imageDir exists.
	imageDir ensureCreateDirectory.
	"Starting Pharo 9, working directory resolution handles non ascii characters. It is not the case before.
	That's why we use a resultDir for test output files."
	resultDir := FileLocator temp / uuid.
	self deny: resultDir exists.
	resultDir ensureCreateDirectory.
	vmStoreBackup := PhLVirtualMachineManager vmStore.
	tempVmStoreFolder := FileLocator temp / self class name , uuid.
	PhLVirtualMachineManager vmStore: tempVmStoreFolder! !
!PhLLaunchImageTest methodsFor: 'running'!
tearDown 
	PhLLaunchConfiguration launchInALoginShell: launchInALoginShellBackup.
	tempVmStoreFolder ensureDeleteAll.
	PhLVirtualMachineManager vmStore: vmStoreBackup.
	imageDir ensureDeleteAll.
	resultDir ensureDeleteAll.
	process ifNotNil: [ process isRunning ifTrue: [ process terminate ] ].
	super tearDown! !
!PhLLaunchImageTest methodsFor: 'tests'!
testArchitectureErrorSignaledWhenTryingToRun32BitImageOn64BitOnlyOS
	| image |
	image := PhLOsXMojaveTestImage example32.
	
	self 
		should: [ process := image launchWithConfiguration: nil ]
		raise: PhLArchitectureError
	
! !
!PhLLaunchImageTest methodsFor: 'tests'!
testCanLaunchImageWithHeadlessVM
	| vm image config commandToEval |
	image := self prepare80imageIn: imageDir.
	vm := self pharo80HeadlessVm.
	commandToEval := '"''' , resultDir fullName , '/result'' asFileReference writeStreamDo:[ :s | s nextPutAll: (1 + 1) asString ]"'.
 
	config := image defaultLaunchConfiguration.
	config
		vm: vm;
		vmArguments: #('--headless');
		imageArguments: {'eval' . commandToEval}.
			
	image launchWithConfiguration: config.
	1 second wait. "wait for file generation"
	
	self
		assert: (resultDir / 'result') exists
		description: 'Image run did not generate result file.'.
	self
		assert: (resultDir / 'result') contents
		equals: '2'! !
!PhLLaunchImageTest methodsFor: 'tests'!
testCanLaunchImageWithNonAsciiCharacters
	| image |
	
	FileLocator image copyTo: imageDir / FileLocator image basename.
	image := PhLImage location: imageDir / FileLocator image basename.
	
	image launch.
	
	"ensure image determination succeeded"
	self
		assert: (imageDir / PhLImage versionFileName) contents
		equals: SystemVersion current major asString , SystemVersion current minor asString.
		
	"image is run but tearDown could delete the image before it is run leading to the dialog to choose the image"
	"for now, no simple way to test that the image is actually launched"! !
!PhLLaunchImageTest methodsFor: 'tests'!
testCanLaunchImageWithNonAsciiCharactersUsingLoginShell
	
	PhLLaunchConfiguration launchInALoginShell: true.
	self testCanLaunchImageWithNonAsciiCharacters.! !
!PhLLaunchImageTest methodsFor: 'tests'!
testCanRun64bitImageOn64BitOnlyOS
	| image config commandToEval |
	image := PhLOsXMojaveTestImage example.
	commandToEval := '"''' , resultDir fullName , '/result'' asFileReference writeStreamDo:[ :s | s nextPutAll: (1 + 1) asString ]"'.
	config := image defaultLaunchConfiguration.
	config
		vm: self pharo80x86Vm;
		imageArguments: {'eval' . commandToEval}.
	
	self 
		shouldnt: [ process := image launchWithConfiguration: config ]
		raise: PhLArchitectureError
	
	
! !
!PhLLaunchImageTest methodsFor: 'tests'!
testLaunchImageSetShouldRunInitilizationScriptToFalse
	| image |
	
	FileLocator image copyTo: imageDir / FileLocator image basename.
	image := PhLImage location: imageDir / FileLocator image basename.
	image initializationScript: '.' asFileReference.
	
	image launch.
	
	image := PhLImage location: imageDir / FileLocator image basename. "read image metadata from disk"
	self deny: image shouldRunInitializationScript.! !
!PhLLaunchedImagesWatcherTest methodsFor: 'tests'!
testCanCatchProcessError
	| process image |
	process := PhLProcessWrapper new
		command: '/bin/ls';
		addArgument: '/foo/bar';
		yourself.
	image := PhLImage location: FileSystem memory root.
	
	process runUnwatch.
	
	self
		should:
			[ (PhLLaunchedImagesWatcher process: process image: image) basicCheckProcess ]
		raise: PhLLaunchError! !
!PhLLaunchedImagesWatcherTest methodsFor: 'tests'!
testProcessSuccessfulDoesNotThrowError
	| process image |
	process := PhLProcessWrapper new
		command: '/bin/ls';
		yourself.
	image := PhLImage location: FileSystem memory root.
	
	process runUnwatch.
	
	self
		shouldnt:
			[ (PhLLaunchedImagesWatcher process: process image: image) basicCheckProcess ]
		raise: PhLLaunchError! !
!PhLPrivateVirtualMachineTest methodsFor: 'tests'!
testCanGetDownloadUrl
	| vm |
	vm := PhLPrivateVirtualMachine new 
		basicInitializeOn: FileSystem memory / '6521';
		yourself.
	self 
		assert: (self replaceOSByMacIn: vm downloadUrl)
		equals: 'https://files.pharo.org/get-files/70/pharo-mac-stable.zip'! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testCanDetectAvailableCommandOnLinux
	Smalltalk os isWindows ifTrue: [ self skip. ^ self ].

	self assert: (PhLProcessWrapper isCommandAvailable: 'ls').
	self deny: (PhLProcessWrapper isCommandAvailable: 'foobar').! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testCanDetectAvailableCommandOnWindows
	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].

	self assert: (PhLProcessWrapper isCommandAvailable: 'dir').
	self deny: (PhLProcessWrapper isCommandAvailable: 'foobar').! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testCanRunCommandWithNonAsciiCharacters
	| process fileRef |

	fileRef := (FileLocator temp / 'Yann-Gaël Bérès.bat') asFileReference.
	fileRef ensureCreateFile.

	[ process := PhLProcessWrapper new 
		shellCommand;
		addArgument: (Smalltalk os isWindows 
			ifTrue: [ 'dir' ]
			ifFalse: [ 'ls' ]);
		addArgument: fileRef fullName surroundedByDoubleQuotes;
		runAndWait.
	
	self assert: process isSuccess. ]
		ensure: [ fileRef ensureDelete ]! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testLinuxCommandLineString
	| process commandString |
	process := PhLProcessWrapper new 
		command: '/home/me/Pharo/pharo';
		addArgument: '/tmp/ba r.image' surroundedByDoubleQuotes;
		prepareProcess;
		yourself.
	
	commandString := PhLProcessWrapperCommandStringGenerator new 
		processWrapper: process;
		visit.
	
	self assert: commandString equals: '"/home/me/Pharo/pharo" /tmp/ba r.image'
	! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testLinuxCommandLineStringWhenUsingShell
	| process commandString |
	process := PhLProcessWrapper new 
		shellCommand;
		addArgument: 'ls';
		addArgument: '/foo/ba r' surroundedByDoubleQuotes;
		prepareProcess;
		yourself.
	
	commandString := PhLProcessWrapperCommandStringGenerator new 
		processWrapper: process;
		visit.
	
	self assert: commandString equals: 'bash -c ''ls "/foo/ba r"'''
	! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testLinuxCommandRemoveDoubleQuotesFromArguments
	"OSSubProcess gets an array of arguments as input. If arguments are protected with double-quotes, they are interpreted as part of the argument. Protecting arguments with double quotes only works when using a shell command with an arguments string. The shell the interprets double-quotes and remove them to run the command."
	| process argument |
	Smalltalk os isWindows ifTrue: [ self skip. ^ self ].

	process := PhLProcessWrapper new 
		command: 'sleep';
		addArgument: '1'.
	
	argument := process arguments first.
	self deny: (argument includes: $").
	process runAndWait.
	self assert: process isSuccess! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testLinuxShellCommandDoesNotRemoveDoubleQuotesFromArguments
	"OSSubProcess gets an array of arguments as input. If arguments are protected with double-quotes, they are interpreted as part of the argument. Protecting arguments with double quotes only works when using a shell command with an arguments string. The shell the interprets double-quotes and remove them to run the command."
	| process pathArgument |
	Smalltalk os isWindows ifTrue: [ self skip. ^ self ].

	process := PhLProcessWrapper new 
		shellCommand;
		addArgument: 'ls';
		addArgument: FileLocator home fullName surroundedByDoubleQuotes.
	
	pathArgument := process arguments second.
	self assert: pathArgument first equals: $".
	self assert: pathArgument last equals: $".
	process runAndWait.
	self assert: process isSuccess! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testRunningInfiniteProcessThrowsTimeout
	| process |
	process := PhLProcessWrapper new 
		shellCommand;
		yourself.
	Smalltalk os isWindows 
		ifTrue: [ process addArgument: 'FOR /L %N IN () DO @echo Oops' ]
		ifFalse: [ process addArgument: 'bash -c " while true; do echo ''Hit CTRL+C''; sleep 1; done"' ].

	self 
		should: [ process runAndWaitTimeOut: 300 milliSeconds. ]
		raise: PhLProcessTimeOut.! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testRunningShortProcessDoesNotTimeout
	| cmd |
	 cmd := Smalltalk os isWindows 
		ifTrue: [ 'timeout 1' ]
		ifFalse: [ 'sleep 1' ].
	self 
		shouldnt: [ PhLProcessWrapper new 
			shellCommand;
			addArguments: cmd;
			runAndWaitTimeOut: 2 seconds ]
		raise: PhLProcessTimeOut.! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testWindowsCommandDoesNotRemoveDoubleQuotesFromArguments
	"Windows API takes a single String with all arguments as parameter. Paths have to be protected by double quotes."
	| process argument |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self ].

	process := PhLProcessWrapper new 
		command: Smalltalk vmBinary fullName;
		addArgument: Smalltalk imagePath surroundedByDoubleQuotes;
		addArgument: '--headless'.
	
	argument := process arguments first.
	self assert: argument first equals: $".
	self assert: argument last equals: $".
	process runAndWait.
	self assert: process isSuccess! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testWindowsCommandLineString
	| process commandString osPlatform |
	osPlatform := OSPlatform current.
	[ OSPlatform classVarNamed: 'Current' put: Win64Platform new.
	process := PhLProcessWrapper new 
		command: 'C:\Users\me\pharo\Pharo.exe';
		addArgument: '"D:\foo\ba r\ba r.image"';
		prepareProcess;
		yourself.
	
	commandString := PhLProcessWrapperCommandStringGenerator new 
		processWrapper: process;
		visit. ]
	ensure: [ OSPlatform classVarNamed: 'Current' put: osPlatform ].
	
	self assert: commandString equals: '"C:\Users\me\pharo\Pharo.exe" "D:\foo\ba r\ba r.image"'
	! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testWindowsCommandLineStringWhenUsingShell
	| process commandString osPlatform |
	osPlatform := OSPlatform current.
	[ OSPlatform classVarNamed: 'Current' put: Win64Platform new.
	process := PhLProcessWrapper new 
		shellCommand;
		addArgument: 'dir';
		addArgument: '/foo/ba r';
		prepareProcess;
		yourself.
	
	commandString := PhLProcessWrapperCommandStringGenerator new 
		processWrapper: process;
		visit. ]
	ensure: [ OSPlatform classVarNamed: 'Current' put: osPlatform ].
	
	self assert: commandString equals: 'C:\Windows\System32\cmd.exe /C "dir /foo/ba r"'
	! !
!PhLProcessWrapperTest methodsFor: 'tests'!
testWindowsShellCommandOnWindowsDoesNotRemoveDoubleQuotesFromArguments
	"Windows API takes a single String with all arguments as parameter. Paths have to be protected by double quotes."
	| process argument |
	Smalltalk os isWindows ifFalse: [ self skip. ^ self ].

	process := PhLProcessWrapper new 
		shellCommand;
		addArgument: 'timeout';
		addArgument: '"/?"'.
	
	argument := process arguments last.
	self assert: argument first equals: $".
	self assert: argument last equals: $".
	process runAndWait.
	self assert: process isSuccess! !
!PhLUnixSubprocessTest methodsFor: 'tests'!
testCanGetExitStatusFromLaunchCommand
	| process |
	process := OSSUnixSubprocess new 
		command: '/bin/ls';
		arguments: #( '/foo/bar' );
		yourself.
		
	process run.
	500 milliSeconds wait.
	
	self assert: process isComplete.
	self deny: process isSuccess.
	self assert: process exitStatusInterpreter isExited.
	"Exit code is 1 on OS X, 2 on Linux"
	self assert: (#(1 2) includes: process exitStatusInterpreter statusIfExited).
! !
!PhLUnixSubprocessTest methodsFor: 'tests'!
testCanGetStdErrFromLaunchCommand
	| process stdErrString |
	process := OSSUnixSubprocess new 
		command: '/bin/ls';
		arguments: #( '/foo/bar' );
		redirectStderr;
		yourself.
		
	process run.
	500 milliSeconds wait.
	
	self assert: process isComplete.
	self deny: process isSuccess.
	stdErrString := process stderrStream upToEndOfFile.
	self 
		assert: ( stdErrString includesSubstring: 'No such file or directory')
		description: 'Cannot find "No such file or directory" in std err stream'.
	self 
		assert: (stdErrString includesSubstring: '/foo/bar')
		description: 'Cannot find "/foo/bar" in std err stream'.
	self 
		assert: (stdErrString includesSubstring: 'ls')
		description: 'Cannot find "ls" in std err stream'.! !
!PhLVirtualMachineTest methodsFor: 'tests'!
testCanDetect32BitArchPath
	| vm |
	vm := PhLVirtualMachine new 
		basicInitializeOn: FileSystem memory / '70-x86';
		yourself.
	self 
		assert: vm archPath
		equals: ''! !
!PhLVirtualMachineTest methodsFor: 'tests'!
testCanDetect64BitArchPath
	| vm |
	vm := PhLVirtualMachine new 
		basicInitializeOn: FileSystem memory / '70-x64';
		yourself.
	self 
		assert: vm archPath
		equals: '64'! !
!PhLVirtualMachineTest methodsFor: 'tests'!
testCanDetectExecutablePath
	"WARNING: this test is Linux specific!!"
	| vm vmFolder |
	Smalltalk os isWindows ifTrue: [ self skip. ^ self  ].
	
	vmFolder := FileLocator imageDirectory asFileReference / 'pharo-vm'.
	vm := PhLVirtualMachine directory: vmFolder.
	self 
		assert: vm executablePath
		equals: (vmFolder / PhLVirtualMachine executableName) fullName! !
!PhLVirtualMachineTest methodsFor: 'tests'!
testCanDetectVMDirectory
	"WARNING: this test is Linux specific!!"
	| vm |
	Smalltalk os isWindows ifTrue: [ self skip. ^ self  ].
	
	vm := PhLVirtualMachine directory: FileLocator imageDirectory asFileReference / 'pharo-vm'.
	self
		assert: vm vmFolderPath
		equals: FileLocator vmDirectory fullName! !
!PhLVirtualMachineTest methodsFor: 'tests'!
testCanGetDownloadUrl
	| vm |
	vm := PhLVirtualMachine new 
		basicInitializeOn: FileSystem memory / '70-x64';
		yourself.
	self 
		assert: (self replaceOSByMacIn: vm downloadUrl) 
		equals: 'https://files.pharo.org/get-files/70/pharo64-mac-stable.zip'! !
!PhLVirtualMachineTest methodsFor: 'tests'!
testCanGetPharoVersion
	| vm |
	vm := PhLVirtualMachine new 
		basicInitializeOn: FileSystem memory / '70-x64';
		yourself.
	self 
		assert: vm pharoVersion
		equals: '70'! !
!PhLVirtualMachineTest methodsFor: 'tests'!
testSerialization
	| vm vmDirectory deserializedVm vmBinaryRef |
	
	vmDirectory := (FileSystem memory root / '80-x64') ensureCreateDirectory.
	(vmDirectory / PhLVirtualMachine executableName) 
		binaryWriteStreamDo: [ :stream | stream nextPutAll: PhLVirtualMachine elfMagicNumber ].
	vm := PhLVirtualMachine directory: vmDirectory.
	vmBinaryRef := (FileLocator documents / 'Pharo' / 'vms' / '80-x64' / 'pharo') asFileReference.
	vm vmBinary: vmBinaryRef. "do not serialize a memory FS"

	deserializedVm := STON fromString: (STON toStringPretty: vm).
	
	self assert: deserializedVm vmFolder class equals: FileLocator.
	self assert: deserializedVm vmFolder fullName equals: vmBinaryRef parent fullName.
	self assert: deserializedVm id equals: vm id.
	self assert: deserializedVm blessing equals: vm blessing.
	self assert: deserializedVm archPath equals: vm archPath.
	self assert: deserializedVm flavour equals: vm flavour.
! !
!ZipArchiveMember methodsFor: '*PharoLauncher-Tests-Functional'!
binaryContentsFrom: start to: finish
	"Answer my contents as a string."
	| s |
	s := (ByteArray new: finish - start + 1) writeStream.
	self extractTo: s from: start to: finish.
	^s contents! !
!PhLAbstractTemplateGroupTest class methodsFor: 'testing'!
isAbstract
	^ self name = 'PhLAbstractTemplateGroupTest'! !
!PhLAbstractTemplateGroupTest methodsFor: 'helpers'!
downloadManager
	^ PhLDownloadManager default! !
!PhLAbstractTemplateGroupTest methodsFor: 'instance creation'!
newGroup
	^ self subclassResponsibility! !
!PhLAbstractTemplateGroupTest methodsFor: 'running'!
setUp
	super setUp.
	PhLDownloadManagerMock install! !
!PhLAbstractTemplateGroupTest methodsFor: 'running'!
tearDown
	PhLDownloadManagerMock remove.
	super tearDown! !
!PhLAbstractTemplateGroupTest methodsFor: 'tests'!
testTemplatesAndGroupsIsACollection
	| group templateAndGroups |
	group := self newGroup.
	templateAndGroups := group templatesAndGroups.
	self assert: templateAndGroups isCollection.
	self assert: templateAndGroups size > 0.
	group templatesAndGroups
		do: [ :templateOrGroup | templateOrGroup isTemplateGroup	"we just make sure the message can be sent without checking its result" ]! !
!PhLHTTPListingTemplateGroupTest methodsFor: 'coverage'!
classToBeTested
	^ PhLHTTPListingTemplateGroup! !
!PhLHTTPListingTemplateGroupTest methodsFor: 'helpers'!
exampleContent
	^ '<html>
	<head></head><body>
	<a href="foo.html">foo.zip</a>
	<a href="bla1.zip">bla1.zip</a>
	... bla bla ...
	<a href="bla2.zip">bla2.zip</a>
	... bla bla ...
	</body>
	</html>'! !
!PhLHTTPListingTemplateGroupTest methodsFor: 'helpers'!
exampleUrl
	^ 'http://foo.example.com/bar' asZnUrl! !
!PhLHTTPListingTemplateGroupTest methodsFor: 'instance creation'!
newGroup
	^ PhLHTTPListingTemplateGroup name: 'Test' url: self exampleUrl! !
!PhLHTTPListingTemplateGroupTest methodsFor: 'running'!
setUp
	super setUp.
	self downloadManager atUrl: self exampleUrl answer: self exampleContent! !
!PhLHTTPListingTemplateGroupTest methodsFor: 'tests'!
testIsGroup
	self assert: self newGroup isTemplateGroup! !
!PhLHTTPListingTemplateGroupTest methodsFor: 'tests'!
testTemplatesAndGroups
	| group templatesAndGroups |
	group := self newGroup.
	templatesAndGroups := group templatesAndGroups.
	self assert: templatesAndGroups size equals: 2.	"<- 2 archive links in exampleContent"
	self assert: (templatesAndGroups noneSatisfy: [ :template | template isTemplateGroup ]).
	self assert: (templatesAndGroups collect: #name) asSet equals: #('bla1' 'bla2') asSet! !
!PhLOsXMojaveTestImage methodsFor: 'private - accessing'!
os
	^ TestMacOSXMojavePlatform new! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'support'!
preSpurHeader
	^ self getImageHeader: 'http://files.pharo.org/image/50-preSpur/latest.zip'! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'running'!
setUp
	super setUp.
	vmStoreBackup := PhLVirtualMachineManager vmStore.
	tempVmStoreFolder := FileLocator temp / self class name , UUIDGenerator next asString.
	PhLVirtualMachineManager vmStore: tempVmStoreFolder! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'running'!
tearDown
	tempVmStoreFolder ensureDeleteAll.
	PhLVirtualMachineManager vmStore: vmStoreBackup.
	super tearDown! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testCanDetectPreSpurImage
	| version |
	self timeLimit: 60 seconds.
	version := PhLVirtualMachineManager imageFormatNumberFromStream: self preSpurHeader.	
	self assert: (PhLVirtualMachineManager isPreSpur: version)! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testCanDetectSystemUnzip
	self assert: PhLVirtualMachineManager canUseSytemZip! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testCanGetImageVersion
	| version |
	self timeLimit: 30 seconds.
	
	self withCopyOfCurrentImageDo: 
	[ :imagePath |
	version := (PhLVirtualMachineManager forImage: imagePath) 
		imageVersion.
	self assert: version equals: self currentImageVersion ]! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testCanGetImageVersionFromFileWhenRunningExtraVM
	| vmManager |
	self timeLimit: 30 seconds.
	
	self withCopyOfCurrentImageDo: 
	[ :imagePath |
	vmManager := PhLVirtualMachineManager forImage:imagePath.
	vmManager imageVersionFile ensureDelete.

	self
		assert: vmManager imageVersion
		equals: self currentImageVersion ]! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testCanGetImageVersionFromFileWithRightCommand
	| vmManager command |
	self timeLimit: 30 seconds.
	
	vmManager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.
	vmManager imageVersionFile ensureDelete.
	command := PhLProcessWrapper new 
		shellCommand;
		addArguments: 'echo 60 >';
		addArgument: vmManager imageVersionFile fullName surroundedByDoubleQuotes.
		
	self
		assert: (vmManager imageVersionFromFileWith: command)
		equals: '60'! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testCanGetImageVersionFromPharo14Image
	| vmManager destDir image |
	self skip: 'skip this test for now to allow a release soon'.
	self timeLimit: 60 seconds.

	destDir := FileLocator temp	/ ('pharo-launcher-testCanGetImageVersionFromPharo14Image-', UUIDGenerator next asString).
	ZipArchive new 
		readFrom: (ZnEasy get: 'http://files.pharo.org/image/14/latest.zip') contents readStream;
		extractAllTo: destDir.
	destDir allFiles 
		detect: [ :each | each basename endsWith: '.sources' ]
		ifFound: #ensureDelete.
	image := destDir allFiles detect: [ :each | each basename endsWith: '.image' ].
	vmManager := PhLVirtualMachineManager forImage: image.
	vmManager imageVersionFile ensureDelete.

	"self flag: 'Remove the following instruction once we based Pharo Launcher on Pharo 7: sources file comes with the image. It is actually needed so that the launched image can get environment variables from the system at startup.'.	
	{ vmManager compatibleVm vmFolder . Smalltalk vmBinary parent asFileReference }
		do: [ :each | vmManager fetchSourcesFilesFor: '61' in: each ]."
	self
		assert: vmManager imageVersion
		equals: '14'! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testGetExceptionWhenRunningImageVersionFromFileWithBadCommand
	| vmManager command |
	
	command := PhLProcessWrapper new 
		shellCommand;
		addArgument: 'foo'.
		
	self withCopyOfCurrentImageDo: 
	[ :imagePath |
	vmManager := PhLVirtualMachineManager forImage: imagePath.
	vmManager imageVersionFile ensureDelete.
	
	self
		should: [ vmManager imageVersionFromFileWith: command ]
		raise: PhLImageVersionDeterminationError. ]! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
testImageVersionDeterminationIsRunWithoutSettings
	| manager command |
	manager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.
	
	command := manager imageVersionCommandWithPreferences: false.
	
	self assert: (command arguments includes: '--no-default-preferences')! !
!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!
withCopyOfCurrentImageDo: aBlock
	| imagePath imageRef |
	imageRef := Smalltalk image lastImagePath asFileReference.
	imagePath := FileLocator temp / imageRef basename.
	imageRef copyTo: imagePath.
	
	[ aBlock value: imagePath ]
	ensure: [ imagePath asFileReference ensureDelete ]
! !

"PharoLauncher-Tests-Functional"!

----QUIT----2020-07-20T13:56:08.601857+02:00 PharoLauncher.image priorSource: 199!

----QUIT/NOSAVE----2020-07-20T13:56:52.777688+02:00 PharoLauncher.image priorSource: 2057890!

----QUIT----2020-07-20T13:56:54.021121+02:00 PharoLauncher.image priorSource: 2057890!

----QUIT----2020-07-20T13:56:54.994324+02:00 PharoLauncher.image priorSource: 2058069!

----QUIT----2020-07-20T13:56:55.917827+02:00 PharoLauncher.image priorSource: 2058157!